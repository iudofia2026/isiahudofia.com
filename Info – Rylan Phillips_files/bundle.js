function Cm(n, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(n, typeof (s = (function(r, a) {
      if (typeof r != "object" || r === null) return r;
      var o = r[Symbol.toPrimitive];
      if (o !== void 0) {
        var l = o.call(r, "string");
        if (typeof l != "object") return l;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return String(r);
    })(i.key)) == "symbol" ? s : String(s), i);
  }
  var s;
}
function tu(n, e, t) {
  return e && Cm(n.prototype, e), Object.defineProperty(n, "prototype", { writable: !1 }), n;
}
function ts() {
  return ts = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
    }
    return n;
  }, ts.apply(this, arguments);
}
function Xo(n, e) {
  n.prototype = Object.create(e.prototype), n.prototype.constructor = n, ia(n, e);
}
function ic(n) {
  return ic = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, ic(n);
}
function ia(n, e) {
  return ia = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, i) {
    return t.__proto__ = i, t;
  }, ia(n, e);
}
function Pm() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function sc(n, e, t) {
  return sc = Pm() ? Reflect.construct.bind() : function(i, s, r) {
    var a = [null];
    a.push.apply(a, s);
    var o = new (Function.bind.apply(i, a))();
    return r && ia(o, r.prototype), o;
  }, sc.apply(null, arguments);
}
function rc(n) {
  var e = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return rc = function(t) {
    if (t === null || Function.toString.call(t).indexOf("[native code]") === -1) return t;
    if (typeof t != "function") throw new TypeError("Super expression must either be null or a function");
    if (e !== void 0) {
      if (e.has(t)) return e.get(t);
      e.set(t, i);
    }
    function i() {
      return sc(t, arguments, ic(this).constructor);
    }
    return i.prototype = Object.create(t.prototype, { constructor: { value: i, enumerable: !1, writable: !0, configurable: !0 } }), ia(i, t);
  }, rc(n);
}
function Dm(n) {
  if (n === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return n;
}
var Fs, km = function() {
  this.before = void 0, this.beforeLeave = void 0, this.leave = void 0, this.afterLeave = void 0, this.beforeEnter = void 0, this.enter = void 0, this.afterEnter = void 0, this.after = void 0;
};
(function(n) {
  n[n.off = 0] = "off", n[n.error = 1] = "error", n[n.warning = 2] = "warning", n[n.info = 3] = "info", n[n.debug = 4] = "debug";
})(Fs || (Fs = {}));
var sd = Fs.off, fr = /* @__PURE__ */ (function() {
  function n(t) {
    this.t = void 0, this.t = t;
  }
  n.getLevel = function() {
    return sd;
  }, n.setLevel = function(t) {
    return sd = Fs[t];
  };
  var e = n.prototype;
  return e.error = function() {
    this.i(console.error, Fs.error, [].slice.call(arguments));
  }, e.warn = function() {
    this.i(console.warn, Fs.warning, [].slice.call(arguments));
  }, e.info = function() {
    this.i(console.info, Fs.info, [].slice.call(arguments));
  }, e.debug = function() {
    this.i(console.log, Fs.debug, [].slice.call(arguments));
  }, e.i = function(t, i, s) {
    i <= n.getLevel() && t.apply(console, ["[" + this.t + "] "].concat(s));
  }, n;
})();
function Or(n) {
  return n.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
function rd(n) {
  return n && n.sensitive ? "" : "i";
}
var as = { container: "container", history: "history", namespace: "namespace", prefix: "data-barba", prevent: "prevent", wrapper: "wrapper" }, hr = new (/* @__PURE__ */ (function() {
  function n() {
    this.o = as, this.u = void 0, this.h = { after: null, before: null, parent: null };
  }
  var e = n.prototype;
  return e.toString = function(t) {
    return t.outerHTML;
  }, e.toDocument = function(t) {
    return this.u || (this.u = new DOMParser()), this.u.parseFromString(t, "text/html");
  }, e.toElement = function(t) {
    var i = document.createElement("div");
    return i.innerHTML = t, i;
  }, e.getHtml = function(t) {
    return t === void 0 && (t = document), this.toString(t.documentElement);
  }, e.getWrapper = function(t) {
    return t === void 0 && (t = document), t.querySelector("[" + this.o.prefix + '="' + this.o.wrapper + '"]');
  }, e.getContainer = function(t) {
    return t === void 0 && (t = document), t.querySelector("[" + this.o.prefix + '="' + this.o.container + '"]');
  }, e.removeContainer = function(t) {
    document.body.contains(t) && (this.v(t), t.parentNode.removeChild(t));
  }, e.addContainer = function(t, i) {
    var s = this.getContainer() || this.h.before;
    s ? this.l(t, s) : this.h.after ? this.h.after.parentNode.insertBefore(t, this.h.after) : this.h.parent ? this.h.parent.appendChild(t) : i.appendChild(t);
  }, e.getSibling = function() {
    return this.h;
  }, e.getNamespace = function(t) {
    t === void 0 && (t = document);
    var i = t.querySelector("[" + this.o.prefix + "-" + this.o.namespace + "]");
    return i ? i.getAttribute(this.o.prefix + "-" + this.o.namespace) : null;
  }, e.getHref = function(t) {
    if (t.tagName && t.tagName.toLowerCase() === "a") {
      if (typeof t.href == "string") return t.href;
      var i = t.getAttribute("href") || t.getAttribute("xlink:href");
      if (i) return this.resolveUrl(i.baseVal || i);
    }
    return null;
  }, e.resolveUrl = function() {
    var t = [].slice.call(arguments).length;
    if (t === 0) throw new Error("resolveUrl requires at least one argument; got none.");
    var i = document.createElement("base");
    if (i.href = arguments[0], t === 1) return i.href;
    var s = document.getElementsByTagName("head")[0];
    s.insertBefore(i, s.firstChild);
    for (var r, a = document.createElement("a"), o = 1; o < t; o++) a.href = arguments[o], i.href = r = a.href;
    return s.removeChild(i), r;
  }, e.l = function(t, i) {
    i.parentNode.insertBefore(t, i.nextSibling);
  }, e.v = function(t) {
    return this.h = { after: t.nextElementSibling, before: t.previousElementSibling, parent: t.parentElement }, this.h;
  }, n;
})())(), Mm = /* @__PURE__ */ (function() {
  function n() {
    this.p = void 0, this.m = [], this.P = -1;
  }
  var e = n.prototype;
  return e.init = function(t, i) {
    this.p = "barba";
    var s = { data: {}, ns: i, scroll: { x: window.scrollX, y: window.scrollY }, url: t };
    this.P = 0, this.m.push(s);
    var r = { from: this.p, index: this.P, states: [].concat(this.m) };
    window.history && window.history.replaceState(r, "", t);
  }, e.change = function(t, i, s) {
    if (s && s.state) {
      var r = s.state, a = r.index;
      i = this.g(this.P - a), this.replace(r.states), this.P = a;
    } else this.add(t, i);
    return i;
  }, e.add = function(t, i, s, r) {
    var a = s ?? this.R(i), o = { data: r ?? {}, ns: "tmp", scroll: { x: window.scrollX, y: window.scrollY }, url: t };
    switch (a) {
      case "push":
        this.P = this.size, this.m.push(o);
        break;
      case "replace":
        this.set(this.P, o);
    }
    var l = { from: this.p, index: this.P, states: [].concat(this.m) };
    switch (a) {
      case "push":
        window.history && window.history.pushState(l, "", t);
        break;
      case "replace":
        window.history && window.history.replaceState(l, "", t);
    }
  }, e.store = function(t, i) {
    var s = i || this.P, r = this.get(s);
    r.data = ts({}, r.data, t), this.set(s, r);
    var a = { from: this.p, index: this.P, states: [].concat(this.m) };
    window.history.replaceState(a, "");
  }, e.update = function(t, i) {
    var s = i || this.P, r = ts({}, this.get(s), t);
    this.set(s, r);
  }, e.remove = function(t) {
    t ? this.m.splice(t, 1) : this.m.pop(), this.P--;
  }, e.clear = function() {
    this.m = [], this.P = -1;
  }, e.replace = function(t) {
    this.m = t;
  }, e.get = function(t) {
    return this.m[t];
  }, e.set = function(t, i) {
    return this.m[t] = i;
  }, e.R = function(t) {
    var i = "push", s = t, r = as.prefix + "-" + as.history;
    return s.hasAttribute && s.hasAttribute(r) && (i = s.getAttribute(r)), i;
  }, e.g = function(t) {
    return Math.abs(t) > 1 ? t > 0 ? "forward" : "back" : t === 0 ? "popstate" : t > 0 ? "back" : "forward";
  }, tu(n, [{ key: "current", get: function() {
    return this.m[this.P];
  } }, { key: "previous", get: function() {
    return this.P < 1 ? null : this.m[this.P - 1];
  } }, { key: "size", get: function() {
    return this.m.length;
  } }]), n;
})(), hh = new Mm(), xo = function(n, e) {
  try {
    var t = (function() {
      if (!e.next.html) return Promise.resolve(n).then(function(i) {
        var s = e.next;
        if (i) {
          var r = hr.toElement(i.html);
          s.namespace = hr.getNamespace(r), s.container = hr.getContainer(r), s.url = i.url, s.html = i.html, hh.update({ ns: s.namespace });
          var a = hr.toDocument(i.html);
          document.title = a.title;
        }
      });
    })();
    return Promise.resolve(t && t.then ? t.then(function() {
    }) : void 0);
  } catch (i) {
    return Promise.reject(i);
  }
}, ph = function n(e, t, i) {
  return e instanceof RegExp ? (function(s, r) {
    if (!r) return s;
    for (var a = /\((?:\?<(.*?)>)?(?!\?)/g, o = 0, l = a.exec(s.source); l; ) r.push({ name: l[1] || o++, prefix: "", suffix: "", modifier: "", pattern: "" }), l = a.exec(s.source);
    return s;
  })(e, t) : Array.isArray(e) ? (function(s, r, a) {
    var o = s.map(function(l) {
      return n(l, r, a).source;
    });
    return new RegExp("(?:".concat(o.join("|"), ")"), rd(a));
  })(e, t, i) : (function(s, r, a) {
    return (function(o, l, c) {
      c === void 0 && (c = {});
      for (var u = c.strict, d = u !== void 0 && u, f = c.start, p = f === void 0 || f, h = c.end, g = h === void 0 || h, m = c.encode, v = m === void 0 ? function(F) {
        return F;
      } : m, y = c.delimiter, E = y === void 0 ? "/#?" : y, T = c.endsWith, S = "[".concat(Or(T === void 0 ? "" : T), "]|$"), w = "[".concat(Or(E), "]"), b = p ? "^" : "", L = 0, A = o; L < A.length; L++) {
        var _ = A[L];
        if (typeof _ == "string") b += Or(v(_));
        else {
          var R = Or(v(_.prefix)), I = Or(v(_.suffix));
          if (_.pattern) if (l && l.push(_), R || I) if (_.modifier === "+" || _.modifier === "*") {
            var k = _.modifier === "*" ? "?" : "";
            b += "(?:".concat(R, "((?:").concat(_.pattern, ")(?:").concat(I).concat(R, "(?:").concat(_.pattern, "))*)").concat(I, ")").concat(k);
          } else b += "(?:".concat(R, "(").concat(_.pattern, ")").concat(I, ")").concat(_.modifier);
          else b += _.modifier === "+" || _.modifier === "*" ? "((?:".concat(_.pattern, ")").concat(_.modifier, ")") : "(".concat(_.pattern, ")").concat(_.modifier);
          else b += "(?:".concat(R).concat(I, ")").concat(_.modifier);
        }
      }
      if (g) d || (b += "".concat(w, "?")), b += c.endsWith ? "(?=".concat(S, ")") : "$";
      else {
        var M = o[o.length - 1], O = typeof M == "string" ? w.indexOf(M[M.length - 1]) > -1 : M === void 0;
        d || (b += "(?:".concat(w, "(?=").concat(S, "))?")), O || (b += "(?=".concat(w, "|").concat(S, ")"));
      }
      return new RegExp(b, rd(c));
    })((function(o, l) {
      l === void 0 && (l = {});
      for (var c = (function(I) {
        for (var k = [], M = 0; M < I.length; ) {
          var O = I[M];
          if (O !== "*" && O !== "+" && O !== "?") if (O !== "\\") if (O !== "{") if (O !== "}") if (O !== ":") if (O !== "(") k.push({ type: "CHAR", index: M, value: I[M++] });
          else {
            var F = 1, C = "";
            if (I[B = M + 1] === "?") throw new TypeError('Pattern cannot start with "?" at '.concat(B));
            for (; B < I.length; ) if (I[B] !== "\\") {
              if (I[B] === ")") {
                if (--F == 0) {
                  B++;
                  break;
                }
              } else if (I[B] === "(" && (F++, I[B + 1] !== "?")) throw new TypeError("Capturing groups are not allowed at ".concat(B));
              C += I[B++];
            } else C += I[B++] + I[B++];
            if (F) throw new TypeError("Unbalanced pattern at ".concat(M));
            if (!C) throw new TypeError("Missing pattern at ".concat(M));
            k.push({ type: "PATTERN", index: M, value: C }), M = B;
          }
          else {
            for (var D = "", B = M + 1; B < I.length; ) {
              var P = I.charCodeAt(B);
              if (!(P >= 48 && P <= 57 || P >= 65 && P <= 90 || P >= 97 && P <= 122 || P === 95)) break;
              D += I[B++];
            }
            if (!D) throw new TypeError("Missing parameter name at ".concat(M));
            k.push({ type: "NAME", index: M, value: D }), M = B;
          }
          else k.push({ type: "CLOSE", index: M, value: I[M++] });
          else k.push({ type: "OPEN", index: M, value: I[M++] });
          else k.push({ type: "ESCAPED_CHAR", index: M++, value: I[M++] });
          else k.push({ type: "MODIFIER", index: M, value: I[M++] });
        }
        return k.push({ type: "END", index: M, value: "" }), k;
      })(o), u = l.prefixes, d = u === void 0 ? "./" : u, f = "[^".concat(Or(l.delimiter || "/#?"), "]+?"), p = [], h = 0, g = 0, m = "", v = function(I) {
        if (g < c.length && c[g].type === I) return c[g++].value;
      }, y = function(I) {
        var k = v(I);
        if (k !== void 0) return k;
        var M = c[g], O = M.index;
        throw new TypeError("Unexpected ".concat(M.type, " at ").concat(O, ", expected ").concat(I));
      }, E = function() {
        for (var I, k = ""; I = v("CHAR") || v("ESCAPED_CHAR"); ) k += I;
        return k;
      }; g < c.length; ) {
        var T = v("CHAR"), S = v("NAME"), w = v("PATTERN");
        if (S || w) d.indexOf(L = T || "") === -1 && (m += L, L = ""), m && (p.push(m), m = ""), p.push({ name: S || h++, prefix: L, suffix: "", pattern: w || f, modifier: v("MODIFIER") || "" });
        else {
          var b = T || v("ESCAPED_CHAR");
          if (b) m += b;
          else if (m && (p.push(m), m = ""), v("OPEN")) {
            var L = E(), A = v("NAME") || "", _ = v("PATTERN") || "", R = E();
            y("CLOSE"), p.push({ name: A || (_ ? h++ : ""), pattern: A && !_ ? f : _, prefix: L, suffix: R, modifier: v("MODIFIER") || "" });
          } else y("END");
        }
      }
      return p;
    })(s, a), r, a);
  })(e, t, i);
}, Om = { __proto__: null, update: xo, nextTick: function() {
  return new Promise(function(n) {
    window.requestAnimationFrame(n);
  });
}, pathToRegexp: ph }, gh = function() {
  return window.location.origin;
}, sa = function(n) {
  return n === void 0 && (n = window.location.href), Ns(n).port;
}, Ns = function(n) {
  var e, t = n.match(/:\d+/);
  if (t === null) /^http/.test(n) && (e = 80), /^https/.test(n) && (e = 443);
  else {
    var i = t[0].substring(1);
    e = parseInt(i, 10);
  }
  var s, r = n.replace(gh(), ""), a = {}, o = r.indexOf("#");
  o >= 0 && (s = r.slice(o + 1), r = r.slice(0, o));
  var l = r.indexOf("?");
  return l >= 0 && (a = mh(r.slice(l + 1)), r = r.slice(0, l)), { hash: s, path: r, port: e, query: a };
}, mh = function(n) {
  return n.split("&").reduce(function(e, t) {
    var i = t.split("=");
    return e[i[0]] = i[1], e;
  }, {});
}, nc = function(n) {
  return n === void 0 && (n = window.location.href), n.replace(/(\/#.*|\/|#.*)$/, "");
}, Fm = { __proto__: null, getHref: function() {
  return window.location.href;
}, getAbsoluteHref: function(n, e) {
  return e === void 0 && (e = document.baseURI), new URL(n, e).href;
}, getOrigin: gh, getPort: sa, getPath: function(n) {
  return n === void 0 && (n = window.location.href), Ns(n).path;
}, getQuery: function(n, e) {
  return e === void 0 && (e = !1), e ? JSON.stringify(Ns(n).query) : Ns(n).query;
}, getHash: function(n) {
  return Ns(n).hash;
}, parse: Ns, parseQuery: mh, clean: nc };
function Nm(n, e, t, i, s) {
  return e === void 0 && (e = 2e3), new Promise(function(r, a) {
    var o = new XMLHttpRequest();
    o.onreadystatechange = function() {
      if (o.readyState === XMLHttpRequest.DONE) {
        if (o.status === 200) {
          var l = o.responseURL !== "" && o.responseURL !== n ? o.responseURL : n;
          r({ html: o.responseText, url: ts({ href: l }, Ns(l)) }), i.update(n, { status: "fulfilled", target: l });
        } else if (o.status) {
          var c = { status: o.status, statusText: o.statusText };
          t(n, c), a(c), i.update(n, { status: "rejected" });
        }
      }
    }, o.ontimeout = function() {
      var l = new Error("Timeout error [" + e + "]");
      t(n, l), a(l), i.update(n, { status: "rejected" });
    }, o.onerror = function() {
      var l = new Error("Fetch error");
      t(n, l), a(l), i.update(n, { status: "rejected" });
    }, o.open("GET", n), o.timeout = e, o.setRequestHeader("Accept", "text/html,application/xhtml+xml,application/xml"), o.setRequestHeader("x-barba", "yes"), s.all().forEach(function(l, c) {
      o.setRequestHeader(c, l);
    }), o.send();
  });
}
function $m(n) {
  return !!n && (typeof n == "object" || typeof n == "function") && typeof n.then == "function";
}
function Yr(n, e) {
  return e === void 0 && (e = {}), function() {
    var t = arguments, i = !1, s = new Promise(function(r, a) {
      e.async = function() {
        return i = !0, function(l, c) {
          l ? a(l) : r(c);
        };
      };
      var o = n.apply(e, [].slice.call(t));
      i || ($m(o) ? o.then(r, a) : r(o));
    });
    return s;
  };
}
var ks = new (/* @__PURE__ */ (function(n) {
  function e() {
    var i;
    return (i = n.call(this) || this).logger = new fr("@barba/core"), i.all = ["ready", "page", "reset", "currentAdded", "currentRemoved", "nextAdded", "nextRemoved", "beforeOnce", "once", "afterOnce", "before", "beforeLeave", "leave", "afterLeave", "beforeEnter", "enter", "afterEnter", "after"], i.registered = /* @__PURE__ */ new Map(), i.init(), i;
  }
  Xo(e, n);
  var t = e.prototype;
  return t.init = function() {
    var i = this;
    this.registered.clear(), this.all.forEach(function(s) {
      i[s] || (i[s] = function(r, a) {
        i.registered.has(s) || i.registered.set(s, /* @__PURE__ */ new Set()), i.registered.get(s).add({ ctx: a || {}, fn: r });
      });
    });
  }, t.do = function(i) {
    var s = arguments, r = this;
    if (this.registered.has(i)) {
      var a = Promise.resolve();
      return this.registered.get(i).forEach(function(o) {
        a = a.then(function() {
          return Yr(o.fn, o.ctx).apply(void 0, [].slice.call(s, 1));
        });
      }), a.catch(function(o) {
        r.logger.debug("Hook error [" + i + "]"), r.logger.error(o);
      });
    }
    return Promise.resolve();
  }, t.clear = function() {
    var i = this;
    this.all.forEach(function(s) {
      delete i[s];
    }), this.init();
  }, t.help = function() {
    this.logger.info("Available hooks: " + this.all.join(","));
    var i = [];
    this.registered.forEach(function(s, r) {
      return i.push(r);
    }), this.logger.info("Registered hooks: " + i.join(","));
  }, e;
})(km))(), vh = /* @__PURE__ */ (function() {
  function n(e) {
    if (this.k = void 0, this.O = [], typeof e == "boolean") this.k = e;
    else {
      var t = Array.isArray(e) ? e : [e];
      this.O = t.map(function(i) {
        return ph(i);
      });
    }
  }
  return n.prototype.checkHref = function(e) {
    if (typeof this.k == "boolean") return this.k;
    var t = Ns(e).path;
    return this.O.some(function(i) {
      return i.exec(t) !== null;
    });
  }, n;
})(), Bm = /* @__PURE__ */ (function(n) {
  function e(i) {
    var s;
    return (s = n.call(this, i) || this).T = /* @__PURE__ */ new Map(), s;
  }
  Xo(e, n);
  var t = e.prototype;
  return t.set = function(i, s, r, a, o) {
    return this.T.set(i, { action: r, request: s, status: a, target: o ?? i }), { action: r, request: s, status: a, target: o };
  }, t.get = function(i) {
    return this.T.get(i);
  }, t.getRequest = function(i) {
    return this.T.get(i).request;
  }, t.getAction = function(i) {
    return this.T.get(i).action;
  }, t.getStatus = function(i) {
    return this.T.get(i).status;
  }, t.getTarget = function(i) {
    return this.T.get(i).target;
  }, t.has = function(i) {
    return !this.checkHref(i) && this.T.has(i);
  }, t.delete = function(i) {
    return this.T.delete(i);
  }, t.update = function(i, s) {
    var r = ts({}, this.T.get(i), s);
    return this.T.set(i, r), r;
  }, e;
})(vh), Um = /* @__PURE__ */ (function() {
  function n() {
    this.A = /* @__PURE__ */ new Map();
  }
  var e = n.prototype;
  return e.set = function(t, i) {
    return this.A.set(t, i), { name: i };
  }, e.get = function(t) {
    return this.A.get(t);
  }, e.all = function() {
    return this.A;
  }, e.has = function(t) {
    return this.A.has(t);
  }, e.delete = function(t) {
    return this.A.delete(t);
  }, e.clear = function() {
    return this.A.clear();
  }, n;
})(), Gm = function() {
  return !window.history.pushState;
}, Hm = function(n) {
  return !n.el || !n.href;
}, Vm = function(n) {
  var e = n.event;
  return e.which > 1 || e.metaKey || e.ctrlKey || e.shiftKey || e.altKey;
}, zm = function(n) {
  var e = n.el;
  return e.hasAttribute("target") && e.target === "_blank";
}, Wm = function(n) {
  var e = n.el;
  return e.protocol !== void 0 && window.location.protocol !== e.protocol || e.hostname !== void 0 && window.location.hostname !== e.hostname;
}, Km = function(n) {
  var e = n.el;
  return e.port !== void 0 && sa() !== sa(e.href);
}, Ym = function(n) {
  var e = n.el;
  return e.getAttribute && typeof e.getAttribute("download") == "string";
}, qm = function(n) {
  return n.el.hasAttribute(as.prefix + "-" + as.prevent);
}, Xm = function(n) {
  return !!n.el.closest("[" + as.prefix + "-" + as.prevent + '="all"]');
}, jm = function(n) {
  var e = n.href;
  return nc(e) === nc() && sa(e) === sa();
}, Qm = /* @__PURE__ */ (function(n) {
  function e(i) {
    var s;
    return (s = n.call(this, i) || this).suite = [], s.tests = /* @__PURE__ */ new Map(), s.init(), s;
  }
  Xo(e, n);
  var t = e.prototype;
  return t.init = function() {
    this.add("pushState", Gm), this.add("exists", Hm), this.add("newTab", Vm), this.add("blank", zm), this.add("corsDomain", Wm), this.add("corsPort", Km), this.add("download", Ym), this.add("preventSelf", qm), this.add("preventAll", Xm), this.add("sameUrl", jm, !1);
  }, t.add = function(i, s, r) {
    r === void 0 && (r = !0), this.tests.set(i, s), r && this.suite.push(i);
  }, t.run = function(i, s, r, a) {
    return this.tests.get(i)({ el: s, event: r, href: a });
  }, t.checkLink = function(i, s, r) {
    var a = this;
    return this.suite.some(function(o) {
      return a.run(o, i, s, r);
    });
  }, e;
})(vh), ll = /* @__PURE__ */ (function(n) {
  function e(t, i) {
    var s;
    return i === void 0 && (i = "Barba error"), (s = n.call.apply(n, [this].concat([].slice.call(arguments, 2))) || this).error = void 0, s.label = void 0, s.error = t, s.label = i, Error.captureStackTrace && Error.captureStackTrace(Dm(s), e), s.name = "BarbaError", s;
  }
  return Xo(e, n), e;
})(/* @__PURE__ */ rc(Error)), Zm = /* @__PURE__ */ (function() {
  function n(t) {
    t === void 0 && (t = []), this.logger = new fr("@barba/core"), this.all = [], this.page = [], this.once = [], this.j = [{ name: "namespace", type: "strings" }, { name: "custom", type: "function" }], t && (this.all = this.all.concat(t)), this.update();
  }
  var e = n.prototype;
  return e.add = function(t, i) {
    t === "rule" ? this.j.splice(i.position || 0, 0, i.value) : this.all.push(i), this.update();
  }, e.resolve = function(t, i) {
    var s = this;
    i === void 0 && (i = {});
    var r = i.once ? this.once : this.page;
    r = r.filter(i.self ? function(f) {
      return f.name && f.name === "self";
    } : function(f) {
      return !f.name || f.name !== "self";
    });
    var a = /* @__PURE__ */ new Map(), o = r.find(function(f) {
      var p = !0, h = {};
      return i.self && f.name === "self" ? (a.set(f, h), !0) : (s.j.reverse().forEach(function(g) {
        p && (p = s.M(f, g, t, h), f.from && f.to && (p = s.M(f, g, t, h, "from") && s.M(f, g, t, h, "to")), f.from && !f.to && (p = s.M(f, g, t, h, "from")), !f.from && f.to && (p = s.M(f, g, t, h, "to")));
      }), a.set(f, h), p);
    }), l = a.get(o), c = [];
    if (c.push(i.once ? "once" : "page"), i.self && c.push("self"), l) {
      var u, d = [o];
      Object.keys(l).length > 0 && d.push(l), (u = this.logger).info.apply(u, ["Transition found [" + c.join(",") + "]"].concat(d));
    } else this.logger.info("No transition found [" + c.join(",") + "]");
    return o;
  }, e.update = function() {
    var t = this;
    this.all = this.all.map(function(i) {
      return t.N(i);
    }).sort(function(i, s) {
      return i.priority - s.priority;
    }).reverse().map(function(i) {
      return delete i.priority, i;
    }), this.page = this.all.filter(function(i) {
      return i.leave !== void 0 || i.enter !== void 0;
    }), this.once = this.all.filter(function(i) {
      return i.once !== void 0;
    });
  }, e.M = function(t, i, s, r, a) {
    var o = !0, l = !1, c = t, u = i.name, d = u, f = u, p = u, h = a ? c[a] : c, g = a === "to" ? s.next : s.current;
    if (a ? h && h[u] : h[u]) {
      switch (i.type) {
        case "strings":
        default:
          var m = Array.isArray(h[d]) ? h[d] : [h[d]];
          g[d] && m.indexOf(g[d]) !== -1 && (l = !0), m.indexOf(g[d]) === -1 && (o = !1);
          break;
        case "object":
          var v = Array.isArray(h[f]) ? h[f] : [h[f]];
          g[f] ? (g[f].name && v.indexOf(g[f].name) !== -1 && (l = !0), v.indexOf(g[f].name) === -1 && (o = !1)) : o = !1;
          break;
        case "function":
          h[p](s) ? l = !0 : o = !1;
      }
      l && (a ? (r[a] = r[a] || {}, r[a][u] = c[a][u]) : r[u] = c[u]);
    }
    return o;
  }, e.S = function(t, i, s) {
    var r = 0;
    return (t[i] || t.from && t.from[i] || t.to && t.to[i]) && (r += Math.pow(10, s), t.from && t.from[i] && (r += 1), t.to && t.to[i] && (r += 2)), r;
  }, e.N = function(t) {
    var i = this;
    t.priority = 0;
    var s = 0;
    return this.j.forEach(function(r, a) {
      s += i.S(t, r.name, a + 1);
    }), t.priority = s, t;
  }, n;
})();
function _n(n, e) {
  try {
    var t = n();
  } catch (i) {
    return e(i);
  }
  return t && t.then ? t.then(void 0, e) : t;
}
var Jm = /* @__PURE__ */ (function() {
  function n(t) {
    t === void 0 && (t = []), this.logger = new fr("@barba/core"), this.store = void 0, this.C = !1, this.store = new Zm(t);
  }
  var e = n.prototype;
  return e.get = function(t, i) {
    return this.store.resolve(t, i);
  }, e.doOnce = function(t) {
    var i = t.data, s = t.transition;
    try {
      var r = function() {
        a.C = !1;
      }, a = this, o = s || {};
      a.C = !0;
      var l = _n(function() {
        return Promise.resolve(a.L("beforeOnce", i, o)).then(function() {
          return Promise.resolve(a.once(i, o)).then(function() {
            return Promise.resolve(a.L("afterOnce", i, o)).then(function() {
            });
          });
        });
      }, function(c) {
        a.C = !1, a.logger.debug("Transition error [before/after/once]"), a.logger.error(c);
      });
      return Promise.resolve(l && l.then ? l.then(r) : r());
    } catch (c) {
      return Promise.reject(c);
    }
  }, e.doPage = function(t) {
    var i = t.data, s = t.transition, r = t.page, a = t.wrapper;
    try {
      var o = function(f) {
        l.C = !1;
      }, l = this, c = s || {}, u = c.sync === !0 || !1;
      l.C = !0;
      var d = _n(function() {
        function f() {
          return Promise.resolve(l.L("before", i, c)).then(function() {
            function h(m) {
              return Promise.resolve(l.remove(i)).then(function() {
                return Promise.resolve(l.L("after", i, c)).then(function() {
                });
              });
            }
            var g = (function() {
              if (u) return _n(function() {
                return Promise.resolve(l.add(i, a)).then(function() {
                  return Promise.resolve(l.L("beforeLeave", i, c)).then(function() {
                    return Promise.resolve(l.L("beforeEnter", i, c)).then(function() {
                      return Promise.resolve(Promise.all([l.leave(i, c), l.enter(i, c)])).then(function() {
                        return Promise.resolve(l.L("afterLeave", i, c)).then(function() {
                          return Promise.resolve(l.L("afterEnter", i, c)).then(function() {
                          });
                        });
                      });
                    });
                  });
                });
              }, function(E) {
                if (l.H(E)) throw new ll(E, "Transition error [sync]");
              });
              var m = function(E) {
                return _n(function() {
                  var T = (function() {
                    if (v !== !1) return Promise.resolve(l.add(i, a)).then(function() {
                      return Promise.resolve(l.L("beforeEnter", i, c)).then(function() {
                        return Promise.resolve(l.enter(i, c, v)).then(function() {
                          return Promise.resolve(l.L("afterEnter", i, c)).then(function() {
                          });
                        });
                      });
                    });
                  })();
                  if (T && T.then) return T.then(function() {
                  });
                }, function(T) {
                  if (l.H(T)) throw new ll(T, "Transition error [before/after/enter]");
                });
              }, v = !1, y = _n(function() {
                return Promise.resolve(l.L("beforeLeave", i, c)).then(function() {
                  return Promise.resolve(Promise.all([l.leave(i, c), xo(r, i)]).then(function(E) {
                    return E[0];
                  })).then(function(E) {
                    return v = E, Promise.resolve(l.L("afterLeave", i, c)).then(function() {
                    });
                  });
                });
              }, function(E) {
                if (l.H(E)) throw new ll(E, "Transition error [before/after/leave]");
              });
              return y && y.then ? y.then(m) : m();
            })();
            return g && g.then ? g.then(h) : h();
          });
        }
        var p = (function() {
          if (u) return Promise.resolve(xo(r, i)).then(function() {
          });
        })();
        return p && p.then ? p.then(f) : f();
      }, function(f) {
        throw l.C = !1, f.name && f.name === "BarbaError" ? (l.logger.debug(f.label), l.logger.error(f.error), f) : (l.logger.debug("Transition error [page]"), l.logger.error(f), f);
      });
      return Promise.resolve(d && d.then ? d.then(o) : o());
    } catch (f) {
      return Promise.reject(f);
    }
  }, e.once = function(t, i) {
    try {
      return Promise.resolve(ks.do("once", t, i)).then(function() {
        return i.once ? Yr(i.once, i)(t) : Promise.resolve();
      });
    } catch (s) {
      return Promise.reject(s);
    }
  }, e.leave = function(t, i) {
    try {
      return Promise.resolve(ks.do("leave", t, i)).then(function() {
        return i.leave ? Yr(i.leave, i)(t) : Promise.resolve();
      });
    } catch (s) {
      return Promise.reject(s);
    }
  }, e.enter = function(t, i, s) {
    try {
      return Promise.resolve(ks.do("enter", t, i)).then(function() {
        return i.enter ? Yr(i.enter, i)(t, s) : Promise.resolve();
      });
    } catch (r) {
      return Promise.reject(r);
    }
  }, e.add = function(t, i) {
    try {
      return hr.addContainer(t.next.container, i), ks.do("nextAdded", t), Promise.resolve();
    } catch (s) {
      return Promise.reject(s);
    }
  }, e.remove = function(t) {
    try {
      return hr.removeContainer(t.current.container), ks.do("currentRemoved", t), Promise.resolve();
    } catch (i) {
      return Promise.reject(i);
    }
  }, e.H = function(t) {
    return t.message ? !/Timeout error|Fetch error/.test(t.message) : !t.status;
  }, e.L = function(t, i, s) {
    try {
      return Promise.resolve(ks.do(t, i, s)).then(function() {
        return s[t] ? Yr(s[t], s)(i) : Promise.resolve();
      });
    } catch (r) {
      return Promise.reject(r);
    }
  }, tu(n, [{ key: "isRunning", get: function() {
    return this.C;
  }, set: function(t) {
    this.C = t;
  } }, { key: "hasOnce", get: function() {
    return this.store.once.length > 0;
  } }, { key: "hasSelf", get: function() {
    return this.store.all.some(function(t) {
      return t.name === "self";
    });
  } }, { key: "shouldWait", get: function() {
    return this.store.all.some(function(t) {
      return t.to && !t.to.route || t.sync;
    });
  } }]), n;
})(), e0 = /* @__PURE__ */ (function() {
  function n(e) {
    var t = this;
    this.names = ["beforeLeave", "afterLeave", "beforeEnter", "afterEnter"], this.byNamespace = /* @__PURE__ */ new Map(), e.length !== 0 && (e.forEach(function(i) {
      t.byNamespace.set(i.namespace, i);
    }), this.names.forEach(function(i) {
      ks[i](t._(i));
    }));
  }
  return n.prototype._ = function(e) {
    var t = this;
    return function(i) {
      var s = e.match(/enter/i) ? i.next : i.current, r = t.byNamespace.get(s.namespace);
      return r && r[e] ? Yr(r[e], r)(i) : Promise.resolve();
    };
  }, n;
})();
Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector), Element.prototype.closest || (Element.prototype.closest = function(n) {
  var e = this;
  do {
    if (e.matches(n)) return e;
    e = e.parentElement || e.parentNode;
  } while (e !== null && e.nodeType === 1);
  return null;
});
var t0 = { container: null, html: "", namespace: "", url: { hash: "", href: "", path: "", port: null, query: {} } }, cl = new (/* @__PURE__ */ (function() {
  function n() {
    this.version = "2.10.3", this.schemaPage = t0, this.Logger = fr, this.logger = new fr("@barba/core"), this.plugins = [], this.timeout = void 0, this.cacheIgnore = void 0, this.cacheFirstPage = void 0, this.prefetchIgnore = void 0, this.preventRunning = void 0, this.hooks = ks, this.cache = void 0, this.headers = void 0, this.prevent = void 0, this.transitions = void 0, this.views = void 0, this.dom = hr, this.helpers = Om, this.history = hh, this.request = Nm, this.url = Fm, this.D = void 0, this.B = void 0, this.q = void 0, this.F = void 0;
  }
  var e = n.prototype;
  return e.use = function(t, i) {
    var s = this.plugins;
    s.indexOf(t) > -1 ? this.logger.warn("Plugin [" + t.name + "] already installed.") : typeof t.install == "function" ? (t.install(this, i), s.push(t)) : this.logger.warn("Plugin [" + t.name + '] has no "install" method.');
  }, e.init = function(t) {
    var i = t === void 0 ? {} : t, s = i.transitions, r = s === void 0 ? [] : s, a = i.views, o = a === void 0 ? [] : a, l = i.schema, c = l === void 0 ? as : l, u = i.requestError, d = i.timeout, f = d === void 0 ? 2e3 : d, p = i.cacheIgnore, h = p !== void 0 && p, g = i.cacheFirstPage, m = g !== void 0 && g, v = i.prefetchIgnore, y = v !== void 0 && v, E = i.preventRunning, T = E !== void 0 && E, S = i.prevent, w = S === void 0 ? null : S, b = i.debug, L = i.logLevel;
    if (fr.setLevel((b !== void 0 && b) === !0 ? "debug" : L === void 0 ? "off" : L), this.logger.info(this.version), Object.keys(c).forEach(function(R) {
      as[R] && (as[R] = c[R]);
    }), this.B = u, this.timeout = f, this.cacheIgnore = h, this.cacheFirstPage = m, this.prefetchIgnore = y, this.preventRunning = T, this.q = this.dom.getWrapper(), !this.q) throw new Error("[@barba/core] No Barba wrapper found");
    this.I();
    var A = this.data.current;
    if (!A.container) throw new Error("[@barba/core] No Barba container found");
    if (this.cache = new Bm(h), this.headers = new Um(), this.prevent = new Qm(y), this.transitions = new Jm(r), this.views = new e0(o), w !== null) {
      if (typeof w != "function") throw new Error("[@barba/core] Prevent should be a function");
      this.prevent.add("preventCustom", w);
    }
    this.history.init(A.url.href, A.namespace), m && this.cache.set(A.url.href, Promise.resolve({ html: A.html, url: A.url }), "init", "fulfilled"), this.U = this.U.bind(this), this.$ = this.$.bind(this), this.X = this.X.bind(this), this.G(), this.plugins.forEach(function(R) {
      return R.init();
    });
    var _ = this.data;
    _.trigger = "barba", _.next = _.current, _.current = ts({}, this.schemaPage), this.hooks.do("ready", _), this.once(_), this.I();
  }, e.destroy = function() {
    this.I(), this.J(), this.history.clear(), this.hooks.clear(), this.plugins = [];
  }, e.force = function(t) {
    window.location.assign(t);
  }, e.go = function(t, i, s) {
    var r;
    if (i === void 0 && (i = "barba"), this.F = null, this.transitions.isRunning) this.force(t);
    else if (!(r = i === "popstate" ? this.history.current && this.url.getPath(this.history.current.url) === this.url.getPath(t) && this.url.getQuery(this.history.current.url, !0) === this.url.getQuery(t, !0) : this.prevent.run("sameUrl", null, null, t)) || this.transitions.hasSelf) return i = this.history.change(this.cache.has(t) ? this.cache.get(t).target : t, i, s), s && (s.stopPropagation(), s.preventDefault()), this.page(t, i, s ?? void 0, r);
  }, e.once = function(t) {
    try {
      var i = this;
      return Promise.resolve(i.hooks.do("beforeEnter", t)).then(function() {
        function s() {
          return Promise.resolve(i.hooks.do("afterEnter", t)).then(function() {
          });
        }
        var r = (function() {
          if (i.transitions.hasOnce) {
            var a = i.transitions.get(t, { once: !0 });
            return Promise.resolve(i.transitions.doOnce({ transition: a, data: t })).then(function() {
            });
          }
        })();
        return r && r.then ? r.then(s) : s();
      });
    } catch (s) {
      return Promise.reject(s);
    }
  }, e.page = function(t, i, s, r) {
    try {
      var a, o = function() {
        var d = l.data;
        return Promise.resolve(l.hooks.do("page", d)).then(function() {
          var f = (function(p, h) {
            try {
              var g = (m = l.transitions.get(d, { once: !1, self: r }), Promise.resolve(l.transitions.doPage({ data: d, page: a, transition: m, wrapper: l.q })).then(function() {
                l.I();
              }));
            } catch {
              return h();
            }
            var m;
            return g && g.then ? g.then(void 0, h) : g;
          })(0, function() {
            fr.getLevel() === 0 && l.force(d.next.url.href);
          });
          if (f && f.then) return f.then(function() {
          });
        });
      }, l = this;
      if (l.data.next.url = ts({ href: t }, l.url.parse(t)), l.data.trigger = i, l.data.event = s, l.cache.has(t)) a = l.cache.update(t, { action: "click" }).request;
      else {
        var c = l.request(t, l.timeout, l.onRequestError.bind(l, i), l.cache, l.headers);
        c.then(function(d) {
          d.url.href !== t && l.history.add(d.url.href, i, "replace");
        }), a = l.cache.set(t, c, "click", "pending").request;
      }
      var u = (function() {
        if (l.transitions.shouldWait) return Promise.resolve(xo(a, l.data)).then(function() {
        });
      })();
      return Promise.resolve(u && u.then ? u.then(o) : o());
    } catch (d) {
      return Promise.reject(d);
    }
  }, e.onRequestError = function(t) {
    this.transitions.isRunning = !1;
    var i = [].slice.call(arguments, 1), s = i[0], r = i[1], a = this.cache.getAction(s);
    return this.cache.delete(s), this.B && this.B(t, a, s, r) === !1 || a === "click" && this.force(s), !1;
  }, e.prefetch = function(t) {
    var i = this;
    t = this.url.getAbsoluteHref(t), this.cache.has(t) || this.cache.set(t, this.request(t, this.timeout, this.onRequestError.bind(this, "barba"), this.cache, this.headers).catch(function(s) {
      i.logger.error(s);
    }), "prefetch", "pending");
  }, e.G = function() {
    this.prefetchIgnore !== !0 && (document.addEventListener("mouseover", this.U), document.addEventListener("touchstart", this.U)), document.addEventListener("click", this.$), window.addEventListener("popstate", this.X);
  }, e.J = function() {
    this.prefetchIgnore !== !0 && (document.removeEventListener("mouseover", this.U), document.removeEventListener("touchstart", this.U)), document.removeEventListener("click", this.$), window.removeEventListener("popstate", this.X);
  }, e.U = function(t) {
    var i = this, s = this.W(t);
    if (s) {
      var r = this.url.getAbsoluteHref(this.dom.getHref(s));
      this.prevent.checkHref(r) || this.cache.has(r) || this.cache.set(r, this.request(r, this.timeout, this.onRequestError.bind(this, s), this.cache, this.headers).catch(function(a) {
        i.logger.error(a);
      }), "enter", "pending");
    }
  }, e.$ = function(t) {
    var i = this.W(t);
    if (i) {
      if (this.transitions.isRunning && this.preventRunning) return t.preventDefault(), void t.stopPropagation();
      this.F = t, this.go(this.dom.getHref(i), i, t);
    }
  }, e.X = function(t) {
    this.go(this.url.getHref(), "popstate", t);
  }, e.W = function(t) {
    for (var i = t.target; i && !this.dom.getHref(i); ) i = i.parentNode;
    if (i && !this.prevent.checkLink(i, t, this.dom.getHref(i))) return i;
  }, e.I = function() {
    var t = this.url.getHref(), i = { container: this.dom.getContainer(), html: this.dom.getHtml(), namespace: this.dom.getNamespace(), url: ts({ href: t }, this.url.parse(t)) };
    this.D = { current: i, event: void 0, next: ts({}, this.schemaPage), trigger: void 0 }, this.hooks.do("reset", this.data);
  }, tu(n, [{ key: "data", get: function() {
    return this.D;
  } }, { key: "wrapper", get: function() {
    return this.q;
  } }]), n;
})())();
function i0(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var io = { exports: {} }, s0 = io.exports, nd;
function r0() {
  return nd || (nd = 1, (function(n, e) {
    (function(t, i) {
      n.exports = i();
    })(s0, (function() {
      var t = document, i = t.createTextNode.bind(t);
      function s(W, Y, N) {
        W.style.setProperty(Y, N);
      }
      function r(W, Y) {
        return W.appendChild(Y);
      }
      function a(W, Y, N, U) {
        var V = t.createElement("span");
        return Y && (V.className = Y), N && (!U && V.setAttribute("data-" + Y, N), V.textContent = N), W && r(W, V) || V;
      }
      function o(W, Y) {
        return W.getAttribute("data-" + Y);
      }
      function l(W, Y) {
        return !W || W.length == 0 ? (
          // null or empty string returns empty array
          []
        ) : W.nodeName ? (
          // a single element is wrapped in an array
          [W]
        ) : (
          // selector and NodeList are converted to Element[]
          [].slice.call(W[0].nodeName ? W : (Y || t).querySelectorAll(W))
        );
      }
      function c(W) {
        for (var Y = []; W--; )
          Y[W] = [];
        return Y;
      }
      function u(W, Y) {
        W && W.some(Y);
      }
      function d(W) {
        return function(Y) {
          return W[Y];
        };
      }
      function f(W, Y, N) {
        var U = "--" + Y, V = U + "-index";
        u(N, function(j, ee) {
          Array.isArray(j) ? u(j, function(ce) {
            s(ce, V, ee);
          }) : s(j, V, ee);
        }), s(W, U + "-total", N.length);
      }
      var p = {};
      function h(W, Y, N) {
        var U = N.indexOf(W);
        if (U == -1) {
          N.unshift(W);
          var V = p[W];
          if (!V)
            throw new Error("plugin not loaded: " + W);
          u(V.depends, function(ee) {
            h(ee, W, N);
          });
        } else {
          var j = N.indexOf(Y);
          N.splice(U, 1), N.splice(j, 0, W);
        }
        return N;
      }
      function g(W, Y, N, U) {
        return {
          by: W,
          depends: Y,
          key: N,
          split: U
        };
      }
      function m(W) {
        return h(W, 0, []).map(d(p));
      }
      function v(W) {
        p[W.by] = W;
      }
      function y(W, Y, N, U, V) {
        W.normalize();
        var j = [], ee = document.createDocumentFragment();
        U && j.push(W.previousSibling);
        var ce = [];
        return l(W.childNodes).some(function(oe) {
          if (oe.tagName && !oe.hasChildNodes()) {
            ce.push(oe);
            return;
          }
          if (oe.childNodes && oe.childNodes.length) {
            ce.push(oe), j.push.apply(j, y(oe, Y, N, U, V));
            return;
          }
          var Le = oe.wholeText || "", ne = Le.trim();
          if (ne.length) {
            Le[0] === " " && ce.push(i(" "));
            var fe = N === "" && typeof Intl.Segmenter == "function";
            u(fe ? Array.from(new Intl.Segmenter().segment(ne)).map(function(Ce) {
              return Ce.segment;
            }) : ne.split(N), function(Ce, re) {
              re && V && ce.push(a(ee, "whitespace", " ", V));
              var z = a(ee, Y, Ce);
              j.push(z), ce.push(z);
            }), Le[Le.length - 1] === " " && ce.push(i(" "));
          }
        }), u(ce, function(oe) {
          r(ee, oe);
        }), W.innerHTML = "", r(W, ee), j;
      }
      var E = 0;
      function T(W, Y) {
        for (var N in Y)
          W[N] = Y[N];
        return W;
      }
      var S = "words", w = g(
        /* by= */
        S,
        /* depends= */
        E,
        /* key= */
        "word",
        /* split= */
        function(W) {
          return y(W, "word", /\s+/, 0, 1);
        }
      ), b = "chars", L = g(
        /* by= */
        b,
        /* depends= */
        [S],
        /* key= */
        "char",
        /* split= */
        function(W, Y, N) {
          var U = [];
          return u(N[S], function(V, j) {
            U.push.apply(U, y(V, "char", "", Y.whitespace && j));
          }), U;
        }
      );
      function A(W) {
        W = W || {};
        var Y = W.key;
        return l(W.target || "[data-splitting]").map(function(N) {
          var U = N["üçå"];
          if (!W.force && U)
            return U;
          U = N["üçå"] = { el: N };
          var V = W.by || o(N, "splitting");
          (!V || V == "true") && (V = b);
          var j = m(V), ee = T({}, W);
          return u(j, function(ce) {
            if (ce.split) {
              var oe = ce.by, Le = (Y ? "-" + Y : "") + ce.key, ne = ce.split(N, ee, U);
              Le && f(N, Le, ne), U[oe] = ne, N.classList.add(oe);
            }
          }), N.classList.add("splitting"), U;
        });
      }
      function _(W) {
        W = W || {};
        var Y = W.target = a();
        return Y.innerHTML = W.content, A(W), Y.outerHTML;
      }
      A.html = _, A.add = v;
      function R(W, Y, N) {
        var U = l(Y.matching || W.children, W), V = {};
        return u(U, function(j) {
          var ee = Math.round(j[N]);
          (V[ee] || (V[ee] = [])).push(j);
        }), Object.keys(V).map(Number).sort(I).map(d(V));
      }
      function I(W, Y) {
        return W - Y;
      }
      var k = g(
        /* by= */
        "lines",
        /* depends= */
        [S],
        /* key= */
        "line",
        /* split= */
        function(W, Y, N) {
          return R(W, { matching: N[S] }, "offsetTop");
        }
      ), M = g(
        /* by= */
        "items",
        /* depends= */
        E,
        /* key= */
        "item",
        /* split= */
        function(W, Y) {
          return l(Y.matching || W.children, W);
        }
      ), O = g(
        /* by= */
        "rows",
        /* depends= */
        E,
        /* key= */
        "row",
        /* split= */
        function(W, Y) {
          return R(W, Y, "offsetTop");
        }
      ), F = g(
        /* by= */
        "cols",
        /* depends= */
        E,
        /* key= */
        "col",
        /* split= */
        function(W, Y) {
          return R(W, Y, "offsetLeft");
        }
      ), C = g(
        /* by= */
        "grid",
        /* depends= */
        ["rows", "cols"]
      ), D = "layout", B = g(
        /* by= */
        D,
        /* depends= */
        E,
        /* key= */
        E,
        /* split= */
        function(W, Y) {
          var N = Y.rows = +(Y.rows || o(W, "rows") || 1), U = Y.columns = +(Y.columns || o(W, "columns") || 1);
          if (Y.image = Y.image || o(W, "image") || W.currentSrc || W.src, Y.image) {
            var V = l("img", W)[0];
            Y.image = V && (V.currentSrc || V.src);
          }
          Y.image && s(W, "background-image", "url(" + Y.image + ")");
          for (var j = N * U, ee = [], ce = a(E, "cell-grid"); j--; ) {
            var oe = a(ce, "cell");
            a(oe, "cell-inner"), ee.push(oe);
          }
          return r(W, ce), ee;
        }
      ), P = g(
        /* by= */
        "cellRows",
        /* depends= */
        [D],
        /* key= */
        "row",
        /* split= */
        function(W, Y, N) {
          var U = Y.rows, V = c(U);
          return u(N[D], function(j, ee, ce) {
            V[Math.floor(ee / (ce.length / U))].push(j);
          }), V;
        }
      ), K = g(
        /* by= */
        "cellColumns",
        /* depends= */
        [D],
        /* key= */
        "col",
        /* split= */
        function(W, Y, N) {
          var U = Y.columns, V = c(U);
          return u(N[D], function(j, ee) {
            V[ee % U].push(j);
          }), V;
        }
      ), X = g(
        /* by= */
        "cells",
        /* depends= */
        ["cellRows", "cellColumns"],
        /* key= */
        "cell",
        /* split= */
        function(W, Y, N) {
          return N[D];
        }
      );
      return v(w), v(L), v(k), v(M), v(O), v(F), v(C), v(B), v(P), v(K), v(X), A;
    }));
  })(io)), io.exports;
}
var n0 = r0();
const bo = /* @__PURE__ */ i0(n0);
function gs(n) {
  if (n === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return n;
}
function yh(n, e) {
  n.prototype = Object.create(e.prototype), n.prototype.constructor = n, n.__proto__ = e;
}
var xi = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
}, cn = {
  duration: 0.5,
  overwrite: !1,
  delay: 0
}, iu, kt, Ye, Pi = 1e8, Be = 1 / Pi, ac = Math.PI * 2, a0 = ac / 4, o0 = 0, Eh = Math.sqrt, l0 = Math.cos, c0 = Math.sin, At = function(e) {
  return typeof e == "string";
}, it = function(e) {
  return typeof e == "function";
}, bs = function(e) {
  return typeof e == "number";
}, su = function(e) {
  return typeof e > "u";
}, ls = function(e) {
  return typeof e == "object";
}, ii = function(e) {
  return e !== !1;
}, ru = function() {
  return typeof window < "u";
}, La = function(e) {
  return it(e) || At(e);
}, Th = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {
}, Vt = Array.isArray, oc = /(?:-?\.?\d|\.)+/gi, Sh = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, qr = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, ul = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, xh = /[+-]=-?[.\d]+/, bh = /[^,'"\[\]\s]+/gi, u0 = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, Qe, Qi, lc, nu, _i = {}, _o = {}, _h, Ah = function(e) {
  return (_o = un(e, _i)) && ai;
}, au = function(e, t) {
  return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()");
}, ra = function(e, t) {
  return !t && console.warn(e);
}, wh = function(e, t) {
  return e && (_i[e] = t) && _o && (_o[e] = t) || _i;
}, na = function() {
  return 0;
}, d0 = {
  suppressEvents: !0,
  isStart: !0,
  kill: !1
}, so = {
  suppressEvents: !0,
  kill: !1
}, f0 = {
  suppressEvents: !0
}, ou = {}, zs = [], cc = {}, Lh, pi = {}, dl = {}, ad = 30, ro = [], lu = "", cu = function(e) {
  var t = e[0], i, s;
  if (ls(t) || it(t) || (e = [e]), !(i = (t._gsap || {}).harness)) {
    for (s = ro.length; s-- && !ro[s].targetTest(t); )
      ;
    i = ro[s];
  }
  for (s = e.length; s--; )
    e[s] && (e[s]._gsap || (e[s]._gsap = new Qh(e[s], i))) || e.splice(s, 1);
  return e;
}, mr = function(e) {
  return e._gsap || cu(Di(e))[0]._gsap;
}, Ih = function(e, t, i) {
  return (i = e[t]) && it(i) ? e[t]() : su(i) && e.getAttribute && e.getAttribute(t) || i;
}, si = function(e, t) {
  return (e = e.split(",")).forEach(t) || e;
}, at = function(e) {
  return Math.round(e * 1e5) / 1e5 || 0;
}, ft = function(e) {
  return Math.round(e * 1e7) / 1e7 || 0;
}, Zr = function(e, t) {
  var i = t.charAt(0), s = parseFloat(t.substr(2));
  return e = parseFloat(e), i === "+" ? e + s : i === "-" ? e - s : i === "*" ? e * s : e / s;
}, h0 = function(e, t) {
  for (var i = t.length, s = 0; e.indexOf(t[s]) < 0 && ++s < i; )
    ;
  return s < i;
}, Ao = function() {
  var e = zs.length, t = zs.slice(0), i, s;
  for (cc = {}, zs.length = 0, i = 0; i < e; i++)
    s = t[i], s && s._lazy && (s.render(s._lazy[0], s._lazy[1], !0)._lazy = 0);
}, uu = function(e) {
  return !!(e._initted || e._startAt || e.add);
}, Rh = function(e, t, i, s) {
  zs.length && !kt && Ao(), e.render(t, i, !!(kt && t < 0 && uu(e))), zs.length && !kt && Ao();
}, Ch = function(e) {
  var t = parseFloat(e);
  return (t || t === 0) && (e + "").match(bh).length < 2 ? t : At(e) ? e.trim() : e;
}, Ph = function(e) {
  return e;
}, Ai = function(e, t) {
  for (var i in t)
    i in e || (e[i] = t[i]);
  return e;
}, p0 = function(e) {
  return function(t, i) {
    for (var s in i)
      s in t || s === "duration" && e || s === "ease" || (t[s] = i[s]);
  };
}, un = function(e, t) {
  for (var i in t)
    e[i] = t[i];
  return e;
}, od = function n(e, t) {
  for (var i in t)
    i !== "__proto__" && i !== "constructor" && i !== "prototype" && (e[i] = ls(t[i]) ? n(e[i] || (e[i] = {}), t[i]) : t[i]);
  return e;
}, wo = function(e, t) {
  var i = {}, s;
  for (s in e)
    s in t || (i[s] = e[s]);
  return i;
}, Un = function(e) {
  var t = e.parent || Qe, i = e.keyframes ? p0(Vt(e.keyframes)) : Ai;
  if (ii(e.inherit))
    for (; t; )
      i(e, t.vars.defaults), t = t.parent || t._dp;
  return e;
}, g0 = function(e, t) {
  for (var i = e.length, s = i === t.length; s && i-- && e[i] === t[i]; )
    ;
  return i < 0;
}, Dh = function(e, t, i, s, r) {
  var a = e[s], o;
  if (r)
    for (o = t[r]; a && a[r] > o; )
      a = a._prev;
  return a ? (t._next = a._next, a._next = t) : (t._next = e[i], e[i] = t), t._next ? t._next._prev = t : e[s] = t, t._prev = a, t.parent = t._dp = e, t;
}, jo = function(e, t, i, s) {
  i === void 0 && (i = "_first"), s === void 0 && (s = "_last");
  var r = t._prev, a = t._next;
  r ? r._next = a : e[i] === t && (e[i] = a), a ? a._prev = r : e[s] === t && (e[s] = r), t._next = t._prev = t.parent = null;
}, qs = function(e, t) {
  e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0;
}, vr = function(e, t) {
  if (e && (!t || t._end > e._dur || t._start < 0))
    for (var i = e; i; )
      i._dirty = 1, i = i.parent;
  return e;
}, m0 = function(e) {
  for (var t = e.parent; t && t.parent; )
    t._dirty = 1, t.totalDuration(), t = t.parent;
  return e;
}, uc = function(e, t, i, s) {
  return e._startAt && (kt ? e._startAt.revert(so) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, s));
}, v0 = function n(e) {
  return !e || e._ts && n(e.parent);
}, ld = function(e) {
  return e._repeat ? dn(e._tTime, e = e.duration() + e._rDelay) * e : 0;
}, dn = function(e, t) {
  var i = Math.floor(e = ft(e / t));
  return e && i === e ? i - 1 : i;
}, Lo = function(e, t) {
  return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur);
}, Qo = function(e) {
  return e._end = ft(e._start + (e._tDur / Math.abs(e._ts || e._rts || Be) || 0));
}, Zo = function(e, t) {
  var i = e._dp;
  return i && i.smoothChildTiming && e._ts && (e._start = ft(i._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), Qo(e), i._dirty || vr(i, e)), e;
}, kh = function(e, t) {
  var i;
  if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (i = Lo(e.rawTime(), t), (!t._dur || Sa(0, t.totalDuration(), i) - t._tTime > Be) && t.render(i, !0)), vr(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
    if (e._dur < e.duration())
      for (i = e; i._dp; )
        i.rawTime() >= 0 && i.totalTime(i._tTime), i = i._dp;
    e._zTime = -Be;
  }
}, es = function(e, t, i, s) {
  return t.parent && qs(t), t._start = ft((bs(i) ? i : i || e !== Qe ? Li(e, i, t) : e._time) + t._delay), t._end = ft(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), Dh(e, t, "_first", "_last", e._sort ? "_start" : 0), dc(t) || (e._recent = t), s || kh(e, t), e._ts < 0 && Zo(e, e._tTime), e;
}, Mh = function(e, t) {
  return (_i.ScrollTrigger || au("scrollTrigger", t)) && _i.ScrollTrigger.create(t, e);
}, Oh = function(e, t, i, s, r) {
  if (fu(e, t, r), !e._initted)
    return 1;
  if (!i && e._pt && !kt && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && Lh !== yi.frame)
    return zs.push(e), e._lazy = [r, s], 1;
}, y0 = function n(e) {
  var t = e.parent;
  return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || n(t));
}, dc = function(e) {
  var t = e.data;
  return t === "isFromStart" || t === "isStart";
}, E0 = function(e, t, i, s) {
  var r = e.ratio, a = t < 0 || !t && (!e._start && y0(e) && !(!e._initted && dc(e)) || (e._ts < 0 || e._dp._ts < 0) && !dc(e)) ? 0 : 1, o = e._rDelay, l = 0, c, u, d;
  if (o && e._repeat && (l = Sa(0, e._tDur, t), u = dn(l, o), e._yoyo && u & 1 && (a = 1 - a), u !== dn(e._tTime, o) && (r = 1 - a, e.vars.repeatRefresh && e._initted && e.invalidate())), a !== r || kt || s || e._zTime === Be || !t && e._zTime) {
    if (!e._initted && Oh(e, t, s, i, l))
      return;
    for (d = e._zTime, e._zTime = t || (i ? Be : 0), i || (i = t && !d), e.ratio = a, e._from && (a = 1 - a), e._time = 0, e._tTime = l, c = e._pt; c; )
      c.r(a, c.d), c = c._next;
    t < 0 && uc(e, t, i, !0), e._onUpdate && !i && Ti(e, "onUpdate"), l && e._repeat && !i && e.parent && Ti(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === a && (a && qs(e, 1), !i && !kt && (Ti(e, a ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()));
  } else e._zTime || (e._zTime = t);
}, T0 = function(e, t, i) {
  var s;
  if (i > t)
    for (s = e._first; s && s._start <= i; ) {
      if (s.data === "isPause" && s._start > t)
        return s;
      s = s._next;
    }
  else
    for (s = e._last; s && s._start >= i; ) {
      if (s.data === "isPause" && s._start < t)
        return s;
      s = s._prev;
    }
}, fn = function(e, t, i, s) {
  var r = e._repeat, a = ft(t) || 0, o = e._tTime / e._tDur;
  return o && !s && (e._time *= a / e._dur), e._dur = a, e._tDur = r ? r < 0 ? 1e10 : ft(a * (r + 1) + e._rDelay * r) : a, o > 0 && !s && Zo(e, e._tTime = e._tDur * o), e.parent && Qo(e), i || vr(e.parent, e), e;
}, cd = function(e) {
  return e instanceof jt ? vr(e) : fn(e, e._dur);
}, S0 = {
  _start: 0,
  endTime: na,
  totalDuration: na
}, Li = function n(e, t, i) {
  var s = e.labels, r = e._recent || S0, a = e.duration() >= Pi ? r.endTime(!1) : e._dur, o, l, c;
  return At(t) && (isNaN(t) || t in s) ? (l = t.charAt(0), c = t.substr(-1) === "%", o = t.indexOf("="), l === "<" || l === ">" ? (o >= 0 && (t = t.replace(/=/, "")), (l === "<" ? r._start : r.endTime(r._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (c ? (o < 0 ? r : i).totalDuration() / 100 : 1)) : o < 0 ? (t in s || (s[t] = a), s[t]) : (l = parseFloat(t.charAt(o - 1) + t.substr(o + 1)), c && i && (l = l / 100 * (Vt(i) ? i[0] : i).totalDuration()), o > 1 ? n(e, t.substr(0, o - 1), i) + l : a + l)) : t == null ? a : +t;
}, Gn = function(e, t, i) {
  var s = bs(t[1]), r = (s ? 2 : 1) + (e < 2 ? 0 : 1), a = t[r], o, l;
  if (s && (a.duration = t[1]), a.parent = i, e) {
    for (o = a, l = i; l && !("immediateRender" in o); )
      o = l.vars.defaults || {}, l = ii(l.vars.inherit) && l.parent;
    a.immediateRender = ii(o.immediateRender), e < 2 ? a.runBackwards = 1 : a.startAt = t[r - 1];
  }
  return new dt(t[0], a, t[r + 1]);
}, Js = function(e, t) {
  return e || e === 0 ? t(e) : t;
}, Sa = function(e, t, i) {
  return i < e ? e : i > t ? t : i;
}, Gt = function(e, t) {
  return !At(e) || !(t = u0.exec(e)) ? "" : t[1];
}, x0 = function(e, t, i) {
  return Js(i, function(s) {
    return Sa(e, t, s);
  });
}, fc = [].slice, Fh = function(e, t) {
  return e && ls(e) && "length" in e && (!t && !e.length || e.length - 1 in e && ls(e[0])) && !e.nodeType && e !== Qi;
}, b0 = function(e, t, i) {
  return i === void 0 && (i = []), e.forEach(function(s) {
    var r;
    return At(s) && !t || Fh(s, 1) ? (r = i).push.apply(r, Di(s)) : i.push(s);
  }) || i;
}, Di = function(e, t, i) {
  return Ye && !t && Ye.selector ? Ye.selector(e) : At(e) && !i && (lc || !hn()) ? fc.call((t || nu).querySelectorAll(e), 0) : Vt(e) ? b0(e, i) : Fh(e) ? fc.call(e, 0) : e ? [e] : [];
}, hc = function(e) {
  return e = Di(e)[0] || ra("Invalid scope") || {}, function(t) {
    var i = e.current || e.nativeElement || e;
    return Di(t, i.querySelectorAll ? i : i === e ? ra("Invalid scope") || nu.createElement("div") : e);
  };
}, Nh = function(e) {
  return e.sort(function() {
    return 0.5 - Math.random();
  });
}, $h = function(e) {
  if (it(e))
    return e;
  var t = ls(e) ? e : {
    each: e
  }, i = yr(t.ease), s = t.from || 0, r = parseFloat(t.base) || 0, a = {}, o = s > 0 && s < 1, l = isNaN(s) || o, c = t.axis, u = s, d = s;
  return At(s) ? u = d = {
    center: 0.5,
    edges: 0.5,
    end: 1
  }[s] || 0 : !o && l && (u = s[0], d = s[1]), function(f, p, h) {
    var g = (h || t).length, m = a[g], v, y, E, T, S, w, b, L, A;
    if (!m) {
      if (A = t.grid === "auto" ? 0 : (t.grid || [1, Pi])[1], !A) {
        for (b = -Pi; b < (b = h[A++].getBoundingClientRect().left) && A < g; )
          ;
        A < g && A--;
      }
      for (m = a[g] = [], v = l ? Math.min(A, g) * u - 0.5 : s % A, y = A === Pi ? 0 : l ? g * d / A - 0.5 : s / A | 0, b = 0, L = Pi, w = 0; w < g; w++)
        E = w % A - v, T = y - (w / A | 0), m[w] = S = c ? Math.abs(c === "y" ? T : E) : Eh(E * E + T * T), S > b && (b = S), S < L && (L = S);
      s === "random" && Nh(m), m.max = b - L, m.min = L, m.v = g = (parseFloat(t.amount) || parseFloat(t.each) * (A > g ? g - 1 : c ? c === "y" ? g / A : A : Math.max(A, g / A)) || 0) * (s === "edges" ? -1 : 1), m.b = g < 0 ? r - g : r, m.u = Gt(t.amount || t.each) || 0, i = i && g < 0 ? qh(i) : i;
    }
    return g = (m[f] - m.min) / m.max || 0, ft(m.b + (i ? i(g) : g) * m.v) + m.u;
  };
}, pc = function(e) {
  var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
  return function(i) {
    var s = ft(Math.round(parseFloat(i) / e) * e * t);
    return (s - s % 1) / t + (bs(i) ? 0 : Gt(i));
  };
}, Bh = function(e, t) {
  var i = Vt(e), s, r;
  return !i && ls(e) && (s = i = e.radius || Pi, e.values ? (e = Di(e.values), (r = !bs(e[0])) && (s *= s)) : e = pc(e.increment)), Js(t, i ? it(e) ? function(a) {
    return r = e(a), Math.abs(r - a) <= s ? r : a;
  } : function(a) {
    for (var o = parseFloat(r ? a.x : a), l = parseFloat(r ? a.y : 0), c = Pi, u = 0, d = e.length, f, p; d--; )
      r ? (f = e[d].x - o, p = e[d].y - l, f = f * f + p * p) : f = Math.abs(e[d] - o), f < c && (c = f, u = d);
    return u = !s || c <= s ? e[u] : a, r || u === a || bs(a) ? u : u + Gt(a);
  } : pc(e));
}, Uh = function(e, t, i, s) {
  return Js(Vt(e) ? !t : i === !0 ? !!(i = 0) : !s, function() {
    return Vt(e) ? e[~~(Math.random() * e.length)] : (i = i || 1e-5) && (s = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((e - i / 2 + Math.random() * (t - e + i * 0.99)) / i) * i * s) / s;
  });
}, _0 = function() {
  for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
    t[i] = arguments[i];
  return function(s) {
    return t.reduce(function(r, a) {
      return a(r);
    }, s);
  };
}, A0 = function(e, t) {
  return function(i) {
    return e(parseFloat(i)) + (t || Gt(i));
  };
}, w0 = function(e, t, i) {
  return Hh(e, t, 0, 1, i);
}, Gh = function(e, t, i) {
  return Js(i, function(s) {
    return e[~~t(s)];
  });
}, L0 = function n(e, t, i) {
  var s = t - e;
  return Vt(e) ? Gh(e, n(0, e.length), t) : Js(i, function(r) {
    return (s + (r - e) % s) % s + e;
  });
}, I0 = function n(e, t, i) {
  var s = t - e, r = s * 2;
  return Vt(e) ? Gh(e, n(0, e.length - 1), t) : Js(i, function(a) {
    return a = (r + (a - e) % r) % r || 0, e + (a > s ? r - a : a);
  });
}, aa = function(e) {
  for (var t = 0, i = "", s, r, a, o; ~(s = e.indexOf("random(", t)); )
    a = e.indexOf(")", s), o = e.charAt(s + 7) === "[", r = e.substr(s + 7, a - s - 7).match(o ? bh : oc), i += e.substr(t, s - t) + Uh(o ? r : +r[0], o ? 0 : +r[1], +r[2] || 1e-5), t = a + 1;
  return i + e.substr(t, e.length - t);
}, Hh = function(e, t, i, s, r) {
  var a = t - e, o = s - i;
  return Js(r, function(l) {
    return i + ((l - e) / a * o || 0);
  });
}, R0 = function n(e, t, i, s) {
  var r = isNaN(e + t) ? 0 : function(p) {
    return (1 - p) * e + p * t;
  };
  if (!r) {
    var a = At(e), o = {}, l, c, u, d, f;
    if (i === !0 && (s = 1) && (i = null), a)
      e = {
        p: e
      }, t = {
        p: t
      };
    else if (Vt(e) && !Vt(t)) {
      for (u = [], d = e.length, f = d - 2, c = 1; c < d; c++)
        u.push(n(e[c - 1], e[c]));
      d--, r = function(h) {
        h *= d;
        var g = Math.min(f, ~~h);
        return u[g](h - g);
      }, i = t;
    } else s || (e = un(Vt(e) ? [] : {}, e));
    if (!u) {
      for (l in t)
        du.call(o, e, l, "get", t[l]);
      r = function(h) {
        return gu(h, o) || (a ? e.p : e);
      };
    }
  }
  return Js(i, r);
}, ud = function(e, t, i) {
  var s = e.labels, r = Pi, a, o, l;
  for (a in s)
    o = s[a] - t, o < 0 == !!i && o && r > (o = Math.abs(o)) && (l = a, r = o);
  return l;
}, Ti = function(e, t, i) {
  var s = e.vars, r = s[t], a = Ye, o = e._ctx, l, c, u;
  if (r)
    return l = s[t + "Params"], c = s.callbackScope || e, i && zs.length && Ao(), o && (Ye = o), u = l ? r.apply(c, l) : r.call(c), Ye = a, u;
}, Rn = function(e) {
  return qs(e), e.scrollTrigger && e.scrollTrigger.kill(!!kt), e.progress() < 1 && Ti(e, "onInterrupt"), e;
}, Xr, Vh = [], zh = function(e) {
  if (e)
    if (e = !e.name && e.default || e, ru() || e.headless) {
      var t = e.name, i = it(e), s = t && !i && e.init ? function() {
        this._props = [];
      } : e, r = {
        init: na,
        render: gu,
        add: du,
        kill: W0,
        modifier: z0,
        rawVars: 0
      }, a = {
        targetTest: 0,
        get: 0,
        getSetter: pu,
        aliases: {},
        register: 0
      };
      if (hn(), e !== s) {
        if (pi[t])
          return;
        Ai(s, Ai(wo(e, r), a)), un(s.prototype, un(r, wo(e, a))), pi[s.prop = t] = s, e.targetTest && (ro.push(s), ou[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin";
      }
      wh(t, s), e.register && e.register(ai, s, ri);
    } else
      Vh.push(e);
}, $e = 255, Cn = {
  aqua: [0, $e, $e],
  lime: [0, $e, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, $e],
  navy: [0, 0, 128],
  white: [$e, $e, $e],
  olive: [128, 128, 0],
  yellow: [$e, $e, 0],
  orange: [$e, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [$e, 0, 0],
  pink: [$e, 192, 203],
  cyan: [0, $e, $e],
  transparent: [$e, $e, $e, 0]
}, fl = function(e, t, i) {
  return e += e < 0 ? 1 : e > 1 ? -1 : 0, (e * 6 < 1 ? t + (i - t) * e * 6 : e < 0.5 ? i : e * 3 < 2 ? t + (i - t) * (2 / 3 - e) * 6 : t) * $e + 0.5 | 0;
}, Wh = function(e, t, i) {
  var s = e ? bs(e) ? [e >> 16, e >> 8 & $e, e & $e] : 0 : Cn.black, r, a, o, l, c, u, d, f, p, h;
  if (!s) {
    if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), Cn[e])
      s = Cn[e];
    else if (e.charAt(0) === "#") {
      if (e.length < 6 && (r = e.charAt(1), a = e.charAt(2), o = e.charAt(3), e = "#" + r + r + a + a + o + o + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9)
        return s = parseInt(e.substr(1, 6), 16), [s >> 16, s >> 8 & $e, s & $e, parseInt(e.substr(7), 16) / 255];
      e = parseInt(e.substr(1), 16), s = [e >> 16, e >> 8 & $e, e & $e];
    } else if (e.substr(0, 3) === "hsl") {
      if (s = h = e.match(oc), !t)
        l = +s[0] % 360 / 360, c = +s[1] / 100, u = +s[2] / 100, a = u <= 0.5 ? u * (c + 1) : u + c - u * c, r = u * 2 - a, s.length > 3 && (s[3] *= 1), s[0] = fl(l + 1 / 3, r, a), s[1] = fl(l, r, a), s[2] = fl(l - 1 / 3, r, a);
      else if (~e.indexOf("="))
        return s = e.match(Sh), i && s.length < 4 && (s[3] = 1), s;
    } else
      s = e.match(oc) || Cn.transparent;
    s = s.map(Number);
  }
  return t && !h && (r = s[0] / $e, a = s[1] / $e, o = s[2] / $e, d = Math.max(r, a, o), f = Math.min(r, a, o), u = (d + f) / 2, d === f ? l = c = 0 : (p = d - f, c = u > 0.5 ? p / (2 - d - f) : p / (d + f), l = d === r ? (a - o) / p + (a < o ? 6 : 0) : d === a ? (o - r) / p + 2 : (r - a) / p + 4, l *= 60), s[0] = ~~(l + 0.5), s[1] = ~~(c * 100 + 0.5), s[2] = ~~(u * 100 + 0.5)), i && s.length < 4 && (s[3] = 1), s;
}, Kh = function(e) {
  var t = [], i = [], s = -1;
  return e.split(Ws).forEach(function(r) {
    var a = r.match(qr) || [];
    t.push.apply(t, a), i.push(s += a.length + 1);
  }), t.c = i, t;
}, dd = function(e, t, i) {
  var s = "", r = (e + s).match(Ws), a = t ? "hsla(" : "rgba(", o = 0, l, c, u, d;
  if (!r)
    return e;
  if (r = r.map(function(f) {
    return (f = Wh(f, t, 1)) && a + (t ? f[0] + "," + f[1] + "%," + f[2] + "%," + f[3] : f.join(",")) + ")";
  }), i && (u = Kh(e), l = i.c, l.join(s) !== u.c.join(s)))
    for (c = e.replace(Ws, "1").split(qr), d = c.length - 1; o < d; o++)
      s += c[o] + (~l.indexOf(o) ? r.shift() || a + "0,0,0,0)" : (u.length ? u : r.length ? r : i).shift());
  if (!c)
    for (c = e.split(Ws), d = c.length - 1; o < d; o++)
      s += c[o] + r[o];
  return s + c[d];
}, Ws = (function() {
  var n = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e;
  for (e in Cn)
    n += "|" + e + "\\b";
  return new RegExp(n + ")", "gi");
})(), C0 = /hsl[a]?\(/, Yh = function(e) {
  var t = e.join(" "), i;
  if (Ws.lastIndex = 0, Ws.test(t))
    return i = C0.test(t), e[1] = dd(e[1], i), e[0] = dd(e[0], i, Kh(e[1])), !0;
}, oa, yi = (function() {
  var n = Date.now, e = 500, t = 33, i = n(), s = i, r = 1e3 / 240, a = r, o = [], l, c, u, d, f, p, h = function g(m) {
    var v = n() - s, y = m === !0, E, T, S, w;
    if ((v > e || v < 0) && (i += v - t), s += v, S = s - i, E = S - a, (E > 0 || y) && (w = ++d.frame, f = S - d.time * 1e3, d.time = S = S / 1e3, a += E + (E >= r ? 4 : r - E), T = 1), y || (l = c(g)), T)
      for (p = 0; p < o.length; p++)
        o[p](S, f, w, m);
  };
  return d = {
    time: 0,
    frame: 0,
    tick: function() {
      h(!0);
    },
    deltaRatio: function(m) {
      return f / (1e3 / (m || 60));
    },
    wake: function() {
      _h && (!lc && ru() && (Qi = lc = window, nu = Qi.document || {}, _i.gsap = ai, (Qi.gsapVersions || (Qi.gsapVersions = [])).push(ai.version), Ah(_o || Qi.GreenSockGlobals || !Qi.gsap && Qi || {}), Vh.forEach(zh)), u = typeof requestAnimationFrame < "u" && requestAnimationFrame, l && d.sleep(), c = u || function(m) {
        return setTimeout(m, a - d.time * 1e3 + 1 | 0);
      }, oa = 1, h(2));
    },
    sleep: function() {
      (u ? cancelAnimationFrame : clearTimeout)(l), oa = 0, c = na;
    },
    lagSmoothing: function(m, v) {
      e = m || 1 / 0, t = Math.min(v || 33, e);
    },
    fps: function(m) {
      r = 1e3 / (m || 240), a = d.time * 1e3 + r;
    },
    add: function(m, v, y) {
      var E = v ? function(T, S, w, b) {
        m(T, S, w, b), d.remove(E);
      } : m;
      return d.remove(m), o[y ? "unshift" : "push"](E), hn(), E;
    },
    remove: function(m, v) {
      ~(v = o.indexOf(m)) && o.splice(v, 1) && p >= v && p--;
    },
    _listeners: o
  }, d;
})(), hn = function() {
  return !oa && yi.wake();
}, we = {}, P0 = /^[\d.\-M][\d.\-,\s]/, D0 = /["']/g, k0 = function(e) {
  for (var t = {}, i = e.substr(1, e.length - 3).split(":"), s = i[0], r = 1, a = i.length, o, l, c; r < a; r++)
    l = i[r], o = r !== a - 1 ? l.lastIndexOf(",") : l.length, c = l.substr(0, o), t[s] = isNaN(c) ? c.replace(D0, "").trim() : +c, s = l.substr(o + 1).trim();
  return t;
}, M0 = function(e) {
  var t = e.indexOf("(") + 1, i = e.indexOf(")"), s = e.indexOf("(", t);
  return e.substring(t, ~s && s < i ? e.indexOf(")", i + 1) : i);
}, O0 = function(e) {
  var t = (e + "").split("("), i = we[t[0]];
  return i && t.length > 1 && i.config ? i.config.apply(null, ~e.indexOf("{") ? [k0(t[1])] : M0(e).split(",").map(Ch)) : we._CE && P0.test(e) ? we._CE("", e) : i;
}, qh = function(e) {
  return function(t) {
    return 1 - e(1 - t);
  };
}, Xh = function n(e, t) {
  for (var i = e._first, s; i; )
    i instanceof jt ? n(i, t) : i.vars.yoyoEase && (!i._yoyo || !i._repeat) && i._yoyo !== t && (i.timeline ? n(i.timeline, t) : (s = i._ease, i._ease = i._yEase, i._yEase = s, i._yoyo = t)), i = i._next;
}, yr = function(e, t) {
  return e && (it(e) ? e : we[e] || O0(e)) || t;
}, Cr = function(e, t, i, s) {
  i === void 0 && (i = function(l) {
    return 1 - t(1 - l);
  }), s === void 0 && (s = function(l) {
    return l < 0.5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2;
  });
  var r = {
    easeIn: t,
    easeOut: i,
    easeInOut: s
  }, a;
  return si(e, function(o) {
    we[o] = _i[o] = r, we[a = o.toLowerCase()] = i;
    for (var l in r)
      we[a + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = we[o + "." + l] = r[l];
  }), r;
}, jh = function(e) {
  return function(t) {
    return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
  };
}, hl = function n(e, t, i) {
  var s = t >= 1 ? t : 1, r = (i || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1), a = r / ac * (Math.asin(1 / s) || 0), o = function(u) {
    return u === 1 ? 1 : s * Math.pow(2, -10 * u) * c0((u - a) * r) + 1;
  }, l = e === "out" ? o : e === "in" ? function(c) {
    return 1 - o(1 - c);
  } : jh(o);
  return r = ac / r, l.config = function(c, u) {
    return n(e, c, u);
  }, l;
}, pl = function n(e, t) {
  t === void 0 && (t = 1.70158);
  var i = function(a) {
    return a ? --a * a * ((t + 1) * a + t) + 1 : 0;
  }, s = e === "out" ? i : e === "in" ? function(r) {
    return 1 - i(1 - r);
  } : jh(i);
  return s.config = function(r) {
    return n(e, r);
  }, s;
};
si("Linear,Quad,Cubic,Quart,Quint,Strong", function(n, e) {
  var t = e < 5 ? e + 1 : e;
  Cr(n + ",Power" + (t - 1), e ? function(i) {
    return Math.pow(i, t);
  } : function(i) {
    return i;
  }, function(i) {
    return 1 - Math.pow(1 - i, t);
  }, function(i) {
    return i < 0.5 ? Math.pow(i * 2, t) / 2 : 1 - Math.pow((1 - i) * 2, t) / 2;
  });
});
we.Linear.easeNone = we.none = we.Linear.easeIn;
Cr("Elastic", hl("in"), hl("out"), hl());
(function(n, e) {
  var t = 1 / e, i = 2 * t, s = 2.5 * t, r = function(o) {
    return o < t ? n * o * o : o < i ? n * Math.pow(o - 1.5 / e, 2) + 0.75 : o < s ? n * (o -= 2.25 / e) * o + 0.9375 : n * Math.pow(o - 2.625 / e, 2) + 0.984375;
  };
  Cr("Bounce", function(a) {
    return 1 - r(1 - a);
  }, r);
})(7.5625, 2.75);
Cr("Expo", function(n) {
  return Math.pow(2, 10 * (n - 1)) * n + n * n * n * n * n * n * (1 - n);
});
Cr("Circ", function(n) {
  return -(Eh(1 - n * n) - 1);
});
Cr("Sine", function(n) {
  return n === 1 ? 1 : -l0(n * a0) + 1;
});
Cr("Back", pl("in"), pl("out"), pl());
we.SteppedEase = we.steps = _i.SteppedEase = {
  config: function(e, t) {
    e === void 0 && (e = 1);
    var i = 1 / e, s = e + (t ? 0 : 1), r = t ? 1 : 0, a = 1 - Be;
    return function(o) {
      return ((s * Sa(0, a, o) | 0) + r) * i;
    };
  }
};
cn.ease = we["quad.out"];
si("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(n) {
  return lu += n + "," + n + "Params,";
});
var Qh = function(e, t) {
  this.id = o0++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : Ih, this.set = t ? t.getSetter : pu;
}, la = /* @__PURE__ */ (function() {
  function n(t) {
    this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, fn(this, +t.duration, 1, 1), this.data = t.data, Ye && (this._ctx = Ye, Ye.data.push(this)), oa || yi.wake();
  }
  var e = n.prototype;
  return e.delay = function(i) {
    return i || i === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + i - this._delay), this._delay = i, this) : this._delay;
  }, e.duration = function(i) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? i + (i + this._rDelay) * this._repeat : i) : this.totalDuration() && this._dur;
  }, e.totalDuration = function(i) {
    return arguments.length ? (this._dirty = 0, fn(this, this._repeat < 0 ? i : (i - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
  }, e.totalTime = function(i, s) {
    if (hn(), !arguments.length)
      return this._tTime;
    var r = this._dp;
    if (r && r.smoothChildTiming && this._ts) {
      for (Zo(this, i), !r._dp || r.parent || kh(r, this); r && r.parent; )
        r.parent._time !== r._start + (r._ts >= 0 ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, !0), r = r.parent;
      !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && i < this._tDur || this._ts < 0 && i > 0 || !this._tDur && !i) && es(this._dp, this, this._start - this._delay);
    }
    return (this._tTime !== i || !this._dur && !s || this._initted && Math.abs(this._zTime) === Be || !i && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = i), Rh(this, i, s)), this;
  }, e.time = function(i, s) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), i + ld(this)) % (this._dur + this._rDelay) || (i ? this._dur : 0), s) : this._time;
  }, e.totalProgress = function(i, s) {
    return arguments.length ? this.totalTime(this.totalDuration() * i, s) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;
  }, e.progress = function(i, s) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - i : i) + ld(this), s) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
  }, e.iteration = function(i, s) {
    var r = this.duration() + this._rDelay;
    return arguments.length ? this.totalTime(this._time + (i - 1) * r, s) : this._repeat ? dn(this._tTime, r) + 1 : 1;
  }, e.timeScale = function(i, s) {
    if (!arguments.length)
      return this._rts === -Be ? 0 : this._rts;
    if (this._rts === i)
      return this;
    var r = this.parent && this._ts ? Lo(this.parent._time, this) : this._tTime;
    return this._rts = +i || 0, this._ts = this._ps || i === -Be ? 0 : this._rts, this.totalTime(Sa(-Math.abs(this._delay), this.totalDuration(), r), s !== !1), Qo(this), m0(this);
  }, e.paused = function(i) {
    return arguments.length ? (this._ps !== i && (this._ps = i, i ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (hn(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Be && (this._tTime -= Be)))), this) : this._ps;
  }, e.startTime = function(i) {
    if (arguments.length) {
      this._start = i;
      var s = this.parent || this._dp;
      return s && (s._sort || !this.parent) && es(s, this, i - this._delay), this;
    }
    return this._start;
  }, e.endTime = function(i) {
    return this._start + (ii(i) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  }, e.rawTime = function(i) {
    var s = this.parent || this._dp;
    return s ? i && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Lo(s.rawTime(i), this) : this._tTime : this._tTime;
  }, e.revert = function(i) {
    i === void 0 && (i = f0);
    var s = kt;
    return kt = i, uu(this) && (this.timeline && this.timeline.revert(i), this.totalTime(-0.01, i.suppressEvents)), this.data !== "nested" && i.kill !== !1 && this.kill(), kt = s, this;
  }, e.globalTime = function(i) {
    for (var s = this, r = arguments.length ? i : s.rawTime(); s; )
      r = s._start + r / (Math.abs(s._ts) || 1), s = s._dp;
    return !this.parent && this._sat ? this._sat.globalTime(i) : r;
  }, e.repeat = function(i) {
    return arguments.length ? (this._repeat = i === 1 / 0 ? -2 : i, cd(this)) : this._repeat === -2 ? 1 / 0 : this._repeat;
  }, e.repeatDelay = function(i) {
    if (arguments.length) {
      var s = this._time;
      return this._rDelay = i, cd(this), s ? this.time(s) : this;
    }
    return this._rDelay;
  }, e.yoyo = function(i) {
    return arguments.length ? (this._yoyo = i, this) : this._yoyo;
  }, e.seek = function(i, s) {
    return this.totalTime(Li(this, i), ii(s));
  }, e.restart = function(i, s) {
    return this.play().totalTime(i ? -this._delay : 0, ii(s)), this._dur || (this._zTime = -Be), this;
  }, e.play = function(i, s) {
    return i != null && this.seek(i, s), this.reversed(!1).paused(!1);
  }, e.reverse = function(i, s) {
    return i != null && this.seek(i || this.totalDuration(), s), this.reversed(!0).paused(!1);
  }, e.pause = function(i, s) {
    return i != null && this.seek(i, s), this.paused(!0);
  }, e.resume = function() {
    return this.paused(!1);
  }, e.reversed = function(i) {
    return arguments.length ? (!!i !== this.reversed() && this.timeScale(-this._rts || (i ? -Be : 0)), this) : this._rts < 0;
  }, e.invalidate = function() {
    return this._initted = this._act = 0, this._zTime = -Be, this;
  }, e.isActive = function() {
    var i = this.parent || this._dp, s = this._start, r;
    return !!(!i || this._ts && this._initted && i.isActive() && (r = i.rawTime(!0)) >= s && r < this.endTime(!0) - Be);
  }, e.eventCallback = function(i, s, r) {
    var a = this.vars;
    return arguments.length > 1 ? (s ? (a[i] = s, r && (a[i + "Params"] = r), i === "onUpdate" && (this._onUpdate = s)) : delete a[i], this) : a[i];
  }, e.then = function(i) {
    var s = this;
    return new Promise(function(r) {
      var a = it(i) ? i : Ph, o = function() {
        var c = s.then;
        s.then = null, it(a) && (a = a(s)) && (a.then || a === s) && (s.then = c), r(a), s.then = c;
      };
      s._initted && s.totalProgress() === 1 && s._ts >= 0 || !s._tTime && s._ts < 0 ? o() : s._prom = o;
    });
  }, e.kill = function() {
    Rn(this);
  }, n;
})();
Ai(la.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -Be,
  _prom: 0,
  _ps: !1,
  _rts: 1
});
var jt = /* @__PURE__ */ (function(n) {
  yh(e, n);
  function e(i, s) {
    var r;
    return i === void 0 && (i = {}), r = n.call(this, i) || this, r.labels = {}, r.smoothChildTiming = !!i.smoothChildTiming, r.autoRemoveChildren = !!i.autoRemoveChildren, r._sort = ii(i.sortChildren), Qe && es(i.parent || Qe, gs(r), s), i.reversed && r.reverse(), i.paused && r.paused(!0), i.scrollTrigger && Mh(gs(r), i.scrollTrigger), r;
  }
  var t = e.prototype;
  return t.to = function(s, r, a) {
    return Gn(0, arguments, this), this;
  }, t.from = function(s, r, a) {
    return Gn(1, arguments, this), this;
  }, t.fromTo = function(s, r, a, o) {
    return Gn(2, arguments, this), this;
  }, t.set = function(s, r, a) {
    return r.duration = 0, r.parent = this, Un(r).repeatDelay || (r.repeat = 0), r.immediateRender = !!r.immediateRender, new dt(s, r, Li(this, a), 1), this;
  }, t.call = function(s, r, a) {
    return es(this, dt.delayedCall(0, s, r), a);
  }, t.staggerTo = function(s, r, a, o, l, c, u) {
    return a.duration = r, a.stagger = a.stagger || o, a.onComplete = c, a.onCompleteParams = u, a.parent = this, new dt(s, a, Li(this, l)), this;
  }, t.staggerFrom = function(s, r, a, o, l, c, u) {
    return a.runBackwards = 1, Un(a).immediateRender = ii(a.immediateRender), this.staggerTo(s, r, a, o, l, c, u);
  }, t.staggerFromTo = function(s, r, a, o, l, c, u, d) {
    return o.startAt = a, Un(o).immediateRender = ii(o.immediateRender), this.staggerTo(s, r, o, l, c, u, d);
  }, t.render = function(s, r, a) {
    var o = this._time, l = this._dirty ? this.totalDuration() : this._tDur, c = this._dur, u = s <= 0 ? 0 : ft(s), d = this._zTime < 0 != s < 0 && (this._initted || !c), f, p, h, g, m, v, y, E, T, S, w, b;
    if (this !== Qe && u > l && s >= 0 && (u = l), u !== this._tTime || a || d) {
      if (o !== this._time && c && (u += this._time - o, s += this._time - o), f = u, T = this._start, E = this._ts, v = !E, d && (c || (o = this._zTime), (s || !r) && (this._zTime = s)), this._repeat) {
        if (w = this._yoyo, m = c + this._rDelay, this._repeat < -1 && s < 0)
          return this.totalTime(m * 100 + s, r, a);
        if (f = ft(u % m), u === l ? (g = this._repeat, f = c) : (S = ft(u / m), g = ~~S, g && g === S && (f = c, g--), f > c && (f = c)), S = dn(this._tTime, m), !o && this._tTime && S !== g && this._tTime - S * m - this._dur <= 0 && (S = g), w && g & 1 && (f = c - f, b = 1), g !== S && !this._lock) {
          var L = w && S & 1, A = L === (w && g & 1);
          if (g < S && (L = !L), o = L ? 0 : u % c ? c : u, this._lock = 1, this.render(o || (b ? 0 : ft(g * m)), r, !c)._lock = 0, this._tTime = u, !r && this.parent && Ti(this, "onRepeat"), this.vars.repeatRefresh && !b && (this.invalidate()._lock = 1), o && o !== this._time || v !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
            return this;
          if (c = this._dur, l = this._tDur, A && (this._lock = 2, o = L ? c : -1e-4, this.render(o, !0), this.vars.repeatRefresh && !b && this.invalidate()), this._lock = 0, !this._ts && !v)
            return this;
          Xh(this, b);
        }
      }
      if (this._hasPause && !this._forcing && this._lock < 2 && (y = T0(this, ft(o), ft(f)), y && (u -= f - (f = y._start))), this._tTime = u, this._time = f, this._act = !E, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = s, o = 0), !o && u && !r && !S && (Ti(this, "onStart"), this._tTime !== u))
        return this;
      if (f >= o && s >= 0)
        for (p = this._first; p; ) {
          if (h = p._next, (p._act || f >= p._start) && p._ts && y !== p) {
            if (p.parent !== this)
              return this.render(s, r, a);
            if (p.render(p._ts > 0 ? (f - p._start) * p._ts : (p._dirty ? p.totalDuration() : p._tDur) + (f - p._start) * p._ts, r, a), f !== this._time || !this._ts && !v) {
              y = 0, h && (u += this._zTime = -Be);
              break;
            }
          }
          p = h;
        }
      else {
        p = this._last;
        for (var _ = s < 0 ? s : f; p; ) {
          if (h = p._prev, (p._act || _ <= p._end) && p._ts && y !== p) {
            if (p.parent !== this)
              return this.render(s, r, a);
            if (p.render(p._ts > 0 ? (_ - p._start) * p._ts : (p._dirty ? p.totalDuration() : p._tDur) + (_ - p._start) * p._ts, r, a || kt && uu(p)), f !== this._time || !this._ts && !v) {
              y = 0, h && (u += this._zTime = _ ? -Be : Be);
              break;
            }
          }
          p = h;
        }
      }
      if (y && !r && (this.pause(), y.render(f >= o ? 0 : -Be)._zTime = f >= o ? 1 : -1, this._ts))
        return this._start = T, Qo(this), this.render(s, r, a);
      this._onUpdate && !r && Ti(this, "onUpdate", !0), (u === l && this._tTime >= this.totalDuration() || !u && o) && (T === this._start || Math.abs(E) !== Math.abs(this._ts)) && (this._lock || ((s || !c) && (u === l && this._ts > 0 || !u && this._ts < 0) && qs(this, 1), !r && !(s < 0 && !o) && (u || o || !l) && (Ti(this, u === l && s >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(u < l && this.timeScale() > 0) && this._prom())));
    }
    return this;
  }, t.add = function(s, r) {
    var a = this;
    if (bs(r) || (r = Li(this, r, s)), !(s instanceof la)) {
      if (Vt(s))
        return s.forEach(function(o) {
          return a.add(o, r);
        }), this;
      if (At(s))
        return this.addLabel(s, r);
      if (it(s))
        s = dt.delayedCall(0, s);
      else
        return this;
    }
    return this !== s ? es(this, s, r) : this;
  }, t.getChildren = function(s, r, a, o) {
    s === void 0 && (s = !0), r === void 0 && (r = !0), a === void 0 && (a = !0), o === void 0 && (o = -Pi);
    for (var l = [], c = this._first; c; )
      c._start >= o && (c instanceof dt ? r && l.push(c) : (a && l.push(c), s && l.push.apply(l, c.getChildren(!0, r, a)))), c = c._next;
    return l;
  }, t.getById = function(s) {
    for (var r = this.getChildren(1, 1, 1), a = r.length; a--; )
      if (r[a].vars.id === s)
        return r[a];
  }, t.remove = function(s) {
    return At(s) ? this.removeLabel(s) : it(s) ? this.killTweensOf(s) : (s.parent === this && jo(this, s), s === this._recent && (this._recent = this._last), vr(this));
  }, t.totalTime = function(s, r) {
    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = ft(yi.time - (this._ts > 0 ? s / this._ts : (this.totalDuration() - s) / -this._ts))), n.prototype.totalTime.call(this, s, r), this._forcing = 0, this) : this._tTime;
  }, t.addLabel = function(s, r) {
    return this.labels[s] = Li(this, r), this;
  }, t.removeLabel = function(s) {
    return delete this.labels[s], this;
  }, t.addPause = function(s, r, a) {
    var o = dt.delayedCall(0, r || na, a);
    return o.data = "isPause", this._hasPause = 1, es(this, o, Li(this, s));
  }, t.removePause = function(s) {
    var r = this._first;
    for (s = Li(this, s); r; )
      r._start === s && r.data === "isPause" && qs(r), r = r._next;
  }, t.killTweensOf = function(s, r, a) {
    for (var o = this.getTweensOf(s, a), l = o.length; l--; )
      $s !== o[l] && o[l].kill(s, r);
    return this;
  }, t.getTweensOf = function(s, r) {
    for (var a = [], o = Di(s), l = this._first, c = bs(r), u; l; )
      l instanceof dt ? h0(l._targets, o) && (c ? (!$s || l._initted && l._ts) && l.globalTime(0) <= r && l.globalTime(l.totalDuration()) > r : !r || l.isActive()) && a.push(l) : (u = l.getTweensOf(o, r)).length && a.push.apply(a, u), l = l._next;
    return a;
  }, t.tweenTo = function(s, r) {
    r = r || {};
    var a = this, o = Li(a, s), l = r, c = l.startAt, u = l.onStart, d = l.onStartParams, f = l.immediateRender, p, h = dt.to(a, Ai({
      ease: r.ease || "none",
      lazy: !1,
      immediateRender: !1,
      time: o,
      overwrite: "auto",
      duration: r.duration || Math.abs((o - (c && "time" in c ? c.time : a._time)) / a.timeScale()) || Be,
      onStart: function() {
        if (a.pause(), !p) {
          var m = r.duration || Math.abs((o - (c && "time" in c ? c.time : a._time)) / a.timeScale());
          h._dur !== m && fn(h, m, 0, 1).render(h._time, !0, !0), p = 1;
        }
        u && u.apply(h, d || []);
      }
    }, r));
    return f ? h.render(0) : h;
  }, t.tweenFromTo = function(s, r, a) {
    return this.tweenTo(r, Ai({
      startAt: {
        time: Li(this, s)
      }
    }, a));
  }, t.recent = function() {
    return this._recent;
  }, t.nextLabel = function(s) {
    return s === void 0 && (s = this._time), ud(this, Li(this, s));
  }, t.previousLabel = function(s) {
    return s === void 0 && (s = this._time), ud(this, Li(this, s), 1);
  }, t.currentLabel = function(s) {
    return arguments.length ? this.seek(s, !0) : this.previousLabel(this._time + Be);
  }, t.shiftChildren = function(s, r, a) {
    a === void 0 && (a = 0);
    for (var o = this._first, l = this.labels, c; o; )
      o._start >= a && (o._start += s, o._end += s), o = o._next;
    if (r)
      for (c in l)
        l[c] >= a && (l[c] += s);
    return vr(this);
  }, t.invalidate = function(s) {
    var r = this._first;
    for (this._lock = 0; r; )
      r.invalidate(s), r = r._next;
    return n.prototype.invalidate.call(this, s);
  }, t.clear = function(s) {
    s === void 0 && (s = !0);
    for (var r = this._first, a; r; )
      a = r._next, this.remove(r), r = a;
    return this._dp && (this._time = this._tTime = this._pTime = 0), s && (this.labels = {}), vr(this);
  }, t.totalDuration = function(s) {
    var r = 0, a = this, o = a._last, l = Pi, c, u, d;
    if (arguments.length)
      return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -s : s));
    if (a._dirty) {
      for (d = a.parent; o; )
        c = o._prev, o._dirty && o.totalDuration(), u = o._start, u > l && a._sort && o._ts && !a._lock ? (a._lock = 1, es(a, o, u - o._delay, 1)._lock = 0) : l = u, u < 0 && o._ts && (r -= u, (!d && !a._dp || d && d.smoothChildTiming) && (a._start += u / a._ts, a._time -= u, a._tTime -= u), a.shiftChildren(-u, !1, -1 / 0), l = 0), o._end > r && o._ts && (r = o._end), o = c;
      fn(a, a === Qe && a._time > r ? a._time : r, 1, 1), a._dirty = 0;
    }
    return a._tDur;
  }, e.updateRoot = function(s) {
    if (Qe._ts && (Rh(Qe, Lo(s, Qe)), Lh = yi.frame), yi.frame >= ad) {
      ad += xi.autoSleep || 120;
      var r = Qe._first;
      if ((!r || !r._ts) && xi.autoSleep && yi._listeners.length < 2) {
        for (; r && !r._ts; )
          r = r._next;
        r || yi.sleep();
      }
    }
  }, e;
})(la);
Ai(jt.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});
var F0 = function(e, t, i, s, r, a, o) {
  var l = new ri(this._pt, e, t, 0, 1, sp, null, r), c = 0, u = 0, d, f, p, h, g, m, v, y;
  for (l.b = i, l.e = s, i += "", s += "", (v = ~s.indexOf("random(")) && (s = aa(s)), a && (y = [i, s], a(y, e, t), i = y[0], s = y[1]), f = i.match(ul) || []; d = ul.exec(s); )
    h = d[0], g = s.substring(c, d.index), p ? p = (p + 1) % 5 : g.substr(-5) === "rgba(" && (p = 1), h !== f[u++] && (m = parseFloat(f[u - 1]) || 0, l._pt = {
      _next: l._pt,
      p: g || u === 1 ? g : ",",
      //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
      s: m,
      c: h.charAt(1) === "=" ? Zr(m, h) - m : parseFloat(h) - m,
      m: p && p < 4 ? Math.round : 0
    }, c = ul.lastIndex);
  return l.c = c < s.length ? s.substring(c, s.length) : "", l.fp = o, (xh.test(s) || v) && (l.e = 0), this._pt = l, l;
}, du = function(e, t, i, s, r, a, o, l, c, u) {
  it(s) && (s = s(r || 0, e, a));
  var d = e[t], f = i !== "get" ? i : it(d) ? c ? e[t.indexOf("set") || !it(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](c) : e[t]() : d, p = it(d) ? c ? G0 : tp : hu, h;
  if (At(s) && (~s.indexOf("random(") && (s = aa(s)), s.charAt(1) === "=" && (h = Zr(f, s) + (Gt(f) || 0), (h || h === 0) && (s = h))), !u || f !== s || gc)
    return !isNaN(f * s) && s !== "" ? (h = new ri(this._pt, e, t, +f || 0, s - (f || 0), typeof d == "boolean" ? V0 : ip, 0, p), c && (h.fp = c), o && h.modifier(o, this, e), this._pt = h) : (!d && !(t in e) && au(t, s), F0.call(this, e, t, f, s, p, l || xi.stringFilter, c));
}, N0 = function(e, t, i, s, r) {
  if (it(e) && (e = Hn(e, r, t, i, s)), !ls(e) || e.style && e.nodeType || Vt(e) || Th(e))
    return At(e) ? Hn(e, r, t, i, s) : e;
  var a = {}, o;
  for (o in e)
    a[o] = Hn(e[o], r, t, i, s);
  return a;
}, Zh = function(e, t, i, s, r, a) {
  var o, l, c, u;
  if (pi[e] && (o = new pi[e]()).init(r, o.rawVars ? t[e] : N0(t[e], s, r, a, i), i, s, a) !== !1 && (i._pt = l = new ri(i._pt, r, e, 0, 1, o.render, o, 0, o.priority), i !== Xr))
    for (c = i._ptLookup[i._targets.indexOf(r)], u = o._props.length; u--; )
      c[o._props[u]] = l;
  return o;
}, $s, gc, fu = function n(e, t, i) {
  var s = e.vars, r = s.ease, a = s.startAt, o = s.immediateRender, l = s.lazy, c = s.onUpdate, u = s.runBackwards, d = s.yoyoEase, f = s.keyframes, p = s.autoRevert, h = e._dur, g = e._startAt, m = e._targets, v = e.parent, y = v && v.data === "nested" ? v.vars.targets : m, E = e._overwrite === "auto" && !iu, T = e.timeline, S, w, b, L, A, _, R, I, k, M, O, F, C;
  if (T && (!f || !r) && (r = "none"), e._ease = yr(r, cn.ease), e._yEase = d ? qh(yr(d === !0 ? r : d, cn.ease)) : 0, d && e._yoyo && !e._repeat && (d = e._yEase, e._yEase = e._ease, e._ease = d), e._from = !T && !!s.runBackwards, !T || f && !s.stagger) {
    if (I = m[0] ? mr(m[0]).harness : 0, F = I && s[I.prop], S = wo(s, ou), g && (g._zTime < 0 && g.progress(1), t < 0 && u && o && !p ? g.render(-1, !0) : g.revert(u && h ? so : d0), g._lazy = 0), a) {
      if (qs(e._startAt = dt.set(m, Ai({
        data: "isStart",
        overwrite: !1,
        parent: v,
        immediateRender: !0,
        lazy: !g && ii(l),
        startAt: null,
        delay: 0,
        onUpdate: c && function() {
          return Ti(e, "onUpdate");
        },
        stagger: 0
      }, a))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (kt || !o && !p) && e._startAt.revert(so), o && h && t <= 0 && i <= 0) {
        t && (e._zTime = t);
        return;
      }
    } else if (u && h && !g) {
      if (t && (o = !1), b = Ai({
        overwrite: !1,
        data: "isFromStart",
        //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
        lazy: o && !g && ii(l),
        immediateRender: o,
        //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
        stagger: 0,
        parent: v
        //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
      }, S), F && (b[I.prop] = F), qs(e._startAt = dt.set(m, b)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (kt ? e._startAt.revert(so) : e._startAt.render(-1, !0)), e._zTime = t, !o)
        n(e._startAt, Be, Be);
      else if (!t)
        return;
    }
    for (e._pt = e._ptCache = 0, l = h && ii(l) || l && !h, w = 0; w < m.length; w++) {
      if (A = m[w], R = A._gsap || cu(m)[w]._gsap, e._ptLookup[w] = M = {}, cc[R.id] && zs.length && Ao(), O = y === m ? w : y.indexOf(A), I && (k = new I()).init(A, F || S, e, O, y) !== !1 && (e._pt = L = new ri(e._pt, A, k.name, 0, 1, k.render, k, 0, k.priority), k._props.forEach(function(D) {
        M[D] = L;
      }), k.priority && (_ = 1)), !I || F)
        for (b in S)
          pi[b] && (k = Zh(b, S, e, O, A, y)) ? k.priority && (_ = 1) : M[b] = L = du.call(e, A, b, "get", S[b], O, y, 0, s.stringFilter);
      e._op && e._op[w] && e.kill(A, e._op[w]), E && e._pt && ($s = e, Qe.killTweensOf(A, M, e.globalTime(t)), C = !e.parent, $s = 0), e._pt && l && (cc[R.id] = 1);
    }
    _ && rp(e), e._onInit && e._onInit(e);
  }
  e._onUpdate = c, e._initted = (!e._op || e._pt) && !C, f && t <= 0 && T.render(Pi, !0, !0);
}, $0 = function(e, t, i, s, r, a, o, l) {
  var c = (e._pt && e._ptCache || (e._ptCache = {}))[t], u, d, f, p;
  if (!c)
    for (c = e._ptCache[t] = [], f = e._ptLookup, p = e._targets.length; p--; ) {
      if (u = f[p][t], u && u.d && u.d._pt)
        for (u = u.d._pt; u && u.p !== t && u.fp !== t; )
          u = u._next;
      if (!u)
        return gc = 1, e.vars[t] = "+=0", fu(e, o), gc = 0, l ? ra(t + " not eligible for reset") : 1;
      c.push(u);
    }
  for (p = c.length; p--; )
    d = c[p], u = d._pt || d, u.s = (s || s === 0) && !r ? s : u.s + (s || 0) + a * u.c, u.c = i - u.s, d.e && (d.e = at(i) + Gt(d.e)), d.b && (d.b = u.s + Gt(d.b));
}, B0 = function(e, t) {
  var i = e[0] ? mr(e[0]).harness : 0, s = i && i.aliases, r, a, o, l;
  if (!s)
    return t;
  r = un({}, t);
  for (a in s)
    if (a in r)
      for (l = s[a].split(","), o = l.length; o--; )
        r[l[o]] = r[a];
  return r;
}, U0 = function(e, t, i, s) {
  var r = t.ease || s || "power1.inOut", a, o;
  if (Vt(t))
    o = i[e] || (i[e] = []), t.forEach(function(l, c) {
      return o.push({
        t: c / (t.length - 1) * 100,
        v: l,
        e: r
      });
    });
  else
    for (a in t)
      o = i[a] || (i[a] = []), a === "ease" || o.push({
        t: parseFloat(e),
        v: t[a],
        e: r
      });
}, Hn = function(e, t, i, s, r) {
  return it(e) ? e.call(t, i, s, r) : At(e) && ~e.indexOf("random(") ? aa(e) : e;
}, Jh = lu + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", ep = {};
si(Jh + ",id,stagger,delay,duration,paused,scrollTrigger", function(n) {
  return ep[n] = 1;
});
var dt = /* @__PURE__ */ (function(n) {
  yh(e, n);
  function e(i, s, r, a) {
    var o;
    typeof s == "number" && (r.duration = s, s = r, r = null), o = n.call(this, a ? s : Un(s)) || this;
    var l = o.vars, c = l.duration, u = l.delay, d = l.immediateRender, f = l.stagger, p = l.overwrite, h = l.keyframes, g = l.defaults, m = l.scrollTrigger, v = l.yoyoEase, y = s.parent || Qe, E = (Vt(i) || Th(i) ? bs(i[0]) : "length" in s) ? [i] : Di(i), T, S, w, b, L, A, _, R;
    if (o._targets = E.length ? cu(E) : ra("GSAP target " + i + " not found. https://gsap.com", !xi.nullTargetWarn) || [], o._ptLookup = [], o._overwrite = p, h || f || La(c) || La(u)) {
      if (s = o.vars, T = o.timeline = new jt({
        data: "nested",
        defaults: g || {},
        targets: y && y.data === "nested" ? y.vars.targets : E
      }), T.kill(), T.parent = T._dp = gs(o), T._start = 0, f || La(c) || La(u)) {
        if (b = E.length, _ = f && $h(f), ls(f))
          for (L in f)
            ~Jh.indexOf(L) && (R || (R = {}), R[L] = f[L]);
        for (S = 0; S < b; S++)
          w = wo(s, ep), w.stagger = 0, v && (w.yoyoEase = v), R && un(w, R), A = E[S], w.duration = +Hn(c, gs(o), S, A, E), w.delay = (+Hn(u, gs(o), S, A, E) || 0) - o._delay, !f && b === 1 && w.delay && (o._delay = u = w.delay, o._start += u, w.delay = 0), T.to(A, w, _ ? _(S, A, E) : 0), T._ease = we.none;
        T.duration() ? c = u = 0 : o.timeline = 0;
      } else if (h) {
        Un(Ai(T.vars.defaults, {
          ease: "none"
        })), T._ease = yr(h.ease || s.ease || "none");
        var I = 0, k, M, O;
        if (Vt(h))
          h.forEach(function(F) {
            return T.to(E, F, ">");
          }), T.duration();
        else {
          w = {};
          for (L in h)
            L === "ease" || L === "easeEach" || U0(L, h[L], w, h.easeEach);
          for (L in w)
            for (k = w[L].sort(function(F, C) {
              return F.t - C.t;
            }), I = 0, S = 0; S < k.length; S++)
              M = k[S], O = {
                ease: M.e,
                duration: (M.t - (S ? k[S - 1].t : 0)) / 100 * c
              }, O[L] = M.v, T.to(E, O, I), I += O.duration;
          T.duration() < c && T.to({}, {
            duration: c - T.duration()
          });
        }
      }
      c || o.duration(c = T.duration());
    } else
      o.timeline = 0;
    return p === !0 && !iu && ($s = gs(o), Qe.killTweensOf(E), $s = 0), es(y, gs(o), r), s.reversed && o.reverse(), s.paused && o.paused(!0), (d || !c && !h && o._start === ft(y._time) && ii(d) && v0(gs(o)) && y.data !== "nested") && (o._tTime = -Be, o.render(Math.max(0, -u) || 0)), m && Mh(gs(o), m), o;
  }
  var t = e.prototype;
  return t.render = function(s, r, a) {
    var o = this._time, l = this._tDur, c = this._dur, u = s < 0, d = s > l - Be && !u ? l : s < Be ? 0 : s, f, p, h, g, m, v, y, E, T;
    if (!c)
      E0(this, s, r, a);
    else if (d !== this._tTime || !s || a || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== u || this._lazy) {
      if (f = d, E = this.timeline, this._repeat) {
        if (g = c + this._rDelay, this._repeat < -1 && u)
          return this.totalTime(g * 100 + s, r, a);
        if (f = ft(d % g), d === l ? (h = this._repeat, f = c) : (m = ft(d / g), h = ~~m, h && h === m ? (f = c, h--) : f > c && (f = c)), v = this._yoyo && h & 1, v && (T = this._yEase, f = c - f), m = dn(this._tTime, g), f === o && !a && this._initted && h === m)
          return this._tTime = d, this;
        h !== m && (E && this._yEase && Xh(E, v), this.vars.repeatRefresh && !v && !this._lock && f !== g && this._initted && (this._lock = a = 1, this.render(ft(g * h), !0).invalidate()._lock = 0));
      }
      if (!this._initted) {
        if (Oh(this, u ? s : f, a, r, d))
          return this._tTime = 0, this;
        if (o !== this._time && !(a && this.vars.repeatRefresh && h !== m))
          return this;
        if (c !== this._dur)
          return this.render(s, r, a);
      }
      if (this._tTime = d, this._time = f, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = y = (T || this._ease)(f / c), this._from && (this.ratio = y = 1 - y), !o && d && !r && !m && (Ti(this, "onStart"), this._tTime !== d))
        return this;
      for (p = this._pt; p; )
        p.r(y, p.d), p = p._next;
      E && E.render(s < 0 ? s : E._dur * E._ease(f / this._dur), r, a) || this._startAt && (this._zTime = s), this._onUpdate && !r && (u && uc(this, s, r, a), Ti(this, "onUpdate")), this._repeat && h !== m && this.vars.onRepeat && !r && this.parent && Ti(this, "onRepeat"), (d === this._tDur || !d) && this._tTime === d && (u && !this._onUpdate && uc(this, s, !0, !0), (s || !c) && (d === this._tDur && this._ts > 0 || !d && this._ts < 0) && qs(this, 1), !r && !(u && !o) && (d || o || v) && (Ti(this, d === l ? "onComplete" : "onReverseComplete", !0), this._prom && !(d < l && this.timeScale() > 0) && this._prom()));
    }
    return this;
  }, t.targets = function() {
    return this._targets;
  }, t.invalidate = function(s) {
    return (!s || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(s), n.prototype.invalidate.call(this, s);
  }, t.resetTo = function(s, r, a, o, l) {
    oa || yi.wake(), this._ts || this.play();
    var c = Math.min(this._dur, (this._dp._time - this._start) * this._ts), u;
    return this._initted || fu(this, c), u = this._ease(c / this._dur), $0(this, s, r, a, o, u, c, l) ? this.resetTo(s, r, a, o, 1) : (Zo(this, 0), this.parent || Dh(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0));
  }, t.kill = function(s, r) {
    if (r === void 0 && (r = "all"), !s && (!r || r === "all"))
      return this._lazy = this._pt = 0, this.parent ? Rn(this) : this.scrollTrigger && this.scrollTrigger.kill(!!kt), this;
    if (this.timeline) {
      var a = this.timeline.totalDuration();
      return this.timeline.killTweensOf(s, r, $s && $s.vars.overwrite !== !0)._first || Rn(this), this.parent && a !== this.timeline.totalDuration() && fn(this, this._dur * this.timeline._tDur / a, 0, 1), this;
    }
    var o = this._targets, l = s ? Di(s) : o, c = this._ptLookup, u = this._pt, d, f, p, h, g, m, v;
    if ((!r || r === "all") && g0(o, l))
      return r === "all" && (this._pt = 0), Rn(this);
    for (d = this._op = this._op || [], r !== "all" && (At(r) && (g = {}, si(r, function(y) {
      return g[y] = 1;
    }), r = g), r = B0(o, r)), v = o.length; v--; )
      if (~l.indexOf(o[v])) {
        f = c[v], r === "all" ? (d[v] = r, h = f, p = {}) : (p = d[v] = d[v] || {}, h = r);
        for (g in h)
          m = f && f[g], m && ((!("kill" in m.d) || m.d.kill(g) === !0) && jo(this, m, "_pt"), delete f[g]), p !== "all" && (p[g] = 1);
      }
    return this._initted && !this._pt && u && Rn(this), this;
  }, e.to = function(s, r) {
    return new e(s, r, arguments[2]);
  }, e.from = function(s, r) {
    return Gn(1, arguments);
  }, e.delayedCall = function(s, r, a, o) {
    return new e(r, 0, {
      immediateRender: !1,
      lazy: !1,
      overwrite: !1,
      delay: s,
      onComplete: r,
      onReverseComplete: r,
      onCompleteParams: a,
      onReverseCompleteParams: a,
      callbackScope: o
    });
  }, e.fromTo = function(s, r, a) {
    return Gn(2, arguments);
  }, e.set = function(s, r) {
    return r.duration = 0, r.repeatDelay || (r.repeat = 0), new e(s, r);
  }, e.killTweensOf = function(s, r, a) {
    return Qe.killTweensOf(s, r, a);
  }, e;
})(la);
Ai(dt.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
});
si("staggerTo,staggerFrom,staggerFromTo", function(n) {
  dt[n] = function() {
    var e = new jt(), t = fc.call(arguments, 0);
    return t.splice(n === "staggerFromTo" ? 5 : 4, 0, 0), e[n].apply(e, t);
  };
});
var hu = function(e, t, i) {
  return e[t] = i;
}, tp = function(e, t, i) {
  return e[t](i);
}, G0 = function(e, t, i, s) {
  return e[t](s.fp, i);
}, H0 = function(e, t, i) {
  return e.setAttribute(t, i);
}, pu = function(e, t) {
  return it(e[t]) ? tp : su(e[t]) && e.setAttribute ? H0 : hu;
}, ip = function(e, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
}, V0 = function(e, t) {
  return t.set(t.t, t.p, !!(t.s + t.c * e), t);
}, sp = function(e, t) {
  var i = t._pt, s = "";
  if (!e && t.b)
    s = t.b;
  else if (e === 1 && t.e)
    s = t.e;
  else {
    for (; i; )
      s = i.p + (i.m ? i.m(i.s + i.c * e) : Math.round((i.s + i.c * e) * 1e4) / 1e4) + s, i = i._next;
    s += t.c;
  }
  t.set(t.t, t.p, s, t);
}, gu = function(e, t) {
  for (var i = t._pt; i; )
    i.r(e, i.d), i = i._next;
}, z0 = function(e, t, i, s) {
  for (var r = this._pt, a; r; )
    a = r._next, r.p === s && r.modifier(e, t, i), r = a;
}, W0 = function(e) {
  for (var t = this._pt, i, s; t; )
    s = t._next, t.p === e && !t.op || t.op === e ? jo(this, t, "_pt") : t.dep || (i = 1), t = s;
  return !i;
}, K0 = function(e, t, i, s) {
  s.mSet(e, t, s.m.call(s.tween, i, s.mt), s);
}, rp = function(e) {
  for (var t = e._pt, i, s, r, a; t; ) {
    for (i = t._next, s = r; s && s.pr > t.pr; )
      s = s._next;
    (t._prev = s ? s._prev : a) ? t._prev._next = t : r = t, (t._next = s) ? s._prev = t : a = t, t = i;
  }
  e._pt = r;
}, ri = /* @__PURE__ */ (function() {
  function n(t, i, s, r, a, o, l, c, u) {
    this.t = i, this.s = r, this.c = a, this.p = s, this.r = o || ip, this.d = l || this, this.set = c || hu, this.pr = u || 0, this._next = t, t && (t._prev = this);
  }
  var e = n.prototype;
  return e.modifier = function(i, s, r) {
    this.mSet = this.mSet || this.set, this.set = K0, this.m = i, this.mt = r, this.tween = s;
  }, n;
})();
si(lu + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(n) {
  return ou[n] = 1;
});
_i.TweenMax = _i.TweenLite = dt;
_i.TimelineLite = _i.TimelineMax = jt;
Qe = new jt({
  sortChildren: !1,
  defaults: cn,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0
});
xi.stringFilter = Yh;
var Er = [], no = {}, Y0 = [], fd = 0, q0 = 0, gl = function(e) {
  return (no[e] || Y0).map(function(t) {
    return t();
  });
}, mc = function() {
  var e = Date.now(), t = [];
  e - fd > 2 && (gl("matchMediaInit"), Er.forEach(function(i) {
    var s = i.queries, r = i.conditions, a, o, l, c;
    for (o in s)
      a = Qi.matchMedia(s[o]).matches, a && (l = 1), a !== r[o] && (r[o] = a, c = 1);
    c && (i.revert(), l && t.push(i));
  }), gl("matchMediaRevert"), t.forEach(function(i) {
    return i.onMatch(i, function(s) {
      return i.add(null, s);
    });
  }), fd = e, gl("matchMedia"));
}, np = /* @__PURE__ */ (function() {
  function n(t, i) {
    this.selector = i && hc(i), this.data = [], this._r = [], this.isReverted = !1, this.id = q0++, t && this.add(t);
  }
  var e = n.prototype;
  return e.add = function(i, s, r) {
    it(i) && (r = s, s = i, i = it);
    var a = this, o = function() {
      var c = Ye, u = a.selector, d;
      return c && c !== a && c.data.push(a), r && (a.selector = hc(r)), Ye = a, d = s.apply(a, arguments), it(d) && a._r.push(d), Ye = c, a.selector = u, a.isReverted = !1, d;
    };
    return a.last = o, i === it ? o(a, function(l) {
      return a.add(null, l);
    }) : i ? a[i] = o : o;
  }, e.ignore = function(i) {
    var s = Ye;
    Ye = null, i(this), Ye = s;
  }, e.getTweens = function() {
    var i = [];
    return this.data.forEach(function(s) {
      return s instanceof n ? i.push.apply(i, s.getTweens()) : s instanceof dt && !(s.parent && s.parent.data === "nested") && i.push(s);
    }), i;
  }, e.clear = function() {
    this._r.length = this.data.length = 0;
  }, e.kill = function(i, s) {
    var r = this;
    if (i ? (function() {
      for (var o = r.getTweens(), l = r.data.length, c; l--; )
        c = r.data[l], c.data === "isFlip" && (c.revert(), c.getChildren(!0, !0, !1).forEach(function(u) {
          return o.splice(o.indexOf(u), 1);
        }));
      for (o.map(function(u) {
        return {
          g: u._dur || u._delay || u._sat && !u._sat.vars.immediateRender ? u.globalTime(0) : -1 / 0,
          t: u
        };
      }).sort(function(u, d) {
        return d.g - u.g || -1 / 0;
      }).forEach(function(u) {
        return u.t.revert(i);
      }), l = r.data.length; l--; )
        c = r.data[l], c instanceof jt ? c.data !== "nested" && (c.scrollTrigger && c.scrollTrigger.revert(), c.kill()) : !(c instanceof dt) && c.revert && c.revert(i);
      r._r.forEach(function(u) {
        return u(i, r);
      }), r.isReverted = !0;
    })() : this.data.forEach(function(o) {
      return o.kill && o.kill();
    }), this.clear(), s)
      for (var a = Er.length; a--; )
        Er[a].id === this.id && Er.splice(a, 1);
  }, e.revert = function(i) {
    this.kill(i || {});
  }, n;
})(), X0 = /* @__PURE__ */ (function() {
  function n(t) {
    this.contexts = [], this.scope = t, Ye && Ye.data.push(this);
  }
  var e = n.prototype;
  return e.add = function(i, s, r) {
    ls(i) || (i = {
      matches: i
    });
    var a = new np(0, r || this.scope), o = a.conditions = {}, l, c, u;
    Ye && !a.selector && (a.selector = Ye.selector), this.contexts.push(a), s = a.add("onMatch", s), a.queries = i;
    for (c in i)
      c === "all" ? u = 1 : (l = Qi.matchMedia(i[c]), l && (Er.indexOf(a) < 0 && Er.push(a), (o[c] = l.matches) && (u = 1), l.addListener ? l.addListener(mc) : l.addEventListener("change", mc)));
    return u && s(a, function(d) {
      return a.add(null, d);
    }), this;
  }, e.revert = function(i) {
    this.kill(i || {});
  }, e.kill = function(i) {
    this.contexts.forEach(function(s) {
      return s.kill(i, !0);
    });
  }, n;
})(), Io = {
  registerPlugin: function() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    t.forEach(function(s) {
      return zh(s);
    });
  },
  timeline: function(e) {
    return new jt(e);
  },
  getTweensOf: function(e, t) {
    return Qe.getTweensOf(e, t);
  },
  getProperty: function(e, t, i, s) {
    At(e) && (e = Di(e)[0]);
    var r = mr(e || {}).get, a = i ? Ph : Ch;
    return i === "native" && (i = ""), e && (t ? a((pi[t] && pi[t].get || r)(e, t, i, s)) : function(o, l, c) {
      return a((pi[o] && pi[o].get || r)(e, o, l, c));
    });
  },
  quickSetter: function(e, t, i) {
    if (e = Di(e), e.length > 1) {
      var s = e.map(function(u) {
        return ai.quickSetter(u, t, i);
      }), r = s.length;
      return function(u) {
        for (var d = r; d--; )
          s[d](u);
      };
    }
    e = e[0] || {};
    var a = pi[t], o = mr(e), l = o.harness && (o.harness.aliases || {})[t] || t, c = a ? function(u) {
      var d = new a();
      Xr._pt = 0, d.init(e, i ? u + i : u, Xr, 0, [e]), d.render(1, d), Xr._pt && gu(1, Xr);
    } : o.set(e, l);
    return a ? c : function(u) {
      return c(e, l, i ? u + i : u, o, 1);
    };
  },
  quickTo: function(e, t, i) {
    var s, r = ai.to(e, Ai((s = {}, s[t] = "+=0.1", s.paused = !0, s.stagger = 0, s), i || {})), a = function(l, c, u) {
      return r.resetTo(t, l, c, u);
    };
    return a.tween = r, a;
  },
  isTweening: function(e) {
    return Qe.getTweensOf(e, !0).length > 0;
  },
  defaults: function(e) {
    return e && e.ease && (e.ease = yr(e.ease, cn.ease)), od(cn, e || {});
  },
  config: function(e) {
    return od(xi, e || {});
  },
  registerEffect: function(e) {
    var t = e.name, i = e.effect, s = e.plugins, r = e.defaults, a = e.extendTimeline;
    (s || "").split(",").forEach(function(o) {
      return o && !pi[o] && !_i[o] && ra(t + " effect requires " + o + " plugin.");
    }), dl[t] = function(o, l, c) {
      return i(Di(o), Ai(l || {}, r), c);
    }, a && (jt.prototype[t] = function(o, l, c) {
      return this.add(dl[t](o, ls(l) ? l : (c = l) && {}, this), c);
    });
  },
  registerEase: function(e, t) {
    we[e] = yr(t);
  },
  parseEase: function(e, t) {
    return arguments.length ? yr(e, t) : we;
  },
  getById: function(e) {
    return Qe.getById(e);
  },
  exportRoot: function(e, t) {
    e === void 0 && (e = {});
    var i = new jt(e), s, r;
    for (i.smoothChildTiming = ii(e.smoothChildTiming), Qe.remove(i), i._dp = 0, i._time = i._tTime = Qe._time, s = Qe._first; s; )
      r = s._next, (t || !(!s._dur && s instanceof dt && s.vars.onComplete === s._targets[0])) && es(i, s, s._start - s._delay), s = r;
    return es(Qe, i, 0), i;
  },
  context: function(e, t) {
    return e ? new np(e, t) : Ye;
  },
  matchMedia: function(e) {
    return new X0(e);
  },
  matchMediaRefresh: function() {
    return Er.forEach(function(e) {
      var t = e.conditions, i, s;
      for (s in t)
        t[s] && (t[s] = !1, i = 1);
      i && e.revert();
    }) || mc();
  },
  addEventListener: function(e, t) {
    var i = no[e] || (no[e] = []);
    ~i.indexOf(t) || i.push(t);
  },
  removeEventListener: function(e, t) {
    var i = no[e], s = i && i.indexOf(t);
    s >= 0 && i.splice(s, 1);
  },
  utils: {
    wrap: L0,
    wrapYoyo: I0,
    distribute: $h,
    random: Uh,
    snap: Bh,
    normalize: w0,
    getUnit: Gt,
    clamp: x0,
    splitColor: Wh,
    toArray: Di,
    selector: hc,
    mapRange: Hh,
    pipe: _0,
    unitize: A0,
    interpolate: R0,
    shuffle: Nh
  },
  install: Ah,
  effects: dl,
  ticker: yi,
  updateRoot: jt.updateRoot,
  plugins: pi,
  globalTimeline: Qe,
  core: {
    PropTween: ri,
    globals: wh,
    Tween: dt,
    Timeline: jt,
    Animation: la,
    getCache: mr,
    _removeLinkedListItem: jo,
    reverting: function() {
      return kt;
    },
    context: function(e) {
      return e && Ye && (Ye.data.push(e), e._ctx = Ye), Ye;
    },
    suppressOverwrites: function(e) {
      return iu = e;
    }
  }
};
si("to,from,fromTo,delayedCall,set,killTweensOf", function(n) {
  return Io[n] = dt[n];
});
yi.add(jt.updateRoot);
Xr = Io.to({}, {
  duration: 0
});
var j0 = function(e, t) {
  for (var i = e._pt; i && i.p !== t && i.op !== t && i.fp !== t; )
    i = i._next;
  return i;
}, Q0 = function(e, t) {
  var i = e._targets, s, r, a;
  for (s in t)
    for (r = i.length; r--; )
      a = e._ptLookup[r][s], a && (a = a.d) && (a._pt && (a = j0(a, s)), a && a.modifier && a.modifier(t[s], e, i[r], s));
}, ml = function(e, t) {
  return {
    name: e,
    headless: 1,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function(s, r, a) {
      a._onInit = function(o) {
        var l, c;
        if (At(r) && (l = {}, si(r, function(u) {
          return l[u] = 1;
        }), r = l), t) {
          l = {};
          for (c in r)
            l[c] = t(r[c]);
          r = l;
        }
        Q0(o, r);
      };
    }
  };
}, ai = Io.registerPlugin({
  name: "attr",
  init: function(e, t, i, s, r) {
    var a, o, l;
    this.tween = i;
    for (a in t)
      l = e.getAttribute(a) || "", o = this.add(e, "setAttribute", (l || 0) + "", t[a], s, r, 0, 0, a), o.op = a, o.b = l, this._props.push(a);
  },
  render: function(e, t) {
    for (var i = t._pt; i; )
      kt ? i.set(i.t, i.p, i.b, i) : i.r(e, i.d), i = i._next;
  }
}, {
  name: "endArray",
  headless: 1,
  init: function(e, t) {
    for (var i = t.length; i--; )
      this.add(e, i, e[i] || 0, t[i], 0, 0, 0, 0, 0, 1);
  }
}, ml("roundProps", pc), ml("modifiers"), ml("snap", Bh)) || Io;
dt.version = jt.version = ai.version = "3.13.0";
_h = 1;
ru() && hn();
we.Power0;
we.Power1;
we.Power2;
we.Power3;
we.Power4;
we.Linear;
we.Quad;
we.Cubic;
we.Quart;
we.Quint;
we.Strong;
we.Elastic;
we.Back;
we.SteppedEase;
we.Bounce;
we.Sine;
we.Expo;
we.Circ;
var hd, Bs, Jr, mu, pr, pd, vu, Z0 = function() {
  return typeof window < "u";
}, _s = {}, lr = 180 / Math.PI, en = Math.PI / 180, Fr = Math.atan2, gd = 1e8, yu = /([A-Z])/g, J0 = /(left|right|width|margin|padding|x)/i, ev = /[\s,\(]\S/, is = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
}, vc = function(e, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
}, tv = function(e, t) {
  return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
}, iv = function(e, t) {
  return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t);
}, sv = function(e, t) {
  var i = t.s + t.c * e;
  t.set(t.t, t.p, ~~(i + (i < 0 ? -0.5 : 0.5)) + t.u, t);
}, ap = function(e, t) {
  return t.set(t.t, t.p, e ? t.e : t.b, t);
}, op = function(e, t) {
  return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
}, rv = function(e, t, i) {
  return e.style[t] = i;
}, nv = function(e, t, i) {
  return e.style.setProperty(t, i);
}, av = function(e, t, i) {
  return e._gsap[t] = i;
}, ov = function(e, t, i) {
  return e._gsap.scaleX = e._gsap.scaleY = i;
}, lv = function(e, t, i, s, r) {
  var a = e._gsap;
  a.scaleX = a.scaleY = i, a.renderTransform(r, a);
}, cv = function(e, t, i, s, r) {
  var a = e._gsap;
  a[t] = i, a.renderTransform(r, a);
}, Je = "transform", ni = Je + "Origin", uv = function n(e, t) {
  var i = this, s = this.target, r = s.style, a = s._gsap;
  if (e in _s && r) {
    if (this.tfm = this.tfm || {}, e !== "transform")
      e = is[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function(o) {
        return i.tfm[o] = ys(s, o);
      }) : this.tfm[e] = a.x ? a[e] : ys(s, e), e === ni && (this.tfm.zOrigin = a.zOrigin);
    else
      return is.transform.split(",").forEach(function(o) {
        return n.call(i, o, t);
      });
    if (this.props.indexOf(Je) >= 0)
      return;
    a.svg && (this.svgo = s.getAttribute("data-svg-origin"), this.props.push(ni, t, "")), e = Je;
  }
  (r || t) && this.props.push(e, t, r[e]);
}, lp = function(e) {
  e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate"));
}, dv = function() {
  var e = this.props, t = this.target, i = t.style, s = t._gsap, r, a;
  for (r = 0; r < e.length; r += 3)
    e[r + 1] ? e[r + 1] === 2 ? t[e[r]](e[r + 2]) : t[e[r]] = e[r + 2] : e[r + 2] ? i[e[r]] = e[r + 2] : i.removeProperty(e[r].substr(0, 2) === "--" ? e[r] : e[r].replace(yu, "-$1").toLowerCase());
  if (this.tfm) {
    for (a in this.tfm)
      s[a] = this.tfm[a];
    s.svg && (s.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), r = vu(), (!r || !r.isStart) && !i[Je] && (lp(i), s.zOrigin && i[ni] && (i[ni] += " " + s.zOrigin + "px", s.zOrigin = 0, s.renderTransform()), s.uncache = 1);
  }
}, cp = function(e, t) {
  var i = {
    target: e,
    props: [],
    revert: dv,
    save: uv
  };
  return e._gsap || ai.core.getCache(e), t && e.style && e.nodeType && t.split(",").forEach(function(s) {
    return i.save(s);
  }), i;
}, up, yc = function(e, t) {
  var i = Bs.createElementNS ? Bs.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : Bs.createElement(e);
  return i && i.style ? i : Bs.createElement(e);
}, ki = function n(e, t, i) {
  var s = getComputedStyle(e);
  return s[t] || s.getPropertyValue(t.replace(yu, "-$1").toLowerCase()) || s.getPropertyValue(t) || !i && n(e, pn(t) || t, 1) || "";
}, md = "O,Moz,ms,Ms,Webkit".split(","), pn = function(e, t, i) {
  var s = t || pr, r = s.style, a = 5;
  if (e in r && !i)
    return e;
  for (e = e.charAt(0).toUpperCase() + e.substr(1); a-- && !(md[a] + e in r); )
    ;
  return a < 0 ? null : (a === 3 ? "ms" : a >= 0 ? md[a] : "") + e;
}, Ec = function() {
  Z0() && window.document && (hd = window, Bs = hd.document, Jr = Bs.documentElement, pr = yc("div") || {
    style: {}
  }, yc("div"), Je = pn(Je), ni = Je + "Origin", pr.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", up = !!pn("perspective"), vu = ai.core.reverting, mu = 1);
}, vd = function(e) {
  var t = e.ownerSVGElement, i = yc("svg", t && t.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), s = e.cloneNode(!0), r;
  s.style.display = "block", i.appendChild(s), Jr.appendChild(i);
  try {
    r = s.getBBox();
  } catch {
  }
  return i.removeChild(s), Jr.removeChild(i), r;
}, yd = function(e, t) {
  for (var i = t.length; i--; )
    if (e.hasAttribute(t[i]))
      return e.getAttribute(t[i]);
}, dp = function(e) {
  var t, i;
  try {
    t = e.getBBox();
  } catch {
    t = vd(e), i = 1;
  }
  return t && (t.width || t.height) || i || (t = vd(e)), t && !t.width && !t.x && !t.y ? {
    x: +yd(e, ["x", "cx", "x1"]) || 0,
    y: +yd(e, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : t;
}, fp = function(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && dp(e));
}, Ar = function(e, t) {
  if (t) {
    var i = e.style, s;
    t in _s && t !== ni && (t = Je), i.removeProperty ? (s = t.substr(0, 2), (s === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), i.removeProperty(s === "--" ? t : t.replace(yu, "-$1").toLowerCase())) : i.removeAttribute(t);
  }
}, Us = function(e, t, i, s, r, a) {
  var o = new ri(e._pt, t, i, 0, 1, a ? op : ap);
  return e._pt = o, o.b = s, o.e = r, e._props.push(i), o;
}, Ed = {
  deg: 1,
  rad: 1,
  turn: 1
}, fv = {
  grid: 1,
  flex: 1
}, Xs = function n(e, t, i, s) {
  var r = parseFloat(i) || 0, a = (i + "").trim().substr((r + "").length) || "px", o = pr.style, l = J0.test(t), c = e.tagName.toLowerCase() === "svg", u = (c ? "client" : "offset") + (l ? "Width" : "Height"), d = 100, f = s === "px", p = s === "%", h, g, m, v;
  if (s === a || !r || Ed[s] || Ed[a])
    return r;
  if (a !== "px" && !f && (r = n(e, t, i, "px")), v = e.getCTM && fp(e), (p || a === "%") && (_s[t] || ~t.indexOf("adius")))
    return h = v ? e.getBBox()[l ? "width" : "height"] : e[u], at(p ? r / h * d : r / 100 * h);
  if (o[l ? "width" : "height"] = d + (f ? a : s), g = s !== "rem" && ~t.indexOf("adius") || s === "em" && e.appendChild && !c ? e : e.parentNode, v && (g = (e.ownerSVGElement || {}).parentNode), (!g || g === Bs || !g.appendChild) && (g = Bs.body), m = g._gsap, m && p && m.width && l && m.time === yi.time && !m.uncache)
    return at(r / m.width * d);
  if (p && (t === "height" || t === "width")) {
    var y = e.style[t];
    e.style[t] = d + s, h = e[u], y ? e.style[t] = y : Ar(e, t);
  } else
    (p || a === "%") && !fv[ki(g, "display")] && (o.position = ki(e, "position")), g === e && (o.position = "static"), g.appendChild(pr), h = pr[u], g.removeChild(pr), o.position = "absolute";
  return l && p && (m = mr(g), m.time = yi.time, m.width = g[u]), at(f ? h * r / d : h && r ? d / h * r : 0);
}, ys = function(e, t, i, s) {
  var r;
  return mu || Ec(), t in is && t !== "transform" && (t = is[t], ~t.indexOf(",") && (t = t.split(",")[0])), _s[t] && t !== "transform" ? (r = ua(e, s), r = t !== "transformOrigin" ? r[t] : r.svg ? r.origin : Co(ki(e, ni)) + " " + r.zOrigin + "px") : (r = e.style[t], (!r || r === "auto" || s || ~(r + "").indexOf("calc(")) && (r = Ro[t] && Ro[t](e, t, i) || ki(e, t) || Ih(e, t) || (t === "opacity" ? 1 : 0))), i && !~(r + "").trim().indexOf(" ") ? Xs(e, t, r, i) + i : r;
}, hv = function(e, t, i, s) {
  if (!i || i === "none") {
    var r = pn(t, e, 1), a = r && ki(e, r, 1);
    a && a !== i ? (t = r, i = a) : t === "borderColor" && (i = ki(e, "borderTopColor"));
  }
  var o = new ri(this._pt, e.style, t, 0, 1, sp), l = 0, c = 0, u, d, f, p, h, g, m, v, y, E, T, S;
  if (o.b = i, o.e = s, i += "", s += "", s.substring(0, 6) === "var(--" && (s = ki(e, s.substring(4, s.indexOf(")")))), s === "auto" && (g = e.style[t], e.style[t] = s, s = ki(e, t) || s, g ? e.style[t] = g : Ar(e, t)), u = [i, s], Yh(u), i = u[0], s = u[1], f = i.match(qr) || [], S = s.match(qr) || [], S.length) {
    for (; d = qr.exec(s); )
      m = d[0], y = s.substring(l, d.index), h ? h = (h + 1) % 5 : (y.substr(-5) === "rgba(" || y.substr(-5) === "hsla(") && (h = 1), m !== (g = f[c++] || "") && (p = parseFloat(g) || 0, T = g.substr((p + "").length), m.charAt(1) === "=" && (m = Zr(p, m) + T), v = parseFloat(m), E = m.substr((v + "").length), l = qr.lastIndex - E.length, E || (E = E || xi.units[t] || T, l === s.length && (s += E, o.e += E)), T !== E && (p = Xs(e, t, g, E) || 0), o._pt = {
        _next: o._pt,
        p: y || c === 1 ? y : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: p,
        c: v - p,
        m: h && h < 4 || t === "zIndex" ? Math.round : 0
      });
    o.c = l < s.length ? s.substring(l, s.length) : "";
  } else
    o.r = t === "display" && s === "none" ? op : ap;
  return xh.test(s) && (o.e = 0), this._pt = o, o;
}, Td = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
}, pv = function(e) {
  var t = e.split(" "), i = t[0], s = t[1] || "50%";
  return (i === "top" || i === "bottom" || s === "left" || s === "right") && (e = i, i = s, s = e), t[0] = Td[i] || i, t[1] = Td[s] || s, t.join(" ");
}, gv = function(e, t) {
  if (t.tween && t.tween._time === t.tween._dur) {
    var i = t.t, s = i.style, r = t.u, a = i._gsap, o, l, c;
    if (r === "all" || r === !0)
      s.cssText = "", l = 1;
    else
      for (r = r.split(","), c = r.length; --c > -1; )
        o = r[c], _s[o] && (l = 1, o = o === "transformOrigin" ? ni : Je), Ar(i, o);
    l && (Ar(i, Je), a && (a.svg && i.removeAttribute("transform"), s.scale = s.rotate = s.translate = "none", ua(i, 1), a.uncache = 1, lp(s)));
  }
}, Ro = {
  clearProps: function(e, t, i, s, r) {
    if (r.data !== "isFromStart") {
      var a = e._pt = new ri(e._pt, t, i, 0, 0, gv);
      return a.u = s, a.pr = -10, a.tween = r, e._props.push(i), 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */
}, ca = [1, 0, 0, 1, 0, 0], hp = {}, pp = function(e) {
  return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e;
}, Sd = function(e) {
  var t = ki(e, Je);
  return pp(t) ? ca : t.substr(7).match(Sh).map(at);
}, Eu = function(e, t) {
  var i = e._gsap || mr(e), s = e.style, r = Sd(e), a, o, l, c;
  return i.svg && e.getAttribute("transform") ? (l = e.transform.baseVal.consolidate().matrix, r = [l.a, l.b, l.c, l.d, l.e, l.f], r.join(",") === "1,0,0,1,0,0" ? ca : r) : (r === ca && !e.offsetParent && e !== Jr && !i.svg && (l = s.display, s.display = "block", a = e.parentNode, (!a || !e.offsetParent && !e.getBoundingClientRect().width) && (c = 1, o = e.nextElementSibling, Jr.appendChild(e)), r = Sd(e), l ? s.display = l : Ar(e, "display"), c && (o ? a.insertBefore(e, o) : a ? a.appendChild(e) : Jr.removeChild(e))), t && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r);
}, Tc = function(e, t, i, s, r, a) {
  var o = e._gsap, l = r || Eu(e, !0), c = o.xOrigin || 0, u = o.yOrigin || 0, d = o.xOffset || 0, f = o.yOffset || 0, p = l[0], h = l[1], g = l[2], m = l[3], v = l[4], y = l[5], E = t.split(" "), T = parseFloat(E[0]) || 0, S = parseFloat(E[1]) || 0, w, b, L, A;
  i ? l !== ca && (b = p * m - h * g) && (L = T * (m / b) + S * (-g / b) + (g * y - m * v) / b, A = T * (-h / b) + S * (p / b) - (p * y - h * v) / b, T = L, S = A) : (w = dp(e), T = w.x + (~E[0].indexOf("%") ? T / 100 * w.width : T), S = w.y + (~(E[1] || E[0]).indexOf("%") ? S / 100 * w.height : S)), s || s !== !1 && o.smooth ? (v = T - c, y = S - u, o.xOffset = d + (v * p + y * g) - v, o.yOffset = f + (v * h + y * m) - y) : o.xOffset = o.yOffset = 0, o.xOrigin = T, o.yOrigin = S, o.smooth = !!s, o.origin = t, o.originIsAbsolute = !!i, e.style[ni] = "0px 0px", a && (Us(a, o, "xOrigin", c, T), Us(a, o, "yOrigin", u, S), Us(a, o, "xOffset", d, o.xOffset), Us(a, o, "yOffset", f, o.yOffset)), e.setAttribute("data-svg-origin", T + " " + S);
}, ua = function(e, t) {
  var i = e._gsap || new Qh(e);
  if ("x" in i && !t && !i.uncache)
    return i;
  var s = e.style, r = i.scaleX < 0, a = "px", o = "deg", l = getComputedStyle(e), c = ki(e, ni) || "0", u, d, f, p, h, g, m, v, y, E, T, S, w, b, L, A, _, R, I, k, M, O, F, C, D, B, P, K, X, W, Y, N;
  return u = d = f = g = m = v = y = E = T = 0, p = h = 1, i.svg = !!(e.getCTM && fp(e)), l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (s[Je] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[Je] !== "none" ? l[Je] : "")), s.scale = s.rotate = s.translate = "none"), b = Eu(e, i.svg), i.svg && (i.uncache ? (D = e.getBBox(), c = i.xOrigin - D.x + "px " + (i.yOrigin - D.y) + "px", C = "") : C = !t && e.getAttribute("data-svg-origin"), Tc(e, C || c, !!C || i.originIsAbsolute, i.smooth !== !1, b)), S = i.xOrigin || 0, w = i.yOrigin || 0, b !== ca && (R = b[0], I = b[1], k = b[2], M = b[3], u = O = b[4], d = F = b[5], b.length === 6 ? (p = Math.sqrt(R * R + I * I), h = Math.sqrt(M * M + k * k), g = R || I ? Fr(I, R) * lr : 0, y = k || M ? Fr(k, M) * lr + g : 0, y && (h *= Math.abs(Math.cos(y * en))), i.svg && (u -= S - (S * R + w * k), d -= w - (S * I + w * M))) : (N = b[6], W = b[7], P = b[8], K = b[9], X = b[10], Y = b[11], u = b[12], d = b[13], f = b[14], L = Fr(N, X), m = L * lr, L && (A = Math.cos(-L), _ = Math.sin(-L), C = O * A + P * _, D = F * A + K * _, B = N * A + X * _, P = O * -_ + P * A, K = F * -_ + K * A, X = N * -_ + X * A, Y = W * -_ + Y * A, O = C, F = D, N = B), L = Fr(-k, X), v = L * lr, L && (A = Math.cos(-L), _ = Math.sin(-L), C = R * A - P * _, D = I * A - K * _, B = k * A - X * _, Y = M * _ + Y * A, R = C, I = D, k = B), L = Fr(I, R), g = L * lr, L && (A = Math.cos(L), _ = Math.sin(L), C = R * A + I * _, D = O * A + F * _, I = I * A - R * _, F = F * A - O * _, R = C, O = D), m && Math.abs(m) + Math.abs(g) > 359.9 && (m = g = 0, v = 180 - v), p = at(Math.sqrt(R * R + I * I + k * k)), h = at(Math.sqrt(F * F + N * N)), L = Fr(O, F), y = Math.abs(L) > 2e-4 ? L * lr : 0, T = Y ? 1 / (Y < 0 ? -Y : Y) : 0), i.svg && (C = e.getAttribute("transform"), i.forceCSS = e.setAttribute("transform", "") || !pp(ki(e, Je)), C && e.setAttribute("transform", C))), Math.abs(y) > 90 && Math.abs(y) < 270 && (r ? (p *= -1, y += g <= 0 ? 180 : -180, g += g <= 0 ? 180 : -180) : (h *= -1, y += y <= 0 ? 180 : -180)), t = t || i.uncache, i.x = u - ((i.xPercent = u && (!t && i.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-u) ? -50 : 0))) ? e.offsetWidth * i.xPercent / 100 : 0) + a, i.y = d - ((i.yPercent = d && (!t && i.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-d) ? -50 : 0))) ? e.offsetHeight * i.yPercent / 100 : 0) + a, i.z = f + a, i.scaleX = at(p), i.scaleY = at(h), i.rotation = at(g) + o, i.rotationX = at(m) + o, i.rotationY = at(v) + o, i.skewX = y + o, i.skewY = E + o, i.transformPerspective = T + a, (i.zOrigin = parseFloat(c.split(" ")[2]) || !t && i.zOrigin || 0) && (s[ni] = Co(c)), i.xOffset = i.yOffset = 0, i.force3D = xi.force3D, i.renderTransform = i.svg ? vv : up ? gp : mv, i.uncache = 0, i;
}, Co = function(e) {
  return (e = e.split(" "))[0] + " " + e[1];
}, vl = function(e, t, i) {
  var s = Gt(t);
  return at(parseFloat(t) + parseFloat(Xs(e, "x", i + "px", s))) + s;
}, mv = function(e, t) {
  t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, gp(e, t);
}, rr = "0deg", An = "0px", nr = ") ", gp = function(e, t) {
  var i = t || this, s = i.xPercent, r = i.yPercent, a = i.x, o = i.y, l = i.z, c = i.rotation, u = i.rotationY, d = i.rotationX, f = i.skewX, p = i.skewY, h = i.scaleX, g = i.scaleY, m = i.transformPerspective, v = i.force3D, y = i.target, E = i.zOrigin, T = "", S = v === "auto" && e && e !== 1 || v === !0;
  if (E && (d !== rr || u !== rr)) {
    var w = parseFloat(u) * en, b = Math.sin(w), L = Math.cos(w), A;
    w = parseFloat(d) * en, A = Math.cos(w), a = vl(y, a, b * A * -E), o = vl(y, o, -Math.sin(w) * -E), l = vl(y, l, L * A * -E + E);
  }
  m !== An && (T += "perspective(" + m + nr), (s || r) && (T += "translate(" + s + "%, " + r + "%) "), (S || a !== An || o !== An || l !== An) && (T += l !== An || S ? "translate3d(" + a + ", " + o + ", " + l + ") " : "translate(" + a + ", " + o + nr), c !== rr && (T += "rotate(" + c + nr), u !== rr && (T += "rotateY(" + u + nr), d !== rr && (T += "rotateX(" + d + nr), (f !== rr || p !== rr) && (T += "skew(" + f + ", " + p + nr), (h !== 1 || g !== 1) && (T += "scale(" + h + ", " + g + nr), y.style[Je] = T || "translate(0, 0)";
}, vv = function(e, t) {
  var i = t || this, s = i.xPercent, r = i.yPercent, a = i.x, o = i.y, l = i.rotation, c = i.skewX, u = i.skewY, d = i.scaleX, f = i.scaleY, p = i.target, h = i.xOrigin, g = i.yOrigin, m = i.xOffset, v = i.yOffset, y = i.forceCSS, E = parseFloat(a), T = parseFloat(o), S, w, b, L, A;
  l = parseFloat(l), c = parseFloat(c), u = parseFloat(u), u && (u = parseFloat(u), c += u, l += u), l || c ? (l *= en, c *= en, S = Math.cos(l) * d, w = Math.sin(l) * d, b = Math.sin(l - c) * -f, L = Math.cos(l - c) * f, c && (u *= en, A = Math.tan(c - u), A = Math.sqrt(1 + A * A), b *= A, L *= A, u && (A = Math.tan(u), A = Math.sqrt(1 + A * A), S *= A, w *= A)), S = at(S), w = at(w), b = at(b), L = at(L)) : (S = d, L = f, w = b = 0), (E && !~(a + "").indexOf("px") || T && !~(o + "").indexOf("px")) && (E = Xs(p, "x", a, "px"), T = Xs(p, "y", o, "px")), (h || g || m || v) && (E = at(E + h - (h * S + g * b) + m), T = at(T + g - (h * w + g * L) + v)), (s || r) && (A = p.getBBox(), E = at(E + s / 100 * A.width), T = at(T + r / 100 * A.height)), A = "matrix(" + S + "," + w + "," + b + "," + L + "," + E + "," + T + ")", p.setAttribute("transform", A), y && (p.style[Je] = A);
}, yv = function(e, t, i, s, r) {
  var a = 360, o = At(r), l = parseFloat(r) * (o && ~r.indexOf("rad") ? lr : 1), c = l - s, u = s + c + "deg", d, f;
  return o && (d = r.split("_")[1], d === "short" && (c %= a, c !== c % (a / 2) && (c += c < 0 ? a : -a)), d === "cw" && c < 0 ? c = (c + a * gd) % a - ~~(c / a) * a : d === "ccw" && c > 0 && (c = (c - a * gd) % a - ~~(c / a) * a)), e._pt = f = new ri(e._pt, t, i, s, c, tv), f.e = u, f.u = "deg", e._props.push(i), f;
}, xd = function(e, t) {
  for (var i in t)
    e[i] = t[i];
  return e;
}, Ev = function(e, t, i) {
  var s = xd({}, i._gsap), r = "perspective,force3D,transformOrigin,svgOrigin", a = i.style, o, l, c, u, d, f, p, h;
  s.svg ? (c = i.getAttribute("transform"), i.setAttribute("transform", ""), a[Je] = t, o = ua(i, 1), Ar(i, Je), i.setAttribute("transform", c)) : (c = getComputedStyle(i)[Je], a[Je] = t, o = ua(i, 1), a[Je] = c);
  for (l in _s)
    c = s[l], u = o[l], c !== u && r.indexOf(l) < 0 && (p = Gt(c), h = Gt(u), d = p !== h ? Xs(i, l, c, h) : parseFloat(c), f = parseFloat(u), e._pt = new ri(e._pt, o, l, d, f - d, vc), e._pt.u = h || 0, e._props.push(l));
  xd(o, s);
};
si("padding,margin,Width,Radius", function(n, e) {
  var t = "Top", i = "Right", s = "Bottom", r = "Left", a = (e < 3 ? [t, i, s, r] : [t + r, t + i, s + i, s + r]).map(function(o) {
    return e < 2 ? n + o : "border" + o + n;
  });
  Ro[e > 1 ? "border" + n : n] = function(o, l, c, u, d) {
    var f, p;
    if (arguments.length < 4)
      return f = a.map(function(h) {
        return ys(o, h, c);
      }), p = f.join(" "), p.split(f[0]).length === 5 ? f[0] : p;
    f = (u + "").split(" "), p = {}, a.forEach(function(h, g) {
      return p[h] = f[g] = f[g] || f[(g - 1) / 2 | 0];
    }), o.init(l, p, d);
  };
});
var mp = {
  name: "css",
  register: Ec,
  targetTest: function(e) {
    return e.style && e.nodeType;
  },
  init: function(e, t, i, s, r) {
    var a = this._props, o = e.style, l = i.vars.startAt, c, u, d, f, p, h, g, m, v, y, E, T, S, w, b, L;
    mu || Ec(), this.styles = this.styles || cp(e), L = this.styles.props, this.tween = i;
    for (g in t)
      if (g !== "autoRound" && (u = t[g], !(pi[g] && Zh(g, t, i, s, e, r)))) {
        if (p = typeof u, h = Ro[g], p === "function" && (u = u.call(i, s, e, r), p = typeof u), p === "string" && ~u.indexOf("random(") && (u = aa(u)), h)
          h(this, e, g, u, i) && (b = 1);
        else if (g.substr(0, 2) === "--")
          c = (getComputedStyle(e).getPropertyValue(g) + "").trim(), u += "", Ws.lastIndex = 0, Ws.test(c) || (m = Gt(c), v = Gt(u)), v ? m !== v && (c = Xs(e, g, c, v) + v) : m && (u += m), this.add(o, "setProperty", c, u, s, r, 0, 0, g), a.push(g), L.push(g, 0, o[g]);
        else if (p !== "undefined") {
          if (l && g in l ? (c = typeof l[g] == "function" ? l[g].call(i, s, e, r) : l[g], At(c) && ~c.indexOf("random(") && (c = aa(c)), Gt(c + "") || c === "auto" || (c += xi.units[g] || Gt(ys(e, g)) || ""), (c + "").charAt(1) === "=" && (c = ys(e, g))) : c = ys(e, g), f = parseFloat(c), y = p === "string" && u.charAt(1) === "=" && u.substr(0, 2), y && (u = u.substr(2)), d = parseFloat(u), g in is && (g === "autoAlpha" && (f === 1 && ys(e, "visibility") === "hidden" && d && (f = 0), L.push("visibility", 0, o.visibility), Us(this, o, "visibility", f ? "inherit" : "hidden", d ? "inherit" : "hidden", !d)), g !== "scale" && g !== "transform" && (g = is[g], ~g.indexOf(",") && (g = g.split(",")[0]))), E = g in _s, E) {
            if (this.styles.save(g), p === "string" && u.substring(0, 6) === "var(--" && (u = ki(e, u.substring(4, u.indexOf(")"))), d = parseFloat(u)), T || (S = e._gsap, S.renderTransform && !t.parseTransform || ua(e, t.parseTransform), w = t.smoothOrigin !== !1 && S.smooth, T = this._pt = new ri(this._pt, o, Je, 0, 1, S.renderTransform, S, 0, -1), T.dep = 1), g === "scale")
              this._pt = new ri(this._pt, S, "scaleY", S.scaleY, (y ? Zr(S.scaleY, y + d) : d) - S.scaleY || 0, vc), this._pt.u = 0, a.push("scaleY", g), g += "X";
            else if (g === "transformOrigin") {
              L.push(ni, 0, o[ni]), u = pv(u), S.svg ? Tc(e, u, 0, w, 0, this) : (v = parseFloat(u.split(" ")[2]) || 0, v !== S.zOrigin && Us(this, S, "zOrigin", S.zOrigin, v), Us(this, o, g, Co(c), Co(u)));
              continue;
            } else if (g === "svgOrigin") {
              Tc(e, u, 1, w, 0, this);
              continue;
            } else if (g in hp) {
              yv(this, S, g, f, y ? Zr(f, y + u) : u);
              continue;
            } else if (g === "smoothOrigin") {
              Us(this, S, "smooth", S.smooth, u);
              continue;
            } else if (g === "force3D") {
              S[g] = u;
              continue;
            } else if (g === "transform") {
              Ev(this, u, e);
              continue;
            }
          } else g in o || (g = pn(g) || g);
          if (E || (d || d === 0) && (f || f === 0) && !ev.test(u) && g in o)
            m = (c + "").substr((f + "").length), d || (d = 0), v = Gt(u) || (g in xi.units ? xi.units[g] : m), m !== v && (f = Xs(e, g, c, v)), this._pt = new ri(this._pt, E ? S : o, g, f, (y ? Zr(f, y + d) : d) - f, !E && (v === "px" || g === "zIndex") && t.autoRound !== !1 ? sv : vc), this._pt.u = v || 0, m !== v && v !== "%" && (this._pt.b = c, this._pt.r = iv);
          else if (g in o)
            hv.call(this, e, g, c, y ? y + u : u);
          else if (g in e)
            this.add(e, g, c || e[g], y ? y + u : u, s, r);
          else if (g !== "parseTransform") {
            au(g, u);
            continue;
          }
          E || (g in o ? L.push(g, 0, o[g]) : typeof e[g] == "function" ? L.push(g, 2, e[g]()) : L.push(g, 1, c || e[g])), a.push(g);
        }
      }
    b && rp(this);
  },
  render: function(e, t) {
    if (t.tween._time || !vu())
      for (var i = t._pt; i; )
        i.r(e, i.d), i = i._next;
    else
      t.styles.revert();
  },
  get: ys,
  aliases: is,
  getSetter: function(e, t, i) {
    var s = is[t];
    return s && s.indexOf(",") < 0 && (t = s), t in _s && t !== ni && (e._gsap.x || ys(e, "x")) ? i && pd === i ? t === "scale" ? ov : av : (pd = i || {}) && (t === "scale" ? lv : cv) : e.style && !su(e.style[t]) ? rv : ~t.indexOf("-") ? nv : pu(e, t);
  },
  core: {
    _removeProperty: Ar,
    _getMatrix: Eu
  }
};
ai.utils.checkPrefix = pn;
ai.core.getStyleSaver = cp;
(function(n, e, t, i) {
  var s = si(n + "," + e + "," + t, function(r) {
    _s[r] = 1;
  });
  si(e, function(r) {
    xi.units[r] = "deg", hp[r] = 1;
  }), is[s[13]] = n + "," + e, si(i, function(r) {
    var a = r.split(":");
    is[a[1]] = s[a[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
si("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(n) {
  xi.units[n] = "px";
});
ai.registerPlugin(mp);
var me = ai.registerPlugin(mp) || ai;
me.core.Tween;
const Q = {
  // Character sets
  chars: {
    mixed: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
    upper: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    numbers: "0123456789"
  },
  // Split text into words while preserving spaces and punctuation
  splitIntoWords(n) {
    return n.split(/(\s+)/).filter((e) => e.length > 0);
  },
  // Shuffle a single word
  shuffleWord(n, e) {
    return Array(n.length).fill().map(() => e[Math.floor(Math.random() * e.length)]).join("");
  },
  // Check if a segment is whitespace
  isWhitespace(n) {
    return /^\s+$/.test(n);
  },
  // Enhanced shuffle function that handles words individually
  shuffleWords(n, e, t, i = 50, s = !1, r = null) {
    const a = s ? this.chars.upper : this.chars.mixed;
    t.shuffleInterval && clearInterval(t.shuffleInterval);
    const o = this.splitIntoWords(e);
    let l = o.map(
      (u) => this.isWhitespace(u) ? u : this.shuffleWord(u, a)
    );
    const c = o.map(
      (u) => this.isWhitespace(u) ? u.length : 0
    );
    t.textContent = l.join(""), t.shuffleInterval = setInterval(() => {
      let u = !0;
      l = o.map((d, f) => {
        if (this.isWhitespace(d))
          return d;
        if (c[f] < d.length) {
          u = !1, c[f]++;
          let p = "";
          for (let h = 0; h < d.length; h++)
            h < c[f] ? p += d[h] : p += a[Math.floor(Math.random() * a.length)];
          return p;
        }
        return d;
      }), t.textContent = l.join(""), u && (clearInterval(t.shuffleInterval), t.textContent = e, r && r());
    }, i);
  },
  // Shuffle text away (disappear)
  shuffleAway(n, e, t = 50, i = !1, s = null) {
    const r = i ? this.chars.upper : this.chars.mixed;
    e.shuffleInterval && clearInterval(e.shuffleInterval);
    const a = this.splitIntoWords(n);
    let o = [...a];
    const c = [...a.map(
      (u) => this.isWhitespace(u) ? u.length : u.replace(/\s/g, "").length
    )];
    e.textContent = o.join(""), e.shuffleInterval = setInterval(() => {
      let u = !0;
      o = a.map((d, f) => {
        if (this.isWhitespace(d))
          return d;
        if (c[f] > 0) {
          u = !1, c[f]--;
          const p = c[f];
          return p === 0 ? "" : Array(p).fill().map(() => r[Math.floor(Math.random() * r.length)]).join("");
        }
        return "";
      }), e.textContent = o.join(""), u && (clearInterval(e.shuffleInterval), e.textContent = "", s && s());
    }, t);
  },
  // Shuffle text back from empty (appear) - builds up text
  shuffleIn(n, e, t = 50, i = !1, s = null) {
    const r = i ? this.chars.upper : this.chars.mixed;
    e.shuffleInterval && clearInterval(e.shuffleInterval);
    const a = this.splitIntoWords(n);
    let o = a.map(
      (u) => this.isWhitespace(u) ? u : ""
    );
    const l = a.map(
      (u) => (this.isWhitespace(u), u.length)
    ), c = a.map(() => 0);
    e.textContent = o.join(""), e.shuffleInterval = setInterval(() => {
      let u = !0;
      o = a.map((d, f) => {
        if (this.isWhitespace(d))
          return d;
        if (c[f] < l[f]) {
          u = !1, c[f]++;
          let p = "";
          for (let h = 0; h < l[f]; h++)
            h < c[f] ? p += d[h] : p += r[Math.floor(Math.random() * r.length)];
          return p;
        }
        return d;
      }), e.textContent = o.join(""), u && (clearInterval(e.shuffleInterval), e.textContent = n, s && s());
    }, t);
  },
  // Load animation specific functions
  loadAnimations: {
    isEmptyLine(n) {
      return n.every((e) => !e.textContent.trim());
    },
    processLineText(n) {
      let e = "";
      return n.forEach((t, i) => {
        if (e += t.textContent, i < n.length - 1) {
          const s = n[i + 1].textContent;
          /^[.,!?;:]/.test(s) || (e += " ");
        }
      }), e;
    },
    initializeMulti() {
      bo({
        target: '[data-shuffle-load="multi"]',
        by: "lines",
        whitespace: !0
      }).forEach((e) => {
        const t = e.el, i = window.getComputedStyle(t).display;
        t.setAttribute("data-shuffle-processed", "true"), window.getComputedStyle(t).position === "static" && (t.style.position = "relative");
        const s = window.getComputedStyle(t), r = parseInt(s.lineHeight);
        let a = 0;
        const o = t.offsetWidth;
        t.style.width = `${o}px`, t.classList.add("shuffle-container"), e.lines.forEach((l, c) => {
          if (this.isEmptyLine(l)) {
            const f = document.createElement("div");
            f.className = "line-wrapper empty-line", f.style.cssText = `
            position: absolute;
            top: ${a}px;
            left: 0;
            width: 100%;
            height: ${r}px;
          `, t.appendChild(f), a += r;
            return;
          }
          const u = this.processLineText(l), d = document.createElement("div");
          d.className = "line-wrapper", d.style.cssText = `
          position: absolute;
          top: ${a}px;
          left: 0;
          width: 100%;
          line-height: ${r}px;
          white-space: nowrap;
        `, t.appendChild(d), setTimeout(() => {
            Q.shuffleWords("", u, d, 40, !1);
          }, c * 50), a += r;
        }), e.words.forEach((l) => l.remove()), t.style.height = `${a}px`, t.style.display = i;
      });
    },
    // Optional: Add cleanup method for page unload
    cleanupBeforeUnload() {
      document.querySelectorAll('[data-shuffle-load="multi"]').forEach((e) => {
        e.querySelectorAll(".line-wrapper").forEach((i) => {
          i.shuffleInterval && clearInterval(i.shuffleInterval);
        });
      });
    },
    restoreOriginalContent(n, e, t, i) {
      me.timeline({
        onComplete: () => {
          e && e.parentNode && e.remove(), n.setAttribute("data-shuffle-restored", "true"), n.dispatchEvent(new CustomEvent("shuffleRestored", {
            detail: { container: n }
          }));
        }
      }).to(e, {
        opacity: 0,
        duration: 0.3,
        ease: "power2.out"
      }).to(n, {
        opacity: 1,
        duration: 0.3,
        ease: "power2.out"
      }, 0).set(n, {
        // Restore original styles
        position: i.position || "",
        width: i.width || "",
        height: i.height || ""
      });
      const r = document.createElement("div");
      for (r.innerHTML = t, n.innerHTML = ""; r.firstChild; )
        n.appendChild(r.firstChild);
    },
    cleanupShuffleElements(n = document) {
      n.querySelectorAll('[data-shuffle-load="multi"]').forEach((i) => {
        i.querySelectorAll(".line-wrapper").forEach((a) => {
          a.shuffleInterval && clearInterval(a.shuffleInterval);
        }), i.querySelectorAll(".shuffle-overlay").forEach((a) => a.remove()), i.style.opacity === "0" && (i.style.opacity = "1");
      }), tl.to(shuffleOverlay, {
        opacity: 0,
        duration: 0.3,
        ease: "power2.out"
      }).to(n, {
        opacity: 1,
        duration: 0.3,
        ease: "power2.out"
      }, 0).set(n, {
        // Restore original styles
        position: originalStyles.position || "",
        width: originalStyles.width || "",
        height: originalStyles.height || ""
      });
      const t = document.createElement("div");
      for (t.innerHTML = originalHTML, n.innerHTML = ""; t.firstChild; )
        n.appendChild(t.firstChild);
    },
    restoreOriginalStructure(n) {
      if (!n._shuffleOriginalState) return;
      const e = n._shuffleOriginalState, t = n.querySelectorAll(".line-wrapper:not(.empty-line)"), i = Array.from(t).map((l) => l.textContent).join(`
`), s = document.createElement("div");
      s.style.cssText = `
      position: absolute;
      visibility: hidden;
      top: -9999px;
      left: -9999px;
      width: ${n.offsetWidth}px;
    `, s.textContent = i, document.body.appendChild(s);
      const r = window.getComputedStyle(n);
      [
        "font-family",
        "font-size",
        "font-weight",
        "line-height",
        "letter-spacing",
        "word-spacing",
        "text-align",
        "padding",
        "margin",
        "border",
        "box-sizing"
      ].forEach((l) => {
        s.style[l] = r[l];
      });
      const o = s.offsetHeight;
      document.body.removeChild(s), me.to(n, {
        height: o,
        duration: 0.3,
        ease: "power2.out",
        onComplete: () => {
          n.innerHTML = "", i.split(`
`).forEach((c, u) => {
            u > 0 && n.appendChild(document.createElement("br")), c.trim() && n.appendChild(document.createTextNode(c));
          }), n.style.position = e.position || "", n.style.width = e.width || "", n.style.height = e.height || "", n.style.display = e.display, delete n._shuffleOriginalState, n.setAttribute("data-shuffle-restored", "true"), n.dispatchEvent(new CustomEvent("shuffleRestored", {
            detail: { container: n }
          }));
        }
      });
    },
    restoreOriginalStructure(n) {
      if (!n._shuffleOriginalState) return;
      const e = n._shuffleOriginalState, t = document.createElement("div");
      t.style.cssText = `
      position: absolute;
      visibility: hidden;
      top: -9999px;
      left: -9999px;
      width: ${n.offsetWidth}px;
    `, t.innerHTML = e.innerHTML, document.body.appendChild(t);
      const i = window.getComputedStyle(n);
      [
        "font-family",
        "font-size",
        "font-weight",
        "line-height",
        "letter-spacing",
        "word-spacing",
        "text-align",
        "padding",
        "margin",
        "border",
        "box-sizing"
      ].forEach((a) => {
        t.style[a] = i[a];
      });
      const r = t.offsetHeight;
      document.body.removeChild(t), me.to(n, {
        height: r,
        duration: 0.3,
        ease: "power2.out",
        onComplete: () => {
          n.innerHTML = e.innerHTML, n.style.position = e.position || "", n.style.width = e.width || "", n.style.height = e.height || "", n.style.display = e.display, delete n._shuffleOriginalState, n.setAttribute("data-shuffle-restored", "true"), n.dispatchEvent(new CustomEvent("shuffleRestored", {
            detail: { container: n }
          }));
        }
      });
    },
    cleanupShuffleElements(n = document) {
      n.querySelectorAll('[data-shuffle-load="multi"]').forEach((t) => {
        t._shuffleOriginalState && !t.hasAttribute("data-shuffle-leaving") && Q.loadAnimations.restoreOriginalStructure(t);
      });
    },
    restoreOriginalStructure(n) {
      if (!n._shuffleOriginalState) return;
      const e = n._shuffleOriginalState, t = document.createElement("div");
      t.style.cssText = `
      position: absolute;
      visibility: hidden;
      top: -9999px;
      left: -9999px;
      width: ${n.offsetWidth}px;
    `, t.innerHTML = e.innerHTML, document.body.appendChild(t);
      const i = window.getComputedStyle(n);
      [
        "font-family",
        "font-size",
        "font-weight",
        "line-height",
        "letter-spacing",
        "word-spacing",
        "text-align",
        "padding",
        "margin",
        "border",
        "box-sizing"
      ].forEach((a) => {
        t.style[a] = i[a];
      });
      const r = t.offsetHeight;
      document.body.removeChild(t), me.to(n, {
        height: r,
        duration: 0.3,
        ease: "power2.out",
        onComplete: () => {
          n.innerHTML = e.innerHTML, n.style.position = e.position || "", n.style.width = e.width || "", n.style.height = e.height || "", n.style.display = e.display, delete n._shuffleOriginalState, n.setAttribute("data-shuffle-restored", "true"), n.dispatchEvent(new CustomEvent("shuffleRestored", {
            detail: { container: n }
          }));
        }
      });
    },
    // Enhanced shuffleWords method that returns a Promise
    shuffleWords(n, e, t, i = 50, s = !0) {
      return new Promise((r) => {
        if (!t) {
          r();
          return;
        }
        const a = Q.chars.mixed, o = this.splitIntoWords(e);
        let l = 0;
        const c = Math.max(...o.map(
          (d) => this.isWhitespace(d) ? 0 : d.length
        )), u = setInterval(() => {
          const d = o.map((f) => this.isWhitespace(f) ? f : f.split("").map((p, h) => h < l ? p : a[Math.floor(Math.random() * a.length)]).join("")).join("");
          t.textContent = d, l++, l > c && (clearInterval(u), t.textContent = e, r());
        }, i);
      });
    },
    initializeSingle() {
      document.querySelectorAll('[data-shuffle-load="single"]').forEach((e) => {
        const t = e.textContent;
        Q.shuffleWords("", t, e, 50, !1);
      });
    },
    initialize() {
      if (typeof bo > "u") {
        console.error("Splitting.js is not loaded. Please include it in your page.");
        return;
      }
    }
  },
  buttonAnimations: {
    initialize() {
      document.querySelectorAll('[data-shuffle="button"]').forEach((e) => {
        e.querySelectorAll('[data-shuffle="text"]').forEach((i) => {
          const s = i.textContent, r = i.getAttribute("data-shuffle-hover"), a = i.getAttribute("data-shuffle-click");
          if (r || a) {
            i.style.display = "inline-block";
            const o = document.createElement("span");
            o.style.visibility = "hidden", o.style.position = "absolute", o.style.whiteSpace = "nowrap", o.style.font = window.getComputedStyle(i).font, document.body.appendChild(o);
            let l = o.offsetWidth;
            o.textContent = s, l = o.offsetWidth, r && (o.textContent = r, l = Math.max(l, o.offsetWidth)), a && (o.textContent = a, l = Math.max(l, o.offsetWidth)), document.body.removeChild(o), i.style.width = `${l + 4}px`, i.style.textAlign = "left";
          }
          i.clickTimeout = null, i.isHovered = !1, e.addEventListener("mouseenter", () => {
            i.isHovered = !0, i.isClickAnimating && (i.clickTimeout && (clearTimeout(i.clickTimeout), i.clickTimeout = null), i.isClickAnimating = !1), r ? Q.shuffleWords(
              i.textContent,
              r,
              i,
              50,
              !1
            ) : Q.shuffleWords(
              i.textContent,
              s,
              i,
              50,
              !1
            );
          }), e.addEventListener("mouseleave", () => {
            i.isHovered = !1, i.shuffleInterval && clearInterval(i.shuffleInterval), i.isClickAnimating || (r ? Q.shuffleWords(
              i.textContent,
              s,
              i,
              50,
              !1
            ) : i.textContent = s);
          }), a && e.addEventListener("click", () => {
            i.clickTimeout && clearTimeout(i.clickTimeout), i.isClickAnimating = !0, Q.shuffleWords(
              i.textContent,
              a,
              i,
              50,
              !1
            ), i.clickTimeout = setTimeout(() => {
              const o = i.isHovered && r ? r : s;
              Q.shuffleWords(
                i.textContent,
                o,
                i,
                50,
                !1
              ), setTimeout(() => {
                i.isClickAnimating = !1, i.clickTimeout = null;
              }, 500);
            }, 2e3);
          });
        });
      });
    }
  },
  initialize() {
    const n = document.createElement("style");
    n.textContent = `
      [data-shuffle-load="multi"] {
        position: relative;
        display: block;
      }
      
      .line-wrapper {
        position: absolute;
        left: 0;
        width: 100%;
        display: block;
        line-height: inherit;
        white-space: nowrap;
      }
      
      .splitting .word {
        display: inline-block;
        white-space: nowrap;
      }
      
      .splitting .whitespace {
        display: inline-block;
      }
      
      .empty-line {
        height: 1em;
      }
    `, document.head.appendChild(n), window.addEventListener("load", () => {
      this.buttonAnimations.initialize(), this.loadAnimations.initialize();
    });
  }
};
Q.initialize();
window.ShuffleAnimations = Q;
function Tv(n, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(n, i.key, i);
  }
}
function Sv(n, e, t) {
  return e && Tv(n.prototype, e), n;
}
var Pt, ao, Ei, Gs, Hs, tn, vp, cr, Vn, yp, Ss, Vi, Ep, Tp = function() {
  return Pt || typeof window < "u" && (Pt = window.gsap) && Pt.registerPlugin && Pt;
}, Sp = 1, jr = [], Se = [], os = [], zn = Date.now, Sc = function(e, t) {
  return t;
}, xv = function() {
  var e = Vn.core, t = e.bridge || {}, i = e._scrollers, s = e._proxies;
  i.push.apply(i, Se), s.push.apply(s, os), Se = i, os = s, Sc = function(a, o) {
    return t[a](o);
  };
}, Ks = function(e, t) {
  return ~os.indexOf(e) && os[os.indexOf(e) + 1][t];
}, Wn = function(e) {
  return !!~yp.indexOf(e);
}, Kt = function(e, t, i, s, r) {
  return e.addEventListener(t, i, {
    passive: s !== !1,
    capture: !!r
  });
}, Wt = function(e, t, i, s) {
  return e.removeEventListener(t, i, !!s);
}, Ia = "scrollLeft", Ra = "scrollTop", xc = function() {
  return Ss && Ss.isPressed || Se.cache++;
}, Po = function(e, t) {
  var i = function s(r) {
    if (r || r === 0) {
      Sp && (Ei.history.scrollRestoration = "manual");
      var a = Ss && Ss.isPressed;
      r = s.v = Math.round(r) || (Ss && Ss.iOS ? 1 : 0), e(r), s.cacheID = Se.cache, a && Sc("ss", r);
    } else (t || Se.cache !== s.cacheID || Sc("ref")) && (s.cacheID = Se.cache, s.v = e());
    return s.v + s.offset;
  };
  return i.offset = 0, e && i;
}, Qt = {
  s: Ia,
  p: "left",
  p2: "Left",
  os: "right",
  os2: "Right",
  d: "width",
  d2: "Width",
  a: "x",
  sc: Po(function(n) {
    return arguments.length ? Ei.scrollTo(n, vt.sc()) : Ei.pageXOffset || Gs[Ia] || Hs[Ia] || tn[Ia] || 0;
  })
}, vt = {
  s: Ra,
  p: "top",
  p2: "Top",
  os: "bottom",
  os2: "Bottom",
  d: "height",
  d2: "Height",
  a: "y",
  op: Qt,
  sc: Po(function(n) {
    return arguments.length ? Ei.scrollTo(Qt.sc(), n) : Ei.pageYOffset || Gs[Ra] || Hs[Ra] || tn[Ra] || 0;
  })
}, ei = function(e, t) {
  return (t && t._ctx && t._ctx.selector || Pt.utils.toArray)(e)[0] || (typeof e == "string" && Pt.config().nullTargetWarn !== !1 ? console.warn("Element not found:", e) : null);
}, bv = function(e, t) {
  for (var i = t.length; i--; )
    if (t[i] === e || t[i].contains(e))
      return !0;
  return !1;
}, js = function(e, t) {
  var i = t.s, s = t.sc;
  Wn(e) && (e = Gs.scrollingElement || Hs);
  var r = Se.indexOf(e), a = s === vt.sc ? 1 : 2;
  !~r && (r = Se.push(e) - 1), Se[r + a] || Kt(e, "scroll", xc);
  var o = Se[r + a], l = o || (Se[r + a] = Po(Ks(e, i), !0) || (Wn(e) ? s : Po(function(c) {
    return arguments.length ? e[i] = c : e[i];
  })));
  return l.target = e, o || (l.smooth = Pt.getProperty(e, "scrollBehavior") === "smooth"), l;
}, bc = function(e, t, i) {
  var s = e, r = e, a = zn(), o = a, l = t || 50, c = Math.max(500, l * 3), u = function(h, g) {
    var m = zn();
    g || m - a > l ? (r = s, s = h, o = a, a = m) : i ? s += h : s = r + (h - r) / (m - o) * (a - o);
  }, d = function() {
    r = s = i ? 0 : s, o = a = 0;
  }, f = function(h) {
    var g = o, m = r, v = zn();
    return (h || h === 0) && h !== s && u(h), a === o || v - o > c ? 0 : (s + (i ? m : -m)) / ((i ? v : a) - g) * 1e3;
  };
  return {
    update: u,
    reset: d,
    getVelocity: f
  };
}, wn = function(e, t) {
  return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e;
}, bd = function(e) {
  var t = Math.max.apply(Math, e), i = Math.min.apply(Math, e);
  return Math.abs(t) >= Math.abs(i) ? t : i;
}, xp = function() {
  Vn = Pt.core.globals().ScrollTrigger, Vn && Vn.core && xv();
}, bp = function(e) {
  return Pt = e || Tp(), !ao && Pt && typeof document < "u" && document.body && (Ei = window, Gs = document, Hs = Gs.documentElement, tn = Gs.body, yp = [Ei, Gs, Hs, tn], Pt.utils.clamp, Ep = Pt.core.context || function() {
  }, cr = "onpointerenter" in tn ? "pointer" : "mouse", vp = lt.isTouch = Ei.matchMedia && Ei.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in Ei || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, Vi = lt.eventTypes = ("ontouchstart" in Hs ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in Hs ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function() {
    return Sp = 0;
  }, 500), xp(), ao = 1), ao;
};
Qt.op = vt;
Se.cache = 0;
var lt = /* @__PURE__ */ (function() {
  function n(t) {
    this.init(t);
  }
  var e = n.prototype;
  return e.init = function(i) {
    ao || bp(Pt) || console.warn("Please gsap.registerPlugin(Observer)"), Vn || xp();
    var s = i.tolerance, r = i.dragMinimum, a = i.type, o = i.target, l = i.lineHeight, c = i.debounce, u = i.preventDefault, d = i.onStop, f = i.onStopDelay, p = i.ignore, h = i.wheelSpeed, g = i.event, m = i.onDragStart, v = i.onDragEnd, y = i.onDrag, E = i.onPress, T = i.onRelease, S = i.onRight, w = i.onLeft, b = i.onUp, L = i.onDown, A = i.onChangeX, _ = i.onChangeY, R = i.onChange, I = i.onToggleX, k = i.onToggleY, M = i.onHover, O = i.onHoverEnd, F = i.onMove, C = i.ignoreCheck, D = i.isNormalizer, B = i.onGestureStart, P = i.onGestureEnd, K = i.onWheel, X = i.onEnable, W = i.onDisable, Y = i.onClick, N = i.scrollSpeed, U = i.capture, V = i.allowClicks, j = i.lockAxis, ee = i.onLockAxis;
    this.target = o = ei(o) || Hs, this.vars = i, p && (p = Pt.utils.toArray(p)), s = s || 1e-9, r = r || 0, h = h || 1, N = N || 1, a = a || "wheel,touch,pointer", c = c !== !1, l || (l = parseFloat(Ei.getComputedStyle(tn).lineHeight) || 22);
    var ce, oe, Le, ne, fe, Ce, re, z = this, Re = 0, We = 0, Ve = i.passive || !u && i.passive !== !1, Ie = js(o, Qt), st = js(o, vt), zt = Ie(), Mt = st(), ze = ~a.indexOf("touch") && !~a.indexOf("pointer") && Vi[0] === "pointerdown", Et = Wn(o), Pe = o.ownerDocument || Gs, Ot = [0, 0, 0], rt = [0, 0, 0], wi = 0, Ni = function() {
      return wi = zn();
    }, ct = function(le, De) {
      return (z.event = le) && p && bv(le.target, p) || De && ze && le.pointerType !== "touch" || C && C(le, De);
    }, _a = function() {
      z._vx.reset(), z._vy.reset(), oe.pause(), d && d(z);
    }, ds = function() {
      var le = z.deltaX = bd(Ot), De = z.deltaY = bd(rt), J = Math.abs(le) >= s, he = Math.abs(De) >= s;
      R && (J || he) && R(z, le, De, Ot, rt), J && (S && z.deltaX > 0 && S(z), w && z.deltaX < 0 && w(z), A && A(z), I && z.deltaX < 0 != Re < 0 && I(z), Re = z.deltaX, Ot[0] = Ot[1] = Ot[2] = 0), he && (L && z.deltaY > 0 && L(z), b && z.deltaY < 0 && b(z), _ && _(z), k && z.deltaY < 0 != We < 0 && k(z), We = z.deltaY, rt[0] = rt[1] = rt[2] = 0), (ne || Le) && (F && F(z), Le && (m && Le === 1 && m(z), y && y(z), Le = 0), ne = !1), Ce && !(Ce = !1) && ee && ee(z), fe && (K(z), fe = !1), ce = 0;
    }, Dr = function(le, De, J) {
      Ot[J] += le, rt[J] += De, z._vx.update(le), z._vy.update(De), c ? ce || (ce = requestAnimationFrame(ds)) : ds();
    }, kr = function(le, De) {
      j && !re && (z.axis = re = Math.abs(le) > Math.abs(De) ? "x" : "y", Ce = !0), re !== "y" && (Ot[2] += le, z._vx.update(le, !0)), re !== "x" && (rt[2] += De, z._vy.update(De, !0)), c ? ce || (ce = requestAnimationFrame(ds)) : ds();
    }, ws = function(le) {
      if (!ct(le, 1)) {
        le = wn(le, u);
        var De = le.clientX, J = le.clientY, he = De - z.x, ae = J - z.y, pe = z.isDragging;
        z.x = De, z.y = J, (pe || (he || ae) && (Math.abs(z.startX - De) >= r || Math.abs(z.startY - J) >= r)) && (Le = pe ? 2 : 1, pe || (z.isDragging = !0), kr(he, ae));
      }
    }, er = z.onPress = function(ge) {
      ct(ge, 1) || ge && ge.button || (z.axis = re = null, oe.pause(), z.isPressed = !0, ge = wn(ge), Re = We = 0, z.startX = z.x = ge.clientX, z.startY = z.y = ge.clientY, z._vx.reset(), z._vy.reset(), Kt(D ? o : Pe, Vi[1], ws, Ve, !0), z.deltaX = z.deltaY = 0, E && E(z));
    }, xe = z.onRelease = function(ge) {
      if (!ct(ge, 1)) {
        Wt(D ? o : Pe, Vi[1], ws, !0);
        var le = !isNaN(z.y - z.startY), De = z.isDragging, J = De && (Math.abs(z.x - z.startX) > 3 || Math.abs(z.y - z.startY) > 3), he = wn(ge);
        !J && le && (z._vx.reset(), z._vy.reset(), u && V && Pt.delayedCall(0.08, function() {
          if (zn() - wi > 300 && !ge.defaultPrevented) {
            if (ge.target.click)
              ge.target.click();
            else if (Pe.createEvent) {
              var ae = Pe.createEvent("MouseEvents");
              ae.initMouseEvent("click", !0, !0, Ei, 1, he.screenX, he.screenY, he.clientX, he.clientY, !1, !1, !1, !1, 0, null), ge.target.dispatchEvent(ae);
            }
          }
        })), z.isDragging = z.isGesturing = z.isPressed = !1, d && De && !D && oe.restart(!0), Le && ds(), v && De && v(z), T && T(z, J);
      }
    }, tr = function(le) {
      return le.touches && le.touches.length > 1 && (z.isGesturing = !0) && B(le, z.isDragging);
    }, $i = function() {
      return (z.isGesturing = !1) || P(z);
    }, Bi = function(le) {
      if (!ct(le)) {
        var De = Ie(), J = st();
        Dr((De - zt) * N, (J - Mt) * N, 1), zt = De, Mt = J, d && oe.restart(!0);
      }
    }, Ui = function(le) {
      if (!ct(le)) {
        le = wn(le, u), K && (fe = !0);
        var De = (le.deltaMode === 1 ? l : le.deltaMode === 2 ? Ei.innerHeight : 1) * h;
        Dr(le.deltaX * De, le.deltaY * De, 0), d && !D && oe.restart(!0);
      }
    }, ir = function(le) {
      if (!ct(le)) {
        var De = le.clientX, J = le.clientY, he = De - z.x, ae = J - z.y;
        z.x = De, z.y = J, ne = !0, d && oe.restart(!0), (he || ae) && kr(he, ae);
      }
    }, Mr = function(le) {
      z.event = le, M(z);
    }, fs = function(le) {
      z.event = le, O(z);
    }, Sn = function(le) {
      return ct(le) || wn(le, u) && Y(z);
    };
    oe = z._dc = Pt.delayedCall(f || 0.25, _a).pause(), z.deltaX = z.deltaY = 0, z._vx = bc(0, 50, !0), z._vy = bc(0, 50, !0), z.scrollX = Ie, z.scrollY = st, z.isDragging = z.isGesturing = z.isPressed = !1, Ep(this), z.enable = function(ge) {
      return z.isEnabled || (Kt(Et ? Pe : o, "scroll", xc), a.indexOf("scroll") >= 0 && Kt(Et ? Pe : o, "scroll", Bi, Ve, U), a.indexOf("wheel") >= 0 && Kt(o, "wheel", Ui, Ve, U), (a.indexOf("touch") >= 0 && vp || a.indexOf("pointer") >= 0) && (Kt(o, Vi[0], er, Ve, U), Kt(Pe, Vi[2], xe), Kt(Pe, Vi[3], xe), V && Kt(o, "click", Ni, !0, !0), Y && Kt(o, "click", Sn), B && Kt(Pe, "gesturestart", tr), P && Kt(Pe, "gestureend", $i), M && Kt(o, cr + "enter", Mr), O && Kt(o, cr + "leave", fs), F && Kt(o, cr + "move", ir)), z.isEnabled = !0, z.isDragging = z.isGesturing = z.isPressed = ne = Le = !1, z._vx.reset(), z._vy.reset(), zt = Ie(), Mt = st(), ge && ge.type && er(ge), X && X(z)), z;
    }, z.disable = function() {
      z.isEnabled && (jr.filter(function(ge) {
        return ge !== z && Wn(ge.target);
      }).length || Wt(Et ? Pe : o, "scroll", xc), z.isPressed && (z._vx.reset(), z._vy.reset(), Wt(D ? o : Pe, Vi[1], ws, !0)), Wt(Et ? Pe : o, "scroll", Bi, U), Wt(o, "wheel", Ui, U), Wt(o, Vi[0], er, U), Wt(Pe, Vi[2], xe), Wt(Pe, Vi[3], xe), Wt(o, "click", Ni, !0), Wt(o, "click", Sn), Wt(Pe, "gesturestart", tr), Wt(Pe, "gestureend", $i), Wt(o, cr + "enter", Mr), Wt(o, cr + "leave", fs), Wt(o, cr + "move", ir), z.isEnabled = z.isPressed = z.isDragging = !1, W && W(z));
    }, z.kill = z.revert = function() {
      z.disable();
      var ge = jr.indexOf(z);
      ge >= 0 && jr.splice(ge, 1), Ss === z && (Ss = 0);
    }, jr.push(z), D && Wn(o) && (Ss = z), z.enable(g);
  }, Sv(n, [{
    key: "velocityX",
    get: function() {
      return this._vx.getVelocity();
    }
  }, {
    key: "velocityY",
    get: function() {
      return this._vy.getVelocity();
    }
  }]), n;
})();
lt.version = "3.13.0";
lt.create = function(n) {
  return new lt(n);
};
lt.register = bp;
lt.getAll = function() {
  return jr.slice();
};
lt.getById = function(n) {
  return jr.filter(function(e) {
    return e.vars.id === n;
  })[0];
};
Tp() && Pt.registerPlugin(lt);
var ie, zr, Te, He, mi, ke, Tu, Do, da, Kn, Pn, Ca, Bt, Jo, _c, qt, _d, Ad, Wr, _p, yl, Ap, Yt, Ac, wp, Lp, Ps, wc, Su, sn, xu, ko, Lc, El, Pa = 1, Ut = Date.now, Tl = Ut(), Mi = 0, Dn = 0, wd = function(e, t, i) {
  var s = fi(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1);
  return i["_" + t + "Clamp"] = s, s ? e.substr(6, e.length - 7) : e;
}, Ld = function(e, t) {
  return t && (!fi(e) || e.substr(0, 6) !== "clamp(") ? "clamp(" + e + ")" : e;
}, _v = function n() {
  return Dn && requestAnimationFrame(n);
}, Id = function() {
  return Jo = 1;
}, Rd = function() {
  return Jo = 0;
}, Zi = function(e) {
  return e;
}, kn = function(e) {
  return Math.round(e * 1e5) / 1e5 || 0;
}, Ip = function() {
  return typeof window < "u";
}, Rp = function() {
  return ie || Ip() && (ie = window.gsap) && ie.registerPlugin && ie;
}, wr = function(e) {
  return !!~Tu.indexOf(e);
}, Cp = function(e) {
  return (e === "Height" ? xu : Te["inner" + e]) || mi["client" + e] || ke["client" + e];
}, Pp = function(e) {
  return Ks(e, "getBoundingClientRect") || (wr(e) ? function() {
    return fo.width = Te.innerWidth, fo.height = xu, fo;
  } : function() {
    return Es(e);
  });
}, Av = function(e, t, i) {
  var s = i.d, r = i.d2, a = i.a;
  return (a = Ks(e, "getBoundingClientRect")) ? function() {
    return a()[s];
  } : function() {
    return (t ? Cp(r) : e["client" + r]) || 0;
  };
}, wv = function(e, t) {
  return !t || ~os.indexOf(e) ? Pp(e) : function() {
    return fo;
  };
}, ss = function(e, t) {
  var i = t.s, s = t.d2, r = t.d, a = t.a;
  return Math.max(0, (i = "scroll" + s) && (a = Ks(e, i)) ? a() - Pp(e)()[r] : wr(e) ? (mi[i] || ke[i]) - Cp(s) : e[i] - e["offset" + s]);
}, Da = function(e, t) {
  for (var i = 0; i < Wr.length; i += 3)
    (!t || ~t.indexOf(Wr[i + 1])) && e(Wr[i], Wr[i + 1], Wr[i + 2]);
}, fi = function(e) {
  return typeof e == "string";
}, Ht = function(e) {
  return typeof e == "function";
}, Mn = function(e) {
  return typeof e == "number";
}, ur = function(e) {
  return typeof e == "object";
}, Ln = function(e, t, i) {
  return e && e.progress(t ? 0 : 1) && i && e.pause();
}, Sl = function(e, t) {
  if (e.enabled) {
    var i = e._ctx ? e._ctx.add(function() {
      return t(e);
    }) : t(e);
    i && i.totalTime && (e.callbackAnimation = i);
  }
}, Nr = Math.abs, Dp = "left", kp = "top", bu = "right", _u = "bottom", Tr = "width", Sr = "height", Yn = "Right", qn = "Left", Xn = "Top", jn = "Bottom", ut = "padding", Ii = "margin", gn = "Width", Au = "Height", pt = "px", Ri = function(e) {
  return Te.getComputedStyle(e);
}, Lv = function(e) {
  var t = Ri(e).position;
  e.style.position = t === "absolute" || t === "fixed" ? t : "relative";
}, Cd = function(e, t) {
  for (var i in t)
    i in e || (e[i] = t[i]);
  return e;
}, Es = function(e, t) {
  var i = t && Ri(e)[_c] !== "matrix(1, 0, 0, 1, 0, 0)" && ie.to(e, {
    x: 0,
    y: 0,
    xPercent: 0,
    yPercent: 0,
    rotation: 0,
    rotationX: 0,
    rotationY: 0,
    scale: 1,
    skewX: 0,
    skewY: 0
  }).progress(1), s = e.getBoundingClientRect();
  return i && i.progress(0).kill(), s;
}, Mo = function(e, t) {
  var i = t.d2;
  return e["offset" + i] || e["client" + i] || 0;
}, Mp = function(e) {
  var t = [], i = e.labels, s = e.duration(), r;
  for (r in i)
    t.push(i[r] / s);
  return t;
}, Iv = function(e) {
  return function(t) {
    return ie.utils.snap(Mp(e), t);
  };
}, wu = function(e) {
  var t = ie.utils.snap(e), i = Array.isArray(e) && e.slice(0).sort(function(s, r) {
    return s - r;
  });
  return i ? function(s, r, a) {
    a === void 0 && (a = 1e-3);
    var o;
    if (!r)
      return t(s);
    if (r > 0) {
      for (s -= a, o = 0; o < i.length; o++)
        if (i[o] >= s)
          return i[o];
      return i[o - 1];
    } else
      for (o = i.length, s += a; o--; )
        if (i[o] <= s)
          return i[o];
    return i[0];
  } : function(s, r, a) {
    a === void 0 && (a = 1e-3);
    var o = t(s);
    return !r || Math.abs(o - s) < a || o - s < 0 == r < 0 ? o : t(r < 0 ? s - e : s + e);
  };
}, Rv = function(e) {
  return function(t, i) {
    return wu(Mp(e))(t, i.direction);
  };
}, ka = function(e, t, i, s) {
  return i.split(",").forEach(function(r) {
    return e(t, r, s);
  });
}, bt = function(e, t, i, s, r) {
  return e.addEventListener(t, i, {
    passive: !s,
    capture: !!r
  });
}, xt = function(e, t, i, s) {
  return e.removeEventListener(t, i, !!s);
}, Ma = function(e, t, i) {
  i = i && i.wheelHandler, i && (e(t, "wheel", i), e(t, "touchmove", i));
}, Pd = {
  startColor: "green",
  endColor: "red",
  indent: 0,
  fontSize: "16px",
  fontWeight: "normal"
}, Oa = {
  toggleActions: "play",
  anticipatePin: 0
}, Oo = {
  top: 0,
  left: 0,
  center: 0.5,
  bottom: 1,
  right: 1
}, oo = function(e, t) {
  if (fi(e)) {
    var i = e.indexOf("="), s = ~i ? +(e.charAt(i - 1) + 1) * parseFloat(e.substr(i + 1)) : 0;
    ~i && (e.indexOf("%") > i && (s *= t / 100), e = e.substr(0, i - 1)), e = s + (e in Oo ? Oo[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0);
  }
  return e;
}, Fa = function(e, t, i, s, r, a, o, l) {
  var c = r.startColor, u = r.endColor, d = r.fontSize, f = r.indent, p = r.fontWeight, h = He.createElement("div"), g = wr(i) || Ks(i, "pinType") === "fixed", m = e.indexOf("scroller") !== -1, v = g ? ke : i, y = e.indexOf("start") !== -1, E = y ? c : u, T = "border-color:" + E + ";font-size:" + d + ";color:" + E + ";font-weight:" + p + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
  return T += "position:" + ((m || l) && g ? "fixed;" : "absolute;"), (m || l || !g) && (T += (s === vt ? bu : _u) + ":" + (a + parseFloat(f)) + "px;"), o && (T += "box-sizing:border-box;text-align:left;width:" + o.offsetWidth + "px;"), h._isStart = y, h.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), h.style.cssText = T, h.innerText = t || t === 0 ? e + "-" + t : e, v.children[0] ? v.insertBefore(h, v.children[0]) : v.appendChild(h), h._offset = h["offset" + s.op.d2], lo(h, 0, s, y), h;
}, lo = function(e, t, i, s) {
  var r = {
    display: "block"
  }, a = i[s ? "os2" : "p2"], o = i[s ? "p2" : "os2"];
  e._isFlipped = s, r[i.a + "Percent"] = s ? -100 : 0, r[i.a] = s ? "1px" : 0, r["border" + a + gn] = 1, r["border" + o + gn] = 0, r[i.p] = t + "px", ie.set(e, r);
}, ve = [], Ic = {}, fa, Dd = function() {
  return Ut() - Mi > 34 && (fa || (fa = requestAnimationFrame(xs)));
}, $r = function() {
  (!Yt || !Yt.isPressed || Yt.startX > ke.clientWidth) && (Se.cache++, Yt ? fa || (fa = requestAnimationFrame(xs)) : xs(), Mi || Ir("scrollStart"), Mi = Ut());
}, xl = function() {
  Lp = Te.innerWidth, wp = Te.innerHeight;
}, On = function(e) {
  Se.cache++, (e === !0 || !Bt && !Ap && !He.fullscreenElement && !He.webkitFullscreenElement && (!Ac || Lp !== Te.innerWidth || Math.abs(Te.innerHeight - wp) > Te.innerHeight * 0.25)) && Do.restart(!0);
}, Lr = {}, Cv = [], Op = function n() {
  return xt(_e, "scrollEnd", n) || gr(!0);
}, Ir = function(e) {
  return Lr[e] && Lr[e].map(function(t) {
    return t();
  }) || Cv;
}, ui = [], Fp = function(e) {
  for (var t = 0; t < ui.length; t += 5)
    (!e || ui[t + 4] && ui[t + 4].query === e) && (ui[t].style.cssText = ui[t + 1], ui[t].getBBox && ui[t].setAttribute("transform", ui[t + 2] || ""), ui[t + 3].uncache = 1);
}, Lu = function(e, t) {
  var i;
  for (qt = 0; qt < ve.length; qt++)
    i = ve[qt], i && (!t || i._ctx === t) && (e ? i.kill(1) : i.revert(!0, !0));
  ko = !0, t && Fp(t), t || Ir("revert");
}, Np = function(e, t) {
  Se.cache++, (t || !Xt) && Se.forEach(function(i) {
    return Ht(i) && i.cacheID++ && (i.rec = 0);
  }), fi(e) && (Te.history.scrollRestoration = Su = e);
}, Xt, xr = 0, kd, Pv = function() {
  if (kd !== xr) {
    var e = kd = xr;
    requestAnimationFrame(function() {
      return e === xr && gr(!0);
    });
  }
}, $p = function() {
  ke.appendChild(sn), xu = !Yt && sn.offsetHeight || Te.innerHeight, ke.removeChild(sn);
}, Md = function(e) {
  return da(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(t) {
    return t.style.display = e ? "none" : "block";
  });
}, gr = function(e, t) {
  if (mi = He.documentElement, ke = He.body, Tu = [Te, He, mi, ke], Mi && !e && !ko) {
    bt(_e, "scrollEnd", Op);
    return;
  }
  $p(), Xt = _e.isRefreshing = !0, Se.forEach(function(s) {
    return Ht(s) && ++s.cacheID && (s.rec = s());
  });
  var i = Ir("refreshInit");
  _p && _e.sort(), t || Lu(), Se.forEach(function(s) {
    Ht(s) && (s.smooth && (s.target.style.scrollBehavior = "auto"), s(0));
  }), ve.slice(0).forEach(function(s) {
    return s.refresh();
  }), ko = !1, ve.forEach(function(s) {
    if (s._subPinOffset && s.pin) {
      var r = s.vars.horizontal ? "offsetWidth" : "offsetHeight", a = s.pin[r];
      s.revert(!0, 1), s.adjustPinSpacing(s.pin[r] - a), s.refresh();
    }
  }), Lc = 1, Md(!0), ve.forEach(function(s) {
    var r = ss(s.scroller, s._dir), a = s.vars.end === "max" || s._endClamp && s.end > r, o = s._startClamp && s.start >= r;
    (a || o) && s.setPositions(o ? r - 1 : s.start, a ? Math.max(o ? r : s.start + 1, r) : s.end, !0);
  }), Md(!1), Lc = 0, i.forEach(function(s) {
    return s && s.render && s.render(-1);
  }), Se.forEach(function(s) {
    Ht(s) && (s.smooth && requestAnimationFrame(function() {
      return s.target.style.scrollBehavior = "smooth";
    }), s.rec && s(s.rec));
  }), Np(Su, 1), Do.pause(), xr++, Xt = 2, xs(2), ve.forEach(function(s) {
    return Ht(s.vars.onRefresh) && s.vars.onRefresh(s);
  }), Xt = _e.isRefreshing = !1, Ir("refresh");
}, Rc = 0, co = 1, Qn, xs = function(e) {
  if (e === 2 || !Xt && !ko) {
    _e.isUpdating = !0, Qn && Qn.update(0);
    var t = ve.length, i = Ut(), s = i - Tl >= 50, r = t && ve[0].scroll();
    if (co = Rc > r ? -1 : 1, Xt || (Rc = r), s && (Mi && !Jo && i - Mi > 200 && (Mi = 0, Ir("scrollEnd")), Pn = Tl, Tl = i), co < 0) {
      for (qt = t; qt-- > 0; )
        ve[qt] && ve[qt].update(0, s);
      co = 1;
    } else
      for (qt = 0; qt < t; qt++)
        ve[qt] && ve[qt].update(0, s);
    _e.isUpdating = !1;
  }
  fa = 0;
}, Cc = [Dp, kp, _u, bu, Ii + jn, Ii + Yn, Ii + Xn, Ii + qn, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], uo = Cc.concat([Tr, Sr, "boxSizing", "max" + gn, "max" + Au, "position", Ii, ut, ut + Xn, ut + Yn, ut + jn, ut + qn]), Dv = function(e, t, i) {
  rn(i);
  var s = e._gsap;
  if (s.spacerIsNative)
    rn(s.spacerState);
  else if (e._gsap.swappedIn) {
    var r = t.parentNode;
    r && (r.insertBefore(e, t), r.removeChild(t));
  }
  e._gsap.swappedIn = !1;
}, bl = function(e, t, i, s) {
  if (!e._gsap.swappedIn) {
    for (var r = Cc.length, a = t.style, o = e.style, l; r--; )
      l = Cc[r], a[l] = i[l];
    a.position = i.position === "absolute" ? "absolute" : "relative", i.display === "inline" && (a.display = "inline-block"), o[_u] = o[bu] = "auto", a.flexBasis = i.flexBasis || "auto", a.overflow = "visible", a.boxSizing = "border-box", a[Tr] = Mo(e, Qt) + pt, a[Sr] = Mo(e, vt) + pt, a[ut] = o[Ii] = o[kp] = o[Dp] = "0", rn(s), o[Tr] = o["max" + gn] = i[Tr], o[Sr] = o["max" + Au] = i[Sr], o[ut] = i[ut], e.parentNode !== t && (e.parentNode.insertBefore(t, e), t.appendChild(e)), e._gsap.swappedIn = !0;
  }
}, kv = /([A-Z])/g, rn = function(e) {
  if (e) {
    var t = e.t.style, i = e.length, s = 0, r, a;
    for ((e.t._gsap || ie.core.getCache(e.t)).uncache = 1; s < i; s += 2)
      a = e[s + 1], r = e[s], a ? t[r] = a : t[r] && t.removeProperty(r.replace(kv, "-$1").toLowerCase());
  }
}, Na = function(e) {
  for (var t = uo.length, i = e.style, s = [], r = 0; r < t; r++)
    s.push(uo[r], i[uo[r]]);
  return s.t = e, s;
}, Mv = function(e, t, i) {
  for (var s = [], r = e.length, a = i ? 8 : 0, o; a < r; a += 2)
    o = e[a], s.push(o, o in t ? t[o] : e[a + 1]);
  return s.t = e.t, s;
}, fo = {
  left: 0,
  top: 0
}, Od = function(e, t, i, s, r, a, o, l, c, u, d, f, p, h) {
  Ht(e) && (e = e(l)), fi(e) && e.substr(0, 3) === "max" && (e = f + (e.charAt(4) === "=" ? oo("0" + e.substr(3), i) : 0));
  var g = p ? p.time() : 0, m, v, y;
  if (p && p.seek(0), isNaN(e) || (e = +e), Mn(e))
    p && (e = ie.utils.mapRange(p.scrollTrigger.start, p.scrollTrigger.end, 0, f, e)), o && lo(o, i, s, !0);
  else {
    Ht(t) && (t = t(l));
    var E = (e || "0").split(" "), T, S, w, b;
    y = ei(t, l) || ke, T = Es(y) || {}, (!T || !T.left && !T.top) && Ri(y).display === "none" && (b = y.style.display, y.style.display = "block", T = Es(y), b ? y.style.display = b : y.style.removeProperty("display")), S = oo(E[0], T[s.d]), w = oo(E[1] || "0", i), e = T[s.p] - c[s.p] - u + S + r - w, o && lo(o, w, s, i - w < 20 || o._isStart && w > 20), i -= i - w;
  }
  if (h && (l[h] = e || -1e-3, e < 0 && (e = 0)), a) {
    var L = e + i, A = a._isStart;
    m = "scroll" + s.d2, lo(a, L, s, A && L > 20 || !A && (d ? Math.max(ke[m], mi[m]) : a.parentNode[m]) <= L + 1), d && (c = Es(o), d && (a.style[s.op.p] = c[s.op.p] - s.op.m - a._offset + pt));
  }
  return p && y && (m = Es(y), p.seek(f), v = Es(y), p._caScrollDist = m[s.p] - v[s.p], e = e / p._caScrollDist * f), p && p.seek(g), p ? e : Math.round(e);
}, Ov = /(webkit|moz|length|cssText|inset)/i, Fd = function(e, t, i, s) {
  if (e.parentNode !== t) {
    var r = e.style, a, o;
    if (t === ke) {
      e._stOrig = r.cssText, o = Ri(e);
      for (a in o)
        !+a && !Ov.test(a) && o[a] && typeof r[a] == "string" && a !== "0" && (r[a] = o[a]);
      r.top = i, r.left = s;
    } else
      r.cssText = e._stOrig;
    ie.core.getCache(e).uncache = 1, t.appendChild(e);
  }
}, Bp = function(e, t, i) {
  var s = t, r = s;
  return function(a) {
    var o = Math.round(e());
    return o !== s && o !== r && Math.abs(o - s) > 3 && Math.abs(o - r) > 3 && (a = o, i && i()), r = s, s = Math.round(a), s;
  };
}, $a = function(e, t, i) {
  var s = {};
  s[t.p] = "+=" + i, ie.set(e, s);
}, Nd = function(e, t) {
  var i = js(e, t), s = "_scroll" + t.p2, r = function a(o, l, c, u, d) {
    var f = a.tween, p = l.onComplete, h = {};
    c = c || i();
    var g = Bp(i, c, function() {
      f.kill(), a.tween = 0;
    });
    return d = u && d || 0, u = u || o - c, f && f.kill(), l[s] = o, l.inherit = !1, l.modifiers = h, h[s] = function() {
      return g(c + u * f.ratio + d * f.ratio * f.ratio);
    }, l.onUpdate = function() {
      Se.cache++, a.tween && xs();
    }, l.onComplete = function() {
      a.tween = 0, p && p.call(f);
    }, f = a.tween = ie.to(e, l), f;
  };
  return e[s] = i, i.wheelHandler = function() {
    return r.tween && r.tween.kill() && (r.tween = 0);
  }, bt(e, "wheel", i.wheelHandler), _e.isTouch && bt(e, "touchmove", i.wheelHandler), r;
}, _e = /* @__PURE__ */ (function() {
  function n(t, i) {
    zr || n.register(ie) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), wc(this), this.init(t, i);
  }
  var e = n.prototype;
  return e.init = function(i, s) {
    if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), !Dn) {
      this.update = this.refresh = this.kill = Zi;
      return;
    }
    i = Cd(fi(i) || Mn(i) || i.nodeType ? {
      trigger: i
    } : i, Oa);
    var r = i, a = r.onUpdate, o = r.toggleClass, l = r.id, c = r.onToggle, u = r.onRefresh, d = r.scrub, f = r.trigger, p = r.pin, h = r.pinSpacing, g = r.invalidateOnRefresh, m = r.anticipatePin, v = r.onScrubComplete, y = r.onSnapComplete, E = r.once, T = r.snap, S = r.pinReparent, w = r.pinSpacer, b = r.containerAnimation, L = r.fastScrollEnd, A = r.preventOverlaps, _ = i.horizontal || i.containerAnimation && i.horizontal !== !1 ? Qt : vt, R = !d && d !== 0, I = ei(i.scroller || Te), k = ie.core.getCache(I), M = wr(I), O = ("pinType" in i ? i.pinType : Ks(I, "pinType") || M && "fixed") === "fixed", F = [i.onEnter, i.onLeave, i.onEnterBack, i.onLeaveBack], C = R && i.toggleActions.split(" "), D = "markers" in i ? i.markers : Oa.markers, B = M ? 0 : parseFloat(Ri(I)["border" + _.p2 + gn]) || 0, P = this, K = i.onRefreshInit && function() {
      return i.onRefreshInit(P);
    }, X = Av(I, M, _), W = wv(I, M), Y = 0, N = 0, U = 0, V = js(I, _), j, ee, ce, oe, Le, ne, fe, Ce, re, z, Re, We, Ve, Ie, st, zt, Mt, ze, Et, Pe, Ot, rt, wi, Ni, ct, _a, ds, Dr, kr, ws, er, xe, tr, $i, Bi, Ui, ir, Mr, fs;
    if (P._startClamp = P._endClamp = !1, P._dir = _, m *= 45, P.scroller = I, P.scroll = b ? b.time.bind(b) : V, oe = V(), P.vars = i, s = s || i.animation, "refreshPriority" in i && (_p = 1, i.refreshPriority === -9999 && (Qn = P)), k.tweenScroll = k.tweenScroll || {
      top: Nd(I, vt),
      left: Nd(I, Qt)
    }, P.tweenTo = j = k.tweenScroll[_.p], P.scrubDuration = function(J) {
      tr = Mn(J) && J, tr ? xe ? xe.duration(J) : xe = ie.to(s, {
        ease: "expo",
        totalProgress: "+=0",
        inherit: !1,
        duration: tr,
        paused: !0,
        onComplete: function() {
          return v && v(P);
        }
      }) : (xe && xe.progress(1).kill(), xe = 0);
    }, s && (s.vars.lazy = !1, s._initted && !P.isReverted || s.vars.immediateRender !== !1 && i.immediateRender !== !1 && s.duration() && s.render(0, !0, !0), P.animation = s.pause(), s.scrollTrigger = P, P.scrubDuration(d), ws = 0, l || (l = s.vars.id)), T && ((!ur(T) || T.push) && (T = {
      snapTo: T
    }), "scrollBehavior" in ke.style && ie.set(M ? [ke, mi] : I, {
      scrollBehavior: "auto"
    }), Se.forEach(function(J) {
      return Ht(J) && J.target === (M ? He.scrollingElement || mi : I) && (J.smooth = !1);
    }), ce = Ht(T.snapTo) ? T.snapTo : T.snapTo === "labels" ? Iv(s) : T.snapTo === "labelsDirectional" ? Rv(s) : T.directional !== !1 ? function(J, he) {
      return wu(T.snapTo)(J, Ut() - N < 500 ? 0 : he.direction);
    } : ie.utils.snap(T.snapTo), $i = T.duration || {
      min: 0.1,
      max: 2
    }, $i = ur($i) ? Kn($i.min, $i.max) : Kn($i, $i), Bi = ie.delayedCall(T.delay || tr / 2 || 0.1, function() {
      var J = V(), he = Ut() - N < 500, ae = j.tween;
      if ((he || Math.abs(P.getVelocity()) < 10) && !ae && !Jo && Y !== J) {
        var pe = (J - ne) / Ie, Tt = s && !R ? s.totalProgress() : pe, Ae = he ? 0 : (Tt - er) / (Ut() - Pn) * 1e3 || 0, nt = ie.utils.clamp(-pe, 1 - pe, Nr(Ae / 2) * Ae / 0.185), Ft = pe + (T.inertia === !1 ? 0 : nt), et, Ke, Ne = T, Gi = Ne.onStart, Xe = Ne.onInterrupt, oi = Ne.onComplete;
        if (et = ce(Ft, P), Mn(et) || (et = Ft), Ke = Math.max(0, Math.round(ne + et * Ie)), J <= fe && J >= ne && Ke !== J) {
          if (ae && !ae._initted && ae.data <= Nr(Ke - J))
            return;
          T.inertia === !1 && (nt = et - pe), j(Ke, {
            duration: $i(Nr(Math.max(Nr(Ft - Tt), Nr(et - Tt)) * 0.185 / Ae / 0.05 || 0)),
            ease: T.ease || "power3",
            data: Nr(Ke - J),
            // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.
            onInterrupt: function() {
              return Bi.restart(!0) && Xe && Xe(P);
            },
            onComplete: function() {
              P.update(), Y = V(), s && !R && (xe ? xe.resetTo("totalProgress", et, s._tTime / s._tDur) : s.progress(et)), ws = er = s && !R ? s.totalProgress() : P.progress, y && y(P), oi && oi(P);
            }
          }, J, nt * Ie, Ke - J - nt * Ie), Gi && Gi(P, j.tween);
        }
      } else P.isActive && Y !== J && Bi.restart(!0);
    }).pause()), l && (Ic[l] = P), f = P.trigger = ei(f || p !== !0 && p), fs = f && f._gsap && f._gsap.stRevert, fs && (fs = fs(P)), p = p === !0 ? f : ei(p), fi(o) && (o = {
      targets: f,
      className: o
    }), p && (h === !1 || h === Ii || (h = !h && p.parentNode && p.parentNode.style && Ri(p.parentNode).display === "flex" ? !1 : ut), P.pin = p, ee = ie.core.getCache(p), ee.spacer ? st = ee.pinState : (w && (w = ei(w), w && !w.nodeType && (w = w.current || w.nativeElement), ee.spacerIsNative = !!w, w && (ee.spacerState = Na(w))), ee.spacer = ze = w || He.createElement("div"), ze.classList.add("pin-spacer"), l && ze.classList.add("pin-spacer-" + l), ee.pinState = st = Na(p)), i.force3D !== !1 && ie.set(p, {
      force3D: !0
    }), P.spacer = ze = ee.spacer, kr = Ri(p), Ni = kr[h + _.os2], Pe = ie.getProperty(p), Ot = ie.quickSetter(p, _.a, pt), bl(p, ze, kr), Mt = Na(p)), D) {
      We = ur(D) ? Cd(D, Pd) : Pd, z = Fa("scroller-start", l, I, _, We, 0), Re = Fa("scroller-end", l, I, _, We, 0, z), Et = z["offset" + _.op.d2];
      var Sn = ei(Ks(I, "content") || I);
      Ce = this.markerStart = Fa("start", l, Sn, _, We, Et, 0, b), re = this.markerEnd = Fa("end", l, Sn, _, We, Et, 0, b), b && (Mr = ie.quickSetter([Ce, re], _.a, pt)), !O && !(os.length && Ks(I, "fixedMarkers") === !0) && (Lv(M ? ke : I), ie.set([z, Re], {
        force3D: !0
      }), _a = ie.quickSetter(z, _.a, pt), Dr = ie.quickSetter(Re, _.a, pt));
    }
    if (b) {
      var ge = b.vars.onUpdate, le = b.vars.onUpdateParams;
      b.eventCallback("onUpdate", function() {
        P.update(0, 0, 1), ge && ge.apply(b, le || []);
      });
    }
    if (P.previous = function() {
      return ve[ve.indexOf(P) - 1];
    }, P.next = function() {
      return ve[ve.indexOf(P) + 1];
    }, P.revert = function(J, he) {
      if (!he)
        return P.kill(!0);
      var ae = J !== !1 || !P.enabled, pe = Bt;
      ae !== P.isReverted && (ae && (Ui = Math.max(V(), P.scroll.rec || 0), U = P.progress, ir = s && s.progress()), Ce && [Ce, re, z, Re].forEach(function(Tt) {
        return Tt.style.display = ae ? "none" : "block";
      }), ae && (Bt = P, P.update(ae)), p && (!S || !P.isActive) && (ae ? Dv(p, ze, st) : bl(p, ze, Ri(p), ct)), ae || P.update(ae), Bt = pe, P.isReverted = ae);
    }, P.refresh = function(J, he, ae, pe) {
      if (!((Bt || !P.enabled) && !he)) {
        if (p && J && Mi) {
          bt(n, "scrollEnd", Op);
          return;
        }
        !Xt && K && K(P), Bt = P, j.tween && !ae && (j.tween.kill(), j.tween = 0), xe && xe.pause(), g && s && (s.revert({
          kill: !1
        }).invalidate(), s.getChildren && s.getChildren(!0, !0, !1).forEach(function(Ls) {
          return Ls.vars.immediateRender && Ls.render(0, !0, !0);
        })), P.isReverted || P.revert(!0, !0), P._subPinOffset = !1;
        var Tt = X(), Ae = W(), nt = b ? b.duration() : ss(I, _), Ft = Ie <= 0.01 || !Ie, et = 0, Ke = pe || 0, Ne = ur(ae) ? ae.end : i.end, Gi = i.endTrigger || f, Xe = ur(ae) ? ae.start : i.start || (i.start === 0 || !f ? 0 : p ? "0 0" : "0 100%"), oi = P.pinnedContainer = i.pinnedContainer && ei(i.pinnedContainer, P), Wi = f && Math.max(0, ve.indexOf(P)) || 0, wt = Wi, Lt, Nt, sr, Aa, $t, ht, Ki, ol, id, xn, Yi, bn, wa;
        for (D && ur(ae) && (bn = ie.getProperty(z, _.p), wa = ie.getProperty(Re, _.p)); wt-- > 0; )
          ht = ve[wt], ht.end || ht.refresh(0, 1) || (Bt = P), Ki = ht.pin, Ki && (Ki === f || Ki === p || Ki === oi) && !ht.isReverted && (xn || (xn = []), xn.unshift(ht), ht.revert(!0, !0)), ht !== ve[wt] && (Wi--, wt--);
        for (Ht(Xe) && (Xe = Xe(P)), Xe = wd(Xe, "start", P), ne = Od(Xe, f, Tt, _, V(), Ce, z, P, Ae, B, O, nt, b, P._startClamp && "_startClamp") || (p ? -1e-3 : 0), Ht(Ne) && (Ne = Ne(P)), fi(Ne) && !Ne.indexOf("+=") && (~Ne.indexOf(" ") ? Ne = (fi(Xe) ? Xe.split(" ")[0] : "") + Ne : (et = oo(Ne.substr(2), Tt), Ne = fi(Xe) ? Xe : (b ? ie.utils.mapRange(0, b.duration(), b.scrollTrigger.start, b.scrollTrigger.end, ne) : ne) + et, Gi = f)), Ne = wd(Ne, "end", P), fe = Math.max(ne, Od(Ne || (Gi ? "100% 0" : nt), Gi, Tt, _, V() + et, re, Re, P, Ae, B, O, nt, b, P._endClamp && "_endClamp")) || -1e-3, et = 0, wt = Wi; wt--; )
          ht = ve[wt], Ki = ht.pin, Ki && ht.start - ht._pinPush <= ne && !b && ht.end > 0 && (Lt = ht.end - (P._startClamp ? Math.max(0, ht.start) : ht.start), (Ki === f && ht.start - ht._pinPush < ne || Ki === oi) && isNaN(Xe) && (et += Lt * (1 - ht.progress)), Ki === p && (Ke += Lt));
        if (ne += et, fe += et, P._startClamp && (P._startClamp += et), P._endClamp && !Xt && (P._endClamp = fe || -1e-3, fe = Math.min(fe, ss(I, _))), Ie = fe - ne || (ne -= 0.01) && 1e-3, Ft && (U = ie.utils.clamp(0, 1, ie.utils.normalize(ne, fe, Ui))), P._pinPush = Ke, Ce && et && (Lt = {}, Lt[_.a] = "+=" + et, oi && (Lt[_.p] = "-=" + V()), ie.set([Ce, re], Lt)), p && !(Lc && P.end >= ss(I, _)))
          Lt = Ri(p), Aa = _ === vt, sr = V(), rt = parseFloat(Pe(_.a)) + Ke, !nt && fe > 1 && (Yi = (M ? He.scrollingElement || mi : I).style, Yi = {
            style: Yi,
            value: Yi["overflow" + _.a.toUpperCase()]
          }, M && Ri(ke)["overflow" + _.a.toUpperCase()] !== "scroll" && (Yi.style["overflow" + _.a.toUpperCase()] = "scroll")), bl(p, ze, Lt), Mt = Na(p), Nt = Es(p, !0), ol = O && js(I, Aa ? Qt : vt)(), h ? (ct = [h + _.os2, Ie + Ke + pt], ct.t = ze, wt = h === ut ? Mo(p, _) + Ie + Ke : 0, wt && (ct.push(_.d, wt + pt), ze.style.flexBasis !== "auto" && (ze.style.flexBasis = wt + pt)), rn(ct), oi && ve.forEach(function(Ls) {
            Ls.pin === oi && Ls.vars.pinSpacing !== !1 && (Ls._subPinOffset = !0);
          }), O && V(Ui)) : (wt = Mo(p, _), wt && ze.style.flexBasis !== "auto" && (ze.style.flexBasis = wt + pt)), O && ($t = {
            top: Nt.top + (Aa ? sr - ne : ol) + pt,
            left: Nt.left + (Aa ? ol : sr - ne) + pt,
            boxSizing: "border-box",
            position: "fixed"
          }, $t[Tr] = $t["max" + gn] = Math.ceil(Nt.width) + pt, $t[Sr] = $t["max" + Au] = Math.ceil(Nt.height) + pt, $t[Ii] = $t[Ii + Xn] = $t[Ii + Yn] = $t[Ii + jn] = $t[Ii + qn] = "0", $t[ut] = Lt[ut], $t[ut + Xn] = Lt[ut + Xn], $t[ut + Yn] = Lt[ut + Yn], $t[ut + jn] = Lt[ut + jn], $t[ut + qn] = Lt[ut + qn], zt = Mv(st, $t, S), Xt && V(0)), s ? (id = s._initted, yl(1), s.render(s.duration(), !0, !0), wi = Pe(_.a) - rt + Ie + Ke, ds = Math.abs(Ie - wi) > 1, O && ds && zt.splice(zt.length - 2, 2), s.render(0, !0, !0), id || s.invalidate(!0), s.parent || s.totalTime(s.totalTime()), yl(0)) : wi = Ie, Yi && (Yi.value ? Yi.style["overflow" + _.a.toUpperCase()] = Yi.value : Yi.style.removeProperty("overflow-" + _.a));
        else if (f && V() && !b)
          for (Nt = f.parentNode; Nt && Nt !== ke; )
            Nt._pinOffset && (ne -= Nt._pinOffset, fe -= Nt._pinOffset), Nt = Nt.parentNode;
        xn && xn.forEach(function(Ls) {
          return Ls.revert(!1, !0);
        }), P.start = ne, P.end = fe, oe = Le = Xt ? Ui : V(), !b && !Xt && (oe < Ui && V(Ui), P.scroll.rec = 0), P.revert(!1, !0), N = Ut(), Bi && (Y = -1, Bi.restart(!0)), Bt = 0, s && R && (s._initted || ir) && s.progress() !== ir && s.progress(ir || 0, !0).render(s.time(), !0, !0), (Ft || U !== P.progress || b || g || s && !s._initted) && (s && !R && (s._initted || U || s.vars.immediateRender !== !1) && s.totalProgress(b && ne < -1e-3 && !U ? ie.utils.normalize(ne, fe, 0) : U, !0), P.progress = Ft || (oe - ne) / Ie === U ? 0 : U), p && h && (ze._pinOffset = Math.round(P.progress * wi)), xe && xe.invalidate(), isNaN(bn) || (bn -= ie.getProperty(z, _.p), wa -= ie.getProperty(Re, _.p), $a(z, _, bn), $a(Ce, _, bn - (pe || 0)), $a(Re, _, wa), $a(re, _, wa - (pe || 0))), Ft && !Xt && P.update(), u && !Xt && !Ve && (Ve = !0, u(P), Ve = !1);
      }
    }, P.getVelocity = function() {
      return (V() - Le) / (Ut() - Pn) * 1e3 || 0;
    }, P.endAnimation = function() {
      Ln(P.callbackAnimation), s && (xe ? xe.progress(1) : s.paused() ? R || Ln(s, P.direction < 0, 1) : Ln(s, s.reversed()));
    }, P.labelToScroll = function(J) {
      return s && s.labels && (ne || P.refresh() || ne) + s.labels[J] / s.duration() * Ie || 0;
    }, P.getTrailing = function(J) {
      var he = ve.indexOf(P), ae = P.direction > 0 ? ve.slice(0, he).reverse() : ve.slice(he + 1);
      return (fi(J) ? ae.filter(function(pe) {
        return pe.vars.preventOverlaps === J;
      }) : ae).filter(function(pe) {
        return P.direction > 0 ? pe.end <= ne : pe.start >= fe;
      });
    }, P.update = function(J, he, ae) {
      if (!(b && !ae && !J)) {
        var pe = Xt === !0 ? Ui : P.scroll(), Tt = J ? 0 : (pe - ne) / Ie, Ae = Tt < 0 ? 0 : Tt > 1 ? 1 : Tt || 0, nt = P.progress, Ft, et, Ke, Ne, Gi, Xe, oi, Wi;
        if (he && (Le = oe, oe = b ? V() : pe, T && (er = ws, ws = s && !R ? s.totalProgress() : Ae)), m && p && !Bt && !Pa && Mi && (!Ae && ne < pe + (pe - Le) / (Ut() - Pn) * m ? Ae = 1e-4 : Ae === 1 && fe > pe + (pe - Le) / (Ut() - Pn) * m && (Ae = 0.9999)), Ae !== nt && P.enabled) {
          if (Ft = P.isActive = !!Ae && Ae < 1, et = !!nt && nt < 1, Xe = Ft !== et, Gi = Xe || !!Ae != !!nt, P.direction = Ae > nt ? 1 : -1, P.progress = Ae, Gi && !Bt && (Ke = Ae && !nt ? 0 : Ae === 1 ? 1 : nt === 1 ? 2 : 3, R && (Ne = !Xe && C[Ke + 1] !== "none" && C[Ke + 1] || C[Ke], Wi = s && (Ne === "complete" || Ne === "reset" || Ne in s))), A && (Xe || Wi) && (Wi || d || !s) && (Ht(A) ? A(P) : P.getTrailing(A).forEach(function(sr) {
            return sr.endAnimation();
          })), R || (xe && !Bt && !Pa ? (xe._dp._time - xe._start !== xe._time && xe.render(xe._dp._time - xe._start), xe.resetTo ? xe.resetTo("totalProgress", Ae, s._tTime / s._tDur) : (xe.vars.totalProgress = Ae, xe.invalidate().restart())) : s && s.totalProgress(Ae, !!(Bt && (N || J)))), p) {
            if (J && h && (ze.style[h + _.os2] = Ni), !O)
              Ot(kn(rt + wi * Ae));
            else if (Gi) {
              if (oi = !J && Ae > nt && fe + 1 > pe && pe + 1 >= ss(I, _), S)
                if (!J && (Ft || oi)) {
                  var wt = Es(p, !0), Lt = pe - ne;
                  Fd(p, ke, wt.top + (_ === vt ? Lt : 0) + pt, wt.left + (_ === vt ? 0 : Lt) + pt);
                } else
                  Fd(p, ze);
              rn(Ft || oi ? zt : Mt), ds && Ae < 1 && Ft || Ot(rt + (Ae === 1 && !oi ? wi : 0));
            }
          }
          T && !j.tween && !Bt && !Pa && Bi.restart(!0), o && (Xe || E && Ae && (Ae < 1 || !El)) && da(o.targets).forEach(function(sr) {
            return sr.classList[Ft || E ? "add" : "remove"](o.className);
          }), a && !R && !J && a(P), Gi && !Bt ? (R && (Wi && (Ne === "complete" ? s.pause().totalProgress(1) : Ne === "reset" ? s.restart(!0).pause() : Ne === "restart" ? s.restart(!0) : s[Ne]()), a && a(P)), (Xe || !El) && (c && Xe && Sl(P, c), F[Ke] && Sl(P, F[Ke]), E && (Ae === 1 ? P.kill(!1, 1) : F[Ke] = 0), Xe || (Ke = Ae === 1 ? 1 : 3, F[Ke] && Sl(P, F[Ke]))), L && !Ft && Math.abs(P.getVelocity()) > (Mn(L) ? L : 2500) && (Ln(P.callbackAnimation), xe ? xe.progress(1) : Ln(s, Ne === "reverse" ? 1 : !Ae, 1))) : R && a && !Bt && a(P);
        }
        if (Dr) {
          var Nt = b ? pe / b.duration() * (b._caScrollDist || 0) : pe;
          _a(Nt + (z._isFlipped ? 1 : 0)), Dr(Nt);
        }
        Mr && Mr(-pe / b.duration() * (b._caScrollDist || 0));
      }
    }, P.enable = function(J, he) {
      P.enabled || (P.enabled = !0, bt(I, "resize", On), M || bt(I, "scroll", $r), K && bt(n, "refreshInit", K), J !== !1 && (P.progress = U = 0, oe = Le = Y = V()), he !== !1 && P.refresh());
    }, P.getTween = function(J) {
      return J && j ? j.tween : xe;
    }, P.setPositions = function(J, he, ae, pe) {
      if (b) {
        var Tt = b.scrollTrigger, Ae = b.duration(), nt = Tt.end - Tt.start;
        J = Tt.start + nt * J / Ae, he = Tt.start + nt * he / Ae;
      }
      P.refresh(!1, !1, {
        start: Ld(J, ae && !!P._startClamp),
        end: Ld(he, ae && !!P._endClamp)
      }, pe), P.update();
    }, P.adjustPinSpacing = function(J) {
      if (ct && J) {
        var he = ct.indexOf(_.d) + 1;
        ct[he] = parseFloat(ct[he]) + J + pt, ct[1] = parseFloat(ct[1]) + J + pt, rn(ct);
      }
    }, P.disable = function(J, he) {
      if (P.enabled && (J !== !1 && P.revert(!0, !0), P.enabled = P.isActive = !1, he || xe && xe.pause(), Ui = 0, ee && (ee.uncache = 1), K && xt(n, "refreshInit", K), Bi && (Bi.pause(), j.tween && j.tween.kill() && (j.tween = 0)), !M)) {
        for (var ae = ve.length; ae--; )
          if (ve[ae].scroller === I && ve[ae] !== P)
            return;
        xt(I, "resize", On), M || xt(I, "scroll", $r);
      }
    }, P.kill = function(J, he) {
      P.disable(J, he), xe && !he && xe.kill(), l && delete Ic[l];
      var ae = ve.indexOf(P);
      ae >= 0 && ve.splice(ae, 1), ae === qt && co > 0 && qt--, ae = 0, ve.forEach(function(pe) {
        return pe.scroller === P.scroller && (ae = 1);
      }), ae || Xt || (P.scroll.rec = 0), s && (s.scrollTrigger = null, J && s.revert({
        kill: !1
      }), he || s.kill()), Ce && [Ce, re, z, Re].forEach(function(pe) {
        return pe.parentNode && pe.parentNode.removeChild(pe);
      }), Qn === P && (Qn = 0), p && (ee && (ee.uncache = 1), ae = 0, ve.forEach(function(pe) {
        return pe.pin === p && ae++;
      }), ae || (ee.spacer = 0)), i.onKill && i.onKill(P);
    }, ve.push(P), P.enable(!1, !1), fs && fs(P), s && s.add && !Ie) {
      var De = P.update;
      P.update = function() {
        P.update = De, Se.cache++, ne || fe || P.refresh();
      }, ie.delayedCall(0.01, P.update), Ie = 0.01, ne = fe = 0;
    } else
      P.refresh();
    p && Pv();
  }, n.register = function(i) {
    return zr || (ie = i || Rp(), Ip() && window.document && n.enable(), zr = Dn), zr;
  }, n.defaults = function(i) {
    if (i)
      for (var s in i)
        Oa[s] = i[s];
    return Oa;
  }, n.disable = function(i, s) {
    Dn = 0, ve.forEach(function(a) {
      return a[s ? "kill" : "disable"](i);
    }), xt(Te, "wheel", $r), xt(He, "scroll", $r), clearInterval(Ca), xt(He, "touchcancel", Zi), xt(ke, "touchstart", Zi), ka(xt, He, "pointerdown,touchstart,mousedown", Id), ka(xt, He, "pointerup,touchend,mouseup", Rd), Do.kill(), Da(xt);
    for (var r = 0; r < Se.length; r += 3)
      Ma(xt, Se[r], Se[r + 1]), Ma(xt, Se[r], Se[r + 2]);
  }, n.enable = function() {
    if (Te = window, He = document, mi = He.documentElement, ke = He.body, ie && (da = ie.utils.toArray, Kn = ie.utils.clamp, wc = ie.core.context || Zi, yl = ie.core.suppressOverwrites || Zi, Su = Te.history.scrollRestoration || "auto", Rc = Te.pageYOffset || 0, ie.core.globals("ScrollTrigger", n), ke)) {
      Dn = 1, sn = document.createElement("div"), sn.style.height = "100vh", sn.style.position = "absolute", $p(), _v(), lt.register(ie), n.isTouch = lt.isTouch, Ps = lt.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), Ac = lt.isTouch === 1, bt(Te, "wheel", $r), Tu = [Te, He, mi, ke], ie.matchMedia ? (n.matchMedia = function(c) {
        var u = ie.matchMedia(), d;
        for (d in c)
          u.add(d, c[d]);
        return u;
      }, ie.addEventListener("matchMediaInit", function() {
        return Lu();
      }), ie.addEventListener("matchMediaRevert", function() {
        return Fp();
      }), ie.addEventListener("matchMedia", function() {
        gr(0, 1), Ir("matchMedia");
      }), ie.matchMedia().add("(orientation: portrait)", function() {
        return xl(), xl;
      })) : console.warn("Requires GSAP 3.11.0 or later"), xl(), bt(He, "scroll", $r);
      var i = ke.hasAttribute("style"), s = ke.style, r = s.borderTopStyle, a = ie.core.Animation.prototype, o, l;
      for (a.revert || Object.defineProperty(a, "revert", {
        value: function() {
          return this.time(-0.01, !0);
        }
      }), s.borderTopStyle = "solid", o = Es(ke), vt.m = Math.round(o.top + vt.sc()) || 0, Qt.m = Math.round(o.left + Qt.sc()) || 0, r ? s.borderTopStyle = r : s.removeProperty("border-top-style"), i || (ke.setAttribute("style", ""), ke.removeAttribute("style")), Ca = setInterval(Dd, 250), ie.delayedCall(0.5, function() {
        return Pa = 0;
      }), bt(He, "touchcancel", Zi), bt(ke, "touchstart", Zi), ka(bt, He, "pointerdown,touchstart,mousedown", Id), ka(bt, He, "pointerup,touchend,mouseup", Rd), _c = ie.utils.checkPrefix("transform"), uo.push(_c), zr = Ut(), Do = ie.delayedCall(0.2, gr).pause(), Wr = [He, "visibilitychange", function() {
        var c = Te.innerWidth, u = Te.innerHeight;
        He.hidden ? (_d = c, Ad = u) : (_d !== c || Ad !== u) && On();
      }, He, "DOMContentLoaded", gr, Te, "load", gr, Te, "resize", On], Da(bt), ve.forEach(function(c) {
        return c.enable(0, 1);
      }), l = 0; l < Se.length; l += 3)
        Ma(xt, Se[l], Se[l + 1]), Ma(xt, Se[l], Se[l + 2]);
    }
  }, n.config = function(i) {
    "limitCallbacks" in i && (El = !!i.limitCallbacks);
    var s = i.syncInterval;
    s && clearInterval(Ca) || (Ca = s) && setInterval(Dd, s), "ignoreMobileResize" in i && (Ac = n.isTouch === 1 && i.ignoreMobileResize), "autoRefreshEvents" in i && (Da(xt) || Da(bt, i.autoRefreshEvents || "none"), Ap = (i.autoRefreshEvents + "").indexOf("resize") === -1);
  }, n.scrollerProxy = function(i, s) {
    var r = ei(i), a = Se.indexOf(r), o = wr(r);
    ~a && Se.splice(a, o ? 6 : 2), s && (o ? os.unshift(Te, s, ke, s, mi, s) : os.unshift(r, s));
  }, n.clearMatchMedia = function(i) {
    ve.forEach(function(s) {
      return s._ctx && s._ctx.query === i && s._ctx.kill(!0, !0);
    });
  }, n.isInViewport = function(i, s, r) {
    var a = (fi(i) ? ei(i) : i).getBoundingClientRect(), o = a[r ? Tr : Sr] * s || 0;
    return r ? a.right - o > 0 && a.left + o < Te.innerWidth : a.bottom - o > 0 && a.top + o < Te.innerHeight;
  }, n.positionInViewport = function(i, s, r) {
    fi(i) && (i = ei(i));
    var a = i.getBoundingClientRect(), o = a[r ? Tr : Sr], l = s == null ? o / 2 : s in Oo ? Oo[s] * o : ~s.indexOf("%") ? parseFloat(s) * o / 100 : parseFloat(s) || 0;
    return r ? (a.left + l) / Te.innerWidth : (a.top + l) / Te.innerHeight;
  }, n.killAll = function(i) {
    if (ve.slice(0).forEach(function(r) {
      return r.vars.id !== "ScrollSmoother" && r.kill();
    }), i !== !0) {
      var s = Lr.killAll || [];
      Lr = {}, s.forEach(function(r) {
        return r();
      });
    }
  }, n;
})();
_e.version = "3.13.0";
_e.saveStyles = function(n) {
  return n ? da(n).forEach(function(e) {
    if (e && e.style) {
      var t = ui.indexOf(e);
      t >= 0 && ui.splice(t, 5), ui.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), ie.core.getCache(e), wc());
    }
  }) : ui;
};
_e.revert = function(n, e) {
  return Lu(!n, e);
};
_e.create = function(n, e) {
  return new _e(n, e);
};
_e.refresh = function(n) {
  return n ? On(!0) : (zr || _e.register()) && gr(!0);
};
_e.update = function(n) {
  return ++Se.cache && xs(n === !0 ? 2 : 0);
};
_e.clearScrollMemory = Np;
_e.maxScroll = function(n, e) {
  return ss(n, e ? Qt : vt);
};
_e.getScrollFunc = function(n, e) {
  return js(ei(n), e ? Qt : vt);
};
_e.getById = function(n) {
  return Ic[n];
};
_e.getAll = function() {
  return ve.filter(function(n) {
    return n.vars.id !== "ScrollSmoother";
  });
};
_e.isScrolling = function() {
  return !!Mi;
};
_e.snapDirectional = wu;
_e.addEventListener = function(n, e) {
  var t = Lr[n] || (Lr[n] = []);
  ~t.indexOf(e) || t.push(e);
};
_e.removeEventListener = function(n, e) {
  var t = Lr[n], i = t && t.indexOf(e);
  i >= 0 && t.splice(i, 1);
};
_e.batch = function(n, e) {
  var t = [], i = {}, s = e.interval || 0.016, r = e.batchMax || 1e9, a = function(c, u) {
    var d = [], f = [], p = ie.delayedCall(s, function() {
      u(d, f), d = [], f = [];
    }).pause();
    return function(h) {
      d.length || p.restart(!0), d.push(h.trigger), f.push(h), r <= d.length && p.progress(1);
    };
  }, o;
  for (o in e)
    i[o] = o.substr(0, 2) === "on" && Ht(e[o]) && o !== "onRefreshInit" ? a(o, e[o]) : e[o];
  return Ht(r) && (r = r(), bt(_e, "refresh", function() {
    return r = e.batchMax();
  })), da(n).forEach(function(l) {
    var c = {};
    for (o in i)
      c[o] = i[o];
    c.trigger = l, t.push(_e.create(c));
  }), t;
};
var $d = function(e, t, i, s) {
  return t > s ? e(s) : t < 0 && e(0), i > s ? (s - t) / (i - t) : i < 0 ? t / (t - i) : 1;
}, _l = function n(e, t) {
  t === !0 ? e.style.removeProperty("touch-action") : e.style.touchAction = t === !0 ? "auto" : t ? "pan-" + t + (lt.isTouch ? " pinch-zoom" : "") : "none", e === mi && n(ke, t);
}, Ba = {
  auto: 1,
  scroll: 1
}, Fv = function(e) {
  var t = e.event, i = e.target, s = e.axis, r = (t.changedTouches ? t.changedTouches[0] : t).target, a = r._gsap || ie.core.getCache(r), o = Ut(), l;
  if (!a._isScrollT || o - a._isScrollT > 2e3) {
    for (; r && r !== ke && (r.scrollHeight <= r.clientHeight && r.scrollWidth <= r.clientWidth || !(Ba[(l = Ri(r)).overflowY] || Ba[l.overflowX])); )
      r = r.parentNode;
    a._isScroll = r && r !== i && !wr(r) && (Ba[(l = Ri(r)).overflowY] || Ba[l.overflowX]), a._isScrollT = o;
  }
  (a._isScroll || s === "x") && (t.stopPropagation(), t._gsapAllow = !0);
}, Up = function(e, t, i, s) {
  return lt.create({
    target: e,
    capture: !0,
    debounce: !1,
    lockAxis: !0,
    type: t,
    onWheel: s = s && Fv,
    onPress: s,
    onDrag: s,
    onScroll: s,
    onEnable: function() {
      return i && bt(He, lt.eventTypes[0], Ud, !1, !0);
    },
    onDisable: function() {
      return xt(He, lt.eventTypes[0], Ud, !0);
    }
  });
}, Nv = /(input|label|select|textarea)/i, Bd, Ud = function(e) {
  var t = Nv.test(e.target.tagName);
  (t || Bd) && (e._gsapAllow = !0, Bd = t);
}, $v = function(e) {
  ur(e) || (e = {}), e.preventDefault = e.isNormalizer = e.allowClicks = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer";
  var t = e, i = t.normalizeScrollX, s = t.momentum, r = t.allowNestedScroll, a = t.onRelease, o, l, c = ei(e.target) || mi, u = ie.core.globals().ScrollSmoother, d = u && u.get(), f = Ps && (e.content && ei(e.content) || d && e.content !== !1 && !d.smooth() && d.content()), p = js(c, vt), h = js(c, Qt), g = 1, m = (lt.isTouch && Te.visualViewport ? Te.visualViewport.scale * Te.visualViewport.width : Te.outerWidth) / Te.innerWidth, v = 0, y = Ht(s) ? function() {
    return s(o);
  } : function() {
    return s || 2.8;
  }, E, T, S = Up(c, e.type, !0, r), w = function() {
    return T = !1;
  }, b = Zi, L = Zi, A = function() {
    l = ss(c, vt), L = Kn(Ps ? 1 : 0, l), i && (b = Kn(0, ss(c, Qt))), E = xr;
  }, _ = function() {
    f._gsap.y = kn(parseFloat(f._gsap.y) + p.offset) + "px", f.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(f._gsap.y) + ", 0, 1)", p.offset = p.cacheID = 0;
  }, R = function() {
    if (T) {
      requestAnimationFrame(w);
      var D = kn(o.deltaY / 2), B = L(p.v - D);
      if (f && B !== p.v + p.offset) {
        p.offset = B - p.v;
        var P = kn((parseFloat(f && f._gsap.y) || 0) - p.offset);
        f.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + P + ", 0, 1)", f._gsap.y = P + "px", p.cacheID = Se.cache, xs();
      }
      return !0;
    }
    p.offset && _(), T = !0;
  }, I, k, M, O, F = function() {
    A(), I.isActive() && I.vars.scrollY > l && (p() > l ? I.progress(1) && p(l) : I.resetTo("scrollY", l));
  };
  return f && ie.set(f, {
    y: "+=0"
  }), e.ignoreCheck = function(C) {
    return Ps && C.type === "touchmove" && R() || g > 1.05 && C.type !== "touchstart" || o.isGesturing || C.touches && C.touches.length > 1;
  }, e.onPress = function() {
    T = !1;
    var C = g;
    g = kn((Te.visualViewport && Te.visualViewport.scale || 1) / m), I.pause(), C !== g && _l(c, g > 1.01 ? !0 : i ? !1 : "x"), k = h(), M = p(), A(), E = xr;
  }, e.onRelease = e.onGestureStart = function(C, D) {
    if (p.offset && _(), !D)
      O.restart(!0);
    else {
      Se.cache++;
      var B = y(), P, K;
      i && (P = h(), K = P + B * 0.05 * -C.velocityX / 0.227, B *= $d(h, P, K, ss(c, Qt)), I.vars.scrollX = b(K)), P = p(), K = P + B * 0.05 * -C.velocityY / 0.227, B *= $d(p, P, K, ss(c, vt)), I.vars.scrollY = L(K), I.invalidate().duration(B).play(0.01), (Ps && I.vars.scrollY >= l || P >= l - 1) && ie.to({}, {
        onUpdate: F,
        duration: B
      });
    }
    a && a(C);
  }, e.onWheel = function() {
    I._ts && I.pause(), Ut() - v > 1e3 && (E = 0, v = Ut());
  }, e.onChange = function(C, D, B, P, K) {
    if (xr !== E && A(), D && i && h(b(P[2] === D ? k + (C.startX - C.x) : h() + D - P[1])), B) {
      p.offset && _();
      var X = K[2] === B, W = X ? M + C.startY - C.y : p() + B - K[1], Y = L(W);
      X && W !== Y && (M += Y - W), p(Y);
    }
    (B || D) && xs();
  }, e.onEnable = function() {
    _l(c, i ? !1 : "x"), _e.addEventListener("refresh", F), bt(Te, "resize", F), p.smooth && (p.target.style.scrollBehavior = "auto", p.smooth = h.smooth = !1), S.enable();
  }, e.onDisable = function() {
    _l(c, !0), xt(Te, "resize", F), _e.removeEventListener("refresh", F), S.kill();
  }, e.lockAxis = e.lockAxis !== !1, o = new lt(e), o.iOS = Ps, Ps && !p() && p(1), Ps && ie.ticker.add(Zi), O = o._dc, I = ie.to(o, {
    ease: "power4",
    paused: !0,
    inherit: !1,
    scrollX: i ? "+=0.1" : "+=0",
    scrollY: "+=0.1",
    modifiers: {
      scrollY: Bp(p, p(), function() {
        return I.pause();
      })
    },
    onUpdate: xs,
    onComplete: O.vars.onComplete
  }), o;
};
_e.sort = function(n) {
  if (Ht(n))
    return ve.sort(n);
  var e = Te.pageYOffset || 0;
  return _e.getAll().forEach(function(t) {
    return t._sortY = t.trigger ? e + t.trigger.getBoundingClientRect().top : t.start + Te.innerHeight;
  }), ve.sort(n || function(t, i) {
    return (t.vars.refreshPriority || 0) * -1e6 + (t.vars.containerAnimation ? 1e6 : t._sortY) - ((i.vars.containerAnimation ? 1e6 : i._sortY) + (i.vars.refreshPriority || 0) * -1e6);
  });
};
_e.observe = function(n) {
  return new lt(n);
};
_e.normalizeScroll = function(n) {
  if (typeof n > "u")
    return Yt;
  if (n === !0 && Yt)
    return Yt.enable();
  if (n === !1) {
    Yt && Yt.kill(), Yt = n;
    return;
  }
  var e = n instanceof lt ? n : $v(n);
  return Yt && Yt.target === e.target && Yt.kill(), wr(e.target) && (Yt = e), e;
};
_e.core = {
  // smaller file size way to leverage in ScrollSmoother and Observer
  _getVelocityProp: bc,
  _inputObserver: Up,
  _scrollers: Se,
  _proxies: os,
  bridge: {
    // when normalizeScroll sets the scroll position (ss = setScroll)
    ss: function() {
      Mi || Ir("scrollStart"), Mi = Ut();
    },
    // a way to get the _refreshing value in Observer
    ref: function() {
      return Bt;
    }
  }
};
Rp() && ie.registerPlugin(_e);
function el() {
  me.registerPlugin(_e), me.utils.toArray("[data-image-reveal]").forEach((n) => {
    me.fromTo(
      n,
      {
        filter: "blur(12px)",
        opacity: 0
      },
      {
        filter: "blur(0px)",
        opacity: 1,
        duration: 0.4,
        ease: "power3.out",
        scrollTrigger: {
          trigger: n,
          start: "top 90%",
          toggleActions: "play none none none"
        }
      }
    );
  });
}
function xa() {
  const n = () => {
    document.body.style.overflow = "hidden", document.body.style.height = "100%";
  }, e = () => {
    document.body.style.overflow = "", document.body.style.height = "";
  };
  document.querySelectorAll('[data-scroll="stop"]').forEach((t) => {
    t.addEventListener("click", n);
  }), document.querySelectorAll('[data-scroll="start"]').forEach((t) => {
    t.addEventListener("click", e);
  });
}
document.addEventListener("DOMContentLoaded", xa);
function Bv() {
  Q.buttonAnimations.initialize(), el(), xa(), window.viewportManager && window.viewportManager.enable();
}
var Uv = "1.3.11";
function Gp(n, e, t) {
  return Math.max(n, Math.min(e, t));
}
function Gv(n, e, t) {
  return (1 - t) * n + t * e;
}
function Hv(n, e, t, i) {
  return Gv(n, e, 1 - Math.exp(-t * i));
}
function Vv(n, e) {
  return (n % e + e) % e;
}
var zv = class {
  isRunning = !1;
  value = 0;
  from = 0;
  to = 0;
  currentTime = 0;
  // These are instanciated in the fromTo method
  lerp;
  duration;
  easing;
  onUpdate;
  /**
   * Advance the animation by the given delta time
   *
   * @param deltaTime - The time in seconds to advance the animation
   */
  advance(n) {
    if (!this.isRunning) return;
    let e = !1;
    if (this.duration && this.easing) {
      this.currentTime += n;
      const t = Gp(0, this.currentTime / this.duration, 1);
      e = t >= 1;
      const i = e ? 1 : this.easing(t);
      this.value = this.from + (this.to - this.from) * i;
    } else this.lerp ? (this.value = Hv(this.value, this.to, this.lerp * 60, n), Math.round(this.value) === this.to && (this.value = this.to, e = !0)) : (this.value = this.to, e = !0);
    e && this.stop(), this.onUpdate?.(this.value, e);
  }
  /** Stop the animation */
  stop() {
    this.isRunning = !1;
  }
  /**
   * Set up the animation from a starting value to an ending value
   * with optional parameters for lerping, duration, easing, and onUpdate callback
   *
   * @param from - The starting value
   * @param to - The ending value
   * @param options - Options for the animation
   */
  fromTo(n, e, { lerp: t, duration: i, easing: s, onStart: r, onUpdate: a }) {
    this.from = this.value = n, this.to = e, this.lerp = t, this.duration = i, this.easing = s, this.currentTime = 0, this.isRunning = !0, r?.(), this.onUpdate = a;
  }
};
function Wv(n, e) {
  let t;
  return function(...i) {
    let s = this;
    clearTimeout(t), t = setTimeout(() => {
      t = void 0, n.apply(s, i);
    }, e);
  };
}
var Kv = class {
  constructor(n, e, { autoResize: t = !0, debounce: i = 250 } = {}) {
    this.wrapper = n, this.content = e, t && (this.debouncedResize = Wv(this.resize, i), this.wrapper instanceof Window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)), this.resize();
  }
  width = 0;
  height = 0;
  scrollHeight = 0;
  scrollWidth = 0;
  // These are instanciated in the constructor as they need information from the options
  debouncedResize;
  wrapperResizeObserver;
  contentResizeObserver;
  destroy() {
    this.wrapperResizeObserver?.disconnect(), this.contentResizeObserver?.disconnect(), this.wrapper === window && this.debouncedResize && window.removeEventListener("resize", this.debouncedResize, !1);
  }
  resize = () => {
    this.onWrapperResize(), this.onContentResize();
  };
  onWrapperResize = () => {
    this.wrapper instanceof Window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight);
  };
  onContentResize = () => {
    this.wrapper instanceof Window ? (this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight, this.scrollWidth = this.wrapper.scrollWidth);
  };
  get limit() {
    return {
      x: this.scrollWidth - this.width,
      y: this.scrollHeight - this.height
    };
  }
}, Hp = class {
  events = {};
  /**
   * Emit an event with the given data
   * @param event Event name
   * @param args Data to pass to the event handlers
   */
  emit(n, ...e) {
    let t = this.events[n] || [];
    for (let i = 0, s = t.length; i < s; i++)
      t[i]?.(...e);
  }
  /**
   * Add a callback to the event
   * @param event Event name
   * @param cb Callback function
   * @returns Unsubscribe function
   */
  on(n, e) {
    return this.events[n]?.push(e) || (this.events[n] = [e]), () => {
      this.events[n] = this.events[n]?.filter((t) => e !== t);
    };
  }
  /**
   * Remove a callback from the event
   * @param event Event name
   * @param callback Callback function
   */
  off(n, e) {
    this.events[n] = this.events[n]?.filter((t) => e !== t);
  }
  /**
   * Remove all event listeners and clean up
   */
  destroy() {
    this.events = {};
  }
}, Gd = 100 / 6, Is = { passive: !1 }, Yv = class {
  constructor(n, e = { wheelMultiplier: 1, touchMultiplier: 1 }) {
    this.element = n, this.options = e, window.addEventListener("resize", this.onWindowResize, !1), this.onWindowResize(), this.element.addEventListener("wheel", this.onWheel, Is), this.element.addEventListener(
      "touchstart",
      this.onTouchStart,
      Is
    ), this.element.addEventListener(
      "touchmove",
      this.onTouchMove,
      Is
    ), this.element.addEventListener("touchend", this.onTouchEnd, Is);
  }
  touchStart = {
    x: 0,
    y: 0
  };
  lastDelta = {
    x: 0,
    y: 0
  };
  window = {
    width: 0,
    height: 0
  };
  emitter = new Hp();
  /**
   * Add an event listener for the given event and callback
   *
   * @param event Event name
   * @param callback Callback function
   */
  on(n, e) {
    return this.emitter.on(n, e);
  }
  /** Remove all event listeners and clean up */
  destroy() {
    this.emitter.destroy(), window.removeEventListener("resize", this.onWindowResize, !1), this.element.removeEventListener("wheel", this.onWheel, Is), this.element.removeEventListener(
      "touchstart",
      this.onTouchStart,
      Is
    ), this.element.removeEventListener(
      "touchmove",
      this.onTouchMove,
      Is
    ), this.element.removeEventListener(
      "touchend",
      this.onTouchEnd,
      Is
    );
  }
  /**
   * Event handler for 'touchstart' event
   *
   * @param event Touch event
   */
  onTouchStart = (n) => {
    const { clientX: e, clientY: t } = n.targetTouches ? n.targetTouches[0] : n;
    this.touchStart.x = e, this.touchStart.y = t, this.lastDelta = {
      x: 0,
      y: 0
    }, this.emitter.emit("scroll", {
      deltaX: 0,
      deltaY: 0,
      event: n
    });
  };
  /** Event handler for 'touchmove' event */
  onTouchMove = (n) => {
    const { clientX: e, clientY: t } = n.targetTouches ? n.targetTouches[0] : n, i = -(e - this.touchStart.x) * this.options.touchMultiplier, s = -(t - this.touchStart.y) * this.options.touchMultiplier;
    this.touchStart.x = e, this.touchStart.y = t, this.lastDelta = {
      x: i,
      y: s
    }, this.emitter.emit("scroll", {
      deltaX: i,
      deltaY: s,
      event: n
    });
  };
  onTouchEnd = (n) => {
    this.emitter.emit("scroll", {
      deltaX: this.lastDelta.x,
      deltaY: this.lastDelta.y,
      event: n
    });
  };
  /** Event handler for 'wheel' event */
  onWheel = (n) => {
    let { deltaX: e, deltaY: t, deltaMode: i } = n;
    const s = i === 1 ? Gd : i === 2 ? this.window.width : 1, r = i === 1 ? Gd : i === 2 ? this.window.height : 1;
    e *= s, t *= r, e *= this.options.wheelMultiplier, t *= this.options.wheelMultiplier, this.emitter.emit("scroll", { deltaX: e, deltaY: t, event: n });
  };
  onWindowResize = () => {
    this.window = {
      width: window.innerWidth,
      height: window.innerHeight
    };
  };
}, Hd = (n) => Math.min(1, 1.001 - Math.pow(2, -10 * n)), qv = class {
  _isScrolling = !1;
  // true when scroll is animating
  _isStopped = !1;
  // true if user should not be able to scroll - enable/disable programmatically
  _isLocked = !1;
  // same as isStopped but enabled/disabled when scroll reaches target
  _preventNextNativeScrollEvent = !1;
  _resetVelocityTimeout = null;
  __rafID = null;
  /**
   * Whether or not the user is touching the screen
   */
  isTouching;
  /**
   * The time in ms since the lenis instance was created
   */
  time = 0;
  /**
   * User data that will be forwarded through the scroll event
   *
   * @example
   * lenis.scrollTo(100, {
   *   userData: {
   *     foo: 'bar'
   *   }
   * })
   */
  userData = {};
  /**
   * The last velocity of the scroll
   */
  lastVelocity = 0;
  /**
   * The current velocity of the scroll
   */
  velocity = 0;
  /**
   * The direction of the scroll
   */
  direction = 0;
  /**
   * The options passed to the lenis instance
   */
  options;
  /**
   * The target scroll value
   */
  targetScroll;
  /**
   * The animated scroll value
   */
  animatedScroll;
  // These are instanciated here as they don't need information from the options
  animate = new zv();
  emitter = new Hp();
  // These are instanciated in the constructor as they need information from the options
  dimensions;
  // This is not private because it's used in the Snap class
  virtualScroll;
  constructor({
    wrapper: n = window,
    content: e = document.documentElement,
    eventsTarget: t = n,
    smoothWheel: i = !0,
    syncTouch: s = !1,
    syncTouchLerp: r = 0.075,
    touchInertiaExponent: a = 1.7,
    duration: o,
    // in seconds
    easing: l,
    lerp: c = 0.1,
    infinite: u = !1,
    orientation: d = "vertical",
    // vertical, horizontal
    gestureOrientation: f = d === "horizontal" ? "both" : "vertical",
    // vertical, horizontal, both
    touchMultiplier: p = 1,
    wheelMultiplier: h = 1,
    autoResize: g = !0,
    prevent: m,
    virtualScroll: v,
    overscroll: y = !0,
    autoRaf: E = !1,
    anchors: T = !1,
    autoToggle: S = !1,
    // https://caniuse.com/?search=transition-behavior
    allowNestedScroll: w = !1,
    __experimental__naiveDimensions: b = !1
  } = {}) {
    window.lenisVersion = Uv, (!n || n === document.documentElement) && (n = window), typeof o == "number" && typeof l != "function" ? l = Hd : typeof l == "function" && typeof o != "number" && (o = 1), this.options = {
      wrapper: n,
      content: e,
      eventsTarget: t,
      smoothWheel: i,
      syncTouch: s,
      syncTouchLerp: r,
      touchInertiaExponent: a,
      duration: o,
      easing: l,
      lerp: c,
      infinite: u,
      gestureOrientation: f,
      orientation: d,
      touchMultiplier: p,
      wheelMultiplier: h,
      autoResize: g,
      prevent: m,
      virtualScroll: v,
      overscroll: y,
      autoRaf: E,
      anchors: T,
      autoToggle: S,
      allowNestedScroll: w,
      __experimental__naiveDimensions: b
    }, this.dimensions = new Kv(n, e, { autoResize: g }), this.updateClassName(), this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1), this.options.wrapper.addEventListener("scrollend", this.onScrollEnd, {
      capture: !0
    }), this.options.anchors && this.options.wrapper === window && this.options.wrapper.addEventListener(
      "click",
      this.onClick,
      !1
    ), this.options.wrapper.addEventListener(
      "pointerdown",
      this.onPointerDown,
      !1
    ), this.virtualScroll = new Yv(t, {
      touchMultiplier: p,
      wheelMultiplier: h
    }), this.virtualScroll.on("scroll", this.onVirtualScroll), this.options.autoToggle && this.rootElement.addEventListener("transitionend", this.onTransitionEnd, {
      passive: !0
    }), this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf));
  }
  /**
   * Destroy the lenis instance, remove all event listeners and clean up the class name
   */
  destroy() {
    this.emitter.destroy(), this.options.wrapper.removeEventListener(
      "scroll",
      this.onNativeScroll,
      !1
    ), this.options.wrapper.removeEventListener("scrollend", this.onScrollEnd, {
      capture: !0
    }), this.options.wrapper.removeEventListener(
      "pointerdown",
      this.onPointerDown,
      !1
    ), this.options.anchors && this.options.wrapper === window && this.options.wrapper.removeEventListener(
      "click",
      this.onClick,
      !1
    ), this.virtualScroll.destroy(), this.dimensions.destroy(), this.cleanUpClassName(), this.__rafID && cancelAnimationFrame(this.__rafID);
  }
  on(n, e) {
    return this.emitter.on(n, e);
  }
  off(n, e) {
    return this.emitter.off(n, e);
  }
  onScrollEnd = (n) => {
    n instanceof CustomEvent || (this.isScrolling === "smooth" || this.isScrolling === !1) && n.stopPropagation();
  };
  dispatchScrollendEvent = () => {
    this.options.wrapper.dispatchEvent(
      new CustomEvent("scrollend", {
        bubbles: this.options.wrapper === window,
        // cancelable: false,
        detail: {
          lenisScrollEnd: !0
        }
      })
    );
  };
  onTransitionEnd = (n) => {
    if (n.propertyName.includes("overflow")) {
      const e = this.isHorizontal ? "overflow-x" : "overflow-y", t = getComputedStyle(this.rootElement)[e];
      ["hidden", "clip"].includes(t) ? this.internalStop() : this.internalStart();
    }
  };
  setScroll(n) {
    this.isHorizontal ? this.options.wrapper.scrollTo({ left: n, behavior: "instant" }) : this.options.wrapper.scrollTo({ top: n, behavior: "instant" });
  }
  onClick = (n) => {
    const t = n.composedPath().find(
      (i) => i instanceof HTMLAnchorElement && (i.getAttribute("href")?.startsWith("#") || i.getAttribute("href")?.startsWith("/#") || i.getAttribute("href")?.startsWith("./#"))
    );
    if (t) {
      const i = t.getAttribute("href");
      if (i) {
        const s = typeof this.options.anchors == "object" && this.options.anchors ? this.options.anchors : void 0;
        let r = `#${i.split("#")[1]}`;
        ["#", "/#", "./#", "#top", "/#top", "./#top"].includes(i) && (r = 0), this.scrollTo(r, s);
      }
    }
  };
  onPointerDown = (n) => {
    n.button === 1 && this.reset();
  };
  onVirtualScroll = (n) => {
    if (typeof this.options.virtualScroll == "function" && this.options.virtualScroll(n) === !1)
      return;
    const { deltaX: e, deltaY: t, event: i } = n;
    if (this.emitter.emit("virtual-scroll", { deltaX: e, deltaY: t, event: i }), i.ctrlKey || i.lenisStopPropagation) return;
    const s = i.type.includes("touch"), r = i.type.includes("wheel");
    this.isTouching = i.type === "touchstart" || i.type === "touchmove";
    const a = e === 0 && t === 0;
    if (this.options.syncTouch && s && i.type === "touchstart" && a && !this.isStopped && !this.isLocked) {
      this.reset();
      return;
    }
    const l = this.options.gestureOrientation === "vertical" && t === 0 || this.options.gestureOrientation === "horizontal" && e === 0;
    if (a || l)
      return;
    let c = i.composedPath();
    c = c.slice(0, c.indexOf(this.rootElement));
    const u = this.options.prevent;
    if (c.find(
      (m) => m instanceof HTMLElement && (typeof u == "function" && u?.(m) || m.hasAttribute?.("data-lenis-prevent") || s && m.hasAttribute?.("data-lenis-prevent-touch") || r && m.hasAttribute?.("data-lenis-prevent-wheel") || this.options.allowNestedScroll && this.checkNestedScroll(m, { deltaX: e, deltaY: t }))
    ))
      return;
    if (this.isStopped || this.isLocked) {
      i.cancelable && i.preventDefault();
      return;
    }
    if (!(this.options.syncTouch && s || this.options.smoothWheel && r)) {
      this.isScrolling = "native", this.animate.stop(), i.lenisStopPropagation = !0;
      return;
    }
    let f = t;
    this.options.gestureOrientation === "both" ? f = Math.abs(t) > Math.abs(e) ? t : e : this.options.gestureOrientation === "horizontal" && (f = e), (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && this.limit > 0 && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && t > 0 || this.animatedScroll === this.limit && t < 0)) && (i.lenisStopPropagation = !0), i.cancelable && i.preventDefault();
    const p = s && this.options.syncTouch, g = s && i.type === "touchend";
    g && (f = Math.sign(this.velocity) * Math.pow(Math.abs(this.velocity), this.options.touchInertiaExponent)), this.scrollTo(this.targetScroll + f, {
      programmatic: !1,
      ...p ? {
        lerp: g ? this.options.syncTouchLerp : 1
        // immediate: !hasTouchInertia,
      } : {
        lerp: this.options.lerp,
        duration: this.options.duration,
        easing: this.options.easing
      }
    });
  };
  /**
   * Force lenis to recalculate the dimensions
   */
  resize() {
    this.dimensions.resize(), this.animatedScroll = this.targetScroll = this.actualScroll, this.emit();
  }
  emit() {
    this.emitter.emit("scroll", this);
  }
  onNativeScroll = () => {
    if (this._resetVelocityTimeout !== null && (clearTimeout(this._resetVelocityTimeout), this._resetVelocityTimeout = null), this._preventNextNativeScrollEvent) {
      this._preventNextNativeScrollEvent = !1;
      return;
    }
    if (this.isScrolling === !1 || this.isScrolling === "native") {
      const n = this.animatedScroll;
      this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity, this.velocity = this.animatedScroll - n, this.direction = Math.sign(
        this.animatedScroll - n
      ), this.isStopped || (this.isScrolling = "native"), this.emit(), this.velocity !== 0 && (this._resetVelocityTimeout = setTimeout(() => {
        this.lastVelocity = this.velocity, this.velocity = 0, this.isScrolling = !1, this.emit();
      }, 400));
    }
  };
  reset() {
    this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity = 0, this.animate.stop();
  }
  /**
   * Start lenis scroll after it has been stopped
   */
  start() {
    if (this.isStopped) {
      if (this.options.autoToggle) {
        this.rootElement.style.removeProperty("overflow");
        return;
      }
      this.internalStart();
    }
  }
  internalStart() {
    this.isStopped && (this.reset(), this.isStopped = !1, this.emit());
  }
  /**
   * Stop lenis scroll
   */
  stop() {
    if (!this.isStopped) {
      if (this.options.autoToggle) {
        this.rootElement.style.setProperty("overflow", "clip");
        return;
      }
      this.internalStop();
    }
  }
  internalStop() {
    this.isStopped || (this.reset(), this.isStopped = !0, this.emit());
  }
  /**
   * RequestAnimationFrame for lenis
   *
   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus
   */
  raf = (n) => {
    const e = n - (this.time || n);
    this.time = n, this.animate.advance(e * 1e-3), this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf));
  };
  /**
   * Scroll to a target value
   *
   * @param target The target value to scroll to
   * @param options The options for the scroll
   *
   * @example
   * lenis.scrollTo(100, {
   *   offset: 100,
   *   duration: 1,
   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),
   *   lerp: 0.1,
   *   onStart: () => {
   *     console.log('onStart')
   *   },
   *   onComplete: () => {
   *     console.log('onComplete')
   *   },
   * })
   */
  scrollTo(n, {
    offset: e = 0,
    immediate: t = !1,
    lock: i = !1,
    duration: s = this.options.duration,
    easing: r = this.options.easing,
    lerp: a = this.options.lerp,
    onStart: o,
    onComplete: l,
    force: c = !1,
    // scroll even if stopped
    programmatic: u = !0,
    // called from outside of the class
    userData: d
  } = {}) {
    if (!((this.isStopped || this.isLocked) && !c)) {
      if (typeof n == "string" && ["top", "left", "start"].includes(n))
        n = 0;
      else if (typeof n == "string" && ["bottom", "right", "end"].includes(n))
        n = this.limit;
      else {
        let f;
        if (typeof n == "string" ? f = document.querySelector(n) : n instanceof HTMLElement && n?.nodeType && (f = n), f) {
          if (this.options.wrapper !== window) {
            const h = this.rootElement.getBoundingClientRect();
            e -= this.isHorizontal ? h.left : h.top;
          }
          const p = f.getBoundingClientRect();
          n = (this.isHorizontal ? p.left : p.top) + this.animatedScroll;
        }
      }
      if (typeof n == "number") {
        if (n += e, n = Math.round(n), this.options.infinite) {
          if (u) {
            this.targetScroll = this.animatedScroll = this.scroll;
            const f = n - this.animatedScroll;
            f > this.limit / 2 ? n = n - this.limit : f < -this.limit / 2 && (n = n + this.limit);
          }
        } else
          n = Gp(0, n, this.limit);
        if (n === this.targetScroll) {
          o?.(this), l?.(this);
          return;
        }
        if (this.userData = d ?? {}, t) {
          this.animatedScroll = this.targetScroll = n, this.setScroll(this.scroll), this.reset(), this.preventNextNativeScrollEvent(), this.emit(), l?.(this), this.userData = {}, requestAnimationFrame(() => {
            this.dispatchScrollendEvent();
          });
          return;
        }
        u || (this.targetScroll = n), typeof s == "number" && typeof r != "function" ? r = Hd : typeof r == "function" && typeof s != "number" && (s = 1), this.animate.fromTo(this.animatedScroll, n, {
          duration: s,
          easing: r,
          lerp: a,
          onStart: () => {
            i && (this.isLocked = !0), this.isScrolling = "smooth", o?.(this);
          },
          onUpdate: (f, p) => {
            this.isScrolling = "smooth", this.lastVelocity = this.velocity, this.velocity = f - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = f, this.setScroll(this.scroll), u && (this.targetScroll = f), p || this.emit(), p && (this.reset(), this.emit(), l?.(this), this.userData = {}, requestAnimationFrame(() => {
              this.dispatchScrollendEvent();
            }), this.preventNextNativeScrollEvent());
          }
        });
      }
    }
  }
  preventNextNativeScrollEvent() {
    this._preventNextNativeScrollEvent = !0, requestAnimationFrame(() => {
      this._preventNextNativeScrollEvent = !1;
    });
  }
  checkNestedScroll(n, { deltaX: e, deltaY: t }) {
    const i = Date.now(), s = n._lenis ??= {};
    let r, a, o, l, c, u, d, f;
    const p = this.options.gestureOrientation;
    if (i - (s.time ?? 0) > 2e3) {
      s.time = Date.now();
      const S = window.getComputedStyle(n);
      s.computedStyle = S;
      const w = S.overflowX, b = S.overflowY;
      if (r = ["auto", "overlay", "scroll"].includes(w), a = ["auto", "overlay", "scroll"].includes(b), s.hasOverflowX = r, s.hasOverflowY = a, !r && !a || p === "vertical" && !a || p === "horizontal" && !r) return !1;
      c = n.scrollWidth, u = n.scrollHeight, d = n.clientWidth, f = n.clientHeight, o = c > d, l = u > f, s.isScrollableX = o, s.isScrollableY = l, s.scrollWidth = c, s.scrollHeight = u, s.clientWidth = d, s.clientHeight = f;
    } else
      o = s.isScrollableX, l = s.isScrollableY, r = s.hasOverflowX, a = s.hasOverflowY, c = s.scrollWidth, u = s.scrollHeight, d = s.clientWidth, f = s.clientHeight;
    if (!r && !a || !o && !l || p === "vertical" && (!a || !l) || p === "horizontal" && (!r || !o))
      return !1;
    let h;
    if (p === "horizontal")
      h = "x";
    else if (p === "vertical")
      h = "y";
    else {
      const S = e !== 0, w = t !== 0;
      S && r && o && (h = "x"), w && a && l && (h = "y");
    }
    if (!h) return !1;
    let g, m, v, y, E;
    if (h === "x")
      g = n.scrollLeft, m = c - d, v = e, y = r, E = o;
    else if (h === "y")
      g = n.scrollTop, m = u - f, v = t, y = a, E = l;
    else
      return !1;
    return (v > 0 ? g < m : g > 0) && y && E;
  }
  /**
   * The root element on which lenis is instanced
   */
  get rootElement() {
    return this.options.wrapper === window ? document.documentElement : this.options.wrapper;
  }
  /**
   * The limit which is the maximum scroll value
   */
  get limit() {
    return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"];
  }
  /**
   * Whether or not the scroll is horizontal
   */
  get isHorizontal() {
    return this.options.orientation === "horizontal";
  }
  /**
   * The actual scroll value
   */
  get actualScroll() {
    const n = this.options.wrapper;
    return this.isHorizontal ? n.scrollX ?? n.scrollLeft : n.scrollY ?? n.scrollTop;
  }
  /**
   * The current scroll value
   */
  get scroll() {
    return this.options.infinite ? Vv(this.animatedScroll, this.limit) : this.animatedScroll;
  }
  /**
   * The progress of the scroll relative to the limit
   */
  get progress() {
    return this.limit === 0 ? 1 : this.scroll / this.limit;
  }
  /**
   * Current scroll state
   */
  get isScrolling() {
    return this._isScrolling;
  }
  set isScrolling(n) {
    this._isScrolling !== n && (this._isScrolling = n, this.updateClassName());
  }
  /**
   * Check if lenis is stopped
   */
  get isStopped() {
    return this._isStopped;
  }
  set isStopped(n) {
    this._isStopped !== n && (this._isStopped = n, this.updateClassName());
  }
  /**
   * Check if lenis is locked
   */
  get isLocked() {
    return this._isLocked;
  }
  set isLocked(n) {
    this._isLocked !== n && (this._isLocked = n, this.updateClassName());
  }
  /**
   * Check if lenis is smooth scrolling
   */
  get isSmooth() {
    return this.isScrolling === "smooth";
  }
  /**
   * The class name applied to the wrapper element
   */
  get className() {
    let n = "lenis";
    return this.options.autoToggle && (n += " lenis-autoToggle"), this.isStopped && (n += " lenis-stopped"), this.isLocked && (n += " lenis-locked"), this.isScrolling && (n += " lenis-scrolling"), this.isScrolling === "smooth" && (n += " lenis-smooth"), n;
  }
  updateClassName() {
    this.cleanUpClassName(), this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim();
  }
  cleanUpClassName() {
    this.rootElement.className = this.rootElement.className.replace(/lenis(-\w+)?/g, "").trim();
  }
};
let Ua;
const Xv = {
  smooth: !0,
  lerp: 0.1,
  multiplier: 0.7
};
function Fn(n = Xv) {
  Ua && Ua.destroy(), Ua = new qv(n);
  function e(t) {
    Ua.raf(t), requestAnimationFrame(e);
  }
  requestAnimationFrame(e);
}
const jv = /* @__PURE__ */ (() => {
  const n = (v, y = document) => y.querySelector(v), e = (v) => n(`[data-reveal="target"][data-reveal-group="${v}"]`), t = (v) => {
    me && me.killTweensOf(v);
  }, i = (v, y = !0) => {
    const E = parseFloat(v.getAttribute("data-reveal-duration")) || NaN, T = parseFloat(v.getAttribute("data-reveal-show-duration")), S = parseFloat(v.getAttribute("data-reveal-hide-duration"));
    return Number.isNaN(E) ? y && !Number.isNaN(T) ? T : !y && !Number.isNaN(S) ? S : y ? 0.6 : 0.5 : E;
  }, s = (v, y = !0) => {
    const E = v.getAttribute("data-reveal-ease"), T = v.getAttribute("data-reveal-show-ease"), S = v.getAttribute("data-reveal-hide-ease");
    return E || (y && T ? T : !y && S ? S : y ? "power2.out" : "power2.in");
  }, r = (v) => v.getAttribute("data-reveal-display") || "flex", a = (v) => v && v.nodeType === 1 && v.children.length === 0 && (v.textContent || "").trim().length > 0, o = (v) => {
    const y = Array.from(v.querySelectorAll("[data-shuffle-reveal]")), E = Array.from(
      v.querySelectorAll(
        "h1,h2,h3,h4,h5,h6,p,span,a,button,li,dt,dd,figcaption,small,strong,em,label,th,td,blockquote"
      )
    );
    return [.../* @__PURE__ */ new Set([...y, ...E])].filter((S) => S.closest('[data-reveal="target"]') === v && a(S));
  }, l = (v) => {
    v.dataset.srOriginalText || (v.dataset.srOriginalText = v.textContent);
  }, c = (v) => {
    const y = v.getBoundingClientRect().width || v.offsetWidth || 0;
    if (typeof bo > "u" || y === 0)
      return [(v.innerText || v.textContent || "").trim()];
    const E = v.cloneNode(!0);
    E.style.position = "absolute", E.style.visibility = "hidden", E.style.pointerEvents = "none", E.style.left = "-9999px", E.style.top = "0", E.style.width = y + "px", document.body.appendChild(E);
    const T = [];
    try {
      bo({ target: E, by: "lines", whitespace: !0 }).forEach((w) => {
        w.lines.forEach((b) => {
          let L = "";
          b.forEach((A, _) => {
            if (L += A.textContent, _ < b.length - 1) {
              const R = b[_ + 1].textContent;
              /^[.,!?;:]/.test(R) || (L += " ");
            }
          }), T.push(L);
        });
      });
    } catch {
      T.push((v.innerText || v.textContent || "").trim());
    } finally {
      E.remove();
    }
    return T.length ? T : [(v.innerText || v.textContent || "").trim()];
  }, u = (v) => {
    l(v), Q.shuffleWords("", v.dataset.srOriginalText, v, 50, !1);
  }, d = (v) => {
    l(v);
    const y = v.dataset.srOriginalText, E = c(v);
    v.innerHTML = "";
    let T = E.length;
    E.forEach((S, w) => {
      const b = document.createElement("div");
      b.className = "sr-line", b.style.display = "block", v.appendChild(b), setTimeout(() => {
        Q.shuffleWords("", S, b, 40, !1, () => {
          T -= 1, T === 0 && (v.textContent = y);
        });
      }, w * 50);
    });
  }, f = (v, y = 40) => {
    l(v);
    const E = Q?.chars?.mixed || "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    v.srInfiniteInterval && clearInterval(v.srInfiniteInterval), v.srInfiniteInterval = setInterval(() => {
      const T = v.dataset.srOriginalText || v.textContent;
      let S = "";
      for (let w = 0; w < T.length; w++) {
        const b = T[w];
        S += /\s/.test(b) ? b : E[Math.floor(Math.random() * E.length)];
      }
      v.textContent = S;
    }, y);
  }, p = (v, y = !0) => {
    v.srInfiniteInterval && (clearInterval(v.srInfiniteInterval), v.srInfiniteInterval = null), y && v.dataset.srOriginalText && (v.textContent = v.dataset.srOriginalText);
  }, h = (v) => {
    if (!me || !Q) {
      console.error("ShuffleReveal needs GSAP + ShuffleAnimations loaded.");
      return;
    }
    t(v);
    const y = o(v);
    y.forEach((S) => p(S, !0)), me.set(v, { display: r(v), opacity: 0 });
    const E = i(v, !0), T = s(v, !0);
    y.forEach((S) => {
      S.getAttribute("data-shuffle-reveal") === "multiline" ? d(S) : u(S);
    }), me.to(v, {
      opacity: 1,
      duration: E,
      ease: T,
      clearProps: "opacity"
    });
  }, g = (v) => {
    if (!me || !Q) {
      console.error("ShuffleReveal needs GSAP + ShuffleAnimations loaded.");
      return;
    }
    t(v);
    const y = o(v);
    y.forEach((T) => f(T, 40)), i(v, !1);
    const E = s(v, !1);
    me.to(v, {
      opacity: 0,
      duration: 0.2,
      ease: E,
      onComplete: () => {
        y.forEach((T) => p(T, !0)), me.set(v, { display: "none" });
      }
    });
  };
  return { bind: () => {
    document.addEventListener("click", (v) => {
      const y = v.target.closest('[data-reveal="show"]'), E = v.target.closest('[data-reveal="hide"]');
      if (y) {
        const T = y.getAttribute("data-reveal-group"), S = e(T);
        S && h(S);
      }
      if (E) {
        const T = E.getAttribute("data-reveal-group"), S = e(T);
        S && g(S);
      }
    });
  }, show: h, hide: g };
})();
document.addEventListener("DOMContentLoaded", () => {
  jv.bind();
});
function Qv(n = !1) {
  if (typeof jQuery > "u") {
    console.warn("initNextProject: jQuery not found.");
    return;
  }
  $('[tr-next="list"]').each(function(e) {
    const t = $(this), i = t.find(".w-dyn-items").first(), s = i.length ? i : t, r = s.children(".w-dyn-item");
    if (n && console.log("[initNextProject] listIndex:", e, "items found:", r.length), !r.length) return;
    const a = window.location.pathname.replace(/\/$/, "");
    let o = r.filter(function() {
      const c = $(this).find("a").first();
      if (!c.length) return !1;
      const u = c.attr("href");
      try {
        return new URL(u, window.location.origin).pathname.replace(/\/$/, "") === a;
      } catch {
        return (u || "").replace(/\/$/, "") === a;
      }
    }).first();
    if (!o.length) {
      const c = s.find(".w--current").first();
      c.length && (o = c.closest(".w-dyn-item"));
    }
    if (!o.length) {
      n && console.warn("[initNextProject] no current item detected for listIndex:", e);
      return;
    }
    let l = o.next(".w-dyn-item");
    l.length || (l = r.first()), n && console.log(
      "[initNextProject] current index:",
      r.index(o),
      "next index:",
      r.index(l)
    ), r.not(l).remove();
  });
}
function Iu() {
  if (typeof Q > "u") {
    setTimeout(Iu, 100);
    return;
  }
  const n = {
    intervals: /* @__PURE__ */ new Map(),
    startInfiniteShuffle(e) {
      e.getAttribute("data-original-text") || e.setAttribute("data-original-text", e.textContent), this.clearIntervals(e);
      const t = e.getAttribute("data-original-text"), i = e.matches('[data-shuffle-infinite="number"]') ? Q.chars.numbers : Q.chars.mixed, s = setInterval(() => {
        const a = Q.splitIntoWords(t).map(
          (o) => Q.isWhitespace(o) ? o : Q.shuffleWord(o, i)
        );
        e.textContent = a.join("");
      }, 50);
      this.intervals.set(e, [s]);
    },
    clearIntervals(e) {
      const t = this.intervals.get(e);
      t && (t.forEach((i) => clearInterval(i)), this.intervals.delete(e));
    },
    stopInfiniteShuffle(e) {
      const t = e.getAttribute("data-original-text");
      t && (this.clearIntervals(e), Q.shuffleWords(
        e.textContent,
        t,
        e,
        50,
        !1
      ));
    },
    shuffleToFixedWord(e, t) {
      e.getAttribute("data-original-text") || e.setAttribute("data-original-text", e.textContent), this.clearIntervals(e), Q.shuffleWords(
        e.textContent,
        t,
        e,
        50,
        !1
      );
    },
    resetToOriginal(e, t = !1) {
      const i = e.getAttribute("data-original-text"), s = t ? " " : i;
      this.clearIntervals(e), Q.shuffleWords(
        e.textContent,
        s,
        e,
        50,
        !1
      );
    },
    initialize() {
      document.querySelectorAll('[data-shuffle-infinite="target"]').forEach((t) => {
        const i = t.closest('[data-barba="container"]') || document, s = i.querySelectorAll(
          '[data-shuffle-infinite="text"], [data-shuffle-infinite="number"]'
        ), r = i.querySelector('[data-shuffle-infinite="next-1"]'), a = i.querySelector('[data-shuffle-infinite="next-2"]'), o = i.querySelector('[data-shuffle-infinite="next-3"]'), l = () => {
          s.forEach((u) => this.startInfiniteShuffle(u)), me.to(i.querySelectorAll('[data-shuffle-infinite="multi"] .line-wrapper'), {
            filter: "blur(12px)",
            opacity: 0,
            duration: 0.4,
            ease: "power3.out",
            stagger: 0.1
          }), r && this.shuffleToFixedWord(r, "Next"), a && this.shuffleToFixedWord(a, "Project"), o && this.shuffleToFixedWord(o, "Project");
        }, c = () => {
          s.forEach((u) => this.stopInfiniteShuffle(u)), me.to(i.querySelectorAll('[data-shuffle-infinite="multi"] .line-wrapper'), {
            filter: "blur(0px)",
            opacity: 1,
            duration: 0.4,
            ease: "power3.out",
            stagger: -0.1
          }), r && this.resetToOriginal(r), a && this.resetToOriginal(a), o && this.resetToOriginal(o, !0);
        };
        t.addEventListener("mouseenter", l), t.addEventListener("mouseleave", c), t._shuffleHandlers = { handleMouseEnter: l, handleMouseLeave: c };
      });
    },
    // Cleanup method for page transitions
    cleanup() {
      this.intervals.forEach((t) => {
        t.forEach((i) => clearInterval(i));
      }), this.intervals.clear(), document.querySelectorAll('[data-shuffle-infinite="target"]').forEach((t) => {
        t._shuffleHandlers && (t.removeEventListener("mouseenter", t._shuffleHandlers.handleMouseEnter), t.removeEventListener("mouseleave", t._shuffleHandlers.handleMouseLeave), delete t._shuffleHandlers);
      }), me.killTweensOf("[data-shuffle-infinite]"), me.killTweensOf('[data-shuffle-infinite="multi"] .line-wrapper');
    }
  };
  return n.initialize(), n;
}
Iu();
function Ru() {
  const n = document.querySelectorAll('[data-shuffle-viewport="single"], [data-shuffle-viewport="multi"]');
  if (!n.length) return;
  const e = new IntersectionObserver((t, i) => {
    t.forEach((s) => {
      if (!s.isIntersecting) return;
      const r = s.target, a = r.getAttribute("data-shuffle-viewport"), o = r.textContent;
      if (r.dataset.shuffledOnce) {
        i.unobserve(r);
        return;
      }
      a === "single" ? Q.shuffleIn(o, r, 50) : a === "multi" && Q.shuffleMulti(r, 50), r.dataset.shuffledOnce = "true", i.unobserve(r);
    });
  }, { threshold: 0.1 });
  n.forEach((t) => e.observe(t));
}
const Z = Number.isFinite || function(n) {
  return typeof n == "number" && isFinite(n);
}, Zv = Number.isSafeInteger || function(n) {
  return typeof n == "number" && Math.abs(n) <= Jv;
}, Jv = Number.MAX_SAFE_INTEGER || 9007199254740991;
let se = /* @__PURE__ */ (function(n) {
  return n.NETWORK_ERROR = "networkError", n.MEDIA_ERROR = "mediaError", n.KEY_SYSTEM_ERROR = "keySystemError", n.MUX_ERROR = "muxError", n.OTHER_ERROR = "otherError", n;
})({}), H = /* @__PURE__ */ (function(n) {
  return n.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", n.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", n.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", n.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense", n.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", n.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = "keySystemServerCertificateRequestFailed", n.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = "keySystemServerCertificateUpdateFailed", n.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed", n.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = "keySystemStatusOutputRestricted", n.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError", n.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR = "keySystemDestroyMediaKeysError", n.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR = "keySystemDestroyCloseSessionError", n.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR = "keySystemDestroyRemoveSessionError", n.MANIFEST_LOAD_ERROR = "manifestLoadError", n.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", n.MANIFEST_PARSING_ERROR = "manifestParsingError", n.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", n.LEVEL_EMPTY_ERROR = "levelEmptyError", n.LEVEL_LOAD_ERROR = "levelLoadError", n.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", n.LEVEL_PARSING_ERROR = "levelParsingError", n.LEVEL_SWITCH_ERROR = "levelSwitchError", n.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", n.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", n.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError", n.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut", n.FRAG_LOAD_ERROR = "fragLoadError", n.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", n.FRAG_DECRYPT_ERROR = "fragDecryptError", n.FRAG_PARSING_ERROR = "fragParsingError", n.FRAG_GAP = "fragGap", n.REMUX_ALLOC_ERROR = "remuxAllocError", n.KEY_LOAD_ERROR = "keyLoadError", n.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", n.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", n.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError", n.BUFFER_APPEND_ERROR = "bufferAppendError", n.BUFFER_APPENDING_ERROR = "bufferAppendingError", n.BUFFER_STALLED_ERROR = "bufferStalledError", n.BUFFER_FULL_ERROR = "bufferFullError", n.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", n.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", n.ASSET_LIST_LOAD_ERROR = "assetListLoadError", n.ASSET_LIST_LOAD_TIMEOUT = "assetListLoadTimeout", n.ASSET_LIST_PARSING_ERROR = "assetListParsingError", n.INTERSTITIAL_ASSET_ITEM_ERROR = "interstitialAssetItemError", n.INTERNAL_EXCEPTION = "internalException", n.INTERNAL_ABORTED = "aborted", n.ATTACH_MEDIA_ERROR = "attachMediaError", n.UNKNOWN = "unknown", n;
})({}), x = /* @__PURE__ */ (function(n) {
  return n.MEDIA_ATTACHING = "hlsMediaAttaching", n.MEDIA_ATTACHED = "hlsMediaAttached", n.MEDIA_DETACHING = "hlsMediaDetaching", n.MEDIA_DETACHED = "hlsMediaDetached", n.MEDIA_ENDED = "hlsMediaEnded", n.STALL_RESOLVED = "hlsStallResolved", n.BUFFER_RESET = "hlsBufferReset", n.BUFFER_CODECS = "hlsBufferCodecs", n.BUFFER_CREATED = "hlsBufferCreated", n.BUFFER_APPENDING = "hlsBufferAppending", n.BUFFER_APPENDED = "hlsBufferAppended", n.BUFFER_EOS = "hlsBufferEos", n.BUFFERED_TO_END = "hlsBufferedToEnd", n.BUFFER_FLUSHING = "hlsBufferFlushing", n.BUFFER_FLUSHED = "hlsBufferFlushed", n.MANIFEST_LOADING = "hlsManifestLoading", n.MANIFEST_LOADED = "hlsManifestLoaded", n.MANIFEST_PARSED = "hlsManifestParsed", n.LEVEL_SWITCHING = "hlsLevelSwitching", n.LEVEL_SWITCHED = "hlsLevelSwitched", n.LEVEL_LOADING = "hlsLevelLoading", n.LEVEL_LOADED = "hlsLevelLoaded", n.LEVEL_UPDATED = "hlsLevelUpdated", n.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", n.LEVELS_UPDATED = "hlsLevelsUpdated", n.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", n.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", n.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", n.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", n.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", n.AUDIO_TRACK_UPDATED = "hlsAudioTrackUpdated", n.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", n.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", n.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", n.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", n.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", n.SUBTITLE_TRACK_UPDATED = "hlsSubtitleTrackUpdated", n.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", n.CUES_PARSED = "hlsCuesParsed", n.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", n.INIT_PTS_FOUND = "hlsInitPtsFound", n.FRAG_LOADING = "hlsFragLoading", n.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", n.FRAG_LOADED = "hlsFragLoaded", n.FRAG_DECRYPTED = "hlsFragDecrypted", n.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", n.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", n.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", n.FRAG_PARSED = "hlsFragParsed", n.FRAG_BUFFERED = "hlsFragBuffered", n.FRAG_CHANGED = "hlsFragChanged", n.FPS_DROP = "hlsFpsDrop", n.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", n.MAX_AUTO_LEVEL_UPDATED = "hlsMaxAutoLevelUpdated", n.ERROR = "hlsError", n.DESTROYING = "hlsDestroying", n.KEY_LOADING = "hlsKeyLoading", n.KEY_LOADED = "hlsKeyLoaded", n.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", n.BACK_BUFFER_REACHED = "hlsBackBufferReached", n.STEERING_MANIFEST_LOADED = "hlsSteeringManifestLoaded", n.ASSET_LIST_LOADING = "hlsAssetListLoading", n.ASSET_LIST_LOADED = "hlsAssetListLoaded", n.INTERSTITIALS_UPDATED = "hlsInterstitialsUpdated", n.INTERSTITIALS_BUFFERED_TO_BOUNDARY = "hlsInterstitialsBufferedToBoundary", n.INTERSTITIAL_ASSET_PLAYER_CREATED = "hlsInterstitialAssetPlayerCreated", n.INTERSTITIAL_STARTED = "hlsInterstitialStarted", n.INTERSTITIAL_ASSET_STARTED = "hlsInterstitialAssetStarted", n.INTERSTITIAL_ASSET_ENDED = "hlsInterstitialAssetEnded", n.INTERSTITIAL_ASSET_ERROR = "hlsInterstitialAssetError", n.INTERSTITIAL_ENDED = "hlsInterstitialEnded", n.INTERSTITIALS_PRIMARY_RESUMED = "hlsInterstitialsPrimaryResumed", n.PLAYOUT_LIMIT_REACHED = "hlsPlayoutLimitReached", n.EVENT_CUE_ENTER = "hlsEventCueEnter", n;
})({});
var Ee = {
  MANIFEST: "manifest",
  LEVEL: "level",
  AUDIO_TRACK: "audioTrack",
  SUBTITLE_TRACK: "subtitleTrack"
}, te = {
  MAIN: "main",
  AUDIO: "audio",
  SUBTITLE: "subtitle"
};
class Br {
  //  About half of the estimated value will be from the last |halfLife| samples by weight.
  constructor(e, t = 0, i = 0) {
    this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = e, this.alpha_ = e ? Math.exp(Math.log(0.5) / e) : 0, this.estimate_ = t, this.totalWeight_ = i;
  }
  sample(e, t) {
    const i = Math.pow(this.alpha_, e);
    this.estimate_ = t * (1 - i) + i * this.estimate_, this.totalWeight_ += e;
  }
  getTotalWeight() {
    return this.totalWeight_;
  }
  getEstimate() {
    if (this.alpha_) {
      const e = 1 - Math.pow(this.alpha_, this.totalWeight_);
      if (e)
        return this.estimate_ / e;
    }
    return this.estimate_;
  }
}
class ey {
  constructor(e, t, i, s = 100) {
    this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultTTFB_ = void 0, this.ttfb_ = void 0, this.defaultEstimate_ = i, this.minWeight_ = 1e-3, this.minDelayMs_ = 50, this.slow_ = new Br(e), this.fast_ = new Br(t), this.defaultTTFB_ = s, this.ttfb_ = new Br(e);
  }
  update(e, t) {
    const {
      slow_: i,
      fast_: s,
      ttfb_: r
    } = this;
    i.halfLife !== e && (this.slow_ = new Br(e, i.getEstimate(), i.getTotalWeight())), s.halfLife !== t && (this.fast_ = new Br(t, s.getEstimate(), s.getTotalWeight())), r.halfLife !== e && (this.ttfb_ = new Br(e, r.getEstimate(), r.getTotalWeight()));
  }
  sample(e, t) {
    e = Math.max(e, this.minDelayMs_);
    const i = 8 * t, s = e / 1e3, r = i / s;
    this.fast_.sample(s, r), this.slow_.sample(s, r);
  }
  sampleTTFB(e) {
    const t = e / 1e3, i = Math.sqrt(2) * Math.exp(-Math.pow(t, 2) / 2);
    this.ttfb_.sample(i, Math.max(e, 5));
  }
  canEstimate() {
    return this.fast_.getTotalWeight() >= this.minWeight_;
  }
  getEstimate() {
    return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_;
  }
  getEstimateTTFB() {
    return this.ttfb_.getTotalWeight() >= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_;
  }
  get defaultEstimate() {
    return this.defaultEstimate_;
  }
  destroy() {
  }
}
function ty(n, e, t) {
  return (e = sy(e)) in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function Fe() {
  return Fe = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var i in t) ({}).hasOwnProperty.call(t, i) && (n[i] = t[i]);
    }
    return n;
  }, Fe.apply(null, arguments);
}
function Vd(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(n);
    e && (i = i.filter(function(s) {
      return Object.getOwnPropertyDescriptor(n, s).enumerable;
    })), t.push.apply(t, i);
  }
  return t;
}
function Me(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Vd(Object(t), !0).forEach(function(i) {
      ty(n, i, t[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : Vd(Object(t)).forEach(function(i) {
      Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i));
    });
  }
  return n;
}
function iy(n, e) {
  if (typeof n != "object" || !n) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var i = t.call(n, e);
    if (typeof i != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function sy(n) {
  var e = iy(n, "string");
  return typeof e == "symbol" ? e : e + "";
}
class Fi {
  constructor(e, t) {
    this.trace = void 0, this.debug = void 0, this.log = void 0, this.warn = void 0, this.info = void 0, this.error = void 0;
    const i = `[${e}]:`;
    this.trace = Ms, this.debug = t.debug.bind(null, i), this.log = t.log.bind(null, i), this.warn = t.warn.bind(null, i), this.info = t.info.bind(null, i), this.error = t.error.bind(null, i);
  }
}
const Ms = function() {
}, ry = {
  trace: Ms,
  debug: Ms,
  log: Ms,
  warn: Ms,
  info: Ms,
  error: Ms
};
function Pc() {
  return Fe({}, ry);
}
function ny(n, e) {
  const t = self.console[n];
  return t ? t.bind(self.console, `${e ? "[" + e + "] " : ""}[${n}] >`) : Ms;
}
function zd(n, e, t) {
  return e[n] ? e[n].bind(e) : ny(n, t);
}
const Dc = Pc();
function ay(n, e, t) {
  const i = Pc();
  if (typeof console == "object" && n === !0 || typeof n == "object") {
    const s = [
      // Remove out from list here to hard-disable a log-level
      // 'trace',
      "debug",
      "log",
      "info",
      "warn",
      "error"
    ];
    s.forEach((r) => {
      i[r] = zd(r, n, t);
    });
    try {
      i.log(`Debug logs enabled for "${e}" in hls.js version 1.6.15`);
    } catch {
      return Pc();
    }
    s.forEach((r) => {
      Dc[r] = zd(r, n);
    });
  } else
    Fe(Dc, i);
  return i;
}
const Oe = Dc;
function Qs(n = !0) {
  return typeof self > "u" ? void 0 : (n || !self.MediaSource) && self.ManagedMediaSource || self.MediaSource || self.WebKitMediaSource;
}
function oy(n) {
  return typeof self < "u" && n === self.ManagedMediaSource;
}
function Vp(n, e) {
  const t = Object.keys(n), i = Object.keys(e), s = t.length, r = i.length;
  return !s || !r || s === r && !t.some((a) => i.indexOf(a) === -1);
}
function bi(n, e = !1) {
  if (typeof TextDecoder < "u") {
    const c = new TextDecoder("utf-8").decode(n);
    if (e) {
      const u = c.indexOf("\0");
      return u !== -1 ? c.substring(0, u) : c;
    }
    return c.replace(/\0/g, "");
  }
  const t = n.length;
  let i, s, r, a = "", o = 0;
  for (; o < t; ) {
    if (i = n[o++], i === 0 && e)
      return a;
    if (i === 0 || i === 3)
      continue;
    switch (i >> 4) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
        a += String.fromCharCode(i);
        break;
      case 12:
      case 13:
        s = n[o++], a += String.fromCharCode((i & 31) << 6 | s & 63);
        break;
      case 14:
        s = n[o++], r = n[o++], a += String.fromCharCode((i & 15) << 12 | (s & 63) << 6 | (r & 63) << 0);
        break;
    }
  }
  return a;
}
function Rt(n) {
  let e = "";
  for (let t = 0; t < n.length; t++) {
    let i = n[t].toString(16);
    i.length < 2 && (i = "0" + i), e += i;
  }
  return e;
}
function zp(n) {
  return Uint8Array.from(n.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer;
}
function ly(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var Al = { exports: {} }, Wd;
function cy() {
  return Wd || (Wd = 1, (function(n, e) {
    (function(t) {
      var i = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, s = /^(?=([^\/?#]*))\1([^]*)$/, r = /(?:\/|^)\.(?=\/)/g, a = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, o = {
        // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
        // E.g
        // With opts.alwaysNormalize = false (default, spec compliant)
        // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
        // With opts.alwaysNormalize = true (not spec compliant)
        // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
        buildAbsoluteURL: function(l, c, u) {
          if (u = u || {}, l = l.trim(), c = c.trim(), !c) {
            if (!u.alwaysNormalize)
              return l;
            var d = o.parseURL(l);
            if (!d)
              throw new Error("Error trying to parse base URL.");
            return d.path = o.normalizePath(
              d.path
            ), o.buildURLFromParts(d);
          }
          var f = o.parseURL(c);
          if (!f)
            throw new Error("Error trying to parse relative URL.");
          if (f.scheme)
            return u.alwaysNormalize ? (f.path = o.normalizePath(f.path), o.buildURLFromParts(f)) : c;
          var p = o.parseURL(l);
          if (!p)
            throw new Error("Error trying to parse base URL.");
          if (!p.netLoc && p.path && p.path[0] !== "/") {
            var h = s.exec(p.path);
            p.netLoc = h[1], p.path = h[2];
          }
          p.netLoc && !p.path && (p.path = "/");
          var g = {
            // 2c) Otherwise, the embedded URL inherits the scheme of
            // the base URL.
            scheme: p.scheme,
            netLoc: f.netLoc,
            path: null,
            params: f.params,
            query: f.query,
            fragment: f.fragment
          };
          if (!f.netLoc && (g.netLoc = p.netLoc, f.path[0] !== "/"))
            if (!f.path)
              g.path = p.path, f.params || (g.params = p.params, f.query || (g.query = p.query));
            else {
              var m = p.path, v = m.substring(0, m.lastIndexOf("/") + 1) + f.path;
              g.path = o.normalizePath(v);
            }
          return g.path === null && (g.path = u.alwaysNormalize ? o.normalizePath(f.path) : f.path), o.buildURLFromParts(g);
        },
        parseURL: function(l) {
          var c = i.exec(l);
          return c ? {
            scheme: c[1] || "",
            netLoc: c[2] || "",
            path: c[3] || "",
            params: c[4] || "",
            query: c[5] || "",
            fragment: c[6] || ""
          } : null;
        },
        normalizePath: function(l) {
          for (l = l.split("").reverse().join("").replace(r, ""); l.length !== (l = l.replace(a, "")).length; )
            ;
          return l.split("").reverse().join("");
        },
        buildURLFromParts: function(l) {
          return l.scheme + l.netLoc + l.path + l.params + l.query + l.fragment;
        }
      };
      n.exports = o;
    })();
  })(Al)), Al.exports;
}
var Cu = cy();
class Pu {
  constructor() {
    this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = {
      start: 0,
      first: 0,
      end: 0
    }, this.parsing = {
      start: 0,
      end: 0
    }, this.buffering = {
      start: 0,
      first: 0,
      end: 0
    };
  }
}
var Ue = {
  AUDIO: "audio",
  VIDEO: "video",
  AUDIOVIDEO: "audiovideo"
};
class Wp {
  constructor(e) {
    this._byteRange = null, this._url = null, this._stats = null, this._streams = null, this.base = void 0, this.relurl = void 0, typeof e == "string" && (e = {
      url: e
    }), this.base = e, dy(this, "stats");
  }
  // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array
  setByteRange(e, t) {
    const i = e.split("@", 2);
    let s;
    i.length === 1 ? s = t?.byteRangeEndOffset || 0 : s = parseInt(i[1]), this._byteRange = [s, parseInt(i[0]) + s];
  }
  get baseurl() {
    return this.base.url;
  }
  get byteRange() {
    return this._byteRange === null ? [] : this._byteRange;
  }
  get byteRangeStartOffset() {
    return this.byteRange[0];
  }
  get byteRangeEndOffset() {
    return this.byteRange[1];
  }
  get elementaryStreams() {
    return this._streams === null && (this._streams = {
      [Ue.AUDIO]: null,
      [Ue.VIDEO]: null,
      [Ue.AUDIOVIDEO]: null
    }), this._streams;
  }
  set elementaryStreams(e) {
    this._streams = e;
  }
  get hasStats() {
    return this._stats !== null;
  }
  get hasStreams() {
    return this._streams !== null;
  }
  get stats() {
    return this._stats === null && (this._stats = new Pu()), this._stats;
  }
  set stats(e) {
    this._stats = e;
  }
  get url() {
    return !this._url && this.baseurl && this.relurl && (this._url = Cu.buildAbsoluteURL(this.baseurl, this.relurl, {
      alwaysNormalize: !0
    })), this._url || "";
  }
  set url(e) {
    this._url = e;
  }
  clearElementaryStreamInfo() {
    const {
      elementaryStreams: e
    } = this;
    e[Ue.AUDIO] = null, e[Ue.VIDEO] = null, e[Ue.AUDIOVIDEO] = null;
  }
}
function ot(n) {
  return n.sn !== "initSegment";
}
class wl extends Wp {
  constructor(e, t) {
    super(t), this._decryptdata = null, this._programDateTime = null, this._ref = null, this._bitrate = void 0, this.rawProgramDateTime = null, this.tagList = [], this.duration = 0, this.sn = 0, this.levelkeys = void 0, this.type = void 0, this.loader = null, this.keyLoader = null, this.level = -1, this.cc = 0, this.startPTS = void 0, this.endPTS = void 0, this.startDTS = void 0, this.endDTS = void 0, this.start = 0, this.playlistOffset = 0, this.deltaPTS = void 0, this.maxStartPTS = void 0, this.minEndPTS = void 0, this.data = void 0, this.bitrateTest = !1, this.title = null, this.initSegment = null, this.endList = void 0, this.gap = void 0, this.urlId = 0, this.type = e;
  }
  get byteLength() {
    if (this.hasStats) {
      const e = this.stats.total;
      if (e)
        return e;
    }
    if (this.byteRange.length) {
      const e = this.byteRange[0], t = this.byteRange[1];
      if (Z(e) && Z(t))
        return t - e;
    }
    return null;
  }
  get bitrate() {
    return this.byteLength ? this.byteLength * 8 / this.duration : this._bitrate ? this._bitrate : null;
  }
  set bitrate(e) {
    this._bitrate = e;
  }
  get decryptdata() {
    var e;
    const {
      levelkeys: t
    } = this;
    if (!t || t.NONE)
      return null;
    if (t.identity)
      this._decryptdata || (this._decryptdata = t.identity.getDecryptData(this.sn));
    else if (!((e = this._decryptdata) != null && e.keyId)) {
      const i = Object.keys(t);
      if (i.length === 1) {
        const s = this._decryptdata = t[i[0]] || null;
        s && (this._decryptdata = s.getDecryptData(this.sn, t));
      }
    }
    return this._decryptdata;
  }
  get end() {
    return this.start + this.duration;
  }
  get endProgramDateTime() {
    if (this.programDateTime === null)
      return null;
    const e = Z(this.duration) ? this.duration : 0;
    return this.programDateTime + e * 1e3;
  }
  get encrypted() {
    var e;
    if ((e = this._decryptdata) != null && e.encrypted)
      return !0;
    if (this.levelkeys) {
      var t;
      const i = Object.keys(this.levelkeys), s = i.length;
      if (s > 1 || s === 1 && (t = this.levelkeys[i[0]]) != null && t.encrypted)
        return !0;
    }
    return !1;
  }
  get programDateTime() {
    return this._programDateTime === null && this.rawProgramDateTime && (this.programDateTime = Date.parse(this.rawProgramDateTime)), this._programDateTime;
  }
  set programDateTime(e) {
    if (!Z(e)) {
      this._programDateTime = this.rawProgramDateTime = null;
      return;
    }
    this._programDateTime = e;
  }
  get ref() {
    return ot(this) ? (this._ref || (this._ref = {
      base: this.base,
      start: this.start,
      duration: this.duration,
      sn: this.sn,
      programDateTime: this.programDateTime
    }), this._ref) : null;
  }
  addStart(e) {
    this.setStart(this.start + e);
  }
  setStart(e) {
    this.start = e, this._ref && (this._ref.start = e);
  }
  setDuration(e) {
    this.duration = e, this._ref && (this._ref.duration = e);
  }
  setKeyFormat(e) {
    const t = this.levelkeys;
    if (t) {
      var i;
      const s = t[e];
      s && !((i = this._decryptdata) != null && i.keyId) && (this._decryptdata = s.getDecryptData(this.sn, t));
    }
  }
  abortRequests() {
    var e, t;
    (e = this.loader) == null || e.abort(), (t = this.keyLoader) == null || t.abort();
  }
  setElementaryStreamInfo(e, t, i, s, r, a = !1) {
    const {
      elementaryStreams: o
    } = this, l = o[e];
    if (!l) {
      o[e] = {
        startPTS: t,
        endPTS: i,
        startDTS: s,
        endDTS: r,
        partial: a
      };
      return;
    }
    l.startPTS = Math.min(l.startPTS, t), l.endPTS = Math.max(l.endPTS, i), l.startDTS = Math.min(l.startDTS, s), l.endDTS = Math.max(l.endDTS, r);
  }
}
class uy extends Wp {
  constructor(e, t, i, s, r) {
    super(i), this.fragOffset = 0, this.duration = 0, this.gap = !1, this.independent = !1, this.relurl = void 0, this.fragment = void 0, this.index = void 0, this.duration = e.decimalFloatingPoint("DURATION"), this.gap = e.bool("GAP"), this.independent = e.bool("INDEPENDENT"), this.relurl = e.enumeratedString("URI"), this.fragment = t, this.index = s;
    const a = e.enumeratedString("BYTERANGE");
    a && this.setByteRange(a, r), r && (this.fragOffset = r.fragOffset + r.duration);
  }
  get start() {
    return this.fragment.start + this.fragOffset;
  }
  get end() {
    return this.start + this.duration;
  }
  get loaded() {
    const {
      elementaryStreams: e
    } = this;
    return !!(e.audio || e.video || e.audiovideo);
  }
}
function Kp(n, e) {
  const t = Object.getPrototypeOf(n);
  if (t) {
    const i = Object.getOwnPropertyDescriptor(t, e);
    return i || Kp(t, e);
  }
}
function dy(n, e) {
  const t = Kp(n, e);
  t && (t.enumerable = !0, Object.defineProperty(n, e, t));
}
const Kd = Math.pow(2, 32) - 1, fy = [].push, Yp = {
  video: 1,
  audio: 2,
  id3: 3,
  text: 4
};
function gt(n) {
  return String.fromCharCode.apply(null, n);
}
function qp(n, e) {
  const t = n[e] << 8 | n[e + 1];
  return t < 0 ? 65536 + t : t;
}
function ue(n, e) {
  const t = Xp(n, e);
  return t < 0 ? 4294967296 + t : t;
}
function Yd(n, e) {
  let t = ue(n, e);
  return t *= Math.pow(2, 32), t += ue(n, e + 4), t;
}
function Xp(n, e) {
  return n[e] << 24 | n[e + 1] << 16 | n[e + 2] << 8 | n[e + 3];
}
function hy(n) {
  const e = n.byteLength;
  for (let t = 0; t < e; ) {
    const i = ue(n, t);
    if (i > 8 && n[t + 4] === 109 && n[t + 5] === 111 && n[t + 6] === 111 && n[t + 7] === 102)
      return !0;
    t = i > 1 ? t + i : e;
  }
  return !1;
}
function ye(n, e) {
  const t = [];
  if (!e.length)
    return t;
  const i = n.byteLength;
  for (let s = 0; s < i; ) {
    const r = ue(n, s), a = gt(n.subarray(s + 4, s + 8)), o = r > 1 ? s + r : i;
    if (a === e[0])
      if (e.length === 1)
        t.push(n.subarray(s + 8, o));
      else {
        const l = ye(n.subarray(s + 8, o), e.slice(1));
        l.length && fy.apply(t, l);
      }
    s = o;
  }
  return t;
}
function py(n) {
  const e = [], t = n[0];
  let i = 8;
  const s = ue(n, i);
  i += 4;
  let r = 0, a = 0;
  t === 0 ? (r = ue(n, i), a = ue(n, i + 4), i += 8) : (r = Yd(n, i), a = Yd(n, i + 8), i += 16), i += 2;
  let o = n.length + a;
  const l = qp(n, i);
  i += 2;
  for (let c = 0; c < l; c++) {
    let u = i;
    const d = ue(n, u);
    u += 4;
    const f = d & 2147483647;
    if ((d & 2147483648) >>> 31 === 1)
      return Oe.warn("SIDX has hierarchical references (not supported)"), null;
    const h = ue(n, u);
    u += 4, e.push({
      referenceSize: f,
      subsegmentDuration: h,
      // unscaled
      info: {
        duration: h / s,
        start: o,
        end: o + f - 1
      }
    }), o += f, u += 4, i = u;
  }
  return {
    earliestPresentationTime: r,
    timescale: s,
    version: t,
    referencesCount: l,
    references: e
  };
}
function jp(n) {
  const e = [], t = ye(n, ["moov", "trak"]);
  for (let s = 0; s < t.length; s++) {
    const r = t[s], a = ye(r, ["tkhd"])[0];
    if (a) {
      let o = a[0];
      const l = ue(a, o === 0 ? 12 : 20), c = ye(r, ["mdia", "mdhd"])[0];
      if (c) {
        o = c[0];
        const u = ue(c, o === 0 ? 12 : 20), d = ye(r, ["mdia", "hdlr"])[0];
        if (d) {
          const f = gt(d.subarray(8, 12)), p = {
            soun: Ue.AUDIO,
            vide: Ue.VIDEO
          }[f], h = ye(r, ["mdia", "minf", "stbl", "stsd"])[0], g = gy(h);
          p ? (e[l] = {
            timescale: u,
            type: p,
            stsd: g
          }, e[p] = Me({
            timescale: u,
            id: l
          }, g)) : e[l] = {
            timescale: u,
            type: f,
            stsd: g
          };
        }
      }
    }
  }
  return ye(n, ["moov", "mvex", "trex"]).forEach((s) => {
    const r = ue(s, 4), a = e[r];
    a && (a.default = {
      duration: ue(s, 12),
      flags: ue(s, 20)
    });
  }), e;
}
function gy(n) {
  const e = n.subarray(8), t = e.subarray(86), i = gt(e.subarray(4, 8));
  let s = i, r;
  const a = i === "enca" || i === "encv";
  if (a) {
    const c = ye(e, [i])[0].subarray(i === "enca" ? 28 : 78);
    ye(c, ["sinf"]).forEach((d) => {
      const f = ye(d, ["schm"])[0];
      if (f) {
        const p = gt(f.subarray(4, 8));
        if (p === "cbcs" || p === "cenc") {
          const h = ye(d, ["frma"])[0];
          h && (s = gt(h));
        }
      }
    });
  }
  const o = s;
  switch (s) {
    case "avc1":
    case "avc2":
    case "avc3":
    case "avc4": {
      const l = ye(t, ["avcC"])[0];
      l && l.length > 3 && (s += "." + Ha(l[1]) + Ha(l[2]) + Ha(l[3]), r = Ga(o === "avc1" ? "dva1" : "dvav", t));
      break;
    }
    case "mp4a": {
      const l = ye(e, [i])[0], c = ye(l.subarray(28), ["esds"])[0];
      if (c && c.length > 7) {
        let u = 4;
        if (c[u++] !== 3)
          break;
        u = Ll(c, u), u += 2;
        const d = c[u++];
        if (d & 128 && (u += 2), d & 64 && (u += c[u++]), c[u++] !== 4)
          break;
        u = Ll(c, u);
        const f = c[u++];
        if (f === 64)
          s += "." + Ha(f);
        else
          break;
        if (u += 12, c[u++] !== 5)
          break;
        u = Ll(c, u);
        const p = c[u++];
        let h = (p & 248) >> 3;
        h === 31 && (h += 1 + ((p & 7) << 3) + ((c[u] & 224) >> 5)), s += "." + h;
      }
      break;
    }
    case "hvc1":
    case "hev1": {
      const l = ye(t, ["hvcC"])[0];
      if (l && l.length > 12) {
        const c = l[1], u = ["", "A", "B", "C"][c >> 6], d = c & 31, f = ue(l, 2), p = (c & 32) >> 5 ? "H" : "L", h = l[12], g = l.subarray(6, 12);
        s += "." + u + d, s += "." + my(f).toString(16).toUpperCase(), s += "." + p + h;
        let m = "";
        for (let v = g.length; v--; ) {
          const y = g[v];
          (y || m) && (m = "." + y.toString(16).toUpperCase() + m);
        }
        s += m;
      }
      r = Ga(o == "hev1" ? "dvhe" : "dvh1", t);
      break;
    }
    case "dvh1":
    case "dvhe":
    case "dvav":
    case "dva1":
    case "dav1": {
      s = Ga(s, t) || s;
      break;
    }
    case "vp09": {
      const l = ye(t, ["vpcC"])[0];
      if (l && l.length > 6) {
        const c = l[4], u = l[5], d = l[6] >> 4 & 15;
        s += "." + ji(c) + "." + ji(u) + "." + ji(d);
      }
      break;
    }
    case "av01": {
      const l = ye(t, ["av1C"])[0];
      if (l && l.length > 2) {
        const c = l[1] >>> 5, u = l[1] & 31, d = l[2] >>> 7 ? "H" : "M", f = (l[2] & 64) >> 6, p = (l[2] & 32) >> 5, h = c === 2 && f ? p ? 12 : 10 : f ? 10 : 8, g = (l[2] & 16) >> 4, m = (l[2] & 8) >> 3, v = (l[2] & 4) >> 2, y = l[2] & 3;
        s += "." + c + "." + ji(u) + d + "." + ji(h) + "." + g + "." + m + v + y + "." + ji(1) + "." + ji(1) + "." + ji(1) + "." + 0, r = Ga("dav1", t);
      }
      break;
    }
  }
  return {
    codec: s,
    encrypted: a,
    supplemental: r
  };
}
function Ga(n, e) {
  const t = ye(e, ["dvvC"]), i = t.length ? t[0] : ye(e, ["dvcC"])[0];
  if (i) {
    const s = i[2] >> 1 & 127, r = i[2] << 5 & 32 | i[3] >> 3 & 31;
    return n + "." + ji(s) + "." + ji(r);
  }
}
function my(n) {
  let e = 0;
  for (let t = 0; t < 32; t++)
    e |= (n >> t & 1) << 31 - t;
  return e >>> 0;
}
function Ll(n, e) {
  const t = e + 5;
  for (; n[e++] & 128 && e < t; )
    ;
  return e;
}
function Ha(n) {
  return ("0" + n.toString(16).toUpperCase()).slice(-2);
}
function ji(n) {
  return (n < 10 ? "0" : "") + n;
}
function vy(n, e) {
  if (!n || !e)
    return;
  const t = e.keyId;
  t && e.isCommonEncryption && Qp(n, (i, s) => {
    const r = i.subarray(8, 24);
    r.some((a) => a !== 0) || (Oe.log(`[eme] Patching keyId in 'enc${s ? "a" : "v"}>sinf>>tenc' box: ${Rt(r)} -> ${Rt(t)}`), i.set(t, 8));
  });
}
function yy(n) {
  const e = [];
  return Qp(n, (t) => e.push(t.subarray(8, 24))), e;
}
function Qp(n, e) {
  ye(n, ["moov", "trak"]).forEach((i) => {
    const s = ye(i, ["mdia", "minf", "stbl", "stsd"])[0];
    if (!s) return;
    const r = s.subarray(8);
    let a = ye(r, ["enca"]);
    const o = a.length > 0;
    o || (a = ye(r, ["encv"])), a.forEach((l) => {
      const c = o ? l.subarray(28) : l.subarray(78);
      ye(c, ["sinf"]).forEach((d) => {
        const f = Zp(d);
        f && e(f, o);
      });
    });
  });
}
function Zp(n) {
  const e = ye(n, ["schm"])[0];
  if (e) {
    const t = gt(e.subarray(4, 8));
    if (t === "cbcs" || t === "cenc") {
      const i = ye(n, ["schi", "tenc"])[0];
      if (i)
        return i;
    }
  }
}
function Ey(n, e, t) {
  const i = {}, s = ye(n, ["moof", "traf"]);
  for (let r = 0; r < s.length; r++) {
    const a = s[r], o = ye(a, ["tfhd"])[0], l = ue(o, 4), c = e[l];
    if (!c)
      continue;
    i[l] || (i[l] = {
      start: NaN,
      duration: 0,
      sampleCount: 0,
      timescale: c.timescale,
      type: c.type
    });
    const u = i[l], d = ye(a, ["tfdt"])[0];
    if (d) {
      const E = d[0];
      let T = ue(d, 4);
      E === 1 && (T === Kd ? t.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time") : (T *= Kd + 1, T += ue(d, 8))), Z(T) && (!Z(u.start) || T < u.start) && (u.start = T);
    }
    const f = c.default, p = ue(o, 0) | f?.flags;
    let h = f?.duration || 0;
    p & 8 && (p & 2 ? h = ue(o, 12) : h = ue(o, 8));
    const g = ye(a, ["trun"]);
    let m = u.start || 0, v = 0, y = h;
    for (let E = 0; E < g.length; E++) {
      const T = g[E], S = ue(T, 4), w = u.sampleCount;
      u.sampleCount += S;
      const b = T[3] & 1, L = T[3] & 4, A = T[2] & 1, _ = T[2] & 2, R = T[2] & 4, I = T[2] & 8;
      let k = 8, M = S;
      for (b && (k += 4), L && S && (!(T[k + 1] & 1) && u.keyFrameIndex === void 0 && (u.keyFrameIndex = w), k += 4, A ? (y = ue(T, k), k += 4) : y = h, _ && (k += 4), I && (k += 4), m += y, v += y, M--); M--; )
        A ? (y = ue(T, k), k += 4) : y = h, _ && (k += 4), R && (T[k + 1] & 1 || u.keyFrameIndex === void 0 && (u.keyFrameIndex = u.sampleCount - (M + 1), u.keyFrameStart = m), k += 4), I && (k += 4), m += y, v += y;
      !v && h && (v += h * S);
    }
    u.duration += v;
  }
  if (!Object.keys(i).some((r) => i[r].duration)) {
    let r = 1 / 0, a = 0;
    const o = ye(n, ["sidx"]);
    for (let l = 0; l < o.length; l++) {
      const c = py(o[l]);
      if (c != null && c.references) {
        r = Math.min(r, c.earliestPresentationTime / c.timescale);
        const u = c.references.reduce((d, f) => d + f.info.duration || 0, 0);
        a = Math.max(a, u + c.earliestPresentationTime / c.timescale);
      }
    }
    a && Z(a) && Object.keys(i).forEach((l) => {
      i[l].duration || (i[l].duration = a * i[l].timescale - i[l].start);
    });
  }
  return i;
}
function Ty(n) {
  const e = {
    valid: null,
    remainder: null
  }, t = ye(n, ["moof"]);
  if (t.length < 2)
    return e.remainder = n, e;
  const i = t[t.length - 1];
  return e.valid = n.slice(0, i.byteOffset - 8), e.remainder = n.slice(i.byteOffset - 8), e;
}
function Oi(n, e) {
  const t = new Uint8Array(n.length + e.length);
  return t.set(n), t.set(e, n.length), t;
}
function qd(n, e) {
  const t = [], i = e.samples, s = e.timescale, r = e.id;
  let a = !1;
  return ye(i, ["moof"]).map((l) => {
    const c = l.byteOffset - 8;
    ye(l, ["traf"]).map((d) => {
      const f = ye(d, ["tfdt"]).map((p) => {
        const h = p[0];
        let g = ue(p, 4);
        return h === 1 && (g *= Math.pow(2, 32), g += ue(p, 8)), g / s;
      })[0];
      return f !== void 0 && (n = f), ye(d, ["tfhd"]).map((p) => {
        const h = ue(p, 4), g = ue(p, 0) & 16777215, m = (g & 1) !== 0, v = (g & 2) !== 0, y = (g & 8) !== 0;
        let E = 0;
        const T = (g & 16) !== 0;
        let S = 0;
        const w = (g & 32) !== 0;
        let b = 8;
        h === r && (m && (b += 8), v && (b += 4), y && (E = ue(p, b), b += 4), T && (S = ue(p, b), b += 4), w && (b += 4), e.type === "video" && (a = il(e.codec)), ye(d, ["trun"]).map((L) => {
          const A = L[0], _ = ue(L, 0) & 16777215, R = (_ & 1) !== 0;
          let I = 0;
          const k = (_ & 4) !== 0, M = (_ & 256) !== 0;
          let O = 0;
          const F = (_ & 512) !== 0;
          let C = 0;
          const D = (_ & 1024) !== 0, B = (_ & 2048) !== 0;
          let P = 0;
          const K = ue(L, 4);
          let X = 8;
          R && (I = ue(L, X), X += 4), k && (X += 4);
          let W = I + c;
          for (let Y = 0; Y < K; Y++) {
            if (M ? (O = ue(L, X), X += 4) : O = E, F ? (C = ue(L, X), X += 4) : C = S, D && (X += 4), B && (A === 0 ? P = ue(L, X) : P = Xp(L, X), X += 4), e.type === Ue.VIDEO) {
              let N = 0;
              for (; N < C; ) {
                const U = ue(i, W);
                if (W += 4, Sy(a, i[W])) {
                  const V = i.subarray(W, W + U);
                  Du(V, a ? 2 : 1, n + P / s, t);
                }
                W += U, N += U + 4;
              }
            }
            n += O / s;
          }
        }));
      });
    });
  }), t;
}
function il(n) {
  if (!n)
    return !1;
  const e = n.substring(0, 4);
  return e === "hvc1" || e === "hev1" || // Dolby Vision
  e === "dvh1" || e === "dvhe";
}
function Sy(n, e) {
  if (n) {
    const t = e >> 1 & 63;
    return t === 39 || t === 40;
  } else
    return (e & 31) === 6;
}
function Du(n, e, t, i) {
  const s = Jp(n);
  let r = 0;
  r += e;
  let a = 0, o = 0, l = 0;
  for (; r < s.length; ) {
    a = 0;
    do {
      if (r >= s.length)
        break;
      l = s[r++], a += l;
    } while (l === 255);
    o = 0;
    do {
      if (r >= s.length)
        break;
      l = s[r++], o += l;
    } while (l === 255);
    const c = s.length - r;
    let u = r;
    if (o < c)
      r += o;
    else if (o > c) {
      Oe.error(`Malformed SEI payload. ${o} is too small, only ${c} bytes left to parse.`);
      break;
    }
    if (a === 4) {
      if (s[u++] === 181) {
        const f = qp(s, u);
        if (u += 2, f === 49) {
          const p = ue(s, u);
          if (u += 4, p === 1195456820) {
            const h = s[u++];
            if (h === 3) {
              const g = s[u++], m = 31 & g, v = 64 & g, y = v ? 2 + m * 3 : 0, E = new Uint8Array(y);
              if (v) {
                E[0] = g;
                for (let T = 1; T < y; T++)
                  E[T] = s[u++];
              }
              i.push({
                type: h,
                payloadType: a,
                pts: t,
                bytes: E
              });
            }
          }
        }
      }
    } else if (a === 5 && o > 16) {
      const d = [];
      for (let h = 0; h < 16; h++) {
        const g = s[u++].toString(16);
        d.push(g.length == 1 ? "0" + g : g), (h === 3 || h === 5 || h === 7 || h === 9) && d.push("-");
      }
      const f = o - 16, p = new Uint8Array(f);
      for (let h = 0; h < f; h++)
        p[h] = s[u++];
      i.push({
        payloadType: a,
        pts: t,
        uuid: d.join(""),
        userData: bi(p),
        userDataBytes: p
      });
    }
  }
}
function Jp(n) {
  const e = n.byteLength, t = [];
  let i = 1;
  for (; i < e - 2; )
    n[i] === 0 && n[i + 1] === 0 && n[i + 2] === 3 ? (t.push(i + 2), i += 2) : i++;
  if (t.length === 0)
    return n;
  const s = e - t.length, r = new Uint8Array(s);
  let a = 0;
  for (i = 0; i < s; a++, i++)
    a === t[0] && (a++, t.shift()), r[i] = n[a];
  return r;
}
function xy(n) {
  const e = n[0];
  let t = "", i = "", s = 0, r = 0, a = 0, o = 0, l = 0, c = 0;
  if (e === 0) {
    for (; gt(n.subarray(c, c + 1)) !== "\0"; )
      t += gt(n.subarray(c, c + 1)), c += 1;
    for (t += gt(n.subarray(c, c + 1)), c += 1; gt(n.subarray(c, c + 1)) !== "\0"; )
      i += gt(n.subarray(c, c + 1)), c += 1;
    i += gt(n.subarray(c, c + 1)), c += 1, s = ue(n, 12), r = ue(n, 16), o = ue(n, 20), l = ue(n, 24), c = 28;
  } else if (e === 1) {
    c += 4, s = ue(n, c), c += 4;
    const d = ue(n, c);
    c += 4;
    const f = ue(n, c);
    for (c += 4, a = 2 ** 32 * d + f, Zv(a) || (a = Number.MAX_SAFE_INTEGER, Oe.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")), o = ue(n, c), c += 4, l = ue(n, c), c += 4; gt(n.subarray(c, c + 1)) !== "\0"; )
      t += gt(n.subarray(c, c + 1)), c += 1;
    for (t += gt(n.subarray(c, c + 1)), c += 1; gt(n.subarray(c, c + 1)) !== "\0"; )
      i += gt(n.subarray(c, c + 1)), c += 1;
    i += gt(n.subarray(c, c + 1)), c += 1;
  }
  const u = n.subarray(c, n.byteLength);
  return {
    schemeIdUri: t,
    value: i,
    timeScale: s,
    presentationTime: a,
    presentationTimeDelta: r,
    eventDuration: o,
    id: l,
    payload: u
  };
}
function by(n, ...e) {
  const t = e.length;
  let i = 8, s = t;
  for (; s--; )
    i += e[s].byteLength;
  const r = new Uint8Array(i);
  for (r[0] = i >> 24 & 255, r[1] = i >> 16 & 255, r[2] = i >> 8 & 255, r[3] = i & 255, r.set(n, 4), s = 0, i = 8; s < t; s++)
    r.set(e[s], i), i += e[s].byteLength;
  return r;
}
function _y(n, e, t) {
  if (n.byteLength !== 16)
    throw new RangeError("Invalid system id");
  let i, s;
  i = 0, s = new Uint8Array();
  let r;
  i > 0 ? (r = new Uint8Array(4), e.length > 0 && new DataView(r.buffer).setUint32(0, e.length, !1)) : r = new Uint8Array();
  const a = new Uint8Array(4);
  return t.byteLength > 0 && new DataView(a.buffer).setUint32(0, t.byteLength, !1), by(
    [112, 115, 115, 104],
    new Uint8Array([
      i,
      0,
      0,
      0
      // Flags
    ]),
    n,
    // 16 bytes
    r,
    s,
    a,
    t
  );
}
function Ay(n) {
  const e = [];
  if (n instanceof ArrayBuffer) {
    const t = n.byteLength;
    let i = 0;
    for (; i + 32 < t; ) {
      const s = new DataView(n, i), r = wy(s);
      e.push(r), i += r.size;
    }
  }
  return e;
}
function wy(n) {
  const e = n.getUint32(0), t = n.byteOffset, i = n.byteLength;
  if (i < e)
    return {
      offset: t,
      size: i
    };
  if (n.getUint32(4) !== 1886614376)
    return {
      offset: t,
      size: e
    };
  const r = n.getUint32(8) >>> 24;
  if (r !== 0 && r !== 1)
    return {
      offset: t,
      size: e
    };
  const a = n.buffer, o = Rt(new Uint8Array(a, t + 12, 16));
  let l = null, c = null, u = 0;
  if (r === 0)
    u = 28;
  else {
    const f = n.getUint32(28);
    if (!f || i < 32 + f * 16)
      return {
        offset: t,
        size: e
      };
    l = [];
    for (let p = 0; p < f; p++)
      l.push(new Uint8Array(a, t + 32 + p * 16, 16));
    u = 32 + f * 16;
  }
  if (!u)
    return {
      offset: t,
      size: e
    };
  const d = n.getUint32(u);
  return e - 32 < d ? {
    offset: t,
    size: e
  } : (c = new Uint8Array(a, t + u + 4, d), {
    version: r,
    systemId: o,
    kids: l,
    data: c,
    offset: t,
    size: e
  });
}
const eg = () => /\(Windows.+Firefox\//i.test(navigator.userAgent), mn = {
  audio: {
    a3ds: 1,
    "ac-3": 0.95,
    "ac-4": 1,
    alac: 0.9,
    alaw: 1,
    dra1: 1,
    "dts+": 1,
    "dts-": 1,
    dtsc: 1,
    dtse: 1,
    dtsh: 1,
    "ec-3": 0.9,
    enca: 1,
    fLaC: 0.9,
    // MP4-RA listed codec entry for FLAC
    flac: 0.9,
    // legacy browser codec name for FLAC
    FLAC: 0.9,
    // some manifests may list "FLAC" with Apple's tools
    g719: 1,
    g726: 1,
    m4ae: 1,
    mha1: 1,
    mha2: 1,
    mhm1: 1,
    mhm2: 1,
    mlpa: 1,
    mp4a: 1,
    "raw ": 1,
    Opus: 1,
    opus: 1,
    // browsers expect this to be lowercase despite MP4RA says 'Opus'
    samr: 1,
    sawb: 1,
    sawp: 1,
    sevc: 1,
    sqcp: 1,
    ssmv: 1,
    twos: 1,
    ulaw: 1
  },
  video: {
    avc1: 1,
    avc2: 1,
    avc3: 1,
    avc4: 1,
    avcp: 1,
    av01: 0.8,
    dav1: 0.8,
    drac: 1,
    dva1: 1,
    dvav: 1,
    dvh1: 0.7,
    dvhe: 0.7,
    encv: 1,
    hev1: 0.75,
    hvc1: 0.75,
    mjp2: 1,
    mp4v: 1,
    mvc1: 1,
    mvc2: 1,
    mvc3: 1,
    mvc4: 1,
    resv: 1,
    rv60: 1,
    s263: 1,
    svc1: 1,
    svc2: 1,
    "vc-1": 1,
    vp08: 1,
    vp09: 0.9
  },
  text: {
    stpp: 1,
    wvtt: 1
  }
};
function ku(n, e) {
  const t = mn[e];
  return !!t && !!t[n.slice(0, 4)];
}
function ha(n, e, t = !0) {
  return !n.split(",").some((i) => !Mu(i, e, t));
}
function Mu(n, e, t = !0) {
  var i;
  const s = Qs(t);
  return (i = s?.isTypeSupported(pa(n, e))) != null ? i : !1;
}
function pa(n, e) {
  return `${e}/mp4;codecs=${n}`;
}
function Xd(n) {
  if (n) {
    const e = n.substring(0, 4);
    return mn.video[e];
  }
  return 2;
}
function Fo(n) {
  const e = eg();
  return n.split(",").reduce((t, i) => {
    const r = e && il(i) ? 9 : mn.video[i];
    return r ? (r * 2 + t) / (t ? 3 : 2) : (mn.audio[i] + t) / (t ? 2 : 1);
  }, 0);
}
const Il = {};
function Ly(n, e = !0) {
  if (Il[n])
    return Il[n];
  const t = {
    // Idealy fLaC and Opus would be first (spec-compliant) but
    // some browsers will report that fLaC is supported then fail.
    // see: https://bugs.chromium.org/p/chromium/issues/detail?id=1422728
    flac: ["flac", "fLaC", "FLAC"],
    opus: ["opus", "Opus"],
    // Replace audio codec info if browser does not support mp4a.40.34,
    // and demuxer can fallback to 'audio/mpeg' or 'audio/mp4;codecs="mp3"'
    "mp4a.40.34": ["mp3"]
  }[n];
  for (let s = 0; s < t.length; s++) {
    var i;
    if (Mu(t[s], "audio", e))
      return Il[n] = t[s], t[s];
    if (t[s] === "mp3" && (i = Qs(e)) != null && i.isTypeSupported("audio/mpeg"))
      return "";
  }
  return n;
}
const Iy = /flac|opus|mp4a\.40\.34/i;
function No(n, e = !0) {
  return n.replace(Iy, (t) => Ly(t.toLowerCase(), e));
}
function Ry(n, e) {
  const t = [];
  if (n) {
    const i = n.split(",");
    for (let s = 0; s < i.length; s++)
      ku(i[s], "video") || t.push(i[s]);
  }
  return e && t.push(e), t.join(",");
}
function ho(n, e) {
  if (n && (n.length > 4 || ["ac-3", "ec-3", "alac", "fLaC", "Opus"].indexOf(n) !== -1) && (jd(n, "audio") || jd(n, "video")))
    return n;
  if (e) {
    const t = e.split(",");
    if (t.length > 1) {
      if (n) {
        for (let i = t.length; i--; )
          if (t[i].substring(0, 4) === n.substring(0, 4))
            return t[i];
      }
      return t[0];
    }
  }
  return e || n;
}
function jd(n, e) {
  return ku(n, e) && Mu(n, e);
}
function Cy(n) {
  const e = n.split(",");
  for (let t = 0; t < e.length; t++) {
    const i = e[t].split(".");
    i.length > 2 && i[0] === "avc1" && (e[t] = `avc1.${parseInt(i[1]).toString(16)}${("000" + parseInt(i[2]).toString(16)).slice(-4)}`);
  }
  return e.join(",");
}
function Py(n) {
  if (n.startsWith("av01.")) {
    const e = n.split("."), t = ["0", "111", "01", "01", "01", "0"];
    for (let i = e.length; i > 4 && i < 10; i++)
      e[i] = t[i - 4];
    return e.join(".");
  }
  return n;
}
function Qd(n) {
  const e = Qs(n) || {
    isTypeSupported: () => !1
  };
  return {
    mpeg: e.isTypeSupported("audio/mpeg"),
    mp3: e.isTypeSupported('audio/mp4; codecs="mp3"'),
    ac3: e.isTypeSupported('audio/mp4; codecs="ac-3"')
  };
}
function kc(n) {
  return n.replace(/^.+codecs=["']?([^"']+).*$/, "$1");
}
const Dy = {
  supported: !0,
  powerEfficient: !0,
  smooth: !0
  // keySystemAccess: null,
}, ky = {
  supported: !1,
  smooth: !1,
  powerEfficient: !1
  // keySystemAccess: null,
}, tg = {
  supported: !0,
  configurations: [],
  decodingInfoResults: [Dy]
};
function ig(n, e) {
  return {
    supported: !1,
    configurations: e,
    decodingInfoResults: [ky],
    error: n
  };
}
function My(n, e, t, i, s, r) {
  const a = n.videoCodec, o = n.audioCodec ? n.audioGroups : null, l = r?.audioCodec, c = r?.channels, u = c ? parseInt(c) : l ? 1 / 0 : 2;
  let d = null;
  if (o != null && o.length)
    try {
      o.length === 1 && o[0] ? d = e.groups[o[0]].channels : d = o.reduce((f, p) => {
        if (p) {
          const h = e.groups[p];
          if (!h)
            throw new Error(`Audio track group ${p} not found`);
          Object.keys(h.channels).forEach((g) => {
            f[g] = (f[g] || 0) + h.channels[g];
          });
        }
        return f;
      }, {
        2: 0
      });
    } catch {
      return !0;
    }
  return a !== void 0 && // Force media capabilities check for HEVC to avoid failure on Windows
  (a.split(",").some((f) => il(f)) || n.width > 1920 && n.height > 1088 || n.height > 1920 && n.width > 1088 || n.frameRate > Math.max(i, 30) || n.videoRange !== "SDR" && n.videoRange !== t || n.bitrate > Math.max(s, 8e6)) || !!d && Z(u) && Object.keys(d).some((f) => parseInt(f) > u);
}
function sg(n, e, t, i = {}) {
  const s = n.videoCodec;
  if (!s && !n.audioCodec || !t)
    return Promise.resolve(tg);
  const r = [], a = Oy(n), o = a.length, l = Fy(n, e, o > 0), c = l.length;
  for (let u = o || 1 * c || 1; u--; ) {
    const d = {
      type: "media-source"
    };
    if (o && (d.video = a[u % o]), c) {
      d.audio = l[u % c];
      const f = d.audio.bitrate;
      d.video && f && (d.video.bitrate -= f);
    }
    r.push(d);
  }
  if (s) {
    const u = navigator.userAgent;
    if (s.split(",").some((d) => il(d)) && eg())
      return Promise.resolve(ig(new Error(`Overriding Windows Firefox HEVC MediaCapabilities result based on user-agent string: (${u})`), r));
  }
  return Promise.all(r.map((u) => {
    const d = $y(u);
    return i[d] || (i[d] = t.decodingInfo(u));
  })).then((u) => ({
    supported: !u.some((d) => !d.supported),
    configurations: r,
    decodingInfoResults: u
  })).catch((u) => ({
    supported: !1,
    configurations: r,
    decodingInfoResults: [],
    error: u
  }));
}
function Oy(n) {
  var e;
  const t = (e = n.videoCodec) == null ? void 0 : e.split(","), i = rg(n), s = n.width || 640, r = n.height || 480, a = n.frameRate || 30, o = n.videoRange.toLowerCase();
  return t ? t.map((l) => {
    const c = {
      contentType: pa(Py(l), "video"),
      width: s,
      height: r,
      bitrate: i,
      framerate: a
    };
    return o !== "sdr" && (c.transferFunction = o), c;
  }) : [];
}
function Fy(n, e, t) {
  var i;
  const s = (i = n.audioCodec) == null ? void 0 : i.split(","), r = rg(n);
  return s && n.audioGroups ? n.audioGroups.reduce((a, o) => {
    var l;
    const c = o ? (l = e.groups[o]) == null ? void 0 : l.tracks : null;
    return c ? c.reduce((u, d) => {
      if (d.groupId === o) {
        const f = parseFloat(d.channels || "");
        s.forEach((p) => {
          const h = {
            contentType: pa(p, "audio"),
            bitrate: t ? Ny(p, r) : r
          };
          f && (h.channels = "" + f), u.push(h);
        });
      }
      return u;
    }, a) : a;
  }, []) : [];
}
function Ny(n, e) {
  if (e <= 1)
    return 1;
  let t = 128e3;
  return n === "ec-3" ? t = 768e3 : n === "ac-3" && (t = 64e4), Math.min(e / 2, t);
}
function rg(n) {
  return Math.ceil(Math.max(n.bitrate * 0.9, n.averageBitrate) / 1e3) * 1e3 || 1;
}
function $y(n) {
  let e = "";
  const {
    audio: t,
    video: i
  } = n;
  if (i) {
    const s = kc(i.contentType);
    e += `${s}_r${i.height}x${i.width}f${Math.ceil(i.framerate)}${i.transferFunction || "sd"}_${Math.ceil(i.bitrate / 1e5)}`;
  }
  if (t) {
    const s = kc(t.contentType);
    e += `${i ? "_" : ""}${s}_c${t.channels}`;
  }
  return e;
}
const Mc = ["NONE", "TYPE-0", "TYPE-1", null];
function By(n) {
  return Mc.indexOf(n) > -1;
}
const $o = ["SDR", "PQ", "HLG"];
function Uy(n) {
  return !!n && $o.indexOf(n) > -1;
}
var po = {
  No: "",
  Yes: "YES",
  v2: "v2"
};
function Zd(n) {
  const {
    canSkipUntil: e,
    canSkipDateRanges: t,
    age: i
  } = n, s = i < e / 2;
  return e && s ? t ? po.v2 : po.Yes : po.No;
}
class Jd {
  constructor(e, t, i) {
    this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = e, this.part = t, this.skip = i;
  }
  addDirectives(e) {
    const t = new self.URL(e);
    return this.msn !== void 0 && t.searchParams.set("_HLS_msn", this.msn.toString()), this.part !== void 0 && t.searchParams.set("_HLS_part", this.part.toString()), this.skip && t.searchParams.set("_HLS_skip", this.skip), t.href;
  }
}
class ga {
  constructor(e) {
    if (this._attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.url = void 0, this.frameRate = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.supplemental = void 0, this.videoCodec = void 0, this.width = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.supportedPromise = void 0, this.supportedResult = void 0, this._avgBitrate = 0, this._audioGroups = void 0, this._subtitleGroups = void 0, this._urlId = 0, this.url = [e.url], this._attrs = [e.attrs], this.bitrate = e.bitrate, e.details && (this.details = e.details), this.id = e.id || 0, this.name = e.name, this.width = e.width || 0, this.height = e.height || 0, this.frameRate = e.attrs.optionalFloat("FRAME-RATE", 0), this._avgBitrate = e.attrs.decimalInteger("AVERAGE-BANDWIDTH"), this.audioCodec = e.audioCodec, this.videoCodec = e.videoCodec, this.codecSet = [e.videoCodec, e.audioCodec].filter((i) => !!i).map((i) => i.substring(0, 4)).join(","), "supplemental" in e) {
      var t;
      this.supplemental = e.supplemental;
      const i = (t = e.supplemental) == null ? void 0 : t.videoCodec;
      i && i !== e.videoCodec && (this.codecSet += `,${i.substring(0, 4)}`);
    }
    this.addGroupId("audio", e.attrs.AUDIO), this.addGroupId("text", e.attrs.SUBTITLES);
  }
  get maxBitrate() {
    return Math.max(this.realBitrate, this.bitrate);
  }
  get averageBitrate() {
    return this._avgBitrate || this.realBitrate || this.bitrate;
  }
  get attrs() {
    return this._attrs[0];
  }
  get codecs() {
    return this.attrs.CODECS || "";
  }
  get pathwayId() {
    return this.attrs["PATHWAY-ID"] || ".";
  }
  get videoRange() {
    return this.attrs["VIDEO-RANGE"] || "SDR";
  }
  get score() {
    return this.attrs.optionalFloat("SCORE", 0);
  }
  get uri() {
    return this.url[0] || "";
  }
  hasAudioGroup(e) {
    return ef(this._audioGroups, e);
  }
  hasSubtitleGroup(e) {
    return ef(this._subtitleGroups, e);
  }
  get audioGroups() {
    return this._audioGroups;
  }
  get subtitleGroups() {
    return this._subtitleGroups;
  }
  addGroupId(e, t) {
    if (t) {
      if (e === "audio") {
        let i = this._audioGroups;
        i || (i = this._audioGroups = []), i.indexOf(t) === -1 && i.push(t);
      } else if (e === "text") {
        let i = this._subtitleGroups;
        i || (i = this._subtitleGroups = []), i.indexOf(t) === -1 && i.push(t);
      }
    }
  }
  // Deprecated methods (retained for backwards compatibility)
  get urlId() {
    return 0;
  }
  set urlId(e) {
  }
  get audioGroupIds() {
    return this.audioGroups ? [this.audioGroupId] : void 0;
  }
  get textGroupIds() {
    return this.subtitleGroups ? [this.textGroupId] : void 0;
  }
  get audioGroupId() {
    var e;
    return (e = this.audioGroups) == null ? void 0 : e[0];
  }
  get textGroupId() {
    var e;
    return (e = this.subtitleGroups) == null ? void 0 : e[0];
  }
  addFallback() {
  }
}
function ef(n, e) {
  return !e || !n ? !1 : n.indexOf(e) !== -1;
}
function Gy() {
  if (typeof matchMedia == "function") {
    const n = matchMedia("(dynamic-range: high)"), e = matchMedia("bad query");
    if (n.media !== e.media)
      return n.matches === !0;
  }
  return !1;
}
function Hy(n, e) {
  let t = !1, i = [];
  if (n && (t = n !== "SDR", i = [n]), e) {
    i = e.allowedVideoRanges || $o.slice(0);
    const s = i.join("") !== "SDR" && !e.videoCodec;
    t = e.preferHDR !== void 0 ? e.preferHDR : s && Gy(), t || (i = ["SDR"]);
  }
  return {
    preferHDR: t,
    allowedVideoRanges: i
  };
}
const Vy = (n) => {
  const e = /* @__PURE__ */ new WeakSet();
  return (t, i) => {
    if (n && (i = n(t, i)), typeof i == "object" && i !== null) {
      if (e.has(i))
        return;
      e.add(i);
    }
    return i;
  };
}, Ge = (n, e) => JSON.stringify(n, Vy(e));
function zy(n, e, t, i, s) {
  const r = Object.keys(n), a = i?.channels, o = i?.audioCodec, l = s?.videoCodec, c = a && parseInt(a) === 2;
  let u = !1, d = !1, f = 1 / 0, p = 1 / 0, h = 1 / 0, g = 1 / 0, m = 0, v = [];
  const {
    preferHDR: y,
    allowedVideoRanges: E
  } = Hy(e, s);
  for (let L = r.length; L--; ) {
    const A = n[r[L]];
    u || (u = A.channels[2] > 0), f = Math.min(f, A.minHeight), p = Math.min(p, A.minFramerate), h = Math.min(h, A.minBitrate), E.filter((R) => A.videoRanges[R] > 0).length > 0 && (d = !0);
  }
  f = Z(f) ? f : 0, p = Z(p) ? p : 0;
  const T = Math.max(1080, f), S = Math.max(30, p);
  h = Z(h) ? h : t, t = Math.max(h, t), d || (e = void 0);
  const w = r.length > 1;
  return {
    codecSet: r.reduce((L, A) => {
      const _ = n[A];
      if (A === L)
        return L;
      if (v = d ? E.filter((R) => _.videoRanges[R] > 0) : [], w) {
        if (_.minBitrate > t)
          return qi(A, `min bitrate of ${_.minBitrate} > current estimate of ${t}`), L;
        if (!_.hasDefaultAudio)
          return qi(A, "no renditions with default or auto-select sound found"), L;
        if (o && A.indexOf(o.substring(0, 4)) % 5 !== 0)
          return qi(A, `audio codec preference "${o}" not found`), L;
        if (a && !c) {
          if (!_.channels[a])
            return qi(A, `no renditions with ${a} channel sound found (channels options: ${Object.keys(_.channels)})`), L;
        } else if ((!o || c) && u && _.channels[2] === 0)
          return qi(A, "no renditions with stereo sound found"), L;
        if (_.minHeight > T)
          return qi(A, `min resolution of ${_.minHeight} > maximum of ${T}`), L;
        if (_.minFramerate > S)
          return qi(A, `min framerate of ${_.minFramerate} > maximum of ${S}`), L;
        if (!v.some((R) => _.videoRanges[R] > 0))
          return qi(A, `no variants with VIDEO-RANGE of ${Ge(v)} found`), L;
        if (l && A.indexOf(l.substring(0, 4)) % 5 !== 0)
          return qi(A, `video codec preference "${l}" not found`), L;
        if (_.maxScore < m)
          return qi(A, `max score of ${_.maxScore} < selected max of ${m}`), L;
      }
      return L && (Fo(A) >= Fo(L) || _.fragmentError > n[L].fragmentError) ? L : (g = _.minIndex, m = _.maxScore, A);
    }, void 0),
    videoRanges: v,
    preferHDR: y,
    minFramerate: p,
    minBitrate: h,
    minIndex: g
  };
}
function qi(n, e) {
  Oe.log(`[abr] start candidates with "${n}" ignored because ${e}`);
}
function ng(n) {
  return n.reduce((e, t) => {
    let i = e.groups[t.groupId];
    i || (i = e.groups[t.groupId] = {
      tracks: [],
      channels: {
        2: 0
      },
      hasDefault: !1,
      hasAutoSelect: !1
    }), i.tracks.push(t);
    const s = t.channels || "2";
    return i.channels[s] = (i.channels[s] || 0) + 1, i.hasDefault = i.hasDefault || t.default, i.hasAutoSelect = i.hasAutoSelect || t.autoselect, i.hasDefault && (e.hasDefaultAudio = !0), i.hasAutoSelect && (e.hasAutoSelectAudio = !0), e;
  }, {
    hasDefaultAudio: !1,
    hasAutoSelectAudio: !1,
    groups: {}
  });
}
function Wy(n, e, t, i) {
  return n.slice(t, i + 1).reduce((s, r, a) => {
    if (!r.codecSet)
      return s;
    const o = r.audioGroups;
    let l = s[r.codecSet];
    l || (s[r.codecSet] = l = {
      minBitrate: 1 / 0,
      minHeight: 1 / 0,
      minFramerate: 1 / 0,
      minIndex: a,
      maxScore: 0,
      videoRanges: {
        SDR: 0
      },
      channels: {
        2: 0
      },
      hasDefaultAudio: !o,
      fragmentError: 0
    }), l.minBitrate = Math.min(l.minBitrate, r.bitrate);
    const c = Math.min(r.height, r.width);
    return l.minHeight = Math.min(l.minHeight, c), l.minFramerate = Math.min(l.minFramerate, r.frameRate), l.minIndex = Math.min(l.minIndex, a), l.maxScore = Math.max(l.maxScore, r.score), l.fragmentError += r.fragmentError, l.videoRanges[r.videoRange] = (l.videoRanges[r.videoRange] || 0) + 1, o && o.forEach((u) => {
      if (!u)
        return;
      const d = e.groups[u];
      d && (l.hasDefaultAudio = l.hasDefaultAudio || e.hasDefaultAudio ? d.hasDefault : d.hasAutoSelect || !e.hasDefaultAudio && !e.hasAutoSelectAudio, Object.keys(d.channels).forEach((f) => {
        l.channels[f] = (l.channels[f] || 0) + d.channels[f];
      }));
    }), s;
  }, {});
}
function tf(n) {
  if (!n)
    return n;
  const {
    lang: e,
    assocLang: t,
    characteristics: i,
    channels: s,
    audioCodec: r
  } = n;
  return {
    lang: e,
    assocLang: t,
    characteristics: i,
    channels: s,
    audioCodec: r
  };
}
function rs(n, e, t) {
  if ("attrs" in n) {
    const i = e.indexOf(n);
    if (i !== -1)
      return i;
  }
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    if (br(n, s, t))
      return i;
  }
  return -1;
}
function br(n, e, t) {
  const {
    groupId: i,
    name: s,
    lang: r,
    assocLang: a,
    default: o
  } = n, l = n.forced;
  return (i === void 0 || e.groupId === i) && (s === void 0 || e.name === s) && (r === void 0 || Ky(r, e.lang)) && (r === void 0 || e.assocLang === a) && (o === void 0 || e.default === o) && (l === void 0 || e.forced === l) && (!("characteristics" in n) || Yy(n.characteristics || "", e.characteristics)) && (t === void 0 || t(n, e));
}
function Ky(n, e = "--") {
  return n.length === e.length ? n === e : n.startsWith(e) || e.startsWith(n);
}
function Yy(n, e = "") {
  const t = n.split(","), i = e.split(",");
  return t.length === i.length && !t.some((s) => i.indexOf(s) === -1);
}
function dr(n, e) {
  const {
    audioCodec: t,
    channels: i
  } = n;
  return (t === void 0 || (e.audioCodec || "").substring(0, 4) === t.substring(0, 4)) && (i === void 0 || i === (e.channels || "2"));
}
function qy(n, e, t, i, s) {
  const r = e[i], o = e.reduce((f, p, h) => {
    const g = p.uri;
    return (f[g] || (f[g] = [])).push(h), f;
  }, {})[r.uri];
  o.length > 1 && (i = Math.max.apply(Math, o));
  const l = r.videoRange, c = r.frameRate, u = r.codecSet.substring(0, 4), d = sf(e, i, (f) => {
    if (f.videoRange !== l || f.frameRate !== c || f.codecSet.substring(0, 4) !== u)
      return !1;
    const p = f.audioGroups, h = t.filter((g) => !p || p.indexOf(g.groupId) !== -1);
    return rs(n, h, s) > -1;
  });
  return d > -1 ? d : sf(e, i, (f) => {
    const p = f.audioGroups, h = t.filter((g) => !p || p.indexOf(g.groupId) !== -1);
    return rs(n, h, s) > -1;
  });
}
function sf(n, e, t) {
  for (let i = e; i > -1; i--)
    if (t(n[i]))
      return i;
  for (let i = e + 1; i < n.length; i++)
    if (t(n[i]))
      return i;
  return -1;
}
function Bo(n, e) {
  var t;
  return !!n && n !== ((t = e.loadLevelObj) == null ? void 0 : t.uri);
}
class Xy extends Fi {
  constructor(e) {
    super("abr", e.logger), this.hls = void 0, this.lastLevelLoadSec = 0, this.lastLoadedFragLevel = -1, this.firstSelection = -1, this._nextAutoLevel = -1, this.nextAutoLevelKey = "", this.audioTracksByGroup = null, this.codecTiers = null, this.timer = -1, this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.rebufferNotice = -1, this.supportedCache = {}, this.bwEstimator = void 0, this._abandonRulesCheck = (t) => {
      var i;
      const {
        fragCurrent: s,
        partCurrent: r,
        hls: a
      } = this, {
        autoLevelEnabled: o,
        media: l
      } = a;
      if (!s || !l)
        return;
      const c = performance.now(), u = r ? r.stats : s.stats, d = r ? r.duration : s.duration, f = c - u.loading.start, p = a.minAutoLevel, h = s.level, g = this._nextAutoLevel;
      if (u.aborted || u.loaded && u.loaded === u.total || h <= p) {
        this.clearTimer(), this._nextAutoLevel = -1;
        return;
      }
      if (!o)
        return;
      const m = g > -1 && g !== h, v = !!t || m;
      if (!v && (l.paused || !l.playbackRate || !l.readyState))
        return;
      const y = a.mainForwardBufferInfo;
      if (!v && y === null)
        return;
      const E = this.bwEstimator.getEstimateTTFB(), T = Math.abs(l.playbackRate);
      if (f <= Math.max(E, 1e3 * (d / (T * 2))))
        return;
      const S = y ? y.len / T : 0, w = u.loading.first ? u.loading.first - u.loading.start : -1, b = u.loaded && w > -1, L = this.getBwEstimate(), A = a.levels, _ = A[h], R = Math.max(u.loaded, Math.round(d * (s.bitrate || _.averageBitrate) / 8));
      let I = b ? f - w : f;
      I < 1 && b && (I = Math.min(f, u.loaded * 8 / L));
      const k = b ? u.loaded * 1e3 / I : 0, M = E / 1e3, O = k ? (R - u.loaded) / k : R * 8 / L + M;
      if (O <= S)
        return;
      const F = k ? k * 8 : L, C = ((i = t?.details || this.hls.latestLevelDetails) == null ? void 0 : i.live) === !0, D = this.hls.config.abrBandWidthUpFactor;
      let B = Number.POSITIVE_INFINITY, P;
      for (P = h - 1; P > p; P--) {
        const Y = A[P].maxBitrate, N = !A[P].details || C;
        if (B = this.getTimeToLoadFrag(M, F, d * Y, N), B < Math.min(S, d + M))
          break;
      }
      if (B >= O || B > d * 10)
        return;
      b ? this.bwEstimator.sample(f - Math.min(E, w), u.loaded) : this.bwEstimator.sampleTTFB(f);
      const K = A[P].maxBitrate;
      this.getBwEstimate() * D > K && this.resetEstimator(K);
      const X = this.findBestLevel(K, p, P, 0, S, 1, 1);
      X > -1 && (P = X), this.warn(`Fragment ${s.sn}${r ? " part " + r.index : ""} of level ${h} is loading too slowly;
      Fragment duration: ${s.duration.toFixed(3)}
      Time to underbuffer: ${S.toFixed(3)} s
      Estimated load time for current fragment: ${O.toFixed(3)} s
      Estimated load time for down switch fragment: ${B.toFixed(3)} s
      TTFB estimate: ${w | 0} ms
      Current BW estimate: ${Z(L) ? L | 0 : "Unknown"} bps
      New BW estimate: ${this.getBwEstimate() | 0} bps
      Switching to level ${P} @ ${K | 0} bps`), a.nextLoadLevel = a.nextAutoLevel = P, this.clearTimer();
      const W = () => {
        if (this.clearTimer(), this.fragCurrent === s && this.hls.loadLevel === P && P > 0) {
          const Y = this.getStarvationDelay();
          if (this.warn(`Aborting inflight request ${P > 0 ? "and switching down" : ""}
      Fragment duration: ${s.duration.toFixed(3)} s
      Time to underbuffer: ${Y.toFixed(3)} s`), s.abortRequests(), this.fragCurrent = this.partCurrent = null, P > p) {
            let N = this.findBestLevel(this.hls.levels[p].bitrate, p, P, 0, Y, 1, 1);
            N === -1 && (N = p), this.hls.nextLoadLevel = this.hls.nextAutoLevel = N, this.resetEstimator(this.hls.levels[N].bitrate);
          }
        }
      };
      m || O > B * 2 ? W() : this.timer = self.setInterval(W, B * 1e3), a.trigger(x.FRAG_LOAD_EMERGENCY_ABORTED, {
        frag: s,
        part: r,
        stats: u
      });
    }, this.hls = e, this.bwEstimator = this.initEstimator(), this.registerListeners();
  }
  resetEstimator(e) {
    e && (this.log(`setting initial bwe to ${e}`), this.hls.config.abrEwmaDefaultEstimate = e), this.firstSelection = -1, this.bwEstimator = this.initEstimator();
  }
  initEstimator() {
    const e = this.hls.config;
    return new ey(e.abrEwmaSlowVoD, e.abrEwmaFastVoD, e.abrEwmaDefaultEstimate);
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.FRAG_LOADING, this.onFragLoading, this), e.on(x.FRAG_LOADED, this.onFragLoaded, this), e.on(x.FRAG_BUFFERED, this.onFragBuffered, this), e.on(x.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(x.LEVEL_LOADED, this.onLevelLoaded, this), e.on(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(x.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.on(x.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.FRAG_LOADING, this.onFragLoading, this), e.off(x.FRAG_LOADED, this.onFragLoaded, this), e.off(x.FRAG_BUFFERED, this.onFragBuffered, this), e.off(x.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(x.LEVEL_LOADED, this.onLevelLoaded, this), e.off(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(x.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.off(x.ERROR, this.onError, this));
  }
  destroy() {
    this.unregisterListeners(), this.clearTimer(), this.hls = this._abandonRulesCheck = this.supportedCache = null, this.fragCurrent = this.partCurrent = null;
  }
  onManifestLoading(e, t) {
    this.lastLoadedFragLevel = -1, this.firstSelection = -1, this.lastLevelLoadSec = 0, this.supportedCache = {}, this.fragCurrent = this.partCurrent = null, this.onLevelsUpdated(), this.clearTimer();
  }
  onLevelsUpdated() {
    this.lastLoadedFragLevel > -1 && this.fragCurrent && (this.lastLoadedFragLevel = this.fragCurrent.level), this._nextAutoLevel = -1, this.onMaxAutoLevelUpdated(), this.codecTiers = null, this.audioTracksByGroup = null;
  }
  onMaxAutoLevelUpdated() {
    this.firstSelection = -1, this.nextAutoLevelKey = "";
  }
  onFragLoading(e, t) {
    const i = t.frag;
    if (!this.ignoreFragment(i)) {
      if (!i.bitrateTest) {
        var s;
        this.fragCurrent = i, this.partCurrent = (s = t.part) != null ? s : null;
      }
      this.clearTimer(), this.timer = self.setInterval(this._abandonRulesCheck, 100);
    }
  }
  onLevelSwitching(e, t) {
    this.clearTimer();
  }
  onError(e, t) {
    if (!t.fatal)
      switch (t.details) {
        case H.BUFFER_ADD_CODEC_ERROR:
        case H.BUFFER_APPEND_ERROR:
          this.lastLoadedFragLevel = -1, this.firstSelection = -1;
          break;
        case H.FRAG_LOAD_TIMEOUT: {
          const i = t.frag, {
            fragCurrent: s,
            partCurrent: r
          } = this;
          if (i && s && i.sn === s.sn && i.level === s.level) {
            const a = performance.now(), o = r ? r.stats : i.stats, l = a - o.loading.start, c = o.loading.first ? o.loading.first - o.loading.start : -1;
            if (o.loaded && c > -1) {
              const d = this.bwEstimator.getEstimateTTFB();
              this.bwEstimator.sample(l - Math.min(d, c), o.loaded);
            } else
              this.bwEstimator.sampleTTFB(l);
          }
          break;
        }
      }
  }
  getTimeToLoadFrag(e, t, i, s) {
    const r = e + i / t, a = s ? e + this.lastLevelLoadSec : 0;
    return r + a;
  }
  onLevelLoaded(e, t) {
    const i = this.hls.config, {
      loading: s
    } = t.stats, r = s.end - s.first;
    Z(r) && (this.lastLevelLoadSec = r / 1e3), t.details.live ? this.bwEstimator.update(i.abrEwmaSlowLive, i.abrEwmaFastLive) : this.bwEstimator.update(i.abrEwmaSlowVoD, i.abrEwmaFastVoD), this.timer > -1 && this._abandonRulesCheck(t.levelInfo);
  }
  onFragLoaded(e, {
    frag: t,
    part: i
  }) {
    const s = i ? i.stats : t.stats;
    if (t.type === te.MAIN && this.bwEstimator.sampleTTFB(s.loading.first - s.loading.start), !this.ignoreFragment(t)) {
      if (this.clearTimer(), t.level === this._nextAutoLevel && (this._nextAutoLevel = -1), this.firstSelection = -1, this.hls.config.abrMaxWithRealBitrate) {
        const r = i ? i.duration : t.duration, a = this.hls.levels[t.level], o = (a.loaded ? a.loaded.bytes : 0) + s.loaded, l = (a.loaded ? a.loaded.duration : 0) + r;
        a.loaded = {
          bytes: o,
          duration: l
        }, a.realBitrate = Math.round(8 * o / l);
      }
      if (t.bitrateTest) {
        const r = {
          stats: s,
          frag: t,
          part: i,
          id: t.type
        };
        this.onFragBuffered(x.FRAG_BUFFERED, r), t.bitrateTest = !1;
      } else
        this.lastLoadedFragLevel = t.level;
    }
  }
  onFragBuffered(e, t) {
    const {
      frag: i,
      part: s
    } = t, r = s != null && s.stats.loaded ? s.stats : i.stats;
    if (r.aborted || this.ignoreFragment(i))
      return;
    const a = r.parsing.end - r.loading.start - Math.min(r.loading.first - r.loading.start, this.bwEstimator.getEstimateTTFB());
    this.bwEstimator.sample(a, r.loaded), r.bwEstimate = this.getBwEstimate(), i.bitrateTest ? this.bitrateTestDelay = a / 1e3 : this.bitrateTestDelay = 0;
  }
  ignoreFragment(e) {
    return e.type !== te.MAIN || e.sn === "initSegment";
  }
  clearTimer() {
    this.timer > -1 && (self.clearInterval(this.timer), this.timer = -1);
  }
  get firstAutoLevel() {
    const {
      maxAutoLevel: e,
      minAutoLevel: t
    } = this.hls, i = this.getBwEstimate(), s = this.hls.config.maxStarvationDelay, r = this.findBestLevel(i, t, e, 0, s, 1, 1);
    if (r > -1)
      return r;
    const a = this.hls.firstLevel, o = Math.min(Math.max(a, t), e);
    return this.warn(`Could not find best starting auto level. Defaulting to first in playlist ${a} clamped to ${o}`), o;
  }
  get forcedAutoLevel() {
    return this.nextAutoLevelKey ? -1 : this._nextAutoLevel;
  }
  // return next auto level
  get nextAutoLevel() {
    const e = this.forcedAutoLevel, i = this.bwEstimator.canEstimate(), s = this.lastLoadedFragLevel > -1;
    if (e !== -1 && (!i || !s || this.nextAutoLevelKey === this.getAutoLevelKey()))
      return e;
    const r = i && s ? this.getNextABRAutoLevel() : this.firstAutoLevel;
    if (e !== -1) {
      const a = this.hls.levels;
      if (a.length > Math.max(e, r) && a[e].loadError <= a[r].loadError)
        return e;
    }
    return this._nextAutoLevel = r, this.nextAutoLevelKey = this.getAutoLevelKey(), r;
  }
  getAutoLevelKey() {
    return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}`;
  }
  getNextABRAutoLevel() {
    const {
      fragCurrent: e,
      partCurrent: t,
      hls: i
    } = this;
    if (i.levels.length <= 1)
      return i.loadLevel;
    const {
      maxAutoLevel: s,
      config: r,
      minAutoLevel: a
    } = i, o = t ? t.duration : e ? e.duration : 0, l = this.getBwEstimate(), c = this.getStarvationDelay();
    let u = r.abrBandWidthFactor, d = r.abrBandWidthUpFactor;
    if (c) {
      const m = this.findBestLevel(l, a, s, c, 0, u, d);
      if (m >= 0)
        return this.rebufferNotice = -1, m;
    }
    let f = o ? Math.min(o, r.maxStarvationDelay) : r.maxStarvationDelay;
    if (!c) {
      const m = this.bitrateTestDelay;
      m && (f = (o ? Math.min(o, r.maxLoadingDelay) : r.maxLoadingDelay) - m, this.info(`bitrate test took ${Math.round(1e3 * m)}ms, set first fragment max fetchDuration to ${Math.round(1e3 * f)} ms`), u = d = 1);
    }
    const p = this.findBestLevel(l, a, s, c, f, u, d);
    if (this.rebufferNotice !== p && (this.rebufferNotice = p, this.info(`${c ? "rebuffering expected" : "buffer is empty"}, optimal quality level ${p}`)), p > -1)
      return p;
    const h = i.levels[a], g = i.loadLevelObj;
    return g && h?.bitrate < g.bitrate ? a : i.loadLevel;
  }
  getStarvationDelay() {
    const e = this.hls, t = e.media;
    if (!t)
      return 1 / 0;
    const i = t && t.playbackRate !== 0 ? Math.abs(t.playbackRate) : 1, s = e.mainForwardBufferInfo;
    return (s ? s.len : 0) / i;
  }
  getBwEstimate() {
    return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;
  }
  findBestLevel(e, t, i, s, r, a, o) {
    var l;
    const c = s + r, u = this.lastLoadedFragLevel, d = u === -1 ? this.hls.firstLevel : u, {
      fragCurrent: f,
      partCurrent: p
    } = this, {
      levels: h,
      allAudioTracks: g,
      loadLevel: m,
      config: v
    } = this.hls;
    if (h.length === 1)
      return 0;
    const y = h[d], E = !!((l = this.hls.latestLevelDetails) != null && l.live), T = m === -1 || u === -1;
    let S, w = "SDR", b = y?.frameRate || 0;
    const {
      audioPreference: L,
      videoPreference: A
    } = v, _ = this.audioTracksByGroup || (this.audioTracksByGroup = ng(g));
    let R = -1;
    if (T) {
      if (this.firstSelection !== -1)
        return this.firstSelection;
      const F = this.codecTiers || (this.codecTiers = Wy(h, _, t, i)), C = zy(F, w, e, L, A), {
        codecSet: D,
        videoRanges: B,
        minFramerate: P,
        minBitrate: K,
        minIndex: X,
        preferHDR: W
      } = C;
      R = X, S = D, w = W ? B[B.length - 1] : B[0], b = P, e = Math.max(e, K), this.log(`picked start tier ${Ge(C)}`);
    } else
      S = y?.codecSet, w = y?.videoRange;
    const I = p ? p.duration : f ? f.duration : 0, k = this.bwEstimator.getEstimateTTFB() / 1e3, M = [];
    for (let F = i; F >= t; F--) {
      var O;
      const C = h[F], D = F > d;
      if (!C)
        continue;
      if (v.useMediaCapabilities && !C.supportedResult && !C.supportedPromise) {
        const N = navigator.mediaCapabilities;
        typeof N?.decodingInfo == "function" && My(C, _, w, b, e, L) ? (C.supportedPromise = sg(C, _, N, this.supportedCache), C.supportedPromise.then((U) => {
          if (!this.hls)
            return;
          C.supportedResult = U;
          const V = this.hls.levels, j = V.indexOf(C);
          U.error ? this.warn(`MediaCapabilities decodingInfo error: "${U.error}" for level ${j} ${Ge(U)}`) : U.supported ? U.decodingInfoResults.some((ee) => ee.smooth === !1 || ee.powerEfficient === !1) && this.log(`MediaCapabilities decodingInfo for level ${j} not smooth or powerEfficient: ${Ge(U)}`) : (this.warn(`Unsupported MediaCapabilities decodingInfo result for level ${j} ${Ge(U)}`), j > -1 && V.length > 1 && (this.log(`Removing unsupported level ${j}`), this.hls.removeLevel(j), this.hls.loadLevel === -1 && (this.hls.nextLoadLevel = 0)));
        }).catch((U) => {
          this.warn(`Error handling MediaCapabilities decodingInfo: ${U}`);
        })) : C.supportedResult = tg;
      }
      if ((S && C.codecSet !== S || w && C.videoRange !== w || D && b > C.frameRate || !D && b > 0 && b < C.frameRate || (O = C.supportedResult) != null && (O = O.decodingInfoResults) != null && O.some((N) => N.smooth === !1)) && (!T || F !== R)) {
        M.push(F);
        continue;
      }
      const B = C.details, P = (p ? B?.partTarget : B?.averagetargetduration) || I;
      let K;
      D ? K = o * e : K = a * e;
      const X = I && s >= I * 2 && r === 0 ? C.averageBitrate : C.maxBitrate, W = this.getTimeToLoadFrag(k, K, X * P, B === void 0);
      if (
        // if adjusted bw is greater than level bitrate AND
        K >= X && // no level change, or new level has no error history
        (F === u || C.loadError === 0 && C.fragmentError === 0) && // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
        // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
        // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1
        (W <= k || !Z(W) || E && !this.bitrateTestDelay || W < c)
      ) {
        const N = this.forcedAutoLevel;
        return F !== m && (N === -1 || N !== m) && (M.length && this.trace(`Skipped level(s) ${M.join(",")} of ${i} max with CODECS and VIDEO-RANGE:"${h[M[0]].codecs}" ${h[M[0]].videoRange}; not compatible with "${S}" ${w}`), this.info(`switch candidate:${d}->${F} adjustedbw(${Math.round(K)})-bitrate=${Math.round(K - X)} ttfb:${k.toFixed(1)} avgDuration:${P.toFixed(1)} maxFetchDuration:${c.toFixed(1)} fetchDuration:${W.toFixed(1)} firstSelection:${T} codecSet:${C.codecSet} videoRange:${C.videoRange} hls.loadLevel:${m}`)), T && (this.firstSelection = F), F;
      }
    }
    return -1;
  }
  set nextAutoLevel(e) {
    const t = this.deriveNextAutoLevel(e);
    this._nextAutoLevel !== t && (this.nextAutoLevelKey = "", this._nextAutoLevel = t);
  }
  deriveNextAutoLevel(e) {
    const {
      maxAutoLevel: t,
      minAutoLevel: i
    } = this.hls;
    return Math.min(Math.max(e, i), t);
  }
}
const ag = {
  /**
   * Searches for an item in an array which matches a certain condition.
   * This requires the condition to only match one item in the array,
   * and for the array to be ordered.
   *
   * @param list The array to search.
   * @param comparisonFn
   *      Called and provided a candidate item as the first argument.
   *      Should return:
   *          > -1 if the item should be located at a lower index than the provided item.
   *          > 1 if the item should be located at a higher index than the provided item.
   *          > 0 if the item is the item you're looking for.
   *
   * @returns the object if found, otherwise returns null
   */
  search: function(n, e) {
    let t = 0, i = n.length - 1, s = null, r = null;
    for (; t <= i; ) {
      s = (t + i) / 2 | 0, r = n[s];
      const a = e(r);
      if (a > 0)
        t = s + 1;
      else if (a < 0)
        i = s - 1;
      else
        return r;
    }
    return null;
  }
};
function jy(n, e, t) {
  if (e === null || !Array.isArray(n) || !n.length || !Z(e))
    return null;
  const i = n[0].programDateTime;
  if (e < (i || 0))
    return null;
  const s = n[n.length - 1].endProgramDateTime;
  if (e >= (s || 0))
    return null;
  for (let r = 0; r < n.length; ++r) {
    const a = n[r];
    if (Zy(e, t, a))
      return a;
  }
  return null;
}
function Rr(n, e, t = 0, i = 0, s = 5e-3) {
  let r = null;
  if (n) {
    r = e[1 + n.sn - e[0].sn] || null;
    const o = n.endDTS - t;
    o > 0 && o < 15e-7 && (t += 15e-7), r && n.level !== r.level && r.end <= n.end && (r = e[2 + n.sn - e[0].sn] || null);
  } else t === 0 && e[0].start === 0 && (r = e[0]);
  if (r && ((!n || n.level === r.level) && rf(t, i, r) === 0 || Qy(r, n, Math.min(s, i))))
    return r;
  const a = ag.search(e, rf.bind(null, t, i));
  return a && (a !== n || !r) ? a : r;
}
function Qy(n, e, t) {
  if (e && e.start === 0 && e.level < n.level && (e.endPTS || 0) > 0) {
    const i = e.tagList.reduce((s, r) => (r[0] === "INF" && (s += parseFloat(r[1])), s), t);
    return n.start <= i;
  }
  return !1;
}
function rf(n = 0, e = 0, t) {
  if (t.start <= n && t.start + t.duration > n)
    return 0;
  const i = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0));
  return t.start + t.duration - i <= n ? 1 : t.start - i > n && t.start ? -1 : 0;
}
function Zy(n, e, t) {
  const i = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0)) * 1e3;
  return (t.endProgramDateTime || 0) - i > n;
}
function og(n, e, t) {
  if (n && n.startCC <= e && n.endCC >= e) {
    let i = n.fragments;
    const {
      fragmentHint: s
    } = n;
    s && (i = i.concat(s));
    let r;
    return ag.search(i, (a) => a.cc < e ? 1 : a.cc > e ? -1 : (r = a, a.end <= t ? 1 : a.start > t ? -1 : 0)), r || null;
  }
  return null;
}
function Uo(n) {
  switch (n.details) {
    case H.FRAG_LOAD_TIMEOUT:
    case H.KEY_LOAD_TIMEOUT:
    case H.LEVEL_LOAD_TIMEOUT:
    case H.MANIFEST_LOAD_TIMEOUT:
      return !0;
  }
  return !1;
}
function lg(n) {
  return n.details.startsWith("key");
}
function cg(n) {
  return lg(n) && !!n.frag && !n.frag.decryptdata;
}
function nf(n, e) {
  const t = Uo(e);
  return n.default[`${t ? "timeout" : "error"}Retry`];
}
function Ou(n, e) {
  const t = n.backoff === "linear" ? 1 : Math.pow(2, e);
  return Math.min(t * n.retryDelayMs, n.maxRetryDelayMs);
}
function af(n) {
  return Me(Me({}, n), {
    errorRetry: null,
    timeoutRetry: null
  });
}
function Go(n, e, t, i) {
  if (!n)
    return !1;
  const s = i?.code, r = e < n.maxNumRetry && (Jy(s) || !!t);
  return n.shouldRetry ? n.shouldRetry(n, e, t, i, r) : r;
}
function Jy(n) {
  return Oc(n) || !!n && (n < 400 || n > 499);
}
function Oc(n) {
  return n === 0 && navigator.onLine === !1;
}
var It = {
  DoNothing: 0,
  SendAlternateToPenaltyBox: 2,
  RemoveAlternatePermanently: 3,
  RetryRequest: 5
}, ci = {
  None: 0,
  MoveAllAlternatesMatchingHost: 1,
  MoveAllAlternatesMatchingHDCP: 2,
  MoveAllAlternatesMatchingKey: 4
};
class eE extends Fi {
  constructor(e) {
    super("error-controller", e.logger), this.hls = void 0, this.playlistError = 0, this.hls = e, this.registerListeners();
  }
  registerListeners() {
    const e = this.hls;
    e.on(x.ERROR, this.onError, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.LEVEL_UPDATED, this.onLevelUpdated, this);
  }
  unregisterListeners() {
    const e = this.hls;
    e && (e.off(x.ERROR, this.onError, this), e.off(x.ERROR, this.onErrorOut, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.LEVEL_UPDATED, this.onLevelUpdated, this));
  }
  destroy() {
    this.unregisterListeners(), this.hls = null;
  }
  startLoad(e) {
  }
  stopLoad() {
    this.playlistError = 0;
  }
  getVariantLevelIndex(e) {
    return e?.type === te.MAIN ? e.level : this.getVariantIndex();
  }
  getVariantIndex() {
    var e;
    const t = this.hls, i = t.currentLevel;
    return (e = t.loadLevelObj) != null && e.details || i === -1 ? t.loadLevel : i;
  }
  variantHasKey(e, t) {
    if (e) {
      var i;
      if ((i = e.details) != null && i.hasKey(t))
        return !0;
      const s = e.audioGroups;
      if (s)
        return this.hls.allAudioTracks.filter((a) => s.indexOf(a.groupId) >= 0).some((a) => {
          var o;
          return (o = a.details) == null ? void 0 : o.hasKey(t);
        });
    }
    return !1;
  }
  onManifestLoading() {
    this.playlistError = 0;
  }
  onLevelUpdated() {
    this.playlistError = 0;
  }
  onError(e, t) {
    var i;
    if (t.fatal)
      return;
    const s = this.hls, r = t.context;
    switch (t.details) {
      case H.FRAG_LOAD_ERROR:
      case H.FRAG_LOAD_TIMEOUT:
      case H.KEY_LOAD_ERROR:
      case H.KEY_LOAD_TIMEOUT:
        t.errorAction = this.getFragRetryOrSwitchAction(t);
        return;
      case H.FRAG_PARSING_ERROR:
        if ((i = t.frag) != null && i.gap) {
          t.errorAction = nn();
          return;
        }
      // falls through
      case H.FRAG_GAP:
      case H.FRAG_DECRYPT_ERROR: {
        t.errorAction = this.getFragRetryOrSwitchAction(t), t.errorAction.action = It.SendAlternateToPenaltyBox;
        return;
      }
      case H.LEVEL_EMPTY_ERROR:
      case H.LEVEL_PARSING_ERROR:
        {
          var a;
          const l = t.parent === te.MAIN ? t.level : s.loadLevel;
          t.details === H.LEVEL_EMPTY_ERROR && ((a = t.context) != null && (a = a.levelDetails) != null && a.live) ? t.errorAction = this.getPlaylistRetryOrSwitchAction(t, l) : (t.levelRetry = !1, t.errorAction = this.getLevelSwitchAction(t, l));
        }
        return;
      case H.LEVEL_LOAD_ERROR:
      case H.LEVEL_LOAD_TIMEOUT:
        typeof r?.level == "number" && (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, r.level));
        return;
      case H.AUDIO_TRACK_LOAD_ERROR:
      case H.AUDIO_TRACK_LOAD_TIMEOUT:
      case H.SUBTITLE_LOAD_ERROR:
      case H.SUBTITLE_TRACK_LOAD_TIMEOUT:
        if (r) {
          const l = s.loadLevelObj;
          if (l && (r.type === Ee.AUDIO_TRACK && l.hasAudioGroup(r.groupId) || r.type === Ee.SUBTITLE_TRACK && l.hasSubtitleGroup(r.groupId))) {
            t.errorAction = this.getPlaylistRetryOrSwitchAction(t, s.loadLevel), t.errorAction.action = It.SendAlternateToPenaltyBox, t.errorAction.flags = ci.MoveAllAlternatesMatchingHost;
            return;
          }
        }
        return;
      case H.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
        t.errorAction = {
          action: It.SendAlternateToPenaltyBox,
          flags: ci.MoveAllAlternatesMatchingHDCP
        };
        return;
      case H.KEY_SYSTEM_SESSION_UPDATE_FAILED:
      case H.KEY_SYSTEM_STATUS_INTERNAL_ERROR:
      case H.KEY_SYSTEM_NO_SESSION:
        t.errorAction = {
          action: It.SendAlternateToPenaltyBox,
          flags: ci.MoveAllAlternatesMatchingKey
        };
        return;
      case H.BUFFER_ADD_CODEC_ERROR:
      case H.REMUX_ALLOC_ERROR:
      case H.BUFFER_APPEND_ERROR:
        if (!t.errorAction) {
          var o;
          t.errorAction = this.getLevelSwitchAction(t, (o = t.level) != null ? o : s.loadLevel);
        }
        return;
      case H.INTERNAL_EXCEPTION:
      case H.BUFFER_APPENDING_ERROR:
      case H.BUFFER_FULL_ERROR:
      case H.LEVEL_SWITCH_ERROR:
      case H.BUFFER_STALLED_ERROR:
      case H.BUFFER_SEEK_OVER_HOLE:
      case H.BUFFER_NUDGE_ON_STALL:
        t.errorAction = nn();
        return;
    }
    t.type === se.KEY_SYSTEM_ERROR && (t.levelRetry = !1, t.errorAction = nn());
  }
  getPlaylistRetryOrSwitchAction(e, t) {
    const i = this.hls, s = nf(i.config.playlistLoadPolicy, e), r = this.playlistError++;
    if (Go(s, r, Uo(e), e.response))
      return {
        action: It.RetryRequest,
        flags: ci.None,
        retryConfig: s,
        retryCount: r
      };
    const o = this.getLevelSwitchAction(e, t);
    return s && (o.retryConfig = s, o.retryCount = r), o;
  }
  getFragRetryOrSwitchAction(e) {
    const t = this.hls, i = this.getVariantLevelIndex(e.frag), s = t.levels[i], {
      fragLoadPolicy: r,
      keyLoadPolicy: a
    } = t.config, o = nf(lg(e) ? a : r, e), l = t.levels.reduce((u, d) => u + d.fragmentError, 0);
    if (s && (e.details !== H.FRAG_GAP && s.fragmentError++, !cg(e) && Go(o, l, Uo(e), e.response)))
      return {
        action: It.RetryRequest,
        flags: ci.None,
        retryConfig: o,
        retryCount: l
      };
    const c = this.getLevelSwitchAction(e, i);
    return o && (c.retryConfig = o, c.retryCount = l), c;
  }
  getLevelSwitchAction(e, t) {
    const i = this.hls;
    t == null && (t = i.loadLevel);
    const s = this.hls.levels[t];
    if (s) {
      var r, a;
      const c = e.details;
      s.loadError++, c === H.BUFFER_APPEND_ERROR && s.fragmentError++;
      let u = -1;
      const {
        levels: d,
        loadLevel: f,
        minAutoLevel: p,
        maxAutoLevel: h
      } = i;
      !i.autoLevelEnabled && !i.config.preserveManualLevelOnError && (i.loadLevel = -1);
      const g = (r = e.frag) == null ? void 0 : r.type, v = (g === te.AUDIO && c === H.FRAG_PARSING_ERROR || e.sourceBufferName === "audio" && (c === H.BUFFER_ADD_CODEC_ERROR || c === H.BUFFER_APPEND_ERROR)) && d.some(({
        audioCodec: w
      }) => s.audioCodec !== w), E = e.sourceBufferName === "video" && (c === H.BUFFER_ADD_CODEC_ERROR || c === H.BUFFER_APPEND_ERROR) && d.some(({
        codecSet: w,
        audioCodec: b
      }) => s.codecSet !== w && s.audioCodec === b), {
        type: T,
        groupId: S
      } = (a = e.context) != null ? a : {};
      for (let w = d.length; w--; ) {
        const b = (w + f) % d.length;
        if (b !== f && b >= p && b <= h && d[b].loadError === 0) {
          var o, l;
          const L = d[b];
          if (c === H.FRAG_GAP && g === te.MAIN && e.frag) {
            const A = d[b].details;
            if (A) {
              const _ = Rr(e.frag, A.fragments, e.frag.start);
              if (_ != null && _.gap)
                continue;
            }
          } else {
            if (T === Ee.AUDIO_TRACK && L.hasAudioGroup(S) || T === Ee.SUBTITLE_TRACK && L.hasSubtitleGroup(S))
              continue;
            if (g === te.AUDIO && (o = s.audioGroups) != null && o.some((A) => L.hasAudioGroup(A)) || g === te.SUBTITLE && (l = s.subtitleGroups) != null && l.some((A) => L.hasSubtitleGroup(A)) || v && s.audioCodec === L.audioCodec || E && s.codecSet === L.codecSet || !v && s.codecSet !== L.codecSet)
              continue;
          }
          u = b;
          break;
        }
      }
      if (u > -1 && i.loadLevel !== u)
        return e.levelRetry = !0, this.playlistError = 0, {
          action: It.SendAlternateToPenaltyBox,
          flags: ci.None,
          nextAutoLevel: u
        };
    }
    return {
      action: It.SendAlternateToPenaltyBox,
      flags: ci.MoveAllAlternatesMatchingHost
    };
  }
  onErrorOut(e, t) {
    var i;
    switch ((i = t.errorAction) == null ? void 0 : i.action) {
      case It.DoNothing:
        break;
      case It.SendAlternateToPenaltyBox:
        this.sendAlternateToPenaltyBox(t), !t.errorAction.resolved && t.details !== H.FRAG_GAP ? t.fatal = !0 : /MediaSource readyState: ended/.test(t.error.message) && (this.warn(`MediaSource ended after "${t.sourceBufferName}" sourceBuffer append error. Attempting to recover from media error.`), this.hls.recoverMediaError());
        break;
    }
    if (t.fatal) {
      this.hls.stopLoad();
      return;
    }
  }
  sendAlternateToPenaltyBox(e) {
    const t = this.hls, i = e.errorAction;
    if (!i)
      return;
    const {
      flags: s
    } = i, r = i.nextAutoLevel;
    switch (s) {
      case ci.None:
        this.switchLevel(e, r);
        break;
      case ci.MoveAllAlternatesMatchingHDCP: {
        const l = this.getVariantLevelIndex(e.frag), c = t.levels[l], u = c?.attrs["HDCP-LEVEL"];
        if (i.hdcpLevel = u, u === "NONE")
          this.warn("HDCP policy resticted output with HDCP-LEVEL=NONE");
        else if (u) {
          t.maxHdcpLevel = Mc[Mc.indexOf(u) - 1], i.resolved = !0, this.warn(`Restricting playback to HDCP-LEVEL of "${t.maxHdcpLevel}" or lower`);
          break;
        }
      }
      // eslint-disable-next-line no-fallthrough
      case ci.MoveAllAlternatesMatchingKey: {
        const l = e.decryptdata;
        if (l) {
          const c = this.hls.levels, u = c.length;
          for (let f = u; f--; )
            if (this.variantHasKey(c[f], l)) {
              var a, o;
              this.log(`Banned key found in level ${f} (${c[f].bitrate}bps) or audio group "${(a = c[f].audioGroups) == null ? void 0 : a.join(",")}" (${(o = e.frag) == null ? void 0 : o.type} fragment) ${Rt(l.keyId || [])}`), c[f].fragmentError++, c[f].loadError++, this.log(`Removing level ${f} with key error (${e.error})`), this.hls.removeLevel(f);
            }
          const d = e.frag;
          if (this.hls.levels.length < u)
            i.resolved = !0;
          else if (d && d.type !== te.MAIN) {
            const f = d.decryptdata;
            f && !l.matches(f) && (i.resolved = !0);
          }
        }
        break;
      }
    }
    i.resolved || this.switchLevel(e, r);
  }
  switchLevel(e, t) {
    if (t !== void 0 && e.errorAction && (this.warn(`switching to level ${t} after ${e.details}`), this.hls.nextAutoLevel = t, e.errorAction.resolved = !0, this.hls.nextLoadLevel = this.hls.nextAutoLevel, e.details === H.BUFFER_ADD_CODEC_ERROR && e.mimeType && e.sourceBufferName !== "audiovideo")) {
      const i = kc(e.mimeType), s = this.hls.levels;
      for (let r = s.length; r--; )
        s[r][`${e.sourceBufferName}Codec`] === i && (this.log(`Removing level ${r} for ${e.details} ("${i}" not supported)`), this.hls.removeLevel(r));
    }
  }
}
function nn(n) {
  const e = {
    action: It.DoNothing,
    flags: ci.None
  };
  return n && (e.resolved = !0), e;
}
var yt = {
  NOT_LOADED: "NOT_LOADED",
  APPENDING: "APPENDING",
  PARTIAL: "PARTIAL",
  OK: "OK"
};
class tE {
  constructor(e) {
    this.activePartLists = /* @__PURE__ */ Object.create(null), this.endListFragments = /* @__PURE__ */ Object.create(null), this.fragments = /* @__PURE__ */ Object.create(null), this.timeRanges = /* @__PURE__ */ Object.create(null), this.bufferPadding = 0.2, this.hls = void 0, this.hasGaps = !1, this.hls = e, this._registerListeners();
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e && (e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.BUFFER_APPENDED, this.onBufferAppended, this), e.on(x.FRAG_BUFFERED, this.onFragBuffered, this), e.on(x.FRAG_LOADED, this.onFragLoaded, this));
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.BUFFER_APPENDED, this.onBufferAppended, this), e.off(x.FRAG_BUFFERED, this.onFragBuffered, this), e.off(x.FRAG_LOADED, this.onFragLoaded, this));
  }
  destroy() {
    this._unregisterListeners(), this.hls = // @ts-ignore
    this.fragments = // @ts-ignore
    this.activePartLists = // @ts-ignore
    this.endListFragments = this.timeRanges = null;
  }
  /**
   * Return a Fragment or Part with an appended range that matches the position and levelType
   * Otherwise, return null
   */
  getAppendedFrag(e, t) {
    const i = this.activePartLists[t];
    if (i)
      for (let s = i.length; s--; ) {
        const r = i[s];
        if (!r)
          break;
        if (r.start <= e && e <= r.end && r.loaded)
          return r;
      }
    return this.getBufferedFrag(e, t);
  }
  /**
   * Return a buffered Fragment that matches the position and levelType.
   * A buffered Fragment is one whose loading, parsing and appending is done (completed or "partial" meaning aborted).
   * If not found any Fragment, return null
   */
  getBufferedFrag(e, t) {
    return this.getFragAtPos(e, t, !0);
  }
  getFragAtPos(e, t, i) {
    const {
      fragments: s
    } = this, r = Object.keys(s);
    for (let a = r.length; a--; ) {
      const o = s[r[a]];
      if (o?.body.type === t && (!i || o.buffered)) {
        const l = o.body;
        if (l.start <= e && e <= l.end)
          return l;
      }
    }
    return null;
  }
  /**
   * Partial fragments effected by coded frame eviction will be removed
   * The browser will unload parts of the buffer to free up memory for new buffer data
   * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)
   */
  detectEvictedFragments(e, t, i, s, r) {
    this.timeRanges && (this.timeRanges[e] = t);
    const a = s?.fragment.sn || -1;
    Object.keys(this.fragments).forEach((o) => {
      const l = this.fragments[o];
      if (!l || a >= l.body.sn)
        return;
      if (!l.buffered && (!l.loaded || r)) {
        l.body.type === i && this.removeFragment(l.body);
        return;
      }
      const c = l.range[e];
      if (c) {
        if (c.time.length === 0) {
          this.removeFragment(l.body);
          return;
        }
        c.time.some((u) => {
          const d = !this.isTimeBuffered(u.startPTS, u.endPTS, t);
          return d && this.removeFragment(l.body), d;
        });
      }
    });
  }
  /**
   * Checks if the fragment passed in is loaded in the buffer properly
   * Partially loaded fragments will be registered as a partial fragment
   */
  detectPartialFragments(e) {
    const t = this.timeRanges;
    if (!t || e.frag.sn === "initSegment")
      return;
    const i = e.frag, s = Ur(i), r = this.fragments[s];
    if (!r || r.buffered && i.gap)
      return;
    const a = !i.relurl;
    Object.keys(t).forEach((o) => {
      const l = i.elementaryStreams[o];
      if (!l)
        return;
      const c = t[o], u = a || l.partial === !0;
      r.range[o] = this.getBufferedTimes(i, e.part, u, c);
    }), r.loaded = null, Object.keys(r.range).length ? (this.bufferedEnd(r, i), Va(r) || this.removeParts(i.sn - 1, i.type)) : this.removeFragment(r.body);
  }
  bufferedEnd(e, t) {
    e.buffered = !0, (e.body.endList = t.endList || e.body.endList) && (this.endListFragments[e.body.type] = e);
  }
  removeParts(e, t) {
    const i = this.activePartLists[t];
    i && (this.activePartLists[t] = of(i, (s) => s.fragment.sn >= e));
  }
  fragBuffered(e, t) {
    const i = Ur(e);
    let s = this.fragments[i];
    !s && t && (s = this.fragments[i] = {
      body: e,
      appendedPTS: null,
      loaded: null,
      buffered: !1,
      range: /* @__PURE__ */ Object.create(null)
    }, e.gap && (this.hasGaps = !0)), s && (s.loaded = null, this.bufferedEnd(s, e));
  }
  getBufferedTimes(e, t, i, s) {
    const r = {
      time: [],
      partial: i
    }, a = e.start, o = e.end, l = e.minEndPTS || o, c = e.maxStartPTS || a;
    for (let u = 0; u < s.length; u++) {
      const d = s.start(u) - this.bufferPadding, f = s.end(u) + this.bufferPadding;
      if (c >= d && l <= f) {
        r.time.push({
          startPTS: Math.max(a, s.start(u)),
          endPTS: Math.min(o, s.end(u))
        });
        break;
      } else if (a < f && o > d) {
        const p = Math.max(a, s.start(u)), h = Math.min(o, s.end(u));
        h > p && (r.partial = !0, r.time.push({
          startPTS: p,
          endPTS: h
        }));
      } else if (o <= d)
        break;
    }
    return r;
  }
  /**
   * Gets the partial fragment for a certain time
   */
  getPartialFragment(e) {
    let t = null, i, s, r, a = 0;
    const {
      bufferPadding: o,
      fragments: l
    } = this;
    return Object.keys(l).forEach((c) => {
      const u = l[c];
      u && Va(u) && (s = u.body.start - o, r = u.body.end + o, e >= s && e <= r && (i = Math.min(e - s, r - e), a <= i && (t = u.body, a = i)));
    }), t;
  }
  isEndListAppended(e) {
    const t = this.endListFragments[e];
    return t !== void 0 && (t.buffered || Va(t));
  }
  getState(e) {
    const t = Ur(e), i = this.fragments[t];
    return i ? i.buffered ? Va(i) ? yt.PARTIAL : yt.OK : yt.APPENDING : yt.NOT_LOADED;
  }
  isTimeBuffered(e, t, i) {
    let s, r;
    for (let a = 0; a < i.length; a++) {
      if (s = i.start(a) - this.bufferPadding, r = i.end(a) + this.bufferPadding, e >= s && t <= r)
        return !0;
      if (t <= s)
        return !1;
    }
    return !1;
  }
  onManifestLoading() {
    this.removeAllFragments();
  }
  onFragLoaded(e, t) {
    if (t.frag.sn === "initSegment" || t.frag.bitrateTest)
      return;
    const i = t.frag, s = t.part ? null : t, r = Ur(i);
    this.fragments[r] = {
      body: i,
      appendedPTS: null,
      loaded: s,
      buffered: !1,
      range: /* @__PURE__ */ Object.create(null)
    };
  }
  onBufferAppended(e, t) {
    const {
      frag: i,
      part: s,
      timeRanges: r,
      type: a
    } = t;
    if (i.sn === "initSegment")
      return;
    const o = i.type;
    if (s) {
      let c = this.activePartLists[o];
      c || (this.activePartLists[o] = c = []), c.push(s);
    }
    this.timeRanges = r;
    const l = r[a];
    this.detectEvictedFragments(a, l, o, s);
  }
  onFragBuffered(e, t) {
    this.detectPartialFragments(t);
  }
  hasFragment(e) {
    const t = Ur(e);
    return !!this.fragments[t];
  }
  hasFragments(e) {
    const {
      fragments: t
    } = this, i = Object.keys(t);
    if (!e)
      return i.length > 0;
    for (let s = i.length; s--; ) {
      const r = t[i[s]];
      if (r?.body.type === e)
        return !0;
    }
    return !1;
  }
  hasParts(e) {
    var t;
    return !!((t = this.activePartLists[e]) != null && t.length);
  }
  removeFragmentsInRange(e, t, i, s, r) {
    s && !this.hasGaps || Object.keys(this.fragments).forEach((a) => {
      const o = this.fragments[a];
      if (!o)
        return;
      const l = o.body;
      l.type !== i || s && !l.gap || l.start < t && l.end > e && (o.buffered || r) && this.removeFragment(l);
    });
  }
  removeFragment(e) {
    const t = Ur(e);
    e.clearElementaryStreamInfo();
    const i = this.activePartLists[e.type];
    if (i) {
      const s = e.sn;
      this.activePartLists[e.type] = of(i, (r) => r.fragment.sn !== s);
    }
    delete this.fragments[t], e.endList && delete this.endListFragments[e.type];
  }
  removeAllFragments() {
    var e;
    this.fragments = /* @__PURE__ */ Object.create(null), this.endListFragments = /* @__PURE__ */ Object.create(null), this.activePartLists = /* @__PURE__ */ Object.create(null), this.hasGaps = !1;
    const t = (e = this.hls) == null || (e = e.latestLevelDetails) == null ? void 0 : e.partList;
    t && t.forEach((i) => i.clearElementaryStreamInfo());
  }
}
function Va(n) {
  var e, t, i;
  return n.buffered && !!(n.body.gap || (e = n.range.video) != null && e.partial || (t = n.range.audio) != null && t.partial || (i = n.range.audiovideo) != null && i.partial);
}
function Ur(n) {
  return `${n.type}_${n.level}_${n.sn}`;
}
function of(n, e) {
  return n.filter((t) => {
    const i = e(t);
    return i || t.clearElementaryStreamInfo(), i;
  });
}
var Zs = {
  cbc: 0,
  ctr: 1
};
class iE {
  constructor(e, t, i) {
    this.subtle = void 0, this.aesIV = void 0, this.aesMode = void 0, this.subtle = e, this.aesIV = t, this.aesMode = i;
  }
  decrypt(e, t) {
    switch (this.aesMode) {
      case Zs.cbc:
        return this.subtle.decrypt({
          name: "AES-CBC",
          iv: this.aesIV
        }, t, e);
      case Zs.ctr:
        return this.subtle.decrypt(
          {
            name: "AES-CTR",
            counter: this.aesIV,
            length: 64
          },
          //64 : NIST SP800-38A standard suggests that the counter should occupy half of the counter block
          t,
          e
        );
      default:
        throw new Error(`[AESCrypto] invalid aes mode ${this.aesMode}`);
    }
  }
}
function sE(n) {
  const e = n.byteLength, t = e && new DataView(n.buffer).getUint8(e - 1);
  return t ? n.slice(0, e - t) : n;
}
class rE {
  constructor() {
    this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable();
  }
  // Using view.getUint32() also swaps the byte order.
  uint8ArrayToUint32Array_(e) {
    const t = new DataView(e), i = new Uint32Array(4);
    for (let s = 0; s < 4; s++)
      i[s] = t.getUint32(s * 4);
    return i;
  }
  initTable() {
    const e = this.sBox, t = this.invSBox, i = this.subMix, s = i[0], r = i[1], a = i[2], o = i[3], l = this.invSubMix, c = l[0], u = l[1], d = l[2], f = l[3], p = new Uint32Array(256);
    let h = 0, g = 0, m = 0;
    for (m = 0; m < 256; m++)
      m < 128 ? p[m] = m << 1 : p[m] = m << 1 ^ 283;
    for (m = 0; m < 256; m++) {
      let v = g ^ g << 1 ^ g << 2 ^ g << 3 ^ g << 4;
      v = v >>> 8 ^ v & 255 ^ 99, e[h] = v, t[v] = h;
      const y = p[h], E = p[y], T = p[E];
      let S = p[v] * 257 ^ v * 16843008;
      s[h] = S << 24 | S >>> 8, r[h] = S << 16 | S >>> 16, a[h] = S << 8 | S >>> 24, o[h] = S, S = T * 16843009 ^ E * 65537 ^ y * 257 ^ h * 16843008, c[v] = S << 24 | S >>> 8, u[v] = S << 16 | S >>> 16, d[v] = S << 8 | S >>> 24, f[v] = S, h ? (h = y ^ p[p[p[T ^ y]]], g ^= p[p[g]]) : h = g = 1;
    }
  }
  expandKey(e) {
    const t = this.uint8ArrayToUint32Array_(e);
    let i = !0, s = 0;
    for (; s < t.length && i; )
      i = t[s] === this.key[s], s++;
    if (i)
      return;
    this.key = t;
    const r = this.keySize = t.length;
    if (r !== 4 && r !== 6 && r !== 8)
      throw new Error("Invalid aes key size=" + r);
    const a = this.ksRows = (r + 6 + 1) * 4;
    let o, l;
    const c = this.keySchedule = new Uint32Array(a), u = this.invKeySchedule = new Uint32Array(a), d = this.sBox, f = this.rcon, p = this.invSubMix, h = p[0], g = p[1], m = p[2], v = p[3];
    let y, E;
    for (o = 0; o < a; o++) {
      if (o < r) {
        y = c[o] = t[o];
        continue;
      }
      E = y, o % r === 0 ? (E = E << 8 | E >>> 24, E = d[E >>> 24] << 24 | d[E >>> 16 & 255] << 16 | d[E >>> 8 & 255] << 8 | d[E & 255], E ^= f[o / r | 0] << 24) : r > 6 && o % r === 4 && (E = d[E >>> 24] << 24 | d[E >>> 16 & 255] << 16 | d[E >>> 8 & 255] << 8 | d[E & 255]), c[o] = y = (c[o - r] ^ E) >>> 0;
    }
    for (l = 0; l < a; l++)
      o = a - l, l & 3 ? E = c[o] : E = c[o - 4], l < 4 || o <= 4 ? u[l] = E : u[l] = h[d[E >>> 24]] ^ g[d[E >>> 16 & 255]] ^ m[d[E >>> 8 & 255]] ^ v[d[E & 255]], u[l] = u[l] >>> 0;
  }
  // Adding this as a method greatly improves performance.
  networkToHostOrderSwap(e) {
    return e << 24 | (e & 65280) << 8 | (e & 16711680) >> 8 | e >>> 24;
  }
  decrypt(e, t, i) {
    const s = this.keySize + 6, r = this.invKeySchedule, a = this.invSBox, o = this.invSubMix, l = o[0], c = o[1], u = o[2], d = o[3], f = this.uint8ArrayToUint32Array_(i);
    let p = f[0], h = f[1], g = f[2], m = f[3];
    const v = new Int32Array(e), y = new Int32Array(v.length);
    let E, T, S, w, b, L, A, _, R, I, k, M, O, F;
    const C = this.networkToHostOrderSwap;
    for (; t < v.length; ) {
      for (R = C(v[t]), I = C(v[t + 1]), k = C(v[t + 2]), M = C(v[t + 3]), b = R ^ r[0], L = M ^ r[1], A = k ^ r[2], _ = I ^ r[3], O = 4, F = 1; F < s; F++)
        E = l[b >>> 24] ^ c[L >> 16 & 255] ^ u[A >> 8 & 255] ^ d[_ & 255] ^ r[O], T = l[L >>> 24] ^ c[A >> 16 & 255] ^ u[_ >> 8 & 255] ^ d[b & 255] ^ r[O + 1], S = l[A >>> 24] ^ c[_ >> 16 & 255] ^ u[b >> 8 & 255] ^ d[L & 255] ^ r[O + 2], w = l[_ >>> 24] ^ c[b >> 16 & 255] ^ u[L >> 8 & 255] ^ d[A & 255] ^ r[O + 3], b = E, L = T, A = S, _ = w, O = O + 4;
      E = a[b >>> 24] << 24 ^ a[L >> 16 & 255] << 16 ^ a[A >> 8 & 255] << 8 ^ a[_ & 255] ^ r[O], T = a[L >>> 24] << 24 ^ a[A >> 16 & 255] << 16 ^ a[_ >> 8 & 255] << 8 ^ a[b & 255] ^ r[O + 1], S = a[A >>> 24] << 24 ^ a[_ >> 16 & 255] << 16 ^ a[b >> 8 & 255] << 8 ^ a[L & 255] ^ r[O + 2], w = a[_ >>> 24] << 24 ^ a[b >> 16 & 255] << 16 ^ a[L >> 8 & 255] << 8 ^ a[A & 255] ^ r[O + 3], y[t] = C(E ^ p), y[t + 1] = C(w ^ h), y[t + 2] = C(S ^ g), y[t + 3] = C(T ^ m), p = R, h = I, g = k, m = M, t = t + 4;
    }
    return y.buffer;
  }
}
class nE {
  constructor(e, t, i) {
    this.subtle = void 0, this.key = void 0, this.aesMode = void 0, this.subtle = e, this.key = t, this.aesMode = i;
  }
  expandKey() {
    const e = aE(this.aesMode);
    return this.subtle.importKey("raw", this.key, {
      name: e
    }, !1, ["encrypt", "decrypt"]);
  }
}
function aE(n) {
  switch (n) {
    case Zs.cbc:
      return "AES-CBC";
    case Zs.ctr:
      return "AES-CTR";
    default:
      throw new Error(`[FastAESKey] invalid aes mode ${n}`);
  }
}
const oE = 16;
class Fu {
  constructor(e, {
    removePKCS7Padding: t = !0
  } = {}) {
    if (this.logEnabled = !0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.useSoftware = void 0, this.enableSoftwareAES = void 0, this.enableSoftwareAES = e.enableSoftwareAES, this.removePKCS7Padding = t, t)
      try {
        const i = self.crypto;
        i && (this.subtle = i.subtle || i.webkitSubtle);
      } catch {
      }
    this.useSoftware = !this.subtle;
  }
  destroy() {
    this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null;
  }
  isSync() {
    return this.useSoftware;
  }
  flush() {
    const {
      currentResult: e,
      remainderData: t
    } = this;
    if (!e || t)
      return this.reset(), null;
    const i = new Uint8Array(e);
    return this.reset(), this.removePKCS7Padding ? sE(i) : i;
  }
  reset() {
    this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null);
  }
  decrypt(e, t, i, s) {
    return this.useSoftware ? new Promise((r, a) => {
      const o = ArrayBuffer.isView(e) ? e : new Uint8Array(e);
      this.softwareDecrypt(o, t, i, s);
      const l = this.flush();
      l ? r(l.buffer) : a(new Error("[softwareDecrypt] Failed to decrypt data"));
    }) : this.webCryptoDecrypt(new Uint8Array(e), t, i, s);
  }
  // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached
  // data is handled in the flush() call
  softwareDecrypt(e, t, i, s) {
    const {
      currentIV: r,
      currentResult: a,
      remainderData: o
    } = this;
    if (s !== Zs.cbc || t.byteLength !== 16)
      return Oe.warn("SoftwareDecrypt: can only handle AES-128-CBC"), null;
    this.logOnce("JS AES decrypt"), o && (e = Oi(o, e), this.remainderData = null);
    const l = this.getValidChunk(e);
    if (!l.length)
      return null;
    r && (i = r);
    let c = this.softwareDecrypter;
    c || (c = this.softwareDecrypter = new rE()), c.expandKey(t);
    const u = a;
    return this.currentResult = c.decrypt(l.buffer, 0, i), this.currentIV = l.slice(-16).buffer, u || null;
  }
  webCryptoDecrypt(e, t, i, s) {
    if (this.key !== t || !this.fastAesKey) {
      if (!this.subtle)
        return Promise.resolve(this.onWebCryptoError(e, t, i, s));
      this.key = t, this.fastAesKey = new nE(this.subtle, t, s);
    }
    return this.fastAesKey.expandKey().then((r) => this.subtle ? (this.logOnce("WebCrypto AES decrypt"), new iE(this.subtle, new Uint8Array(i), s).decrypt(e.buffer, r)) : Promise.reject(new Error("web crypto not initialized"))).catch((r) => (Oe.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${r.name}: ${r.message}`), this.onWebCryptoError(e, t, i, s)));
  }
  onWebCryptoError(e, t, i, s) {
    const r = this.enableSoftwareAES;
    if (r) {
      this.useSoftware = !0, this.logEnabled = !0, this.softwareDecrypt(e, t, i, s);
      const a = this.flush();
      if (a)
        return a.buffer;
    }
    throw new Error("WebCrypto" + (r ? " and softwareDecrypt" : "") + ": failed to decrypt data");
  }
  getValidChunk(e) {
    let t = e;
    const i = e.length - e.length % oE;
    return i !== e.length && (t = e.slice(0, i), this.remainderData = e.slice(i)), t;
  }
  logOnce(e) {
    this.logEnabled && (Oe.log(`[decrypter]: ${e}`), this.logEnabled = !1);
  }
}
const lf = Math.pow(2, 17);
class lE {
  constructor(e) {
    this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = e;
  }
  destroy() {
    this.loader && (this.loader.destroy(), this.loader = null);
  }
  abort() {
    this.loader && this.loader.abort();
  }
  load(e, t) {
    const i = e.url;
    if (!i)
      return Promise.reject(new ms({
        type: se.NETWORK_ERROR,
        details: H.FRAG_LOAD_ERROR,
        fatal: !1,
        frag: e,
        error: new Error(`Fragment does not have a ${i ? "part list" : "url"}`),
        networkDetails: null
      }));
    this.abort();
    const s = this.config, r = s.fLoader, a = s.loader;
    return new Promise((o, l) => {
      if (this.loader && this.loader.destroy(), e.gap)
        if (e.tagList.some((h) => h[0] === "GAP")) {
          l(uf(e));
          return;
        } else
          e.gap = !1;
      const c = this.loader = r ? new r(s) : new a(s), u = cf(e);
      e.loader = c;
      const d = af(s.fragLoadPolicy.default), f = {
        loadPolicy: d,
        timeout: d.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0,
        highWaterMark: e.sn === "initSegment" ? 1 / 0 : lf
      };
      e.stats = c.stats;
      const p = {
        onSuccess: (h, g, m, v) => {
          this.resetLoader(e, c);
          let y = h.data;
          m.resetIV && e.decryptdata && (e.decryptdata.iv = new Uint8Array(y.slice(0, 16)), y = y.slice(16)), o({
            frag: e,
            part: null,
            payload: y,
            networkDetails: v
          });
        },
        onError: (h, g, m, v) => {
          this.resetLoader(e, c), l(new ms({
            type: se.NETWORK_ERROR,
            details: H.FRAG_LOAD_ERROR,
            fatal: !1,
            frag: e,
            response: Me({
              url: i,
              data: void 0
            }, h),
            error: new Error(`HTTP Error ${h.code} ${h.text}`),
            networkDetails: m,
            stats: v
          }));
        },
        onAbort: (h, g, m) => {
          this.resetLoader(e, c), l(new ms({
            type: se.NETWORK_ERROR,
            details: H.INTERNAL_ABORTED,
            fatal: !1,
            frag: e,
            error: new Error("Aborted"),
            networkDetails: m,
            stats: h
          }));
        },
        onTimeout: (h, g, m) => {
          this.resetLoader(e, c), l(new ms({
            type: se.NETWORK_ERROR,
            details: H.FRAG_LOAD_TIMEOUT,
            fatal: !1,
            frag: e,
            error: new Error(`Timeout after ${f.timeout}ms`),
            networkDetails: m,
            stats: h
          }));
        }
      };
      t && (p.onProgress = (h, g, m, v) => t({
        frag: e,
        part: null,
        payload: m,
        networkDetails: v
      })), c.load(u, f, p);
    });
  }
  loadPart(e, t, i) {
    this.abort();
    const s = this.config, r = s.fLoader, a = s.loader;
    return new Promise((o, l) => {
      if (this.loader && this.loader.destroy(), e.gap || t.gap) {
        l(uf(e, t));
        return;
      }
      const c = this.loader = r ? new r(s) : new a(s), u = cf(e, t);
      e.loader = c;
      const d = af(s.fragLoadPolicy.default), f = {
        loadPolicy: d,
        timeout: d.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0,
        highWaterMark: lf
      };
      t.stats = c.stats, c.load(u, f, {
        onSuccess: (p, h, g, m) => {
          this.resetLoader(e, c), this.updateStatsFromPart(e, t);
          const v = {
            frag: e,
            part: t,
            payload: p.data,
            networkDetails: m
          };
          i(v), o(v);
        },
        onError: (p, h, g, m) => {
          this.resetLoader(e, c), l(new ms({
            type: se.NETWORK_ERROR,
            details: H.FRAG_LOAD_ERROR,
            fatal: !1,
            frag: e,
            part: t,
            response: Me({
              url: u.url,
              data: void 0
            }, p),
            error: new Error(`HTTP Error ${p.code} ${p.text}`),
            networkDetails: g,
            stats: m
          }));
        },
        onAbort: (p, h, g) => {
          e.stats.aborted = t.stats.aborted, this.resetLoader(e, c), l(new ms({
            type: se.NETWORK_ERROR,
            details: H.INTERNAL_ABORTED,
            fatal: !1,
            frag: e,
            part: t,
            error: new Error("Aborted"),
            networkDetails: g,
            stats: p
          }));
        },
        onTimeout: (p, h, g) => {
          this.resetLoader(e, c), l(new ms({
            type: se.NETWORK_ERROR,
            details: H.FRAG_LOAD_TIMEOUT,
            fatal: !1,
            frag: e,
            part: t,
            error: new Error(`Timeout after ${f.timeout}ms`),
            networkDetails: g,
            stats: p
          }));
        }
      });
    });
  }
  updateStatsFromPart(e, t) {
    const i = e.stats, s = t.stats, r = s.total;
    if (i.loaded += s.loaded, r) {
      const l = Math.round(e.duration / t.duration), c = Math.min(Math.round(i.loaded / r), l), d = (l - c) * Math.round(i.loaded / c);
      i.total = i.loaded + d;
    } else
      i.total = Math.max(i.loaded, i.total);
    const a = i.loading, o = s.loading;
    a.start ? a.first += o.first - o.start : (a.start = o.start, a.first = o.first), a.end = o.end;
  }
  resetLoader(e, t) {
    e.loader = null, this.loader === t && (self.clearTimeout(this.partLoadTimeout), this.loader = null), t.destroy();
  }
}
function cf(n, e = null) {
  const t = e || n, i = {
    frag: n,
    part: e,
    responseType: "arraybuffer",
    url: t.url,
    headers: {},
    rangeStart: 0,
    rangeEnd: 0
  }, s = t.byteRangeStartOffset, r = t.byteRangeEndOffset;
  if (Z(s) && Z(r)) {
    var a;
    let o = s, l = r;
    if (n.sn === "initSegment" && cE((a = n.decryptdata) == null ? void 0 : a.method)) {
      const c = r - s;
      c % 16 && (l = r + (16 - c % 16)), s !== 0 && (i.resetIV = !0, o = s - 16);
    }
    i.rangeStart = o, i.rangeEnd = l;
  }
  return i;
}
function uf(n, e) {
  const t = new Error(`GAP ${n.gap ? "tag" : "attribute"} found`), i = {
    type: se.MEDIA_ERROR,
    details: H.FRAG_GAP,
    fatal: !1,
    frag: n,
    error: t,
    networkDetails: null
  };
  return e && (i.part = e), (e || n).stats.aborted = !0, new ms(i);
}
function cE(n) {
  return n === "AES-128" || n === "AES-256";
}
class ms extends Error {
  constructor(e) {
    super(e.error.message), this.data = void 0, this.data = e;
  }
}
class ug extends Fi {
  constructor(e, t) {
    super(e, t), this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this);
  }
  destroy() {
    this.onHandlerDestroying(), this.onHandlerDestroyed();
  }
  onHandlerDestroying() {
    this.clearNextTick(), this.clearInterval();
  }
  onHandlerDestroyed() {
  }
  hasInterval() {
    return !!this._tickInterval;
  }
  hasNextTick() {
    return !!this._tickTimer;
  }
  /**
   * @param millis - Interval time (ms)
   * @eturns True when interval has been scheduled, false when already scheduled (no effect)
   */
  setInterval(e) {
    return this._tickInterval ? !1 : (this._tickCallCount = 0, this._tickInterval = self.setInterval(this._boundTick, e), !0);
  }
  /**
   * @returns True when interval was cleared, false when none was set (no effect)
   */
  clearInterval() {
    return this._tickInterval ? (self.clearInterval(this._tickInterval), this._tickInterval = null, !0) : !1;
  }
  /**
   * @returns True when timeout was cleared, false when none was set (no effect)
   */
  clearNextTick() {
    return this._tickTimer ? (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0) : !1;
  }
  /**
   * Will call the subclass doTick implementation in this main loop tick
   * or in the next one (via setTimeout(,0)) in case it has already been called
   * in this tick (in case this is a re-entrant call).
   */
  tick() {
    this._tickCallCount++, this._tickCallCount === 1 && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0);
  }
  tickImmediate() {
    this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0);
  }
  /**
   * For subclass to implement task logic
   * @abstract
   */
  doTick() {
  }
}
class Nu {
  constructor(e, t, i, s = 0, r = -1, a = !1) {
    this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = za(), this.buffering = {
      audio: za(),
      video: za(),
      audiovideo: za()
    }, this.level = e, this.sn = t, this.id = i, this.size = s, this.part = r, this.partial = a;
  }
}
function za() {
  return {
    start: 0,
    executeStart: 0,
    executeEnd: 0,
    end: 0
  };
}
const df = {
  length: 0,
  start: () => 0,
  end: () => 0
};
class de {
  /**
   * Return true if `media`'s buffered include `position`
   */
  static isBuffered(e, t) {
    if (e) {
      const i = de.getBuffered(e);
      for (let s = i.length; s--; )
        if (t >= i.start(s) && t <= i.end(s))
          return !0;
    }
    return !1;
  }
  static bufferedRanges(e) {
    if (e) {
      const t = de.getBuffered(e);
      return de.timeRangesToArray(t);
    }
    return [];
  }
  static timeRangesToArray(e) {
    const t = [];
    for (let i = 0; i < e.length; i++)
      t.push({
        start: e.start(i),
        end: e.end(i)
      });
    return t;
  }
  static bufferInfo(e, t, i) {
    if (e) {
      const s = de.bufferedRanges(e);
      if (s.length)
        return de.bufferedInfo(s, t, i);
    }
    return {
      len: 0,
      start: t,
      end: t,
      bufferedIndex: -1
    };
  }
  static bufferedInfo(e, t, i) {
    t = Math.max(0, t), e.length > 1 && e.sort((u, d) => u.start - d.start || d.end - u.end);
    let s = -1, r = [];
    if (i)
      for (let u = 0; u < e.length; u++) {
        t >= e[u].start && t <= e[u].end && (s = u);
        const d = r.length;
        if (d) {
          const f = r[d - 1].end;
          e[u].start - f < i ? e[u].end > f && (r[d - 1].end = e[u].end) : r.push(e[u]);
        } else
          r.push(e[u]);
      }
    else
      r = e;
    let a = 0, o, l = t, c = t;
    for (let u = 0; u < r.length; u++) {
      const d = r[u].start, f = r[u].end;
      if (s === -1 && t >= d && t <= f && (s = u), t + i >= d && t < f)
        l = d, c = f, a = c - t;
      else if (t + i < d) {
        o = d;
        break;
      }
    }
    return {
      len: a,
      start: l || 0,
      end: c || 0,
      nextStart: o,
      buffered: e,
      bufferedIndex: s
    };
  }
  /**
   * Safe method to get buffered property.
   * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource
   */
  static getBuffered(e) {
    try {
      return e.buffered || df;
    } catch (t) {
      return Oe.log("failed to get media.buffered", t), df;
    }
  }
}
const dg = /\{\$([a-zA-Z0-9-_]+)\}/g;
function ff(n) {
  return dg.test(n);
}
function Fc(n, e) {
  if (n.variableList !== null || n.hasVariableRefs) {
    const t = n.variableList;
    return e.replace(dg, (i) => {
      const s = i.substring(2, i.length - 1), r = t?.[s];
      return r === void 0 ? (n.playlistParsingError || (n.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${s}"`)), i) : r;
    });
  }
  return e;
}
function hf(n, e, t) {
  let i = n.variableList;
  i || (n.variableList = i = {});
  let s, r;
  if ("QUERYPARAM" in e) {
    s = e.QUERYPARAM;
    try {
      const a = new self.URL(t).searchParams;
      if (a.has(s))
        r = a.get(s);
      else
        throw new Error(`"${s}" does not match any query parameter in URI: "${t}"`);
    } catch (a) {
      n.playlistParsingError || (n.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${a.message}`));
    }
  } else
    s = e.NAME, r = e.VALUE;
  s in i ? n.playlistParsingError || (n.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${s}"`)) : i[s] = r || "";
}
function uE(n, e, t) {
  const i = e.IMPORT;
  if (t && i in t) {
    let s = n.variableList;
    s || (n.variableList = s = {}), s[i] = t[i];
  } else
    n.playlistParsingError || (n.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${i}"`));
}
const dE = /^(\d+)x(\d+)$/, pf = /(.+?)=(".*?"|.*?)(?:,|$)/g;
class je {
  constructor(e, t) {
    typeof e == "string" && (e = je.parseAttrList(e, t)), Fe(this, e);
  }
  get clientAttrs() {
    return Object.keys(this).filter((e) => e.substring(0, 2) === "X-");
  }
  decimalInteger(e) {
    const t = parseInt(this[e], 10);
    return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t;
  }
  hexadecimalInteger(e) {
    if (this[e]) {
      let t = (this[e] || "0x").slice(2);
      t = (t.length & 1 ? "0" : "") + t;
      const i = new Uint8Array(t.length / 2);
      for (let s = 0; s < t.length / 2; s++)
        i[s] = parseInt(t.slice(s * 2, s * 2 + 2), 16);
      return i;
    }
    return null;
  }
  hexadecimalIntegerAsNumber(e) {
    const t = parseInt(this[e], 16);
    return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t;
  }
  decimalFloatingPoint(e) {
    return parseFloat(this[e]);
  }
  optionalFloat(e, t) {
    const i = this[e];
    return i ? parseFloat(i) : t;
  }
  enumeratedString(e) {
    return this[e];
  }
  enumeratedStringList(e, t) {
    const i = this[e];
    return (i ? i.split(/[ ,]+/) : []).reduce((s, r) => (s[r.toLowerCase()] = !0, s), t);
  }
  bool(e) {
    return this[e] === "YES";
  }
  decimalResolution(e) {
    const t = dE.exec(this[e]);
    if (t !== null)
      return {
        width: parseInt(t[1], 10),
        height: parseInt(t[2], 10)
      };
  }
  static parseAttrList(e, t) {
    let i;
    const s = {};
    for (pf.lastIndex = 0; (i = pf.exec(e)) !== null; ) {
      const a = i[1].trim();
      let o = i[2];
      const l = o.indexOf('"') === 0 && o.lastIndexOf('"') === o.length - 1;
      let c = !1;
      if (l)
        o = o.slice(1, -1);
      else
        switch (a) {
          case "IV":
          case "SCTE35-CMD":
          case "SCTE35-IN":
          case "SCTE35-OUT":
            c = !0;
        }
      if (t && (l || c))
        o = Fc(t, o);
      else if (!c && !l)
        switch (a) {
          case "CLOSED-CAPTIONS":
            if (o === "NONE")
              break;
          // falls through
          case "ALLOWED-CPC":
          case "CLASS":
          case "ASSOC-LANGUAGE":
          case "AUDIO":
          case "BYTERANGE":
          case "CHANNELS":
          case "CHARACTERISTICS":
          case "CODECS":
          case "DATA-ID":
          case "END-DATE":
          case "GROUP-ID":
          case "ID":
          case "IMPORT":
          case "INSTREAM-ID":
          case "KEYFORMAT":
          case "KEYFORMATVERSIONS":
          case "LANGUAGE":
          case "NAME":
          case "PATHWAY-ID":
          case "QUERYPARAM":
          case "RECENTLY-REMOVED-DATERANGES":
          case "SERVER-URI":
          case "STABLE-RENDITION-ID":
          case "STABLE-VARIANT-ID":
          case "START-DATE":
          case "SUBTITLES":
          case "SUPPLEMENTAL-CODECS":
          case "URI":
          case "VALUE":
          case "VIDEO":
          case "X-ASSET-LIST":
          case "X-ASSET-URI":
            Oe.warn(`${e}: attribute ${a} is missing quotes`);
        }
      s[a] = o;
    }
    return s;
  }
}
const fE = "com.apple.hls.interstitial";
function hE(n) {
  return n !== "ID" && n !== "CLASS" && n !== "CUE" && n !== "START-DATE" && n !== "DURATION" && n !== "END-DATE" && n !== "END-ON-NEXT";
}
function pE(n) {
  return n === "SCTE35-OUT" || n === "SCTE35-IN" || n === "SCTE35-CMD";
}
class fg {
  constructor(e, t, i = 0) {
    var s;
    if (this.attr = void 0, this.tagAnchor = void 0, this.tagOrder = void 0, this._startDate = void 0, this._endDate = void 0, this._dateAtEnd = void 0, this._cue = void 0, this._badValueForSameId = void 0, this.tagAnchor = t?.tagAnchor || null, this.tagOrder = (s = t?.tagOrder) != null ? s : i, t) {
      const r = t.attr;
      for (const a in r)
        if (Object.prototype.hasOwnProperty.call(e, a) && e[a] !== r[a]) {
          Oe.warn(`DATERANGE tag attribute: "${a}" does not match for tags with ID: "${e.ID}"`), this._badValueForSameId = a;
          break;
        }
      e = Fe(new je({}), r, e);
    }
    if (this.attr = e, t ? (this._startDate = t._startDate, this._cue = t._cue, this._endDate = t._endDate, this._dateAtEnd = t._dateAtEnd) : this._startDate = new Date(e["START-DATE"]), "END-DATE" in this.attr) {
      const r = t?.endDate || new Date(this.attr["END-DATE"]);
      Z(r.getTime()) && (this._endDate = r);
    }
  }
  get id() {
    return this.attr.ID;
  }
  get class() {
    return this.attr.CLASS;
  }
  get cue() {
    const e = this._cue;
    return e === void 0 ? this._cue = this.attr.enumeratedStringList(this.attr.CUE ? "CUE" : "X-CUE", {
      pre: !1,
      post: !1,
      once: !1
    }) : e;
  }
  get startTime() {
    const {
      tagAnchor: e
    } = this;
    return e === null || e.programDateTime === null ? (Oe.warn(`Expected tagAnchor Fragment with PDT set for DateRange "${this.id}": ${e}`), NaN) : e.start + (this.startDate.getTime() - e.programDateTime) / 1e3;
  }
  get startDate() {
    return this._startDate;
  }
  get endDate() {
    const e = this._endDate || this._dateAtEnd;
    if (e)
      return e;
    const t = this.duration;
    return t !== null ? this._dateAtEnd = new Date(this._startDate.getTime() + t * 1e3) : null;
  }
  get duration() {
    if ("DURATION" in this.attr) {
      const e = this.attr.decimalFloatingPoint("DURATION");
      if (Z(e))
        return e;
    } else if (this._endDate)
      return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
    return null;
  }
  get plannedDuration() {
    return "PLANNED-DURATION" in this.attr ? this.attr.decimalFloatingPoint("PLANNED-DURATION") : null;
  }
  get endOnNext() {
    return this.attr.bool("END-ON-NEXT");
  }
  get isInterstitial() {
    return this.class === fE;
  }
  get isValid() {
    return !!this.id && !this._badValueForSameId && Z(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class) && (!this.attr.CUE || !this.cue.pre && !this.cue.post || this.cue.pre !== this.cue.post) && (!this.isInterstitial || "X-ASSET-URI" in this.attr || "X-ASSET-LIST" in this.attr);
  }
}
const gE = 10;
class mE {
  constructor(e) {
    this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.dateRangeTagCount = 0, this.live = !0, this.requestScheduled = -1, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.misses = 0, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.encryptedFragments = void 0, this.playlistParsingError = null, this.variableList = null, this.hasVariableRefs = !1, this.appliedTimelineOffset = void 0, this.fragments = [], this.encryptedFragments = [], this.dateRanges = {}, this.url = e;
  }
  reloaded(e) {
    if (!e) {
      this.advanced = !0, this.updated = !0;
      return;
    }
    const t = this.lastPartSn - e.lastPartSn, i = this.lastPartIndex - e.lastPartIndex;
    this.updated = this.endSN !== e.endSN || !!i || !!t || !this.live, this.advanced = this.endSN > e.endSN || t > 0 || t === 0 && i > 0, this.updated || this.advanced ? this.misses = Math.floor(e.misses * 0.6) : this.misses = e.misses + 1;
  }
  hasKey(e) {
    return this.encryptedFragments.some((t) => {
      let i = t.decryptdata;
      return i || (t.setKeyFormat(e.keyFormat), i = t.decryptdata), !!i && e.matches(i);
    });
  }
  get hasProgramDateTime() {
    return this.fragments.length ? Z(this.fragments[this.fragments.length - 1].programDateTime) : !1;
  }
  get levelTargetDuration() {
    return this.averagetargetduration || this.targetduration || gE;
  }
  get drift() {
    const e = this.driftEndTime - this.driftStartTime;
    return e > 0 ? (this.driftEnd - this.driftStart) * 1e3 / e : 1;
  }
  get edge() {
    return this.partEnd || this.fragmentEnd;
  }
  get partEnd() {
    var e;
    return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd;
  }
  get fragmentEnd() {
    return this.fragments.length ? this.fragments[this.fragments.length - 1].end : 0;
  }
  get fragmentStart() {
    return this.fragments.length ? this.fragments[0].start : 0;
  }
  get age() {
    return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0;
  }
  get lastPartIndex() {
    var e;
    return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].index : -1;
  }
  get maxPartIndex() {
    const e = this.partList;
    if (e) {
      const t = this.lastPartIndex;
      if (t !== -1) {
        for (let i = e.length; i--; )
          if (e[i].index > t)
            return e[i].index;
        return t;
      }
    }
    return 0;
  }
  get lastPartSn() {
    var e;
    return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN;
  }
  get expired() {
    if (this.live && this.age && this.misses < 3) {
      const e = this.partEnd - this.fragmentStart;
      return this.age > Math.max(e, this.totalduration) + this.levelTargetDuration;
    }
    return !1;
  }
}
function Ho(n, e) {
  return n.length === e.length ? !n.some((t, i) => t !== e[i]) : !1;
}
function gf(n, e) {
  return !n && !e ? !0 : !n || !e ? !1 : Ho(n, e);
}
function an(n) {
  return n === "AES-128" || n === "AES-256" || n === "AES-256-CTR";
}
function $u(n) {
  switch (n) {
    case "AES-128":
    case "AES-256":
      return Zs.cbc;
    case "AES-256-CTR":
      return Zs.ctr;
    default:
      throw new Error(`invalid full segment method ${n}`);
  }
}
function Bu(n) {
  return Uint8Array.from(atob(n), (e) => e.charCodeAt(0));
}
function Nc(n) {
  return Uint8Array.from(unescape(encodeURIComponent(n)), (e) => e.charCodeAt(0));
}
function vE(n) {
  const e = Nc(n).subarray(0, 16), t = new Uint8Array(16);
  return t.set(e, 16 - e.length), t;
}
function hg(n) {
  const e = function(i, s, r) {
    const a = i[s];
    i[s] = i[r], i[r] = a;
  };
  e(n, 0, 3), e(n, 1, 2), e(n, 4, 5), e(n, 6, 7);
}
function pg(n) {
  const e = n.split(":");
  let t = null;
  if (e[0] === "data" && e.length === 2) {
    const i = e[1].split(";"), s = i[i.length - 1].split(",");
    if (s.length === 2) {
      const r = s[0] === "base64", a = s[1];
      r ? (i.splice(-1, 1), t = Bu(a)) : t = vE(a);
    }
  }
  return t;
}
const Vo = typeof self < "u" ? self : void 0;
var Ze = {
  CLEARKEY: "org.w3.clearkey",
  FAIRPLAY: "com.apple.fps",
  PLAYREADY: "com.microsoft.playready",
  WIDEVINE: "com.widevine.alpha"
}, Ct = {
  CLEARKEY: "org.w3.clearkey",
  FAIRPLAY: "com.apple.streamingkeydelivery",
  PLAYREADY: "com.microsoft.playready",
  WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed"
};
function go(n) {
  switch (n) {
    case Ct.FAIRPLAY:
      return Ze.FAIRPLAY;
    case Ct.PLAYREADY:
      return Ze.PLAYREADY;
    case Ct.WIDEVINE:
      return Ze.WIDEVINE;
    case Ct.CLEARKEY:
      return Ze.CLEARKEY;
  }
}
function Rl(n) {
  switch (n) {
    case Ze.FAIRPLAY:
      return Ct.FAIRPLAY;
    case Ze.PLAYREADY:
      return Ct.PLAYREADY;
    case Ze.WIDEVINE:
      return Ct.WIDEVINE;
    case Ze.CLEARKEY:
      return Ct.CLEARKEY;
  }
}
function Nn(n) {
  const {
    drmSystems: e,
    widevineLicenseUrl: t
  } = n, i = e ? [Ze.FAIRPLAY, Ze.WIDEVINE, Ze.PLAYREADY, Ze.CLEARKEY].filter((s) => !!e[s]) : [];
  return !i[Ze.WIDEVINE] && t && i.push(Ze.WIDEVINE), i;
}
const gg = (function(n) {
  return Vo != null && (n = Vo.navigator) != null && n.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null;
})();
function yE(n, e, t, i) {
  let s;
  switch (n) {
    case Ze.FAIRPLAY:
      s = ["cenc", "sinf"];
      break;
    case Ze.WIDEVINE:
    case Ze.PLAYREADY:
      s = ["cenc"];
      break;
    case Ze.CLEARKEY:
      s = ["cenc", "keyids"];
      break;
    default:
      throw new Error(`Unknown key-system: ${n}`);
  }
  return EE(s, e, t, i);
}
function EE(n, e, t, i) {
  return [{
    initDataTypes: n,
    persistentState: i.persistentState || "optional",
    distinctiveIdentifier: i.distinctiveIdentifier || "optional",
    sessionTypes: i.sessionTypes || [i.sessionType || "temporary"],
    audioCapabilities: e.map((r) => ({
      contentType: `audio/mp4; codecs=${r}`,
      robustness: i.audioRobustness || "",
      encryptionScheme: i.audioEncryptionScheme || null
    })),
    videoCapabilities: t.map((r) => ({
      contentType: `video/mp4; codecs=${r}`,
      robustness: i.videoRobustness || "",
      encryptionScheme: i.videoEncryptionScheme || null
    }))
  }];
}
function TE(n) {
  var e;
  return !!n && (n.sessionType === "persistent-license" || !!((e = n.sessionTypes) != null && e.some((t) => t === "persistent-license")));
}
function mg(n) {
  const e = new Uint16Array(n.buffer, n.byteOffset, n.byteLength / 2), t = String.fromCharCode.apply(null, Array.from(e)), i = t.substring(t.indexOf("<"), t.length), a = new DOMParser().parseFromString(i, "text/xml").getElementsByTagName("KID")[0];
  if (a) {
    const o = a.childNodes[0] ? a.childNodes[0].nodeValue : a.getAttribute("VALUE");
    if (o) {
      const l = Bu(o).subarray(0, 16);
      return hg(l), l;
    }
  }
  return null;
}
let Gr = {};
class Ys {
  static clearKeyUriToKeyIdMap() {
    Gr = {};
  }
  static setKeyIdForUri(e, t) {
    Gr[e] = t;
  }
  static addKeyIdForUri(e) {
    const t = Object.keys(Gr).length % Number.MAX_SAFE_INTEGER, i = new Uint8Array(16);
    return new DataView(i.buffer, 12, 4).setUint32(0, t), Gr[e] = i, i;
  }
  constructor(e, t, i, s = [1], r = null, a) {
    this.uri = void 0, this.method = void 0, this.keyFormat = void 0, this.keyFormatVersions = void 0, this.encrypted = void 0, this.isCommonEncryption = void 0, this.iv = null, this.key = null, this.keyId = null, this.pssh = null, this.method = e, this.uri = t, this.keyFormat = i, this.keyFormatVersions = s, this.iv = r, this.encrypted = e ? e !== "NONE" : !1, this.isCommonEncryption = this.encrypted && !an(e), a != null && a.startsWith("0x") && (this.keyId = new Uint8Array(zp(a)));
  }
  matches(e) {
    return e.uri === this.uri && e.method === this.method && e.encrypted === this.encrypted && e.keyFormat === this.keyFormat && Ho(e.keyFormatVersions, this.keyFormatVersions) && gf(e.iv, this.iv) && gf(e.keyId, this.keyId);
  }
  isSupported() {
    if (this.method) {
      if (an(this.method) || this.method === "NONE")
        return !0;
      if (this.keyFormat === "identity")
        return this.method === "SAMPLE-AES";
      switch (this.keyFormat) {
        case Ct.FAIRPLAY:
        case Ct.WIDEVINE:
        case Ct.PLAYREADY:
        case Ct.CLEARKEY:
          return ["SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method) !== -1;
      }
    }
    return !1;
  }
  getDecryptData(e, t) {
    if (!this.encrypted || !this.uri)
      return null;
    if (an(this.method)) {
      let r = this.iv;
      return r || (typeof e != "number" && (Oe.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`), e = 0), r = xE(e)), new Ys(this.method, this.uri, "identity", this.keyFormatVersions, r);
    }
    if (this.keyId) {
      const r = Gr[this.uri];
      if (r && !Ho(this.keyId, r) && Ys.setKeyIdForUri(this.uri, this.keyId), this.pssh)
        return this;
    }
    const i = pg(this.uri);
    if (i)
      switch (this.keyFormat) {
        case Ct.WIDEVINE:
          if (this.pssh = i, !this.keyId) {
            const r = Ay(i.buffer);
            if (r.length) {
              var s;
              const a = r[0];
              this.keyId = (s = a.kids) != null && s.length ? a.kids[0] : null;
            }
          }
          this.keyId || (this.keyId = mf(t));
          break;
        case Ct.PLAYREADY: {
          const r = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
          this.pssh = _y(r, null, i), this.keyId = mg(i);
          break;
        }
        default: {
          let r = i.subarray(0, 16);
          if (r.length !== 16) {
            const a = new Uint8Array(16);
            a.set(r, 16 - r.length), r = a;
          }
          this.keyId = r;
          break;
        }
      }
    if (!this.keyId || this.keyId.byteLength !== 16) {
      let r;
      r = SE(t), r || (r = mf(t), r || (r = Gr[this.uri])), r && (this.keyId = r, Ys.setKeyIdForUri(this.uri, r));
    }
    return this;
  }
}
function SE(n) {
  const e = n?.[Ct.WIDEVINE];
  return e ? e.keyId : null;
}
function mf(n) {
  const e = n?.[Ct.PLAYREADY];
  if (e) {
    const t = pg(e.uri);
    if (t)
      return mg(t);
  }
  return null;
}
function xE(n) {
  const e = new Uint8Array(16);
  for (let t = 12; t < 16; t++)
    e[t] = n >> 8 * (15 - t) & 255;
  return e;
}
const vf = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g, yf = /#EXT-X-MEDIA:(.*)/g, bE = /^#EXT(?:INF|-X-TARGETDURATION):/m, Cl = new RegExp([
  /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
  // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
  /(?!#) *(\S[^\r\n]*)/.source,
  // segment URI, group 3 => the URI (note newline is not eaten)
  /#.*/.source
  // All other non-segment oriented tags will match with all groups empty
].join("|"), "g"), _E = new RegExp([/#EXT-X-(PROGRAM-DATE-TIME|BYTERANGE|DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"));
class ns {
  static findGroup(e, t) {
    for (let i = 0; i < e.length; i++) {
      const s = e[i];
      if (s.id === t)
        return s;
    }
  }
  static resolve(e, t) {
    return Cu.buildAbsoluteURL(t, e, {
      alwaysNormalize: !0
    });
  }
  static isMediaPlaylist(e) {
    return bE.test(e);
  }
  static parseMasterPlaylist(e, t) {
    const i = ff(e), s = {
      contentSteering: null,
      levels: [],
      playlistParsingError: null,
      sessionData: null,
      sessionKeys: null,
      startTimeOffset: null,
      variableList: null,
      hasVariableRefs: i
    }, r = [];
    if (vf.lastIndex = 0, !e.startsWith("#EXTM3U"))
      return s.playlistParsingError = new Error("no EXTM3U delimiter"), s;
    let a;
    for (; (a = vf.exec(e)) != null; )
      if (a[1]) {
        var o;
        const c = new je(a[1], s), u = Fc(s, a[2]), d = {
          attrs: c,
          bitrate: c.decimalInteger("BANDWIDTH") || c.decimalInteger("AVERAGE-BANDWIDTH"),
          name: c.NAME,
          url: ns.resolve(u, t)
        }, f = c.decimalResolution("RESOLUTION");
        f && (d.width = f.width, d.height = f.height), Sf(c.CODECS, d);
        const p = c["SUPPLEMENTAL-CODECS"];
        p && (d.supplemental = {}, Sf(p, d.supplemental)), (o = d.unknownCodecs) != null && o.length || r.push(d), s.levels.push(d);
      } else if (a[3]) {
        const c = a[3], u = a[4];
        switch (c) {
          case "SESSION-DATA": {
            const d = new je(u, s), f = d["DATA-ID"];
            f && (s.sessionData === null && (s.sessionData = {}), s.sessionData[f] = d);
            break;
          }
          case "SESSION-KEY": {
            const d = Ef(u, t, s);
            d.encrypted && d.isSupported() ? (s.sessionKeys === null && (s.sessionKeys = []), s.sessionKeys.push(d)) : Oe.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${u}"`);
            break;
          }
          case "DEFINE": {
            {
              const d = new je(u, s);
              hf(s, d, t);
            }
            break;
          }
          case "CONTENT-STEERING": {
            const d = new je(u, s);
            s.contentSteering = {
              uri: ns.resolve(d["SERVER-URI"], t),
              pathwayId: d["PATHWAY-ID"] || "."
            };
            break;
          }
          case "START": {
            s.startTimeOffset = Tf(u);
            break;
          }
        }
      }
    const l = r.length > 0 && r.length < s.levels.length;
    return s.levels = l ? r : s.levels, s.levels.length === 0 && (s.playlistParsingError = new Error("no levels found in manifest")), s;
  }
  static parseMasterPlaylistMedia(e, t, i) {
    let s;
    const r = {}, a = i.levels, o = {
      AUDIO: a.map((c) => ({
        id: c.attrs.AUDIO,
        audioCodec: c.audioCodec
      })),
      SUBTITLES: a.map((c) => ({
        id: c.attrs.SUBTITLES,
        textCodec: c.textCodec
      })),
      "CLOSED-CAPTIONS": []
    };
    let l = 0;
    for (yf.lastIndex = 0; (s = yf.exec(e)) !== null; ) {
      const c = new je(s[1], i), u = c.TYPE;
      if (u) {
        const d = o[u], f = r[u] || [];
        r[u] = f;
        const p = c.LANGUAGE, h = c["ASSOC-LANGUAGE"], g = c.CHANNELS, m = c.CHARACTERISTICS, v = c["INSTREAM-ID"], y = {
          attrs: c,
          bitrate: 0,
          id: l++,
          groupId: c["GROUP-ID"] || "",
          name: c.NAME || p || "",
          type: u,
          default: c.bool("DEFAULT"),
          autoselect: c.bool("AUTOSELECT"),
          forced: c.bool("FORCED"),
          lang: p,
          url: c.URI ? ns.resolve(c.URI, t) : ""
        };
        if (h && (y.assocLang = h), g && (y.channels = g), m && (y.characteristics = m), v && (y.instreamId = v), d != null && d.length) {
          const E = ns.findGroup(d, y.groupId) || d[0];
          xf(y, E, "audioCodec"), xf(y, E, "textCodec");
        }
        f.push(y);
      }
    }
    return r;
  }
  static parseLevelPlaylist(e, t, i, s, r, a) {
    var o;
    const l = {
      url: t
    }, c = new mE(t), u = c.fragments, d = [];
    let f = null, p = 0, h = 0, g = 0, m = 0, v = 0, y = null, E = new wl(s, l), T, S, w, b = -1, L = !1, A = null, _;
    if (Cl.lastIndex = 0, c.m3u8 = e, c.hasVariableRefs = ff(e), ((o = Cl.exec(e)) == null ? void 0 : o[0]) !== "#EXTM3U")
      return c.playlistParsingError = new Error("Missing format identifier #EXTM3U"), c;
    for (; (T = Cl.exec(e)) !== null; ) {
      L && (L = !1, E = new wl(s, l), E.playlistOffset = g, E.setStart(g), E.sn = p, E.cc = m, v && (E.bitrate = v), E.level = i, f && (E.initSegment = f, f.rawProgramDateTime && (E.rawProgramDateTime = f.rawProgramDateTime, f.rawProgramDateTime = null), A && (E.setByteRange(A), A = null)));
      const M = T[1];
      if (M) {
        E.duration = parseFloat(M);
        const O = (" " + T[2]).slice(1);
        E.title = O || null, E.tagList.push(O ? ["INF", M, O] : ["INF", M]);
      } else if (T[3]) {
        if (Z(E.duration)) {
          E.playlistOffset = g, E.setStart(g), w && _f(E, w, c), E.sn = p, E.level = i, E.cc = m, u.push(E);
          const O = (" " + T[3]).slice(1);
          E.relurl = Fc(c, O), $c(E, y, d), y = E, g += E.duration, p++, h = 0, L = !0;
        }
      } else {
        if (T = T[0].match(_E), !T) {
          Oe.warn("No matches on slow regex match for level playlist!");
          continue;
        }
        for (S = 1; S < T.length && T[S] === void 0; S++)
          ;
        const O = (" " + T[S]).slice(1), F = (" " + T[S + 1]).slice(1), C = T[S + 2] ? (" " + T[S + 2]).slice(1) : null;
        switch (O) {
          case "BYTERANGE":
            y ? E.setByteRange(F, y) : E.setByteRange(F);
            break;
          case "PROGRAM-DATE-TIME":
            E.rawProgramDateTime = F, E.tagList.push(["PROGRAM-DATE-TIME", F]), b === -1 && (b = u.length);
            break;
          case "PLAYLIST-TYPE":
            c.type && hs(c, O, T), c.type = F.toUpperCase();
            break;
          case "MEDIA-SEQUENCE":
            c.startSN !== 0 ? hs(c, O, T) : u.length > 0 && Af(c, O, T), p = c.startSN = parseInt(F);
            break;
          case "SKIP": {
            c.skippedSegments && hs(c, O, T);
            const D = new je(F, c), B = D.decimalInteger("SKIPPED-SEGMENTS");
            if (Z(B)) {
              c.skippedSegments += B;
              for (let K = B; K--; )
                u.push(null);
              p += B;
            }
            const P = D.enumeratedString("RECENTLY-REMOVED-DATERANGES");
            P && (c.recentlyRemovedDateranges = (c.recentlyRemovedDateranges || []).concat(P.split("	")));
            break;
          }
          case "TARGETDURATION":
            c.targetduration !== 0 && hs(c, O, T), c.targetduration = Math.max(parseInt(F), 1);
            break;
          case "VERSION":
            c.version !== null && hs(c, O, T), c.version = parseInt(F);
            break;
          case "INDEPENDENT-SEGMENTS":
            break;
          case "ENDLIST":
            c.live || hs(c, O, T), c.live = !1;
            break;
          case "#":
            (F || C) && E.tagList.push(C ? [F, C] : [F]);
            break;
          case "DISCONTINUITY":
            m++, E.tagList.push(["DIS"]);
            break;
          case "GAP":
            E.gap = !0, E.tagList.push([O]);
            break;
          case "BITRATE":
            E.tagList.push([O, F]), v = parseInt(F) * 1e3, Z(v) ? E.bitrate = v : v = 0;
            break;
          case "DATERANGE": {
            const D = new je(F, c), B = new fg(D, c.dateRanges[D.ID], c.dateRangeTagCount);
            c.dateRangeTagCount++, B.isValid || c.skippedSegments ? c.dateRanges[B.id] = B : Oe.warn(`Ignoring invalid DATERANGE tag: "${F}"`), E.tagList.push(["EXT-X-DATERANGE", F]);
            break;
          }
          case "DEFINE": {
            {
              const D = new je(F, c);
              "IMPORT" in D ? uE(c, D, a) : hf(c, D, t);
            }
            break;
          }
          case "DISCONTINUITY-SEQUENCE":
            c.startCC !== 0 ? hs(c, O, T) : u.length > 0 && Af(c, O, T), c.startCC = m = parseInt(F);
            break;
          case "KEY": {
            const D = Ef(F, t, c);
            if (D.isSupported()) {
              if (D.method === "NONE") {
                w = void 0;
                break;
              }
              w || (w = {});
              const B = w[D.keyFormat];
              B != null && B.matches(D) || (B && (w = Fe({}, w)), w[D.keyFormat] = D);
            } else
              Oe.warn(`[Keys] Ignoring unsupported EXT-X-KEY tag: "${F}"`);
            break;
          }
          case "START":
            c.startTimeOffset = Tf(F);
            break;
          case "MAP": {
            const D = new je(F, c);
            if (E.duration) {
              const B = new wl(s, l);
              bf(B, D, i, w), f = B, E.initSegment = f, f.rawProgramDateTime && !E.rawProgramDateTime && (E.rawProgramDateTime = f.rawProgramDateTime);
            } else {
              const B = E.byteRangeEndOffset;
              if (B) {
                const P = E.byteRangeStartOffset;
                A = `${B - P}@${P}`;
              } else
                A = null;
              bf(E, D, i, w), f = E, L = !0;
            }
            f.cc = m;
            break;
          }
          case "SERVER-CONTROL": {
            _ && hs(c, O, T), _ = new je(F), c.canBlockReload = _.bool("CAN-BLOCK-RELOAD"), c.canSkipUntil = _.optionalFloat("CAN-SKIP-UNTIL", 0), c.canSkipDateRanges = c.canSkipUntil > 0 && _.bool("CAN-SKIP-DATERANGES"), c.partHoldBack = _.optionalFloat("PART-HOLD-BACK", 0), c.holdBack = _.optionalFloat("HOLD-BACK", 0);
            break;
          }
          case "PART-INF": {
            c.partTarget && hs(c, O, T);
            const D = new je(F);
            c.partTarget = D.decimalFloatingPoint("PART-TARGET");
            break;
          }
          case "PART": {
            let D = c.partList;
            D || (D = c.partList = []);
            const B = h > 0 ? D[D.length - 1] : void 0, P = h++, K = new je(F, c), X = new uy(K, E, l, P, B);
            D.push(X), E.duration += X.duration;
            break;
          }
          case "PRELOAD-HINT": {
            const D = new je(F, c);
            c.preloadHint = D;
            break;
          }
          case "RENDITION-REPORT": {
            const D = new je(F, c);
            c.renditionReports = c.renditionReports || [], c.renditionReports.push(D);
            break;
          }
          default:
            Oe.warn(`line parsed but not handled: ${T}`);
            break;
        }
      }
    }
    y && !y.relurl ? (u.pop(), g -= y.duration, c.partList && (c.fragmentHint = y)) : c.partList && ($c(E, y, d), E.cc = m, c.fragmentHint = E, w && _f(E, w, c)), c.targetduration || (c.playlistParsingError = new Error("Missing Target Duration"));
    const R = u.length, I = u[0], k = u[R - 1];
    if (g += c.skippedSegments * c.targetduration, g > 0 && R && k) {
      c.averagetargetduration = g / R;
      const M = k.sn;
      c.endSN = M !== "initSegment" ? M : 0, c.live || (k.endList = !0), b > 0 && (wE(u, b), I && d.unshift(I));
    }
    return c.fragmentHint && (g += c.fragmentHint.duration), c.totalduration = g, d.length && c.dateRangeTagCount && I && vg(d, c), c.endCC = m, c;
  }
}
function vg(n, e) {
  let t = n.length;
  if (!t)
    if (e.hasProgramDateTime) {
      const o = e.fragments[e.fragments.length - 1];
      n.push(o), t++;
    } else
      return;
  const i = n[t - 1], s = e.live ? 1 / 0 : e.totalduration, r = Object.keys(e.dateRanges);
  for (let o = r.length; o--; ) {
    const l = e.dateRanges[r[o]], c = l.startDate.getTime();
    l.tagAnchor = i.ref;
    for (let u = t; u--; ) {
      var a;
      if (((a = n[u]) == null ? void 0 : a.sn) < e.startSN)
        break;
      const d = AE(e, c, n, u, s);
      if (d !== -1) {
        l.tagAnchor = e.fragments[d].ref;
        break;
      }
    }
  }
}
function AE(n, e, t, i, s) {
  const r = t[i];
  if (r) {
    const o = r.programDateTime;
    if (e >= o || i === 0) {
      var a;
      const l = (((a = t[i + 1]) == null ? void 0 : a.start) || s) - r.start;
      if (e <= o + l * 1e3) {
        const c = t[i].sn - n.startSN;
        if (c < 0)
          return -1;
        const u = n.fragments;
        if (u.length > t.length) {
          const f = (t[i + 1] || u[u.length - 1]).sn - n.startSN;
          for (let p = f; p > c; p--) {
            const h = u[p].programDateTime;
            if (e >= h && e < h + u[p].duration * 1e3)
              return p;
          }
        }
        return c;
      }
    }
  }
  return -1;
}
function Ef(n, e, t) {
  var i, s;
  const r = new je(n, t), a = (i = r.METHOD) != null ? i : "", o = r.URI, l = r.hexadecimalInteger("IV"), c = r.KEYFORMATVERSIONS, u = (s = r.KEYFORMAT) != null ? s : "identity";
  o && r.IV && !l && Oe.error(`Invalid IV: ${r.IV}`);
  const d = o ? ns.resolve(o, e) : "", f = (c || "1").split("/").map(Number).filter(Number.isFinite);
  return new Ys(a, d, u, f, l, r.KEYID);
}
function Tf(n) {
  const t = new je(n).decimalFloatingPoint("TIME-OFFSET");
  return Z(t) ? t : null;
}
function Sf(n, e) {
  let t = (n || "").split(/[ ,]+/).filter((i) => i);
  ["video", "audio", "text"].forEach((i) => {
    const s = t.filter((r) => ku(r, i));
    s.length && (e[`${i}Codec`] = s.map((r) => r.split("/")[0]).join(","), t = t.filter((r) => s.indexOf(r) === -1));
  }), e.unknownCodecs = t;
}
function xf(n, e, t) {
  const i = e[t];
  i && (n[t] = i);
}
function wE(n, e) {
  let t = n[e];
  for (let i = e; i--; ) {
    const s = n[i];
    if (!s)
      return;
    s.programDateTime = t.programDateTime - s.duration * 1e3, t = s;
  }
}
function $c(n, e, t) {
  n.rawProgramDateTime ? t.push(n) : e != null && e.programDateTime && (n.programDateTime = e.endProgramDateTime);
}
function bf(n, e, t, i) {
  n.relurl = e.URI, e.BYTERANGE && n.setByteRange(e.BYTERANGE), n.level = t, n.sn = "initSegment", i && (n.levelkeys = i), n.initSegment = null;
}
function _f(n, e, t) {
  n.levelkeys = e;
  const {
    encryptedFragments: i
  } = t;
  (!i.length || i[i.length - 1].levelkeys !== e) && Object.keys(e).some((s) => e[s].isCommonEncryption) && i.push(n);
}
function hs(n, e, t) {
  n.playlistParsingError = new Error(`#EXT-X-${e} must not appear more than once (${t[0]})`);
}
function Af(n, e, t) {
  n.playlistParsingError = new Error(`#EXT-X-${e} must appear before the first Media Segment (${t[0]})`);
}
function Pl(n, e) {
  const t = e.startPTS;
  if (Z(t)) {
    let i = 0, s;
    e.sn > n.sn ? (i = t - n.start, s = n) : (i = n.start - t, s = e), s.duration !== i && s.setDuration(i);
  } else e.sn > n.sn ? n.cc === e.cc && n.minEndPTS ? e.setStart(n.start + (n.minEndPTS - n.start)) : e.setStart(n.start + n.duration) : e.setStart(Math.max(n.start - e.duration, 0));
}
function yg(n, e, t, i, s, r, a) {
  i - t <= 0 && (a.warn("Fragment should have a positive duration", e), i = t + e.duration, r = s + e.duration);
  let l = t, c = i;
  const u = e.startPTS, d = e.endPTS;
  if (Z(u)) {
    const v = Math.abs(u - t);
    n && v > n.totalduration ? a.warn(`media timestamps and playlist times differ by ${v}s for level ${e.level} ${n.url}`) : Z(e.deltaPTS) ? e.deltaPTS = Math.max(v, e.deltaPTS) : e.deltaPTS = v, l = Math.max(t, u), t = Math.min(t, u), s = e.startDTS !== void 0 ? Math.min(s, e.startDTS) : s, c = Math.min(i, d), i = Math.max(i, d), r = e.endDTS !== void 0 ? Math.max(r, e.endDTS) : r;
  }
  const f = t - e.start;
  e.start !== 0 && e.setStart(t), e.setDuration(i - e.start), e.startPTS = t, e.maxStartPTS = l, e.startDTS = s, e.endPTS = i, e.minEndPTS = c, e.endDTS = r;
  const p = e.sn;
  if (!n || p < n.startSN || p > n.endSN)
    return 0;
  let h;
  const g = p - n.startSN, m = n.fragments;
  for (m[g] = e, h = g; h > 0; h--)
    Pl(m[h], m[h - 1]);
  for (h = g; h < m.length - 1; h++)
    Pl(m[h], m[h + 1]);
  return n.fragmentHint && Pl(m[m.length - 1], n.fragmentHint), n.PTSKnown = n.alignedSliding = !0, f;
}
function LE(n, e, t) {
  if (n === e)
    return;
  let i = null;
  const s = n.fragments;
  for (let u = s.length - 1; u >= 0; u--) {
    const d = s[u].initSegment;
    if (d) {
      i = d;
      break;
    }
  }
  n.fragmentHint && delete n.fragmentHint.endPTS;
  let r;
  CE(n, e, (u, d, f, p) => {
    if ((!e.startCC || e.skippedSegments) && d.cc !== u.cc) {
      const h = u.cc - d.cc;
      for (let g = f; g < p.length; g++)
        p[g].cc += h;
      e.endCC = p[p.length - 1].cc;
    }
    Z(u.startPTS) && Z(u.endPTS) && (d.setStart(d.startPTS = u.startPTS), d.startDTS = u.startDTS, d.maxStartPTS = u.maxStartPTS, d.endPTS = u.endPTS, d.endDTS = u.endDTS, d.minEndPTS = u.minEndPTS, d.setDuration(u.endPTS - u.startPTS), d.duration && (r = d), e.PTSKnown = e.alignedSliding = !0), u.hasStreams && (d.elementaryStreams = u.elementaryStreams), d.loader = u.loader, u.hasStats && (d.stats = u.stats), u.initSegment && (d.initSegment = u.initSegment, i = u.initSegment);
  });
  const a = e.fragments, o = e.fragmentHint ? a.concat(e.fragmentHint) : a;
  if (i && o.forEach((u) => {
    var d;
    u && (!u.initSegment || u.initSegment.relurl === ((d = i) == null ? void 0 : d.relurl)) && (u.initSegment = i);
  }), e.skippedSegments) {
    if (e.deltaUpdateFailed = a.some((u) => !u), e.deltaUpdateFailed) {
      t.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
      for (let u = e.skippedSegments; u--; )
        a.shift();
      e.startSN = a[0].sn;
    } else {
      e.canSkipDateRanges && (e.dateRanges = IE(n.dateRanges, e, t));
      const u = n.fragments.filter((d) => d.rawProgramDateTime);
      if (n.hasProgramDateTime && !e.hasProgramDateTime)
        for (let d = 1; d < o.length; d++)
          o[d].programDateTime === null && $c(o[d], o[d - 1], u);
      vg(u, e);
    }
    e.endCC = a[a.length - 1].cc;
  }
  if (!e.startCC) {
    var l;
    const u = Sg(n, e.startSN - 1);
    e.startCC = (l = u?.cc) != null ? l : a[0].cc;
  }
  RE(n.partList, e.partList, (u, d) => {
    d.elementaryStreams = u.elementaryStreams, d.stats = u.stats;
  }), r ? yg(e, r, r.startPTS, r.endPTS, r.startDTS, r.endDTS, t) : Eg(n, e), a.length && (e.totalduration = e.edge - a[0].start), e.driftStartTime = n.driftStartTime, e.driftStart = n.driftStart;
  const c = e.advancedDateTime;
  if (e.advanced && c) {
    const u = e.edge;
    e.driftStart || (e.driftStartTime = c, e.driftStart = u), e.driftEndTime = c, e.driftEnd = u;
  } else
    e.driftEndTime = n.driftEndTime, e.driftEnd = n.driftEnd, e.advancedDateTime = n.advancedDateTime;
  e.requestScheduled === -1 && (e.requestScheduled = n.requestScheduled);
}
function IE(n, e, t) {
  const {
    dateRanges: i,
    recentlyRemovedDateranges: s
  } = e, r = Fe({}, n);
  s && s.forEach((l) => {
    delete r[l];
  });
  const o = Object.keys(r).length;
  return o ? (Object.keys(i).forEach((l) => {
    const c = r[l], u = new fg(i[l].attr, c);
    u.isValid ? (r[l] = u, c || (u.tagOrder += o)) : t.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${Ge(i[l].attr)}"`);
  }), r) : i;
}
function RE(n, e, t) {
  if (n && e) {
    let i = 0;
    for (let s = 0, r = n.length; s <= r; s++) {
      const a = n[s], o = e[s + i];
      a && o && a.index === o.index && a.fragment.sn === o.fragment.sn ? t(a, o) : i--;
    }
  }
}
function CE(n, e, t) {
  const i = e.skippedSegments, s = Math.max(n.startSN, e.startSN) - e.startSN, r = (n.fragmentHint ? 1 : 0) + (i ? e.endSN : Math.min(n.endSN, e.endSN)) - e.startSN, a = e.startSN - n.startSN, o = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments, l = n.fragmentHint ? n.fragments.concat(n.fragmentHint) : n.fragments;
  for (let c = s; c <= r; c++) {
    const u = l[a + c];
    let d = o[c];
    if (i && !d && u && (d = e.fragments[c] = u), u && d) {
      t(u, d, c, o);
      const f = u.relurl, p = d.relurl;
      if (f && PE(f, p)) {
        e.playlistParsingError = wf(`media sequence mismatch ${d.sn}:`, n, e, u, d);
        return;
      } else if (u.cc !== d.cc) {
        e.playlistParsingError = wf(`discontinuity sequence mismatch (${u.cc}!=${d.cc})`, n, e, u, d);
        return;
      }
    }
  }
}
function wf(n, e, t, i, s) {
  return new Error(`${n} ${s.url}
Playlist starting @${e.startSN}
${e.m3u8}

Playlist starting @${t.startSN}
${t.m3u8}`);
}
function Eg(n, e, t = !0) {
  const i = e.startSN + e.skippedSegments - n.startSN, s = n.fragments, r = i >= 0;
  let a = 0;
  if (r && i < s.length)
    a = s[i].start;
  else if (r && e.startSN === n.endSN + 1)
    a = n.fragmentEnd;
  else if (r && t)
    a = n.fragmentStart + i * e.levelTargetDuration;
  else if (!e.skippedSegments && e.fragmentStart === 0)
    a = n.fragmentStart;
  else
    return;
  Bc(e, a);
}
function Bc(n, e) {
  if (e) {
    const t = n.fragments;
    for (let i = n.skippedSegments; i < t.length; i++)
      t[i].addStart(e);
    n.fragmentHint && n.fragmentHint.addStart(e);
  }
}
function Tg(n, e = 1 / 0) {
  let t = 1e3 * n.targetduration;
  if (n.updated) {
    const i = n.fragments;
    if (i.length && t * 4 > e) {
      const r = i[i.length - 1].duration * 1e3;
      r < t && (t = r);
    }
  } else
    t /= 2;
  return Math.round(t);
}
function Sg(n, e, t) {
  if (!n)
    return null;
  let i = n.fragments[e - n.startSN];
  return i || (i = n.fragmentHint, i && i.sn === e) ? i : e < n.startSN && t && t.sn === e ? t : null;
}
function Lf(n, e, t) {
  return n ? xg(n.partList, e, t) : null;
}
function xg(n, e, t) {
  if (n)
    for (let i = n.length; i--; ) {
      const s = n[i];
      if (s.index === t && s.fragment.sn === e)
        return s;
    }
  return null;
}
function bg(n) {
  n.forEach((e, t) => {
    var i;
    (i = e.details) == null || i.fragments.forEach((s) => {
      s.level = t, s.initSegment && (s.initSegment.level = t);
    });
  });
}
function PE(n, e) {
  return n !== e && e ? If(n) !== If(e) : !1;
}
function If(n) {
  return n.replace(/\?[^?]*$/, "");
}
function Zn(n, e) {
  for (let i = 0, s = n.length; i < s; i++) {
    var t;
    if (((t = n[i]) == null ? void 0 : t.cc) === e)
      return n[i];
  }
  return null;
}
function DE(n, e) {
  return !!(n && e.startCC < n.endCC && e.endCC > n.startCC);
}
function Rf(n, e) {
  const t = n.start + e;
  n.startPTS = t, n.setStart(t), n.endPTS = t + n.duration;
}
function _g(n, e) {
  const t = e.fragments;
  for (let i = 0, s = t.length; i < s; i++)
    Rf(t[i], n);
  e.fragmentHint && Rf(e.fragmentHint, n), e.alignedSliding = !0;
}
function kE(n, e) {
  n && (Ag(e, n), e.alignedSliding || zo(e, n), !e.alignedSliding && !e.skippedSegments && Eg(n, e, !1));
}
function Ag(n, e) {
  if (!DE(e, n))
    return;
  const t = Math.min(e.endCC, n.endCC), i = Zn(e.fragments, t), s = Zn(n.fragments, t);
  if (!i || !s)
    return;
  Oe.log(`Aligning playlist at start of dicontinuity sequence ${t}`);
  const r = i.start - s.start;
  _g(r, n);
}
function zo(n, e) {
  if (!n.hasProgramDateTime || !e.hasProgramDateTime)
    return;
  const t = n.fragments, i = e.fragments;
  if (!t.length || !i.length)
    return;
  let s, r;
  const a = Math.min(e.endCC, n.endCC);
  e.startCC < a && n.startCC < a && (s = Zn(i, a), r = Zn(t, a)), (!s || !r) && (s = i[Math.floor(i.length / 2)], r = Zn(t, s.cc) || t[Math.floor(t.length / 2)]);
  const o = s.programDateTime, l = r.programDateTime;
  if (!o || !l)
    return;
  const c = (l - o) / 1e3 - (r.start - s.start);
  _g(c, n);
}
function Zt(n, e, t) {
  ti(n, e, t), n.addEventListener(e, t);
}
function ti(n, e, t) {
  n.removeEventListener(e, t);
}
const ME = {
  toString: function(n) {
    let e = "";
    const t = n.length;
    for (let i = 0; i < t; i++)
      e += `[${n.start(i).toFixed(3)}-${n.end(i).toFixed(3)}]`;
    return e;
  }
}, q = {
  STOPPED: "STOPPED",
  IDLE: "IDLE",
  KEY_LOADING: "KEY_LOADING",
  FRAG_LOADING: "FRAG_LOADING",
  FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
  WAITING_TRACK: "WAITING_TRACK",
  PARSING: "PARSING",
  PARSED: "PARSED",
  ENDED: "ENDED",
  ERROR: "ERROR",
  WAITING_INIT_PTS: "WAITING_INIT_PTS",
  WAITING_LEVEL: "WAITING_LEVEL"
};
class Uu extends ug {
  constructor(e, t, i, s, r) {
    super(s, e.logger), this.hls = void 0, this.fragPrevious = null, this.fragCurrent = null, this.fragmentTracker = void 0, this.transmuxer = null, this._state = q.STOPPED, this.playlistType = void 0, this.media = null, this.mediaBuffer = null, this.config = void 0, this.bitrateTest = !1, this.lastCurrentTime = 0, this.nextLoadPosition = 0, this.startPosition = 0, this.startTimeOffset = null, this.retryDate = 0, this.levels = null, this.fragmentLoader = void 0, this.keyLoader = void 0, this.levelLastLoaded = null, this.startFragRequested = !1, this.decrypter = void 0, this.initPTS = [], this.buffering = !0, this.loadingParts = !1, this.loopSn = void 0, this.onMediaSeeking = () => {
      const {
        config: a,
        fragCurrent: o,
        media: l,
        mediaBuffer: c,
        state: u
      } = this, d = l ? l.currentTime : 0, f = de.bufferInfo(c || l, d, a.maxBufferHole), p = !f.len;
      if (this.log(`Media seeking to ${Z(d) ? d.toFixed(3) : d}, state: ${u}, ${p ? "out of" : "in"} buffer`), this.state === q.ENDED)
        this.resetLoadingState();
      else if (o) {
        const h = a.maxFragLookUpTolerance, g = o.start - h, m = o.start + o.duration + h;
        if (p || m < f.start || g > f.end) {
          const v = d > m;
          (d < g || v) && (v && o.loader && (this.log(`Cancelling fragment load for seek (sn: ${o.sn})`), o.abortRequests(), this.resetLoadingState()), this.fragPrevious = null);
        }
      }
      if (l) {
        this.fragmentTracker.removeFragmentsInRange(d, 1 / 0, this.playlistType, !0);
        const h = this.lastCurrentTime;
        if (d > h && (this.lastCurrentTime = d), !this.loadingParts) {
          const g = Math.max(f.end, d), m = this.shouldLoadParts(this.getLevelDetails(), g);
          m && (this.log(`LL-Part loading ON after seeking to ${d.toFixed(2)} with buffer @${g.toFixed(2)}`), this.loadingParts = m);
        }
      }
      this.hls.hasEnoughToStart || (this.log(`Setting ${p ? "startPosition" : "nextLoadPosition"} to ${d} for seek without enough to start`), this.nextLoadPosition = d, p && (this.startPosition = d)), p && this.state === q.IDLE && this.tickImmediate();
    }, this.onMediaEnded = () => {
      this.log("setting startPosition to 0 because media ended"), this.startPosition = this.lastCurrentTime = 0;
    }, this.playlistType = r, this.hls = e, this.fragmentLoader = new lE(e.config), this.keyLoader = i, this.fragmentTracker = t, this.config = e.config, this.decrypter = new Fu(e.config);
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(x.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(x.ERROR, this.onError, this);
  }
  doTick() {
    this.onTickEnd();
  }
  onTickEnd() {
  }
  startLoad(e) {
  }
  stopLoad() {
    if (this.state === q.STOPPED)
      return;
    this.fragmentLoader.abort(), this.keyLoader.abort(this.playlistType);
    const e = this.fragCurrent;
    e != null && e.loader && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = q.STOPPED;
  }
  get startPositionValue() {
    const {
      nextLoadPosition: e,
      startPosition: t
    } = this;
    return t === -1 && e ? e : t;
  }
  get bufferingEnabled() {
    return this.buffering;
  }
  pauseBuffering() {
    this.buffering = !1;
  }
  resumeBuffering() {
    this.buffering = !0;
  }
  get inFlightFrag() {
    return {
      frag: this.fragCurrent,
      state: this.state
    };
  }
  _streamEnded(e, t) {
    if (t.live || !this.media)
      return !1;
    const i = e.end || 0, s = this.config.timelineOffset || 0;
    if (i <= s)
      return !1;
    const r = e.buffered;
    this.config.maxBufferHole && r && r.length > 1 && (e = de.bufferedInfo(r, e.start, 0));
    const a = e.nextStart;
    if (a && a > s && a < t.edge || this.media.currentTime < e.start)
      return !1;
    const l = t.partList;
    if (l != null && l.length) {
      const u = l[l.length - 1];
      return de.isBuffered(this.media, u.start + u.duration / 2);
    }
    const c = t.fragments[t.fragments.length - 1].type;
    return this.fragmentTracker.isEndListAppended(c);
  }
  getLevelDetails() {
    if (this.levels && this.levelLastLoaded !== null)
      return this.levelLastLoaded.details;
  }
  get timelineOffset() {
    const e = this.config.timelineOffset;
    if (e) {
      var t;
      return ((t = this.getLevelDetails()) == null ? void 0 : t.appliedTimelineOffset) || e;
    }
    return 0;
  }
  onMediaAttached(e, t) {
    const i = this.media = this.mediaBuffer = t.media;
    Zt(i, "seeking", this.onMediaSeeking), Zt(i, "ended", this.onMediaEnded);
    const s = this.config;
    this.levels && s.autoStartLoad && this.state === q.STOPPED && this.startLoad(s.startPosition);
  }
  onMediaDetaching(e, t) {
    const i = !!t.transferMedia, s = this.media;
    if (s !== null) {
      if (s.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), ti(s, "seeking", this.onMediaSeeking), ti(s, "ended", this.onMediaEnded), this.keyLoader && !i && this.keyLoader.detach(), this.media = this.mediaBuffer = null, this.loopSn = void 0, i) {
        this.resetLoadingState(), this.resetTransmuxer();
        return;
      }
      this.loadingParts = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad();
    }
  }
  onManifestLoading() {
    this.initPTS = [], this.levels = this.levelLastLoaded = this.fragCurrent = null, this.lastCurrentTime = this.startPosition = 0, this.startFragRequested = !1;
  }
  onError(e, t) {
  }
  onManifestLoaded(e, t) {
    this.startTimeOffset = t.startTimeOffset;
  }
  onHandlerDestroying() {
    this.stopLoad(), this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null), super.onHandlerDestroying(), this.hls = this.onMediaSeeking = this.onMediaEnded = null;
  }
  onHandlerDestroyed() {
    this.state = q.STOPPED, this.fragmentLoader && this.fragmentLoader.destroy(), this.keyLoader && this.keyLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null, super.onHandlerDestroyed();
  }
  loadFragment(e, t, i) {
    this.startFragRequested = !0, this._loadFragForPlayback(e, t, i);
  }
  _loadFragForPlayback(e, t, i) {
    const s = (r) => {
      const a = r.frag;
      if (this.fragContextChanged(a)) {
        this.warn(`${a.type} sn: ${a.sn}${r.part ? " part: " + r.part.index : ""} of ${this.fragInfo(a, !1, r.part)}) was dropped during download.`), this.fragmentTracker.removeFragment(a);
        return;
      }
      a.stats.chunkCount++, this._handleFragmentLoadProgress(r);
    };
    this._doFragLoad(e, t, i, s).then((r) => {
      if (!r)
        return;
      const a = this.state, o = r.frag;
      if (this.fragContextChanged(o)) {
        (a === q.FRAG_LOADING || !this.fragCurrent && a === q.PARSING) && (this.fragmentTracker.removeFragment(o), this.state = q.IDLE);
        return;
      }
      "payload" in r && (this.log(`Loaded ${o.type} sn: ${o.sn} of ${this.playlistLabel()} ${o.level}`), this.hls.trigger(x.FRAG_LOADED, r)), this._handleFragmentLoadComplete(r);
    }).catch((r) => {
      this.state === q.STOPPED || this.state === q.ERROR || (this.warn(`Frag error: ${r?.message || r}`), this.resetFragmentLoading(e));
    });
  }
  clearTrackerIfNeeded(e) {
    var t;
    const {
      fragmentTracker: i
    } = this;
    if (i.getState(e) === yt.APPENDING) {
      const r = e.type, a = this.getFwdBufferInfo(this.mediaBuffer, r), o = Math.max(e.duration, a ? a.len : this.config.maxBufferLength), l = this.backtrackFragment;
      ((l ? e.sn - l.sn : 0) === 1 || this.reduceMaxBufferLength(o, e.duration)) && i.removeFragment(e);
    } else ((t = this.mediaBuffer) == null ? void 0 : t.buffered.length) === 0 ? i.removeAllFragments() : i.hasParts(e.type) && (i.detectPartialFragments({
      frag: e,
      part: null,
      stats: e.stats,
      id: e.type
    }), i.getState(e) === yt.PARTIAL && i.removeFragment(e));
  }
  checkLiveUpdate(e) {
    if (e.updated && !e.live) {
      const t = e.fragments[e.fragments.length - 1];
      this.fragmentTracker.detectPartialFragments({
        frag: t,
        part: null,
        stats: t.stats,
        id: t.type
      });
    }
    e.fragments[0] || (e.deltaUpdateFailed = !0);
  }
  waitForLive(e) {
    const t = e.details;
    return t?.live && t.type !== "EVENT" && (this.levelLastLoaded !== e || t.expired);
  }
  flushMainBuffer(e, t, i = null) {
    if (!(e - t))
      return;
    const s = {
      startOffset: e,
      endOffset: t,
      type: i
    };
    this.hls.trigger(x.BUFFER_FLUSHING, s);
  }
  _loadInitSegment(e, t) {
    this._doFragLoad(e, t).then((i) => {
      const s = i?.frag;
      if (!s || this.fragContextChanged(s) || !this.levels)
        throw new Error("init load aborted");
      return i;
    }).then((i) => {
      const {
        hls: s
      } = this, {
        frag: r,
        payload: a
      } = i, o = r.decryptdata;
      if (a && a.byteLength > 0 && o != null && o.key && o.iv && an(o.method)) {
        const l = self.performance.now();
        return this.decrypter.decrypt(new Uint8Array(a), o.key.buffer, o.iv.buffer, $u(o.method)).catch((c) => {
          throw s.trigger(x.ERROR, {
            type: se.MEDIA_ERROR,
            details: H.FRAG_DECRYPT_ERROR,
            fatal: !1,
            error: c,
            reason: c.message,
            frag: r
          }), c;
        }).then((c) => {
          const u = self.performance.now();
          return s.trigger(x.FRAG_DECRYPTED, {
            frag: r,
            payload: c,
            stats: {
              tstart: l,
              tdecrypt: u
            }
          }), i.payload = c, this.completeInitSegmentLoad(i);
        });
      }
      return this.completeInitSegmentLoad(i);
    }).catch((i) => {
      this.state === q.STOPPED || this.state === q.ERROR || (this.warn(i), this.resetFragmentLoading(e));
    });
  }
  completeInitSegmentLoad(e) {
    const {
      levels: t
    } = this;
    if (!t)
      throw new Error("init load aborted, missing levels");
    const i = e.frag.stats;
    this.state !== q.STOPPED && (this.state = q.IDLE), e.frag.data = new Uint8Array(e.payload), i.parsing.start = i.buffering.start = self.performance.now(), i.parsing.end = i.buffering.end = self.performance.now(), this.tick();
  }
  unhandledEncryptionError(e, t) {
    var i, s;
    const r = e.tracks;
    if (r && !t.encrypted && ((i = r.audio) != null && i.encrypted || (s = r.video) != null && s.encrypted) && (!this.config.emeEnabled || !this.keyLoader.emeController)) {
      const a = this.media, o = new Error(`Encrypted track with no key in ${this.fragInfo(t)} (media ${a ? "attached mediaKeys: " + a.mediaKeys : "detached"})`);
      return this.warn(o.message), !a || a.mediaKeys ? !1 : (this.hls.trigger(x.ERROR, {
        type: se.KEY_SYSTEM_ERROR,
        details: H.KEY_SYSTEM_NO_KEYS,
        fatal: !1,
        error: o,
        frag: t
      }), this.resetTransmuxer(), !0);
    }
    return !1;
  }
  fragContextChanged(e) {
    const {
      fragCurrent: t
    } = this;
    return !e || !t || e.sn !== t.sn || e.level !== t.level;
  }
  fragBufferedComplete(e, t) {
    const i = this.mediaBuffer ? this.mediaBuffer : this.media;
    if (this.log(`Buffered ${e.type} sn: ${e.sn}${t ? " part: " + t.index : ""} of ${this.fragInfo(e, !1, t)} > buffer:${i ? ME.toString(de.getBuffered(i)) : "(detached)"})`), ot(e)) {
      var s;
      if (e.type !== te.SUBTITLE) {
        const a = e.elementaryStreams;
        if (!Object.keys(a).some((o) => !!a[o])) {
          this.state = q.IDLE;
          return;
        }
      }
      const r = (s = this.levels) == null ? void 0 : s[e.level];
      r != null && r.fragmentError && (this.log(`Resetting level fragment error count of ${r.fragmentError} on frag buffered`), r.fragmentError = 0);
    }
    this.state = q.IDLE;
  }
  _handleFragmentLoadComplete(e) {
    const {
      transmuxer: t
    } = this;
    if (!t)
      return;
    const {
      frag: i,
      part: s,
      partsLoaded: r
    } = e, a = !r || r.length === 0 || r.some((l) => !l), o = new Nu(i.level, i.sn, i.stats.chunkCount + 1, 0, s ? s.index : -1, !a);
    t.flush(o);
  }
  _handleFragmentLoadProgress(e) {
  }
  _doFragLoad(e, t, i = null, s) {
    var r;
    this.fragCurrent = e;
    const a = t.details;
    if (!this.levels || !a)
      throw new Error(`frag load aborted, missing level${a ? "" : " detail"}s`);
    let o = null;
    if (e.encrypted && !((r = e.decryptdata) != null && r.key)) {
      if (this.log(`Loading key for ${e.sn} of [${a.startSN}-${a.endSN}], ${this.playlistLabel()} ${e.level}`), this.state = q.KEY_LOADING, this.fragCurrent = e, o = this.keyLoader.load(e).then((f) => {
        if (!this.fragContextChanged(f.frag))
          return this.hls.trigger(x.KEY_LOADED, f), this.state === q.KEY_LOADING && (this.state = q.IDLE), f;
      }), this.hls.trigger(x.KEY_LOADING, {
        frag: e
      }), this.fragCurrent === null)
        return this.log("context changed in KEY_LOADING"), Promise.resolve(null);
    } else e.encrypted || (o = this.keyLoader.loadClear(e, a.encryptedFragments, this.startFragRequested), o && this.log("[eme] blocking frag load until media-keys acquired"));
    const l = this.fragPrevious;
    if (ot(e) && (!l || e.sn !== l.sn)) {
      const f = this.shouldLoadParts(t.details, e.end);
      f !== this.loadingParts && (this.log(`LL-Part loading ${f ? "ON" : "OFF"} loading sn ${l?.sn}->${e.sn}`), this.loadingParts = f);
    }
    if (i = Math.max(e.start, i || 0), this.loadingParts && ot(e)) {
      const f = a.partList;
      if (f && s) {
        i > a.fragmentEnd && a.fragmentHint && (e = a.fragmentHint);
        const p = this.getNextPart(f, e, i);
        if (p > -1) {
          const h = f[p];
          e = this.fragCurrent = h.fragment, this.log(`Loading ${e.type} sn: ${e.sn} part: ${h.index} (${p}/${f.length - 1}) of ${this.fragInfo(e, !1, h)}) cc: ${e.cc} [${a.startSN}-${a.endSN}], target: ${parseFloat(i.toFixed(3))}`), this.nextLoadPosition = h.start + h.duration, this.state = q.FRAG_LOADING;
          let g;
          return o ? g = o.then((m) => !m || this.fragContextChanged(m.frag) ? null : this.doFragPartsLoad(e, h, t, s)).catch((m) => this.handleFragLoadError(m)) : g = this.doFragPartsLoad(e, h, t, s).catch((m) => this.handleFragLoadError(m)), this.hls.trigger(x.FRAG_LOADING, {
            frag: e,
            part: h,
            targetBufferTime: i
          }), this.fragCurrent === null ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING parts")) : g;
        } else if (!e.url || this.loadedEndOfParts(f, i))
          return Promise.resolve(null);
      }
    }
    if (ot(e) && this.loadingParts) {
      var c;
      this.log(`LL-Part loading OFF after next part miss @${i.toFixed(2)} Check buffer at sn: ${e.sn} loaded parts: ${(c = a.partList) == null ? void 0 : c.filter((f) => f.loaded).map((f) => `[${f.start}-${f.end}]`)}`), this.loadingParts = !1;
    } else if (!e.url)
      return Promise.resolve(null);
    this.log(`Loading ${e.type} sn: ${e.sn} of ${this.fragInfo(e, !1)}) cc: ${e.cc} ${"[" + a.startSN + "-" + a.endSN + "]"}, target: ${parseFloat(i.toFixed(3))}`), Z(e.sn) && !this.bitrateTest && (this.nextLoadPosition = e.start + e.duration), this.state = q.FRAG_LOADING;
    const u = this.config.progressive && e.type !== te.SUBTITLE;
    let d;
    return u && o ? d = o.then((f) => !f || this.fragContextChanged(f.frag) ? null : this.fragmentLoader.load(e, s)).catch((f) => this.handleFragLoadError(f)) : d = Promise.all([this.fragmentLoader.load(e, u ? s : void 0), o]).then(([f]) => (!u && s && s(f), f)).catch((f) => this.handleFragLoadError(f)), this.hls.trigger(x.FRAG_LOADING, {
      frag: e,
      targetBufferTime: i
    }), this.fragCurrent === null ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING")) : d;
  }
  doFragPartsLoad(e, t, i, s) {
    return new Promise((r, a) => {
      var o;
      const l = [], c = (o = i.details) == null ? void 0 : o.partList, u = (d) => {
        this.fragmentLoader.loadPart(e, d, s).then((f) => {
          l[d.index] = f;
          const p = f.part;
          this.hls.trigger(x.FRAG_LOADED, f);
          const h = Lf(i.details, e.sn, d.index + 1) || xg(c, e.sn, d.index + 1);
          if (h)
            u(h);
          else
            return r({
              frag: e,
              part: p,
              partsLoaded: l
            });
        }).catch(a);
      };
      u(t);
    });
  }
  handleFragLoadError(e) {
    if ("data" in e) {
      const t = e.data;
      t.frag && t.details === H.INTERNAL_ABORTED ? this.handleFragLoadAborted(t.frag, t.part) : t.frag && t.type === se.KEY_SYSTEM_ERROR ? (t.frag.abortRequests(), this.resetStartWhenNotLoaded(), this.resetFragmentLoading(t.frag)) : this.hls.trigger(x.ERROR, t);
    } else
      this.hls.trigger(x.ERROR, {
        type: se.OTHER_ERROR,
        details: H.INTERNAL_EXCEPTION,
        err: e,
        error: e,
        fatal: !0
      });
    return null;
  }
  _handleTransmuxerFlush(e) {
    const t = this.getCurrentContext(e);
    if (!t || this.state !== q.PARSING) {
      !this.fragCurrent && this.state !== q.STOPPED && this.state !== q.ERROR && (this.state = q.IDLE);
      return;
    }
    const {
      frag: i,
      part: s,
      level: r
    } = t, a = self.performance.now();
    i.stats.parsing.end = a, s && (s.stats.parsing.end = a);
    const o = this.getLevelDetails(), c = o && i.sn > o.endSN || this.shouldLoadParts(o, i.end);
    c !== this.loadingParts && (this.log(`LL-Part loading ${c ? "ON" : "OFF"} after parsing segment ending @${i.end.toFixed(2)}`), this.loadingParts = c), this.updateLevelTiming(i, s, r, e.partial);
  }
  shouldLoadParts(e, t) {
    if (this.config.lowLatencyMode) {
      if (!e)
        return this.loadingParts;
      if (e.partList) {
        var i;
        const r = e.partList[0];
        if (r.fragment.type === te.SUBTITLE)
          return !1;
        const a = r.end + (((i = e.fragmentHint) == null ? void 0 : i.duration) || 0);
        if (t >= a) {
          var s;
          if ((this.hls.hasEnoughToStart ? ((s = this.media) == null ? void 0 : s.currentTime) || this.lastCurrentTime : this.getLoadPosition()) > r.start - r.fragment.duration)
            return !0;
        }
      }
    }
    return !1;
  }
  getCurrentContext(e) {
    const {
      levels: t,
      fragCurrent: i
    } = this, {
      level: s,
      sn: r,
      part: a
    } = e;
    if (!(t != null && t[s]))
      return this.warn(`Levels object was unset while buffering fragment ${r} of ${this.playlistLabel()} ${s}. The current chunk will not be buffered.`), null;
    const o = t[s], l = o.details, c = a > -1 ? Lf(l, r, a) : null, u = c ? c.fragment : Sg(l, r, i);
    return u ? (i && i !== u && (u.stats = i.stats), {
      frag: u,
      part: c,
      level: o
    }) : null;
  }
  bufferFragmentData(e, t, i, s, r) {
    if (this.state !== q.PARSING)
      return;
    const {
      data1: a,
      data2: o
    } = e;
    let l = a;
    if (o && (l = Oi(a, o)), !l.length)
      return;
    const c = this.initPTS[t.cc], u = c ? -c.baseTime / c.timescale : void 0, d = {
      type: e.type,
      frag: t,
      part: i,
      chunkMeta: s,
      offset: u,
      parent: t.type,
      data: l
    };
    if (this.hls.trigger(x.BUFFER_APPENDING, d), e.dropped && e.independent && !i) {
      if (r)
        return;
      this.flushBufferGap(t);
    }
  }
  flushBufferGap(e) {
    const t = this.media;
    if (!t)
      return;
    if (!de.isBuffered(t, t.currentTime)) {
      this.flushMainBuffer(0, e.start);
      return;
    }
    const i = t.currentTime, s = de.bufferInfo(t, i, 0), r = e.duration, a = Math.min(this.config.maxFragLookUpTolerance * 2, r * 0.25), o = Math.max(Math.min(e.start - a, s.end - a), i + a);
    e.start - o > a && this.flushMainBuffer(o, e.start);
  }
  getFwdBufferInfo(e, t) {
    var i;
    const s = this.getLoadPosition();
    if (!Z(s))
      return null;
    const a = this.lastCurrentTime > s || (i = this.media) != null && i.paused ? 0 : this.config.maxBufferHole;
    return this.getFwdBufferInfoAtPos(e, s, t, a);
  }
  getFwdBufferInfoAtPos(e, t, i, s) {
    const r = de.bufferInfo(e, t, s);
    if (r.len === 0 && r.nextStart !== void 0) {
      const a = this.fragmentTracker.getBufferedFrag(t, i);
      if (a && (r.nextStart <= a.end || a.gap)) {
        const o = Math.max(Math.min(r.nextStart, a.end) - t, s);
        return de.bufferInfo(e, t, o);
      }
    }
    return r;
  }
  getMaxBufferLength(e) {
    const {
      config: t
    } = this;
    let i;
    return e ? i = Math.max(8 * t.maxBufferSize / e, t.maxBufferLength) : i = t.maxBufferLength, Math.min(i, t.maxMaxBufferLength);
  }
  reduceMaxBufferLength(e, t) {
    const i = this.config, s = Math.max(Math.min(e - t, i.maxBufferLength), t), r = Math.max(e - t * 3, i.maxMaxBufferLength / 2, s);
    return r >= s ? (i.maxMaxBufferLength = r, this.warn(`Reduce max buffer length to ${r}s`), !0) : !1;
  }
  getAppendedFrag(e, t = te.MAIN) {
    const i = this.fragmentTracker ? this.fragmentTracker.getAppendedFrag(e, t) : null;
    return i && "fragment" in i ? i.fragment : i;
  }
  getNextFragment(e, t) {
    const i = t.fragments, s = i.length;
    if (!s)
      return null;
    const {
      config: r
    } = this, a = i[0].start, o = r.lowLatencyMode && !!t.partList;
    let l = null;
    if (t.live) {
      const d = r.initialLiveManifestSize;
      if (s < d)
        return this.warn(`Not enough fragments to start playback (have: ${s}, need: ${d})`), null;
      if (!t.PTSKnown && !this.startFragRequested && this.startPosition === -1 || e < a) {
        var c;
        o && !this.loadingParts && (this.log("LL-Part loading ON for initial live fragment"), this.loadingParts = !0), l = this.getInitialLiveFragment(t);
        const f = this.hls.startPosition, p = this.hls.liveSyncPosition, h = l ? (f !== -1 && f >= a ? f : p) || l.start : e;
        this.log(`Setting startPosition to ${h} to match start frag at live edge. mainStart: ${f} liveSyncPosition: ${p} frag.start: ${(c = l) == null ? void 0 : c.start}`), this.startPosition = this.nextLoadPosition = h;
      }
    } else e <= a && (l = i[0]);
    if (!l) {
      const d = this.loadingParts ? t.partEnd : t.fragmentEnd;
      l = this.getFragmentAtPosition(e, d, t);
    }
    let u = this.filterReplacedPrimary(l, t);
    if (!u && l) {
      const d = l.sn - t.startSN;
      u = this.filterReplacedPrimary(i[d + 1] || null, t);
    }
    return this.mapToInitFragWhenRequired(u);
  }
  isLoopLoading(e, t) {
    const i = this.fragmentTracker.getState(e);
    return (i === yt.OK || i === yt.PARTIAL && !!e.gap) && this.nextLoadPosition > t;
  }
  getNextFragmentLoopLoading(e, t, i, s, r) {
    let a = null;
    if (e.gap && (a = this.getNextFragment(this.nextLoadPosition, t), a && !a.gap && i.nextStart)) {
      const o = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, i.nextStart, s, 0);
      if (o !== null && i.len + o.len >= r) {
        const l = a.sn;
        return this.loopSn !== l && (this.log(`buffer full after gaps in "${s}" playlist starting at sn: ${l}`), this.loopSn = l), null;
      }
    }
    return this.loopSn = void 0, a;
  }
  get primaryPrefetch() {
    if (Cf(this.config)) {
      var e;
      if ((e = this.hls.interstitialsManager) == null || (e = e.playingItem) == null ? void 0 : e.event)
        return !0;
    }
    return !1;
  }
  filterReplacedPrimary(e, t) {
    if (!e)
      return e;
    if (Cf(this.config) && e.type !== te.SUBTITLE) {
      const i = this.hls.interstitialsManager, s = i?.bufferingItem;
      if (s) {
        const a = s.event;
        if (a) {
          if (a.appendInPlace || Math.abs(e.start - s.start) > 1 || s.start === 0)
            return null;
        } else if (e.end <= s.start && t?.live === !1 || e.start > s.end && s.nextEvent && (s.nextEvent.appendInPlace || e.start - s.end > 1))
          return null;
      }
      const r = i?.playerQueue;
      if (r)
        for (let a = r.length; a--; ) {
          const o = r[a].interstitial;
          if (o.appendInPlace && e.start >= o.startTime && e.end <= o.resumeTime)
            return null;
        }
    }
    return e;
  }
  mapToInitFragWhenRequired(e) {
    return e != null && e.initSegment && !e.initSegment.data && !this.bitrateTest ? e.initSegment : e;
  }
  getNextPart(e, t, i) {
    let s = -1, r = !1, a = !0;
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o];
      if (a = a && !c.independent, s > -1 && i < c.start)
        break;
      const u = c.loaded;
      u ? s = -1 : (r || (c.independent || a) && c.fragment === t) && (c.fragment !== t && this.warn(`Need buffer at ${i} but next unloaded part starts at ${c.start}`), s = o), r = u;
    }
    return s;
  }
  loadedEndOfParts(e, t) {
    let i;
    for (let s = e.length; s--; ) {
      if (i = e[s], !i.loaded)
        return !1;
      if (t > i.start)
        return !0;
    }
    return !1;
  }
  /*
   This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the
   "sliding" of the playlist, which is its offset from the start of playback. After sliding we can compute the real
   start and end times for each fragment in the playlist (after which this method will not need to be called).
  */
  getInitialLiveFragment(e) {
    const t = e.fragments, i = this.fragPrevious;
    let s = null;
    if (i) {
      if (e.hasProgramDateTime && (this.log(`Live playlist, switching playlist, load frag with same PDT: ${i.programDateTime}`), s = jy(t, i.endProgramDateTime, this.config.maxFragLookUpTolerance)), !s) {
        const r = i.sn + 1;
        if (r >= e.startSN && r <= e.endSN) {
          const a = t[r - e.startSN];
          i.cc === a.cc && (s = a, this.log(`Live playlist, switching playlist, load frag with next SN: ${s.sn}`));
        }
        s || (s = og(e, i.cc, i.end), s && this.log(`Live playlist, switching playlist, load frag with same CC: ${s.sn}`));
      }
    } else {
      const r = this.hls.liveSyncPosition;
      r !== null && (s = this.getFragmentAtPosition(r, this.bitrateTest ? e.fragmentEnd : e.edge, e));
    }
    return s;
  }
  /*
  This method finds the best matching fragment given the provided position.
   */
  getFragmentAtPosition(e, t, i) {
    const {
      config: s
    } = this;
    let {
      fragPrevious: r
    } = this, {
      fragments: a,
      endSN: o
    } = i;
    const {
      fragmentHint: l
    } = i, {
      maxFragLookUpTolerance: c
    } = s, u = i.partList, d = !!(this.loadingParts && u != null && u.length && l);
    d && !this.bitrateTest && u[u.length - 1].fragment.sn === l.sn && (a = a.concat(l), o = l.sn);
    let f;
    if (e < t) {
      var p;
      const g = e < this.lastCurrentTime || e > t - c || (p = this.media) != null && p.paused || !this.startFragRequested ? 0 : c;
      f = Rr(r, a, e, g);
    } else
      f = a[a.length - 1];
    if (f) {
      const h = f.sn - i.startSN, g = this.fragmentTracker.getState(f);
      if ((g === yt.OK || g === yt.PARTIAL && f.gap) && (r = f), r && f.sn === r.sn && (!d || u[0].fragment.sn > f.sn || !i.live) && f.level === r.level) {
        const v = a[h + 1];
        f.sn < o && this.fragmentTracker.getState(v) !== yt.OK ? f = v : f = null;
      }
    }
    return f;
  }
  alignPlaylists(e, t, i) {
    const s = e.fragments.length;
    if (!s)
      return this.warn("No fragments in live playlist"), 0;
    const r = e.fragmentStart, a = !t, o = e.alignedSliding && Z(r);
    if (a || !o && !r) {
      kE(i, e);
      const l = e.fragmentStart;
      return this.log(`Live playlist sliding: ${l.toFixed(2)} start-sn: ${t ? t.startSN : "na"}->${e.startSN} fragments: ${s}`), l;
    }
    return r;
  }
  waitForCdnTuneIn(e) {
    return e.live && e.canBlockReload && e.partTarget && e.tuneInGoal > Math.max(e.partHoldBack, e.partTarget * 3);
  }
  setStartPosition(e, t) {
    let i = this.startPosition;
    i < t && (i = -1);
    const s = this.timelineOffset;
    if (i === -1) {
      const r = this.startTimeOffset !== null, a = r ? this.startTimeOffset : e.startTimeOffset;
      a !== null && Z(a) ? (i = t + a, a < 0 && (i += e.edge), i = Math.min(Math.max(t, i), t + e.totalduration), this.log(`Setting startPosition to ${i} for start time offset ${a} found in ${r ? "multivariant" : "media"} playlist`), this.startPosition = i) : e.live ? (i = this.hls.liveSyncPosition || t, this.log(`Setting startPosition to -1 to start at live edge ${i}`), this.startPosition = -1) : (this.log("setting startPosition to 0 by default"), this.startPosition = i = 0), this.lastCurrentTime = i + s;
    }
    this.nextLoadPosition = i + s;
  }
  getLoadPosition() {
    var e;
    const {
      media: t
    } = this;
    let i = 0;
    return (e = this.hls) != null && e.hasEnoughToStart && t ? i = t.currentTime : this.nextLoadPosition >= 0 && (i = this.nextLoadPosition), i;
  }
  handleFragLoadAborted(e, t) {
    this.transmuxer && e.type === this.playlistType && ot(e) && e.stats.aborted && (this.log(`Fragment ${e.sn}${t ? " part " + t.index : ""} of ${this.playlistLabel()} ${e.level} was aborted`), this.resetFragmentLoading(e));
  }
  resetFragmentLoading(e) {
    (!this.fragCurrent || !this.fragContextChanged(e) && this.state !== q.FRAG_LOADING_WAITING_RETRY) && (this.state = q.IDLE);
  }
  onFragmentOrKeyLoadError(e, t) {
    var i;
    if (t.chunkMeta && !t.frag) {
      const v = this.getCurrentContext(t.chunkMeta);
      v && (t.frag = v.frag);
    }
    const s = t.frag;
    if (!s || s.type !== e || !this.levels)
      return;
    if (this.fragContextChanged(s)) {
      var r;
      this.warn(`Frag load error must match current frag to retry ${s.url} > ${(r = this.fragCurrent) == null ? void 0 : r.url}`);
      return;
    }
    const a = t.details === H.FRAG_GAP;
    a && this.fragmentTracker.fragBuffered(s, !0);
    const o = t.errorAction;
    if (!o) {
      this.state = q.ERROR;
      return;
    }
    const {
      action: l,
      flags: c,
      retryCount: u = 0,
      retryConfig: d
    } = o, f = !!d, p = f && l === It.RetryRequest, h = f && !o.resolved && c === ci.MoveAllAlternatesMatchingHost, g = (i = this.hls.latestLevelDetails) == null ? void 0 : i.live;
    if (!p && h && ot(s) && !s.endList && g && !cg(t))
      this.resetFragmentErrors(e), this.treatAsGap(s), o.resolved = !0;
    else if ((p || h) && u < d.maxNumRetry) {
      var m;
      const v = Oc((m = t.response) == null ? void 0 : m.code), y = Ou(d, u);
      if (this.resetStartWhenNotLoaded(), this.retryDate = self.performance.now() + y, this.state = q.FRAG_LOADING_WAITING_RETRY, o.resolved = !0, v) {
        this.log("Waiting for connection (offline)"), this.retryDate = 1 / 0, t.reason = "offline";
        return;
      }
      this.warn(`Fragment ${s.sn} of ${e} ${s.level} errored with ${t.details}, retrying loading ${u + 1}/${d.maxNumRetry} in ${y}ms`);
    } else if (d)
      if (this.resetFragmentErrors(e), u < d.maxNumRetry)
        !a && l !== It.RemoveAlternatePermanently && (o.resolved = !0);
      else {
        this.warn(`${t.details} reached or exceeded max retry (${u})`);
        return;
      }
    else l === It.SendAlternateToPenaltyBox ? this.state = q.WAITING_LEVEL : this.state = q.ERROR;
    this.tickImmediate();
  }
  checkRetryDate() {
    const e = self.performance.now(), t = this.retryDate, i = t === 1 / 0;
    (!t || e >= t || i && !Oc(0)) && (i && this.log("Connection restored (online)"), this.resetStartWhenNotLoaded(), this.state = q.IDLE);
  }
  reduceLengthAndFlushBuffer(e) {
    if (this.state === q.PARSING || this.state === q.PARSED) {
      const t = e.frag, i = e.parent, s = this.getFwdBufferInfo(this.mediaBuffer, i), r = s && s.len > 0.5;
      r && this.reduceMaxBufferLength(s.len, t?.duration || 10);
      const a = !r;
      return a && this.warn(`Buffer full error while media.currentTime (${this.getLoadPosition()}) is not buffered, flush ${i} buffer`), t && (this.fragmentTracker.removeFragment(t), this.nextLoadPosition = t.start), this.resetLoadingState(), a;
    }
    return !1;
  }
  resetFragmentErrors(e) {
    e === te.AUDIO && (this.fragCurrent = null), this.hls.hasEnoughToStart || (this.startFragRequested = !1), this.state !== q.STOPPED && (this.state = q.IDLE);
  }
  afterBufferFlushed(e, t, i) {
    if (!e)
      return;
    const s = de.getBuffered(e);
    this.fragmentTracker.detectEvictedFragments(t, s, i), this.state === q.ENDED && this.resetLoadingState();
  }
  resetLoadingState() {
    this.log("Reset loading state"), this.fragCurrent = null, this.fragPrevious = null, this.state !== q.STOPPED && (this.state = q.IDLE);
  }
  resetStartWhenNotLoaded() {
    if (!this.hls.hasEnoughToStart) {
      this.startFragRequested = !1;
      const e = this.levelLastLoaded, t = e ? e.details : null;
      t != null && t.live ? (this.log("resetting startPosition for live start"), this.startPosition = -1, this.setStartPosition(t, t.fragmentStart), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition;
    }
  }
  resetWhenMissingContext(e) {
    this.log(`Loading context changed while buffering sn ${e.sn} of ${this.playlistLabel()} ${e.level === -1 ? "<removed>" : e.level}. This chunk will not be buffered.`), this.removeUnbufferedFrags(), this.resetStartWhenNotLoaded(), this.resetLoadingState();
  }
  removeUnbufferedFrags(e = 0) {
    this.fragmentTracker.removeFragmentsInRange(e, 1 / 0, this.playlistType, !1, !0);
  }
  updateLevelTiming(e, t, i, s) {
    const r = i.details;
    if (!r) {
      this.warn("level.details undefined");
      return;
    }
    if (!Object.keys(e.elementaryStreams).reduce((l, c) => {
      const u = e.elementaryStreams[c];
      if (u) {
        const d = u.endPTS - u.startPTS;
        if (d <= 0)
          return this.warn(`Could not parse fragment ${e.sn} ${c} duration reliably (${d})`), l || !1;
        const f = s ? 0 : yg(r, e, u.startPTS, u.endPTS, u.startDTS, u.endDTS, this);
        return this.hls.trigger(x.LEVEL_PTS_UPDATED, {
          details: r,
          level: i,
          drift: f,
          type: c,
          frag: e,
          start: u.startPTS,
          end: u.endPTS
        }), !0;
      }
      return l;
    }, !1)) {
      var o;
      const l = ((o = this.transmuxer) == null ? void 0 : o.error) === null;
      if ((i.fragmentError === 0 || l && (i.fragmentError < 2 || e.endList)) && this.treatAsGap(e, i), l) {
        const c = new Error(`Found no media in fragment ${e.sn} of ${this.playlistLabel()} ${e.level} resetting transmuxer to fallback to playlist timing`);
        if (this.warn(c.message), this.hls.trigger(x.ERROR, {
          type: se.MEDIA_ERROR,
          details: H.FRAG_PARSING_ERROR,
          fatal: !1,
          error: c,
          frag: e,
          reason: `Found no media in msn ${e.sn} of ${this.playlistLabel()} "${i.url}"`
        }), !this.hls)
          return;
        this.resetTransmuxer();
      }
    }
    this.state = q.PARSED, this.log(`Parsed ${e.type} sn: ${e.sn}${t ? " part: " + t.index : ""} of ${this.fragInfo(e, !1, t)})`), this.hls.trigger(x.FRAG_PARSED, {
      frag: e,
      part: t
    });
  }
  playlistLabel() {
    return this.playlistType === te.MAIN ? "level" : "track";
  }
  fragInfo(e, t = !0, i) {
    var s, r;
    return `${this.playlistLabel()} ${e.level} (${i ? "part" : "frag"}:[${((s = t && !i ? e.startPTS : (i || e).start) != null ? s : NaN).toFixed(3)}-${((r = t && !i ? e.endPTS : (i || e).end) != null ? r : NaN).toFixed(3)}]${i && e.type === "main" ? "INDEPENDENT=" + (i.independent ? "YES" : "NO") : ""}`;
  }
  treatAsGap(e, t) {
    t && t.fragmentError++, e.gap = !0, this.fragmentTracker.removeFragment(e), this.fragmentTracker.fragBuffered(e, !0);
  }
  resetTransmuxer() {
    var e;
    (e = this.transmuxer) == null || e.reset();
  }
  recoverWorkerError(e) {
    e.event === "demuxerWorker" && (this.fragmentTracker.removeAllFragments(), this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null), this.resetStartWhenNotLoaded(), this.resetLoadingState());
  }
  set state(e) {
    const t = this._state;
    t !== e && (this._state = e, this.log(`${t}->${e}`));
  }
  get state() {
    return this._state;
  }
}
function Cf(n) {
  return !!n.interstitialsController && n.enableInterstitialPlayback !== !1;
}
class wg {
  constructor() {
    this.chunks = [], this.dataLength = 0;
  }
  push(e) {
    this.chunks.push(e), this.dataLength += e.length;
  }
  flush() {
    const {
      chunks: e,
      dataLength: t
    } = this;
    let i;
    if (e.length)
      e.length === 1 ? i = e[0] : i = OE(e, t);
    else return new Uint8Array(0);
    return this.reset(), i;
  }
  reset() {
    this.chunks.length = 0, this.dataLength = 0;
  }
}
function OE(n, e) {
  const t = new Uint8Array(e);
  let i = 0;
  for (let s = 0; s < n.length; s++) {
    const r = n[s];
    t.set(r, i), i += r.length;
  }
  return t;
}
var Dl = { exports: {} }, Pf;
function FE() {
  return Pf || (Pf = 1, (function(n) {
    var e = Object.prototype.hasOwnProperty, t = "~";
    function i() {
    }
    Object.create && (i.prototype = /* @__PURE__ */ Object.create(null), new i().__proto__ || (t = !1));
    function s(l, c, u) {
      this.fn = l, this.context = c, this.once = u || !1;
    }
    function r(l, c, u, d, f) {
      if (typeof u != "function")
        throw new TypeError("The listener must be a function");
      var p = new s(u, d || l, f), h = t ? t + c : c;
      return l._events[h] ? l._events[h].fn ? l._events[h] = [l._events[h], p] : l._events[h].push(p) : (l._events[h] = p, l._eventsCount++), l;
    }
    function a(l, c) {
      --l._eventsCount === 0 ? l._events = new i() : delete l._events[c];
    }
    function o() {
      this._events = new i(), this._eventsCount = 0;
    }
    o.prototype.eventNames = function() {
      var c = [], u, d;
      if (this._eventsCount === 0) return c;
      for (d in u = this._events)
        e.call(u, d) && c.push(t ? d.slice(1) : d);
      return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(u)) : c;
    }, o.prototype.listeners = function(c) {
      var u = t ? t + c : c, d = this._events[u];
      if (!d) return [];
      if (d.fn) return [d.fn];
      for (var f = 0, p = d.length, h = new Array(p); f < p; f++)
        h[f] = d[f].fn;
      return h;
    }, o.prototype.listenerCount = function(c) {
      var u = t ? t + c : c, d = this._events[u];
      return d ? d.fn ? 1 : d.length : 0;
    }, o.prototype.emit = function(c, u, d, f, p, h) {
      var g = t ? t + c : c;
      if (!this._events[g]) return !1;
      var m = this._events[g], v = arguments.length, y, E;
      if (m.fn) {
        switch (m.once && this.removeListener(c, m.fn, void 0, !0), v) {
          case 1:
            return m.fn.call(m.context), !0;
          case 2:
            return m.fn.call(m.context, u), !0;
          case 3:
            return m.fn.call(m.context, u, d), !0;
          case 4:
            return m.fn.call(m.context, u, d, f), !0;
          case 5:
            return m.fn.call(m.context, u, d, f, p), !0;
          case 6:
            return m.fn.call(m.context, u, d, f, p, h), !0;
        }
        for (E = 1, y = new Array(v - 1); E < v; E++)
          y[E - 1] = arguments[E];
        m.fn.apply(m.context, y);
      } else {
        var T = m.length, S;
        for (E = 0; E < T; E++)
          switch (m[E].once && this.removeListener(c, m[E].fn, void 0, !0), v) {
            case 1:
              m[E].fn.call(m[E].context);
              break;
            case 2:
              m[E].fn.call(m[E].context, u);
              break;
            case 3:
              m[E].fn.call(m[E].context, u, d);
              break;
            case 4:
              m[E].fn.call(m[E].context, u, d, f);
              break;
            default:
              if (!y) for (S = 1, y = new Array(v - 1); S < v; S++)
                y[S - 1] = arguments[S];
              m[E].fn.apply(m[E].context, y);
          }
      }
      return !0;
    }, o.prototype.on = function(c, u, d) {
      return r(this, c, u, d, !1);
    }, o.prototype.once = function(c, u, d) {
      return r(this, c, u, d, !0);
    }, o.prototype.removeListener = function(c, u, d, f) {
      var p = t ? t + c : c;
      if (!this._events[p]) return this;
      if (!u)
        return a(this, p), this;
      var h = this._events[p];
      if (h.fn)
        h.fn === u && (!f || h.once) && (!d || h.context === d) && a(this, p);
      else {
        for (var g = 0, m = [], v = h.length; g < v; g++)
          (h[g].fn !== u || f && !h[g].once || d && h[g].context !== d) && m.push(h[g]);
        m.length ? this._events[p] = m.length === 1 ? m[0] : m : a(this, p);
      }
      return this;
    }, o.prototype.removeAllListeners = function(c) {
      var u;
      return c ? (u = t ? t + c : c, this._events[u] && a(this, u)) : (this._events = new i(), this._eventsCount = 0), this;
    }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = t, o.EventEmitter = o, n.exports = o;
  })(Dl)), Dl.exports;
}
var NE = FE(), Gu = /* @__PURE__ */ ly(NE);
const ma = "1.6.15", vn = {};
function $E() {
  return typeof __HLS_WORKER_BUNDLE__ == "function";
}
function BE() {
  const n = vn[ma];
  if (n)
    return n.clientCount++, n;
  const e = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {
    type: "text/javascript"
  }), t = self.URL.createObjectURL(e), s = {
    worker: new self.Worker(t),
    objectURL: t,
    clientCount: 1
  };
  return vn[ma] = s, s;
}
function UE(n) {
  const e = vn[n];
  if (e)
    return e.clientCount++, e;
  const t = new self.URL(n, self.location.href).href, s = {
    worker: new self.Worker(t),
    scriptURL: t,
    clientCount: 1
  };
  return vn[n] = s, s;
}
function GE(n) {
  const e = vn[n || ma];
  if (e && e.clientCount-- === 1) {
    const {
      worker: i,
      objectURL: s
    } = e;
    delete vn[n || ma], s && self.URL.revokeObjectURL(s), i.terminate();
  }
}
function Lg(n, e) {
  return e + 10 <= n.length && n[e] === 51 && n[e + 1] === 68 && n[e + 2] === 73 && n[e + 3] < 255 && n[e + 4] < 255 && n[e + 6] < 128 && n[e + 7] < 128 && n[e + 8] < 128 && n[e + 9] < 128;
}
function Hu(n, e) {
  return e + 10 <= n.length && n[e] === 73 && n[e + 1] === 68 && n[e + 2] === 51 && n[e + 3] < 255 && n[e + 4] < 255 && n[e + 6] < 128 && n[e + 7] < 128 && n[e + 8] < 128 && n[e + 9] < 128;
}
function sl(n, e) {
  let t = 0;
  return t = (n[e] & 127) << 21, t |= (n[e + 1] & 127) << 14, t |= (n[e + 2] & 127) << 7, t |= n[e + 3] & 127, t;
}
function va(n, e) {
  const t = e;
  let i = 0;
  for (; Hu(n, e); ) {
    i += 10;
    const s = sl(n, e + 6);
    i += s, Lg(n, e + 10) && (i += 10), e += i;
  }
  if (i > 0)
    return n.subarray(t, t + i);
}
function HE(n, e, t, i) {
  const s = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350], r = e[t + 2], a = r >> 2 & 15;
  if (a > 12) {
    const p = new Error(`invalid ADTS sampling index:${a}`);
    n.emit(x.ERROR, x.ERROR, {
      type: se.MEDIA_ERROR,
      details: H.FRAG_PARSING_ERROR,
      fatal: !0,
      error: p,
      reason: p.message
    });
    return;
  }
  const o = (r >> 6 & 3) + 1, l = e[t + 3] >> 6 & 3 | (r & 1) << 2, c = "mp4a.40." + o, u = s[a];
  let d = a;
  (o === 5 || o === 29) && (d -= 3);
  const f = [o << 3 | (d & 14) >> 1, (d & 1) << 7 | l << 3];
  return Oe.log(`manifest codec:${i}, parsed codec:${c}, channels:${l}, rate:${u} (ADTS object type:${o} sampling index:${a})`), {
    config: f,
    samplerate: u,
    channelCount: l,
    codec: c,
    parsedCodec: c,
    manifestCodec: i
  };
}
function Ig(n, e) {
  return n[e] === 255 && (n[e + 1] & 246) === 240;
}
function Rg(n, e) {
  return n[e + 1] & 1 ? 7 : 9;
}
function Vu(n, e) {
  return (n[e + 3] & 3) << 11 | n[e + 4] << 3 | (n[e + 5] & 224) >>> 5;
}
function VE(n, e) {
  return e + 5 < n.length;
}
function Wo(n, e) {
  return e + 1 < n.length && Ig(n, e);
}
function zE(n, e) {
  return VE(n, e) && Ig(n, e) && Vu(n, e) <= n.length - e;
}
function WE(n, e) {
  if (Wo(n, e)) {
    const t = Rg(n, e);
    if (e + t >= n.length)
      return !1;
    const i = Vu(n, e);
    if (i <= t)
      return !1;
    const s = e + i;
    return s === n.length || Wo(n, s);
  }
  return !1;
}
function Cg(n, e, t, i, s) {
  if (!n.samplerate) {
    const r = HE(e, t, i, s);
    if (!r)
      return;
    Fe(n, r);
  }
}
function Pg(n) {
  return 1024 * 9e4 / n;
}
function KE(n, e) {
  const t = Rg(n, e);
  if (e + t <= n.length) {
    const i = Vu(n, e) - t;
    if (i > 0)
      return {
        headerLength: t,
        frameLength: i
      };
  }
}
function Dg(n, e, t, i, s) {
  const r = Pg(n.samplerate), a = i + s * r, o = KE(e, t);
  let l;
  if (o) {
    const {
      frameLength: d,
      headerLength: f
    } = o, p = f + d, h = Math.max(0, t + p - e.length);
    h ? (l = new Uint8Array(p - f), l.set(e.subarray(t + f, e.length), 0)) : l = e.subarray(t + f, t + p);
    const g = {
      unit: l,
      pts: a
    };
    return h || n.samples.push(g), {
      sample: g,
      length: p,
      missing: h
    };
  }
  const c = e.length - t;
  return l = new Uint8Array(c), l.set(e.subarray(t, e.length), 0), {
    sample: {
      unit: l,
      pts: a
    },
    length: c,
    missing: -1
  };
}
function YE(n, e) {
  return Hu(n, e) && sl(n, e + 6) + 10 <= n.length - e;
}
function qE(n) {
  return n instanceof ArrayBuffer ? n : n.byteOffset == 0 && n.byteLength == n.buffer.byteLength ? n.buffer : new Uint8Array(n).buffer;
}
function kl(n, e = 0, t = 1 / 0) {
  return XE(n, e, t, Uint8Array);
}
function XE(n, e, t, i) {
  const s = jE(n);
  let r = 1;
  "BYTES_PER_ELEMENT" in i && (r = i.BYTES_PER_ELEMENT);
  const a = QE(n) ? n.byteOffset : 0, o = (a + n.byteLength) / r, l = (a + e) / r, c = Math.floor(Math.max(0, Math.min(l, o))), u = Math.floor(Math.min(c + Math.max(t, 0), o));
  return new i(s, c, u - c);
}
function jE(n) {
  return n instanceof ArrayBuffer ? n : n.buffer;
}
function QE(n) {
  return n && n.buffer instanceof ArrayBuffer && n.byteLength !== void 0 && n.byteOffset !== void 0;
}
function ZE(n) {
  const e = {
    key: n.type,
    description: "",
    data: "",
    mimeType: null,
    pictureType: null
  }, t = 3;
  if (n.size < 2)
    return;
  if (n.data[0] !== t) {
    console.log("Ignore frame with unrecognized character encoding");
    return;
  }
  const i = n.data.subarray(1).indexOf(0);
  if (i === -1)
    return;
  const s = bi(kl(n.data, 1, i)), r = n.data[2 + i], a = n.data.subarray(3 + i).indexOf(0);
  if (a === -1)
    return;
  const o = bi(kl(n.data, 3 + i, a));
  let l;
  return s === "-->" ? l = bi(kl(n.data, 4 + i + a)) : l = qE(n.data.subarray(4 + i + a)), e.mimeType = s, e.pictureType = r, e.description = o, e.data = l, e;
}
function JE(n) {
  if (n.size < 2)
    return;
  const e = bi(n.data, !0), t = new Uint8Array(n.data.subarray(e.length + 1));
  return {
    key: n.type,
    info: e,
    data: t.buffer
  };
}
function eT(n) {
  if (n.size < 2)
    return;
  if (n.type === "TXXX") {
    let t = 1;
    const i = bi(n.data.subarray(t), !0);
    t += i.length + 1;
    const s = bi(n.data.subarray(t));
    return {
      key: n.type,
      info: i,
      data: s
    };
  }
  const e = bi(n.data.subarray(1));
  return {
    key: n.type,
    info: "",
    data: e
  };
}
function tT(n) {
  if (n.type === "WXXX") {
    if (n.size < 2)
      return;
    let t = 1;
    const i = bi(n.data.subarray(t), !0);
    t += i.length + 1;
    const s = bi(n.data.subarray(t));
    return {
      key: n.type,
      info: i,
      data: s
    };
  }
  const e = bi(n.data);
  return {
    key: n.type,
    info: "",
    data: e
  };
}
function iT(n) {
  return n.type === "PRIV" ? JE(n) : n.type[0] === "W" ? tT(n) : n.type === "APIC" ? ZE(n) : eT(n);
}
function sT(n) {
  const e = String.fromCharCode(n[0], n[1], n[2], n[3]), t = sl(n, 4), i = 10;
  return {
    type: e,
    size: t,
    data: n.subarray(i, i + t)
  };
}
const Wa = 10, rT = 10;
function kg(n) {
  let e = 0;
  const t = [];
  for (; Hu(n, e); ) {
    const i = sl(n, e + 6);
    n[e + 5] >> 6 & 1 && (e += Wa), e += Wa;
    const s = e + i;
    for (; e + rT < s; ) {
      const r = sT(n.subarray(e)), a = iT(r);
      a && t.push(a), e += r.size + Wa;
    }
    Lg(n, e) && (e += Wa);
  }
  return t;
}
function Mg(n) {
  return n && n.key === "PRIV" && n.info === "com.apple.streaming.transportStreamTimestamp";
}
function nT(n) {
  if (n.data.byteLength === 8) {
    const e = new Uint8Array(n.data), t = e[3] & 1;
    let i = (e[4] << 23) + (e[5] << 15) + (e[6] << 7) + e[7];
    return i /= 45, t && (i += 4772185884e-2), Math.round(i);
  }
}
function zu(n) {
  const e = kg(n);
  for (let t = 0; t < e.length; t++) {
    const i = e[t];
    if (Mg(i))
      return nT(i);
  }
}
let vi = /* @__PURE__ */ (function(n) {
  return n.audioId3 = "org.id3", n.dateRange = "com.apple.quicktime.HLS", n.emsg = "https://aomedia.org/emsg/ID3", n.misbklv = "urn:misb:KLV:bin:1910.1", n;
})({});
function Ji(n = "", e = 9e4) {
  return {
    type: n,
    id: -1,
    pid: -1,
    inputTimeScale: e,
    sequenceNumber: -1,
    samples: [],
    dropped: 0
  };
}
class Wu {
  constructor() {
    this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null;
  }
  resetInitSegment(e, t, i, s) {
    this._id3Track = {
      type: "id3",
      id: 3,
      pid: -1,
      inputTimeScale: 9e4,
      sequenceNumber: 0,
      samples: [],
      dropped: 0
    };
  }
  resetTimeStamp(e) {
    this.initPTS = e, this.resetContiguity();
  }
  resetContiguity() {
    this.basePTS = null, this.lastPTS = null, this.frameIndex = 0;
  }
  canParse(e, t) {
    return !1;
  }
  appendFrame(e, t, i) {
  }
  // feed incoming data to the front of the parsing pipeline
  demux(e, t) {
    this.cachedData && (e = Oi(this.cachedData, e), this.cachedData = null);
    let i = va(e, 0), s = i ? i.length : 0, r;
    const a = this._audioTrack, o = this._id3Track, l = i ? zu(i) : void 0, c = e.length;
    for ((this.basePTS === null || this.frameIndex === 0 && Z(l)) && (this.basePTS = aT(l, t, this.initPTS), this.lastPTS = this.basePTS), this.lastPTS === null && (this.lastPTS = this.basePTS), i && i.length > 0 && o.samples.push({
      pts: this.lastPTS,
      dts: this.lastPTS,
      data: i,
      type: vi.audioId3,
      duration: Number.POSITIVE_INFINITY
    }); s < c; ) {
      if (this.canParse(e, s)) {
        const u = this.appendFrame(a, e, s);
        u ? (this.frameIndex++, this.lastPTS = u.sample.pts, s += u.length, r = s) : s = c;
      } else YE(e, s) ? (i = va(e, s), o.samples.push({
        pts: this.lastPTS,
        dts: this.lastPTS,
        data: i,
        type: vi.audioId3,
        duration: Number.POSITIVE_INFINITY
      }), s += i.length, r = s) : s++;
      if (s === c && r !== c) {
        const u = e.slice(r);
        this.cachedData ? this.cachedData = Oi(this.cachedData, u) : this.cachedData = u;
      }
    }
    return {
      audioTrack: a,
      videoTrack: Ji(),
      id3Track: o,
      textTrack: Ji()
    };
  }
  demuxSampleAes(e, t, i) {
    return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`));
  }
  flush(e) {
    const t = this.cachedData;
    return t && (this.cachedData = null, this.demux(t, 0)), {
      audioTrack: this._audioTrack,
      videoTrack: Ji(),
      id3Track: this._id3Track,
      textTrack: Ji()
    };
  }
  destroy() {
    this.cachedData = null, this._audioTrack = this._id3Track = void 0;
  }
}
const aT = (n, e, t) => {
  if (Z(n))
    return n * 90;
  const i = t ? t.baseTime * 9e4 / t.timescale : 0;
  return e * 9e4 + i;
};
let Ka = null;
const oT = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160], lT = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3], cT = [
  // MPEG 2.5
  [
    0,
    // Reserved
    72,
    // Layer3
    144,
    // Layer2
    12
    // Layer1
  ],
  // Reserved
  [
    0,
    // Reserved
    0,
    // Layer3
    0,
    // Layer2
    0
    // Layer1
  ],
  // MPEG 2
  [
    0,
    // Reserved
    72,
    // Layer3
    144,
    // Layer2
    12
    // Layer1
  ],
  // MPEG 1
  [
    0,
    // Reserved
    144,
    // Layer3
    144,
    // Layer2
    12
    // Layer1
  ]
], uT = [
  0,
  // Reserved
  1,
  // Layer3
  1,
  // Layer2
  4
  // Layer1
];
function Og(n, e, t, i, s) {
  if (t + 24 > e.length)
    return;
  const r = Fg(e, t);
  if (r && t + r.frameLength <= e.length) {
    const a = r.samplesPerFrame * 9e4 / r.sampleRate, o = i + s * a, l = {
      unit: e.subarray(t, t + r.frameLength),
      pts: o,
      dts: o
    };
    return n.config = [], n.channelCount = r.channelCount, n.samplerate = r.sampleRate, n.samples.push(l), {
      sample: l,
      length: r.frameLength,
      missing: 0
    };
  }
}
function Fg(n, e) {
  const t = n[e + 1] >> 3 & 3, i = n[e + 1] >> 1 & 3, s = n[e + 2] >> 4 & 15, r = n[e + 2] >> 2 & 3;
  if (t !== 1 && s !== 0 && s !== 15 && r !== 3) {
    const a = n[e + 2] >> 1 & 1, o = n[e + 3] >> 6, l = t === 3 ? 3 - i : i === 3 ? 3 : 4, c = oT[l * 14 + s - 1] * 1e3, d = lT[(t === 3 ? 0 : t === 2 ? 1 : 2) * 3 + r], f = o === 3 ? 1 : 2, p = cT[t][i], h = uT[i], g = p * 8 * h, m = Math.floor(p * c / d + a) * h;
    if (Ka === null) {
      const E = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
      Ka = E ? parseInt(E[1]) : 0;
    }
    return !!Ka && Ka <= 87 && i === 2 && c >= 224e3 && o === 0 && (n[e + 3] = n[e + 3] | 128), {
      sampleRate: d,
      channelCount: f,
      frameLength: m,
      samplesPerFrame: g
    };
  }
}
function Ku(n, e) {
  return n[e] === 255 && (n[e + 1] & 224) === 224 && (n[e + 1] & 6) !== 0;
}
function Ng(n, e) {
  return e + 1 < n.length && Ku(n, e);
}
function dT(n, e) {
  return Ku(n, e) && 4 <= n.length - e;
}
function $g(n, e) {
  if (e + 1 < n.length && Ku(n, e)) {
    const i = Fg(n, e);
    let s = 4;
    i != null && i.frameLength && (s = i.frameLength);
    const r = e + s;
    return r === n.length || Ng(n, r);
  }
  return !1;
}
class fT extends Wu {
  constructor(e, t) {
    super(), this.observer = void 0, this.config = void 0, this.observer = e, this.config = t;
  }
  resetInitSegment(e, t, i, s) {
    super.resetInitSegment(e, t, i, s), this._audioTrack = {
      container: "audio/adts",
      type: "audio",
      id: 2,
      pid: -1,
      sequenceNumber: 0,
      segmentCodec: "aac",
      samples: [],
      manifestCodec: t,
      duration: s,
      inputTimeScale: 9e4,
      dropped: 0
    };
  }
  // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS
  static probe(e, t) {
    if (!e)
      return !1;
    const i = va(e, 0);
    let s = i?.length || 0;
    if ($g(e, s))
      return !1;
    for (let r = e.length; s < r; s++)
      if (WE(e, s))
        return t.log("ADTS sync word found !"), !0;
    return !1;
  }
  canParse(e, t) {
    return zE(e, t);
  }
  appendFrame(e, t, i) {
    Cg(e, this.observer, t, i, e.manifestCodec);
    const s = Dg(e, t, i, this.basePTS, this.frameIndex);
    if (s && s.missing === 0)
      return s;
  }
}
const Bg = (n, e) => {
  let t = 0, i = 5;
  e += i;
  const s = new Uint32Array(1), r = new Uint32Array(1), a = new Uint8Array(1);
  for (; i > 0; ) {
    a[0] = n[e];
    const o = Math.min(i, 8), l = 8 - o;
    r[0] = 4278190080 >>> 24 + l << l, s[0] = (a[0] & r[0]) >> l, t = t ? t << o | s[0] : s[0], e += 1, i -= o;
  }
  return t;
};
class hT extends Wu {
  constructor(e) {
    super(), this.observer = void 0, this.observer = e;
  }
  resetInitSegment(e, t, i, s) {
    super.resetInitSegment(e, t, i, s), this._audioTrack = {
      container: "audio/ac-3",
      type: "audio",
      id: 2,
      pid: -1,
      sequenceNumber: 0,
      segmentCodec: "ac3",
      samples: [],
      manifestCodec: t,
      duration: s,
      inputTimeScale: 9e4,
      dropped: 0
    };
  }
  canParse(e, t) {
    return t + 64 < e.length;
  }
  appendFrame(e, t, i) {
    const s = Ug(e, t, i, this.basePTS, this.frameIndex);
    if (s !== -1)
      return {
        sample: e.samples[e.samples.length - 1],
        length: s,
        missing: 0
      };
  }
  static probe(e) {
    if (!e)
      return !1;
    const t = va(e, 0);
    if (!t)
      return !1;
    const i = t.length;
    return e[i] === 11 && e[i + 1] === 119 && zu(t) !== void 0 && // check the bsid to confirm ac-3
    Bg(e, i) < 16;
  }
}
function Ug(n, e, t, i, s) {
  if (t + 8 > e.length || e[t] !== 11 || e[t + 1] !== 119)
    return -1;
  const r = e[t + 4] >> 6;
  if (r >= 3)
    return -1;
  const o = [48e3, 44100, 32e3][r], l = e[t + 4] & 63, u = [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920][l * 3 + r] * 2;
  if (t + u > e.length)
    return -1;
  const d = e[t + 6] >> 5;
  let f = 0;
  d === 2 ? f += 2 : (d & 1 && d !== 1 && (f += 2), d & 4 && (f += 2));
  const p = (e[t + 6] << 8 | e[t + 7]) >> 12 - f & 1, g = [2, 1, 2, 3, 3, 4, 4, 5][d] + p, m = e[t + 5] >> 3, v = e[t + 5] & 7, y = new Uint8Array([r << 6 | m << 1 | v >> 2, (v & 3) << 6 | d << 3 | p << 2 | l >> 4, l << 4 & 224]), E = 1536 / o * 9e4, T = i + s * E, S = e.subarray(t, t + u);
  return n.config = y, n.channelCount = g, n.samplerate = o, n.samples.push({
    unit: S,
    pts: T
  }), u;
}
class pT extends Wu {
  resetInitSegment(e, t, i, s) {
    super.resetInitSegment(e, t, i, s), this._audioTrack = {
      container: "audio/mpeg",
      type: "audio",
      id: 2,
      pid: -1,
      sequenceNumber: 0,
      segmentCodec: "mp3",
      samples: [],
      manifestCodec: t,
      duration: s,
      inputTimeScale: 9e4,
      dropped: 0
    };
  }
  static probe(e) {
    if (!e)
      return !1;
    const t = va(e, 0);
    let i = t?.length || 0;
    if (t && e[i] === 11 && e[i + 1] === 119 && zu(t) !== void 0 && // check the bsid to confirm ac-3 or ec-3 (not mp3)
    Bg(e, i) <= 16)
      return !1;
    for (let s = e.length; i < s; i++)
      if ($g(e, i))
        return Oe.log("MPEG Audio sync word found !"), !0;
    return !1;
  }
  canParse(e, t) {
    return dT(e, t);
  }
  appendFrame(e, t, i) {
    if (this.basePTS !== null)
      return Og(e, t, i, this.basePTS, this.frameIndex);
  }
}
const gT = /\/emsg[-/]ID3/i;
class mT {
  constructor(e, t) {
    this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = t;
  }
  resetTimeStamp() {
  }
  resetInitSegment(e, t, i, s) {
    const r = this.videoTrack = Ji("video", 1), a = this.audioTrack = Ji("audio", 1), o = this.txtTrack = Ji("text", 1);
    if (this.id3Track = Ji("id3", 1), this.timeOffset = 0, !(e != null && e.byteLength))
      return;
    const l = jp(e);
    if (l.video) {
      const {
        id: c,
        timescale: u,
        codec: d,
        supplemental: f
      } = l.video;
      r.id = c, r.timescale = o.timescale = u, r.codec = d, r.supplemental = f;
    }
    if (l.audio) {
      const {
        id: c,
        timescale: u,
        codec: d
      } = l.audio;
      a.id = c, a.timescale = u, a.codec = d;
    }
    o.id = Yp.text, r.sampleDuration = 0, r.duration = a.duration = s;
  }
  resetContiguity() {
    this.remainderData = null;
  }
  static probe(e) {
    return hy(e);
  }
  demux(e, t) {
    this.timeOffset = t;
    let i = e;
    const s = this.videoTrack, r = this.txtTrack;
    if (this.config.progressive) {
      this.remainderData && (i = Oi(this.remainderData, e));
      const o = Ty(i);
      this.remainderData = o.remainder, s.samples = o.valid || new Uint8Array();
    } else
      s.samples = i;
    const a = this.extractID3Track(s, t);
    return r.samples = qd(t, s), {
      videoTrack: s,
      audioTrack: this.audioTrack,
      id3Track: a,
      textTrack: this.txtTrack
    };
  }
  flush() {
    const e = this.timeOffset, t = this.videoTrack, i = this.txtTrack;
    t.samples = this.remainderData || new Uint8Array(), this.remainderData = null;
    const s = this.extractID3Track(t, this.timeOffset);
    return i.samples = qd(e, t), {
      videoTrack: t,
      audioTrack: Ji(),
      id3Track: s,
      textTrack: Ji()
    };
  }
  extractID3Track(e, t) {
    const i = this.id3Track;
    if (e.samples.length) {
      const s = ye(e.samples, ["emsg"]);
      s && s.forEach((r) => {
        const a = xy(r);
        if (gT.test(a.schemeIdUri)) {
          const o = Df(a, t);
          let l = a.eventDuration === 4294967295 ? Number.POSITIVE_INFINITY : a.eventDuration / a.timeScale;
          l <= 1e-3 && (l = Number.POSITIVE_INFINITY);
          const c = a.payload;
          i.samples.push({
            data: c,
            len: c.byteLength,
            dts: o,
            pts: o,
            type: vi.emsg,
            duration: l
          });
        } else if (this.config.enableEmsgKLVMetadata && a.schemeIdUri.startsWith("urn:misb:KLV:bin:1910.1")) {
          const o = Df(a, t);
          i.samples.push({
            data: a.payload,
            len: a.payload.byteLength,
            dts: o,
            pts: o,
            type: vi.misbklv,
            duration: Number.POSITIVE_INFINITY
          });
        }
      });
    }
    return i;
  }
  demuxSampleAes(e, t, i) {
    return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"));
  }
  destroy() {
    this.config = null, this.remainderData = null, this.videoTrack = this.audioTrack = this.id3Track = this.txtTrack = void 0;
  }
}
function Df(n, e) {
  return Z(n.presentationTime) ? n.presentationTime / n.timeScale : e + n.presentationTimeDelta / n.timeScale;
}
class vT {
  constructor(e, t, i) {
    this.keyData = void 0, this.decrypter = void 0, this.keyData = i, this.decrypter = new Fu(t, {
      removePKCS7Padding: !1
    });
  }
  decryptBuffer(e) {
    return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer, Zs.cbc);
  }
  // AAC - encrypt all full 16 bytes blocks starting from offset 16
  decryptAacSample(e, t, i) {
    const s = e[t].unit;
    if (s.length <= 16)
      return;
    const r = s.subarray(16, s.length - s.length % 16), a = r.buffer.slice(r.byteOffset, r.byteOffset + r.length);
    this.decryptBuffer(a).then((o) => {
      const l = new Uint8Array(o);
      s.set(l, 16), this.decrypter.isSync() || this.decryptAacSamples(e, t + 1, i);
    }).catch(i);
  }
  decryptAacSamples(e, t, i) {
    for (; ; t++) {
      if (t >= e.length) {
        i();
        return;
      }
      if (!(e[t].unit.length < 32) && (this.decryptAacSample(e, t, i), !this.decrypter.isSync()))
        return;
    }
  }
  // AVC - encrypt one 16 bytes block out of ten, starting from offset 32
  getAvcEncryptedData(e) {
    const t = Math.floor((e.length - 48) / 160) * 16 + 16, i = new Int8Array(t);
    let s = 0;
    for (let r = 32; r < e.length - 16; r += 160, s += 16)
      i.set(e.subarray(r, r + 16), s);
    return i;
  }
  getAvcDecryptedUnit(e, t) {
    const i = new Uint8Array(t);
    let s = 0;
    for (let r = 32; r < e.length - 16; r += 160, s += 16)
      e.set(i.subarray(s, s + 16), r);
    return e;
  }
  decryptAvcSample(e, t, i, s, r) {
    const a = Jp(r.data), o = this.getAvcEncryptedData(a);
    this.decryptBuffer(o.buffer).then((l) => {
      r.data = this.getAvcDecryptedUnit(a, l), this.decrypter.isSync() || this.decryptAvcSamples(e, t, i + 1, s);
    }).catch(s);
  }
  decryptAvcSamples(e, t, i, s) {
    if (e instanceof Uint8Array)
      throw new Error("Cannot decrypt samples of type Uint8Array");
    for (; ; t++, i = 0) {
      if (t >= e.length) {
        s();
        return;
      }
      const r = e[t].units;
      for (; !(i >= r.length); i++) {
        const a = r[i];
        if (!(a.data.length <= 48 || a.type !== 1 && a.type !== 5) && (this.decryptAvcSample(e, t, i, s, a), !this.decrypter.isSync()))
          return;
      }
    }
  }
}
class Gg {
  constructor() {
    this.VideoSample = null;
  }
  createVideoSample(e, t, i) {
    return {
      key: e,
      frame: !1,
      pts: t,
      dts: i,
      units: [],
      length: 0
    };
  }
  getLastNalUnit(e) {
    var t;
    let i = this.VideoSample, s;
    if ((!i || i.units.length === 0) && (i = e[e.length - 1]), (t = i) != null && t.units) {
      const r = i.units;
      s = r[r.length - 1];
    }
    return s;
  }
  pushAccessUnit(e, t) {
    if (e.units.length && e.frame) {
      if (e.pts === void 0) {
        const i = t.samples, s = i.length;
        if (s) {
          const r = i[s - 1];
          e.pts = r.pts, e.dts = r.dts;
        } else {
          t.dropped++;
          return;
        }
      }
      t.samples.push(e);
    }
  }
  parseNALu(e, t, i) {
    const s = t.byteLength;
    let r = e.naluState || 0;
    const a = r, o = [];
    let l = 0, c, u, d, f = -1, p = 0;
    for (r === -1 && (f = 0, p = this.getNALuType(t, 0), r = 0, l = 1); l < s; ) {
      if (c = t[l++], !r) {
        r = c ? 0 : 1;
        continue;
      }
      if (r === 1) {
        r = c ? 0 : 2;
        continue;
      }
      if (!c)
        r = 3;
      else if (c === 1) {
        if (u = l - r - 1, f >= 0) {
          const h = {
            data: t.subarray(f, u),
            type: p
          };
          o.push(h);
        } else {
          const h = this.getLastNalUnit(e.samples);
          h && (a && l <= 4 - a && h.state && (h.data = h.data.subarray(0, h.data.byteLength - a)), u > 0 && (h.data = Oi(h.data, t.subarray(0, u)), h.state = 0));
        }
        l < s ? (d = this.getNALuType(t, l), f = l, p = d, r = 0) : r = -1;
      } else
        r = 0;
    }
    if (f >= 0 && r >= 0) {
      const h = {
        data: t.subarray(f, s),
        type: p,
        state: r
      };
      o.push(h);
    }
    if (o.length === 0) {
      const h = this.getLastNalUnit(e.samples);
      h && (h.data = Oi(h.data, t));
    }
    return e.naluState = r, o;
  }
}
class Jn {
  constructor(e) {
    this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0;
  }
  // ():void
  loadWord() {
    const e = this.data, t = this.bytesAvailable, i = e.byteLength - t, s = new Uint8Array(4), r = Math.min(4, t);
    if (r === 0)
      throw new Error("no bytes available");
    s.set(e.subarray(i, i + r)), this.word = new DataView(s.buffer).getUint32(0), this.bitsAvailable = r * 8, this.bytesAvailable -= r;
  }
  // (count:int):void
  skipBits(e) {
    let t;
    e = Math.min(e, this.bytesAvailable * 8 + this.bitsAvailable), this.bitsAvailable > e ? (this.word <<= e, this.bitsAvailable -= e) : (e -= this.bitsAvailable, t = e >> 3, e -= t << 3, this.bytesAvailable -= t, this.loadWord(), this.word <<= e, this.bitsAvailable -= e);
  }
  // (size:int):uint
  readBits(e) {
    let t = Math.min(this.bitsAvailable, e);
    const i = this.word >>> 32 - t;
    if (e > 32 && Oe.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= t, this.bitsAvailable > 0)
      this.word <<= t;
    else if (this.bytesAvailable > 0)
      this.loadWord();
    else
      throw new Error("no bits available");
    return t = e - t, t > 0 && this.bitsAvailable ? i << t | this.readBits(t) : i;
  }
  // ():uint
  skipLZ() {
    let e;
    for (e = 0; e < this.bitsAvailable; ++e)
      if ((this.word & 2147483648 >>> e) !== 0)
        return this.word <<= e, this.bitsAvailable -= e, e;
    return this.loadWord(), e + this.skipLZ();
  }
  // ():void
  skipUEG() {
    this.skipBits(1 + this.skipLZ());
  }
  // ():void
  skipEG() {
    this.skipBits(1 + this.skipLZ());
  }
  // ():uint
  readUEG() {
    const e = this.skipLZ();
    return this.readBits(e + 1) - 1;
  }
  // ():int
  readEG() {
    const e = this.readUEG();
    return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1);
  }
  // Some convenience functions
  // :Boolean
  readBoolean() {
    return this.readBits(1) === 1;
  }
  // ():int
  readUByte() {
    return this.readBits(8);
  }
  // ():int
  readUShort() {
    return this.readBits(16);
  }
  // ():int
  readUInt() {
    return this.readBits(32);
  }
}
class yT extends Gg {
  parsePES(e, t, i, s) {
    const r = this.parseNALu(e, i.data, s);
    let a = this.VideoSample, o, l = !1;
    i.data = null, a && r.length && !e.audFound && (this.pushAccessUnit(a, e), a = this.VideoSample = this.createVideoSample(!1, i.pts, i.dts)), r.forEach((c) => {
      var u, d;
      switch (c.type) {
        // NDR
        case 1: {
          let g = !1;
          o = !0;
          const m = c.data;
          if (l && m.length > 4) {
            const v = this.readSliceType(m);
            (v === 2 || v === 4 || v === 7 || v === 9) && (g = !0);
          }
          if (g) {
            var f;
            (f = a) != null && f.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null);
          }
          a || (a = this.VideoSample = this.createVideoSample(!0, i.pts, i.dts)), a.frame = !0, a.key = g;
          break;
        }
        case 5:
          o = !0, (u = a) != null && u.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null), a || (a = this.VideoSample = this.createVideoSample(!0, i.pts, i.dts)), a.key = !0, a.frame = !0;
          break;
        // SEI
        case 6: {
          o = !0, Du(c.data, 1, i.pts, t.samples);
          break;
        }
        case 7: {
          var p, h;
          o = !0, l = !0;
          const g = c.data, m = this.readSPS(g);
          if (!e.sps || e.width !== m.width || e.height !== m.height || ((p = e.pixelRatio) == null ? void 0 : p[0]) !== m.pixelRatio[0] || ((h = e.pixelRatio) == null ? void 0 : h[1]) !== m.pixelRatio[1]) {
            e.width = m.width, e.height = m.height, e.pixelRatio = m.pixelRatio, e.sps = [g];
            const v = g.subarray(1, 4);
            let y = "avc1.";
            for (let E = 0; E < 3; E++) {
              let T = v[E].toString(16);
              T.length < 2 && (T = "0" + T), y += T;
            }
            e.codec = y;
          }
          break;
        }
        // PPS
        case 8:
          o = !0, e.pps = [c.data];
          break;
        // AUD
        case 9:
          o = !0, e.audFound = !0, (d = a) != null && d.frame && (this.pushAccessUnit(a, e), a = null), a || (a = this.VideoSample = this.createVideoSample(!1, i.pts, i.dts));
          break;
        // Filler Data
        case 12:
          o = !0;
          break;
        default:
          o = !1;
          break;
      }
      a && o && a.units.push(c);
    }), s && a && (this.pushAccessUnit(a, e), this.VideoSample = null);
  }
  getNALuType(e, t) {
    return e[t] & 31;
  }
  readSliceType(e) {
    const t = new Jn(e);
    return t.readUByte(), t.readUEG(), t.readUEG();
  }
  /**
   * The scaling list is optionally transmitted as part of a sequence parameter
   * set and is not relevant to transmuxing.
   * @param count the number of entries in this scaling list
   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
   */
  skipScalingList(e, t) {
    let i = 8, s = 8, r;
    for (let a = 0; a < e; a++)
      s !== 0 && (r = t.readEG(), s = (i + r + 256) % 256), i = s === 0 ? i : s;
  }
  /**
   * Read a sequence parameter set and return some interesting video
   * properties. A sequence parameter set is the H264 metadata that
   * describes the properties of upcoming video frames.
   * @returns an object with configuration parsed from the
   * sequence parameter set, including the dimensions of the
   * associated video frames.
   */
  readSPS(e) {
    const t = new Jn(e);
    let i = 0, s = 0, r = 0, a = 0, o, l, c;
    const u = t.readUByte.bind(t), d = t.readBits.bind(t), f = t.readUEG.bind(t), p = t.readBoolean.bind(t), h = t.skipBits.bind(t), g = t.skipEG.bind(t), m = t.skipUEG.bind(t), v = this.skipScalingList.bind(this);
    u();
    const y = u();
    if (d(5), h(3), u(), m(), y === 100 || y === 110 || y === 122 || y === 244 || y === 44 || y === 83 || y === 86 || y === 118 || y === 128) {
      const L = f();
      if (L === 3 && h(1), m(), m(), h(1), p())
        for (l = L !== 3 ? 8 : 12, c = 0; c < l; c++)
          p() && (c < 6 ? v(16, t) : v(64, t));
    }
    m();
    const E = f();
    if (E === 0)
      f();
    else if (E === 1)
      for (h(1), g(), g(), o = f(), c = 0; c < o; c++)
        g();
    m(), h(1);
    const T = f(), S = f(), w = d(1);
    w === 0 && h(1), h(1), p() && (i = f(), s = f(), r = f(), a = f());
    let b = [1, 1];
    if (p() && p())
      switch (u()) {
        case 1:
          b = [1, 1];
          break;
        case 2:
          b = [12, 11];
          break;
        case 3:
          b = [10, 11];
          break;
        case 4:
          b = [16, 11];
          break;
        case 5:
          b = [40, 33];
          break;
        case 6:
          b = [24, 11];
          break;
        case 7:
          b = [20, 11];
          break;
        case 8:
          b = [32, 11];
          break;
        case 9:
          b = [80, 33];
          break;
        case 10:
          b = [18, 11];
          break;
        case 11:
          b = [15, 11];
          break;
        case 12:
          b = [64, 33];
          break;
        case 13:
          b = [160, 99];
          break;
        case 14:
          b = [4, 3];
          break;
        case 15:
          b = [3, 2];
          break;
        case 16:
          b = [2, 1];
          break;
        case 255: {
          b = [u() << 8 | u(), u() << 8 | u()];
          break;
        }
      }
    return {
      width: Math.ceil((T + 1) * 16 - i * 2 - s * 2),
      height: (2 - w) * (S + 1) * 16 - (w ? 2 : 4) * (r + a),
      pixelRatio: b
    };
  }
}
class ET extends Gg {
  constructor(...e) {
    super(...e), this.initVPS = null;
  }
  parsePES(e, t, i, s) {
    const r = this.parseNALu(e, i.data, s);
    let a = this.VideoSample, o, l = !1;
    i.data = null, a && r.length && !e.audFound && (this.pushAccessUnit(a, e), a = this.VideoSample = this.createVideoSample(!1, i.pts, i.dts)), r.forEach((c) => {
      var u, d;
      switch (c.type) {
        // NON-IDR, NON RANDOM ACCESS SLICE
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
          a || (a = this.VideoSample = this.createVideoSample(!1, i.pts, i.dts)), a.frame = !0, o = !0;
          break;
        // CRA, BLA (random access picture)
        case 16:
        case 17:
        case 18:
        case 21:
          if (o = !0, l) {
            var f;
            (f = a) != null && f.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null);
          }
          a || (a = this.VideoSample = this.createVideoSample(!0, i.pts, i.dts)), a.key = !0, a.frame = !0;
          break;
        // IDR
        case 19:
        case 20:
          o = !0, (u = a) != null && u.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null), a || (a = this.VideoSample = this.createVideoSample(!0, i.pts, i.dts)), a.key = !0, a.frame = !0;
          break;
        // SEI
        case 39:
          o = !0, Du(
            c.data,
            2,
            // NALu header size
            i.pts,
            t.samples
          );
          break;
        // VPS
        case 32:
          o = !0, e.vps || (typeof e.params != "object" && (e.params = {}), e.params = Fe(e.params, this.readVPS(c.data)), this.initVPS = c.data), e.vps = [c.data];
          break;
        // SPS
        case 33:
          if (o = !0, l = !0, e.vps !== void 0 && e.vps[0] !== this.initVPS && e.sps !== void 0 && !this.matchSPS(e.sps[0], c.data) && (this.initVPS = e.vps[0], e.sps = e.pps = void 0), !e.sps) {
            const p = this.readSPS(c.data);
            e.width = p.width, e.height = p.height, e.pixelRatio = p.pixelRatio, e.codec = p.codecString, e.sps = [], typeof e.params != "object" && (e.params = {});
            for (const h in p.params)
              e.params[h] = p.params[h];
          }
          this.pushParameterSet(e.sps, c.data, e.vps), a || (a = this.VideoSample = this.createVideoSample(!0, i.pts, i.dts)), a.key = !0;
          break;
        // PPS
        case 34:
          if (o = !0, typeof e.params == "object") {
            if (!e.pps) {
              e.pps = [];
              const p = this.readPPS(c.data);
              for (const h in p)
                e.params[h] = p[h];
            }
            this.pushParameterSet(e.pps, c.data, e.vps);
          }
          break;
        // ACCESS UNIT DELIMITER
        case 35:
          o = !0, e.audFound = !0, (d = a) != null && d.frame && (this.pushAccessUnit(a, e), a = null), a || (a = this.VideoSample = this.createVideoSample(!1, i.pts, i.dts));
          break;
        default:
          o = !1;
          break;
      }
      a && o && a.units.push(c);
    }), s && a && (this.pushAccessUnit(a, e), this.VideoSample = null);
  }
  pushParameterSet(e, t, i) {
    (i && i[0] === this.initVPS || !i && !e.length) && e.push(t);
  }
  getNALuType(e, t) {
    return (e[t] & 126) >>> 1;
  }
  ebsp2rbsp(e) {
    const t = new Uint8Array(e.byteLength);
    let i = 0;
    for (let s = 0; s < e.byteLength; s++)
      s >= 2 && e[s] === 3 && e[s - 1] === 0 && e[s - 2] === 0 || (t[i] = e[s], i++);
    return new Uint8Array(t.buffer, 0, i);
  }
  pushAccessUnit(e, t) {
    super.pushAccessUnit(e, t), this.initVPS && (this.initVPS = null);
  }
  readVPS(e) {
    const t = new Jn(e);
    t.readUByte(), t.readUByte(), t.readBits(4), t.skipBits(2), t.readBits(6);
    const i = t.readBits(3), s = t.readBoolean();
    return {
      numTemporalLayers: i + 1,
      temporalIdNested: s
    };
  }
  readSPS(e) {
    const t = new Jn(this.ebsp2rbsp(e));
    t.readUByte(), t.readUByte(), t.readBits(4);
    const i = t.readBits(3);
    t.readBoolean();
    const s = t.readBits(2), r = t.readBoolean(), a = t.readBits(5), o = t.readUByte(), l = t.readUByte(), c = t.readUByte(), u = t.readUByte(), d = t.readUByte(), f = t.readUByte(), p = t.readUByte(), h = t.readUByte(), g = t.readUByte(), m = t.readUByte(), v = t.readUByte(), y = [], E = [];
    for (let re = 0; re < i; re++)
      y.push(t.readBoolean()), E.push(t.readBoolean());
    if (i > 0)
      for (let re = i; re < 8; re++)
        t.readBits(2);
    for (let re = 0; re < i; re++)
      y[re] && (t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte()), E[re] && t.readUByte();
    t.readUEG();
    const T = t.readUEG();
    T == 3 && t.skipBits(1);
    const S = t.readUEG(), w = t.readUEG(), b = t.readBoolean();
    let L = 0, A = 0, _ = 0, R = 0;
    b && (L += t.readUEG(), A += t.readUEG(), _ += t.readUEG(), R += t.readUEG());
    const I = t.readUEG(), k = t.readUEG(), M = t.readUEG(), O = t.readBoolean();
    for (let re = O ? 0 : i; re <= i; re++)
      t.skipUEG(), t.skipUEG(), t.skipUEG();
    if (t.skipUEG(), t.skipUEG(), t.skipUEG(), t.skipUEG(), t.skipUEG(), t.skipUEG(), t.readBoolean() && t.readBoolean())
      for (let z = 0; z < 4; z++)
        for (let Re = 0; Re < (z === 3 ? 2 : 6); Re++)
          if (!t.readBoolean())
            t.readUEG();
          else {
            const Ve = Math.min(64, 1 << 4 + (z << 1));
            z > 1 && t.readEG();
            for (let Ie = 0; Ie < Ve; Ie++)
              t.readEG();
          }
    t.readBoolean(), t.readBoolean(), t.readBoolean() && (t.readUByte(), t.skipUEG(), t.skipUEG(), t.readBoolean());
    const D = t.readUEG();
    let B = 0;
    for (let re = 0; re < D; re++) {
      let z = !1;
      if (re !== 0 && (z = t.readBoolean()), z) {
        re === D && t.readUEG(), t.readBoolean(), t.readUEG();
        let Re = 0;
        for (let We = 0; We <= B; We++) {
          const Ve = t.readBoolean();
          let Ie = !1;
          Ve || (Ie = t.readBoolean()), (Ve || Ie) && Re++;
        }
        B = Re;
      } else {
        const Re = t.readUEG(), We = t.readUEG();
        B = Re + We;
        for (let Ve = 0; Ve < Re; Ve++)
          t.readUEG(), t.readBoolean();
        for (let Ve = 0; Ve < We; Ve++)
          t.readUEG(), t.readBoolean();
      }
    }
    if (t.readBoolean()) {
      const re = t.readUEG();
      for (let z = 0; z < re; z++) {
        for (let Re = 0; Re < M + 4; Re++)
          t.readBits(1);
        t.readBits(1);
      }
    }
    let K = 0, X = 1, W = 1, Y = !0, N = 1, U = 0;
    t.readBoolean(), t.readBoolean();
    let V = !1;
    if (t.readBoolean()) {
      if (t.readBoolean()) {
        const st = t.readUByte(), zt = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2], Mt = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];
        st > 0 && st < 16 ? (X = zt[st - 1], W = Mt[st - 1]) : st === 255 && (X = t.readBits(16), W = t.readBits(16));
      }
      if (t.readBoolean() && t.readBoolean(), t.readBoolean() && (t.readBits(3), t.readBoolean(), t.readBoolean() && (t.readUByte(), t.readUByte(), t.readUByte())), t.readBoolean() && (t.readUEG(), t.readUEG()), t.readBoolean(), t.readBoolean(), t.readBoolean(), V = t.readBoolean(), V && (t.skipUEG(), t.skipUEG(), t.skipUEG(), t.skipUEG()), t.readBoolean() && (N = t.readBits(32), U = t.readBits(32), t.readBoolean() && t.readUEG(), t.readBoolean())) {
        const Mt = t.readBoolean(), ze = t.readBoolean();
        let Et = !1;
        (Mt || ze) && (Et = t.readBoolean(), Et && (t.readUByte(), t.readBits(5), t.readBoolean(), t.readBits(5)), t.readBits(4), t.readBits(4), Et && t.readBits(4), t.readBits(5), t.readBits(5), t.readBits(5));
        for (let Pe = 0; Pe <= i; Pe++) {
          Y = t.readBoolean();
          const Ot = Y || t.readBoolean();
          let rt = !1;
          Ot ? t.readEG() : rt = t.readBoolean();
          const wi = rt ? 1 : t.readUEG() + 1;
          if (Mt)
            for (let Ni = 0; Ni < wi; Ni++)
              t.readUEG(), t.readUEG(), Et && (t.readUEG(), t.readUEG()), t.skipBits(1);
          if (ze)
            for (let Ni = 0; Ni < wi; Ni++)
              t.readUEG(), t.readUEG(), Et && (t.readUEG(), t.readUEG()), t.skipBits(1);
        }
      }
      t.readBoolean() && (t.readBoolean(), t.readBoolean(), t.readBoolean(), K = t.readUEG());
    }
    let ee = S, ce = w;
    if (b) {
      let re = 1, z = 1;
      T === 1 ? re = z = 2 : T == 2 && (re = 2), ee = S - re * A - re * L, ce = w - z * R - z * _;
    }
    const oe = s ? ["A", "B", "C"][s] : "", Le = o << 24 | l << 16 | c << 8 | u;
    let ne = 0;
    for (let re = 0; re < 32; re++)
      ne = (ne | (Le >> re & 1) << 31 - re) >>> 0;
    let fe = ne.toString(16);
    return a === 1 && fe === "2" && (fe = "6"), {
      codecString: `hvc1.${oe}${a}.${fe}.${r ? "H" : "L"}${v}.B0`,
      params: {
        general_tier_flag: r,
        general_profile_idc: a,
        general_profile_space: s,
        general_profile_compatibility_flags: [o, l, c, u],
        general_constraint_indicator_flags: [d, f, p, h, g, m],
        general_level_idc: v,
        bit_depth: I + 8,
        bit_depth_luma_minus8: I,
        bit_depth_chroma_minus8: k,
        min_spatial_segmentation_idc: K,
        chroma_format_idc: T,
        frame_rate: {
          fixed: Y,
          fps: U / N
        }
      },
      width: ee,
      height: ce,
      pixelRatio: [X, W]
    };
  }
  readPPS(e) {
    const t = new Jn(this.ebsp2rbsp(e));
    t.readUByte(), t.readUByte(), t.skipUEG(), t.skipUEG(), t.skipBits(2), t.skipBits(3), t.skipBits(2), t.skipUEG(), t.skipUEG(), t.skipEG(), t.skipBits(2), t.readBoolean() && t.skipUEG(), t.skipEG(), t.skipEG(), t.skipBits(4);
    const s = t.readBoolean(), r = t.readBoolean();
    let a = 1;
    return r && s ? a = 0 : r ? a = 3 : s && (a = 2), {
      parallelismType: a
    };
  }
  matchSPS(e, t) {
    return String.fromCharCode.apply(null, e).substr(3) === String.fromCharCode.apply(null, t).substr(3);
  }
}
const St = 188;
class Os {
  constructor(e, t, i, s) {
    this.logger = void 0, this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._pmtId = -1, this._videoTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.remainderData = null, this.videoParser = void 0, this.observer = e, this.config = t, this.typeSupported = i, this.logger = s, this.videoParser = null;
  }
  static probe(e, t) {
    const i = Os.syncOffset(e);
    return i > 0 && t.warn(`MPEG2-TS detected but first sync word found @ offset ${i}`), i !== -1;
  }
  static syncOffset(e) {
    const t = e.length;
    let i = Math.min(St * 5, t - St) + 1, s = 0;
    for (; s < i; ) {
      let r = !1, a = -1, o = 0;
      for (let l = s; l < t; l += St)
        if (e[l] === 71 && (t - l === St || e[l + St] === 71)) {
          if (o++, a === -1 && (a = l, a !== 0 && (i = Math.min(a + St * 99, e.length - St) + 1)), r || (r = Uc(e, l) === 0), r && o > 1 && (a === 0 && o > 2 || l + St > i))
            return a;
        } else {
          if (o)
            return -1;
          break;
        }
      s++;
    }
    return -1;
  }
  /**
   * Creates a track model internal to demuxer used to drive remuxing input
   */
  static createTrack(e, t) {
    return {
      container: e === "video" || e === "audio" ? "video/mp2t" : void 0,
      type: e,
      id: Yp[e],
      pid: -1,
      inputTimeScale: 9e4,
      sequenceNumber: 0,
      samples: [],
      dropped: 0,
      duration: e === "audio" ? t : void 0
    };
  }
  /**
   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)
   * Resets all internal track instances of the demuxer.
   */
  resetInitSegment(e, t, i, s) {
    this.pmtParsed = !1, this._pmtId = -1, this._videoTrack = Os.createTrack("video"), this._videoTrack.duration = s, this._audioTrack = Os.createTrack("audio", s), this._id3Track = Os.createTrack("id3"), this._txtTrack = Os.createTrack("text"), this._audioTrack.segmentCodec = "aac", this.videoParser = null, this.aacOverFlow = null, this.remainderData = null, this.audioCodec = t, this.videoCodec = i;
  }
  resetTimeStamp() {
  }
  resetContiguity() {
    const {
      _audioTrack: e,
      _videoTrack: t,
      _id3Track: i
    } = this;
    e && (e.pesData = null), t && (t.pesData = null), i && (i.pesData = null), this.aacOverFlow = null, this.remainderData = null;
  }
  demux(e, t, i = !1, s = !1) {
    i || (this.sampleAes = null);
    let r;
    const a = this._videoTrack, o = this._audioTrack, l = this._id3Track, c = this._txtTrack;
    let u = a.pid, d = a.pesData, f = o.pid, p = l.pid, h = o.pesData, g = l.pesData, m = null, v = this.pmtParsed, y = this._pmtId, E = e.length;
    if (this.remainderData && (e = Oi(this.remainderData, e), E = e.length, this.remainderData = null), E < St && !s)
      return this.remainderData = e, {
        audioTrack: o,
        videoTrack: a,
        id3Track: l,
        textTrack: c
      };
    const T = Math.max(0, Os.syncOffset(e));
    E -= (E - T) % St, E < e.byteLength && !s && (this.remainderData = new Uint8Array(e.buffer, E, e.buffer.byteLength - E));
    let S = 0;
    for (let b = T; b < E; b += St)
      if (e[b] === 71) {
        const L = !!(e[b + 1] & 64), A = Uc(e, b), _ = (e[b + 3] & 48) >> 4;
        let R;
        if (_ > 1) {
          if (R = b + 5 + e[b + 4], R === b + St)
            continue;
        } else
          R = b + 4;
        switch (A) {
          case u:
            L && (d && (r = Hr(d, this.logger)) && (this.readyVideoParser(a.segmentCodec), this.videoParser !== null && this.videoParser.parsePES(a, c, r, !1)), d = {
              data: [],
              size: 0
            }), d && (d.data.push(e.subarray(R, b + St)), d.size += b + St - R);
            break;
          case f:
            if (L) {
              if (h && (r = Hr(h, this.logger)))
                switch (o.segmentCodec) {
                  case "aac":
                    this.parseAACPES(o, r);
                    break;
                  case "mp3":
                    this.parseMPEGPES(o, r);
                    break;
                  case "ac3":
                    this.parseAC3PES(o, r);
                    break;
                }
              h = {
                data: [],
                size: 0
              };
            }
            h && (h.data.push(e.subarray(R, b + St)), h.size += b + St - R);
            break;
          case p:
            L && (g && (r = Hr(g, this.logger)) && this.parseID3PES(l, r), g = {
              data: [],
              size: 0
            }), g && (g.data.push(e.subarray(R, b + St)), g.size += b + St - R);
            break;
          case 0:
            L && (R += e[R] + 1), y = this._pmtId = TT(e, R);
            break;
          case y: {
            L && (R += e[R] + 1);
            const I = ST(e, R, this.typeSupported, i, this.observer, this.logger);
            u = I.videoPid, u > 0 && (a.pid = u, a.segmentCodec = I.segmentVideoCodec), f = I.audioPid, f > 0 && (o.pid = f, o.segmentCodec = I.segmentAudioCodec), p = I.id3Pid, p > 0 && (l.pid = p), m !== null && !v && (this.logger.warn(`MPEG-TS PMT found at ${b} after unknown PID '${m}'. Backtracking to sync byte @${T} to parse all TS packets.`), m = null, b = T - 188), v = this.pmtParsed = !0;
            break;
          }
          case 17:
          case 8191:
            break;
          default:
            m = A;
            break;
        }
      } else
        S++;
    S > 0 && Gc(this.observer, new Error(`Found ${S} TS packet/s that do not start with 0x47`), void 0, this.logger), a.pesData = d, o.pesData = h, l.pesData = g;
    const w = {
      audioTrack: o,
      videoTrack: a,
      id3Track: l,
      textTrack: c
    };
    return s && this.extractRemainingSamples(w), w;
  }
  flush() {
    const {
      remainderData: e
    } = this;
    this.remainderData = null;
    let t;
    return e ? t = this.demux(e, -1, !1, !0) : t = {
      videoTrack: this._videoTrack,
      audioTrack: this._audioTrack,
      id3Track: this._id3Track,
      textTrack: this._txtTrack
    }, this.extractRemainingSamples(t), this.sampleAes ? this.decrypt(t, this.sampleAes) : t;
  }
  extractRemainingSamples(e) {
    const {
      audioTrack: t,
      videoTrack: i,
      id3Track: s,
      textTrack: r
    } = e, a = i.pesData, o = t.pesData, l = s.pesData;
    let c;
    if (a && (c = Hr(a, this.logger)) ? (this.readyVideoParser(i.segmentCodec), this.videoParser !== null && (this.videoParser.parsePES(i, r, c, !0), i.pesData = null)) : i.pesData = a, o && (c = Hr(o, this.logger))) {
      switch (t.segmentCodec) {
        case "aac":
          this.parseAACPES(t, c);
          break;
        case "mp3":
          this.parseMPEGPES(t, c);
          break;
        case "ac3":
          this.parseAC3PES(t, c);
          break;
      }
      t.pesData = null;
    } else
      o != null && o.size && this.logger.log("last AAC PES packet truncated,might overlap between fragments"), t.pesData = o;
    l && (c = Hr(l, this.logger)) ? (this.parseID3PES(s, c), s.pesData = null) : s.pesData = l;
  }
  demuxSampleAes(e, t, i) {
    const s = this.demux(e, i, !0, !this.config.progressive), r = this.sampleAes = new vT(this.observer, this.config, t);
    return this.decrypt(s, r);
  }
  readyVideoParser(e) {
    this.videoParser === null && (e === "avc" ? this.videoParser = new yT() : e === "hevc" && (this.videoParser = new ET()));
  }
  decrypt(e, t) {
    return new Promise((i) => {
      const {
        audioTrack: s,
        videoTrack: r
      } = e;
      s.samples && s.segmentCodec === "aac" ? t.decryptAacSamples(s.samples, 0, () => {
        r.samples ? t.decryptAvcSamples(r.samples, 0, 0, () => {
          i(e);
        }) : i(e);
      }) : r.samples && t.decryptAvcSamples(r.samples, 0, 0, () => {
        i(e);
      });
    });
  }
  destroy() {
    this.observer && this.observer.removeAllListeners(), this.config = this.logger = this.observer = null, this.aacOverFlow = this.videoParser = this.remainderData = this.sampleAes = null, this._videoTrack = this._audioTrack = this._id3Track = this._txtTrack = void 0;
  }
  parseAACPES(e, t) {
    let i = 0;
    const s = this.aacOverFlow;
    let r = t.data;
    if (s) {
      this.aacOverFlow = null;
      const d = s.missing, f = s.sample.unit.byteLength;
      if (d === -1)
        r = Oi(s.sample.unit, r);
      else {
        const p = f - d;
        s.sample.unit.set(r.subarray(0, d), p), e.samples.push(s.sample), i = s.missing;
      }
    }
    let a, o;
    for (a = i, o = r.length; a < o - 1 && !Wo(r, a); a++)
      ;
    if (a !== i) {
      let d;
      const f = a < o - 1;
      if (f ? d = `AAC PES did not start with ADTS header,offset:${a}` : d = "No ADTS header found in AAC PES", Gc(this.observer, new Error(d), f, this.logger), !f)
        return;
    }
    Cg(e, this.observer, r, a, this.audioCodec);
    let l;
    if (t.pts !== void 0)
      l = t.pts;
    else if (s) {
      const d = Pg(e.samplerate);
      l = s.sample.pts + d;
    } else {
      this.logger.warn("[tsdemuxer]: AAC PES unknown PTS");
      return;
    }
    let c = 0, u;
    for (; a < o; )
      if (u = Dg(e, r, a, l, c), a += u.length, u.missing) {
        this.aacOverFlow = u;
        break;
      } else
        for (c++; a < o - 1 && !Wo(r, a); a++)
          ;
  }
  parseMPEGPES(e, t) {
    const i = t.data, s = i.length;
    let r = 0, a = 0;
    const o = t.pts;
    if (o === void 0) {
      this.logger.warn("[tsdemuxer]: MPEG PES unknown PTS");
      return;
    }
    for (; a < s; )
      if (Ng(i, a)) {
        const l = Og(e, i, a, o, r);
        if (l)
          a += l.length, r++;
        else
          break;
      } else
        a++;
  }
  parseAC3PES(e, t) {
    {
      const i = t.data, s = t.pts;
      if (s === void 0) {
        this.logger.warn("[tsdemuxer]: AC3 PES unknown PTS");
        return;
      }
      const r = i.length;
      let a = 0, o = 0, l;
      for (; o < r && (l = Ug(e, i, o, s, a++)) > 0; )
        o += l;
    }
  }
  parseID3PES(e, t) {
    if (t.pts === void 0) {
      this.logger.warn("[tsdemuxer]: ID3 PES unknown PTS");
      return;
    }
    const i = Fe({}, t, {
      type: this._videoTrack ? vi.emsg : vi.audioId3,
      duration: Number.POSITIVE_INFINITY
    });
    e.samples.push(i);
  }
}
function Uc(n, e) {
  return ((n[e + 1] & 31) << 8) + n[e + 2];
}
function TT(n, e) {
  return (n[e + 10] & 31) << 8 | n[e + 11];
}
function ST(n, e, t, i, s, r) {
  const a = {
    audioPid: -1,
    videoPid: -1,
    id3Pid: -1,
    segmentVideoCodec: "avc",
    segmentAudioCodec: "aac"
  }, o = (n[e + 1] & 15) << 8 | n[e + 2], l = e + 3 + o - 4, c = (n[e + 10] & 15) << 8 | n[e + 11];
  for (e += 12 + c; e < l; ) {
    const u = Uc(n, e), d = (n[e + 3] & 15) << 8 | n[e + 4];
    switch (n[e]) {
      case 207:
        if (!i) {
          Ml("ADTS AAC", r);
          break;
        }
      /* falls through */
      case 15:
        a.audioPid === -1 && (a.audioPid = u);
        break;
      // Packetized metadata (ID3)
      case 21:
        a.id3Pid === -1 && (a.id3Pid = u);
        break;
      case 219:
        if (!i) {
          Ml("H.264", r);
          break;
        }
      /* falls through */
      case 27:
        a.videoPid === -1 && (a.videoPid = u);
        break;
      // ISO/IEC 11172-3 (MPEG-1 audio)
      // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)
      case 3:
      case 4:
        !t.mpeg && !t.mp3 ? r.log("MPEG audio found, not supported in this browser") : a.audioPid === -1 && (a.audioPid = u, a.segmentAudioCodec = "mp3");
        break;
      case 193:
        if (!i) {
          Ml("AC-3", r);
          break;
        }
      /* falls through */
      case 129:
        t.ac3 ? a.audioPid === -1 && (a.audioPid = u, a.segmentAudioCodec = "ac3") : r.log("AC-3 audio found, not supported in this browser");
        break;
      case 6:
        if (a.audioPid === -1 && d > 0) {
          let f = e + 5, p = d;
          for (; p > 2; ) {
            switch (n[f]) {
              case 106:
                t.ac3 !== !0 ? r.log("AC-3 audio found, not supported in this browser for now") : (a.audioPid = u, a.segmentAudioCodec = "ac3");
                break;
            }
            const g = n[f + 1] + 2;
            f += g, p -= g;
          }
        }
        break;
      case 194:
      // SAMPLE-AES EC3
      /* falls through */
      case 135:
        return Gc(s, new Error("Unsupported EC-3 in M2TS found"), void 0, r), a;
      case 36:
        a.videoPid === -1 && (a.videoPid = u, a.segmentVideoCodec = "hevc", r.log("HEVC in M2TS found"));
        break;
    }
    e += d + 5;
  }
  return a;
}
function Gc(n, e, t, i) {
  i.warn(`parsing error: ${e.message}`), n.emit(x.ERROR, x.ERROR, {
    type: se.MEDIA_ERROR,
    details: H.FRAG_PARSING_ERROR,
    fatal: !1,
    levelRetry: t,
    error: e,
    reason: e.message
  });
}
function Ml(n, e) {
  e.log(`${n} with AES-128-CBC encryption found in unencrypted stream`);
}
function Hr(n, e) {
  let t = 0, i, s, r, a, o;
  const l = n.data;
  if (!n || n.size === 0)
    return null;
  for (; l[0].length < 19 && l.length > 1; )
    l[0] = Oi(l[0], l[1]), l.splice(1, 1);
  if (i = l[0], (i[0] << 16) + (i[1] << 8) + i[2] === 1) {
    if (s = (i[4] << 8) + i[5], s && s > n.size - 6)
      return null;
    const u = i[7];
    u & 192 && (a = (i[9] & 14) * 536870912 + // 1 << 29
    (i[10] & 255) * 4194304 + // 1 << 22
    (i[11] & 254) * 16384 + // 1 << 14
    (i[12] & 255) * 128 + // 1 << 7
    (i[13] & 254) / 2, u & 64 ? (o = (i[14] & 14) * 536870912 + // 1 << 29
    (i[15] & 255) * 4194304 + // 1 << 22
    (i[16] & 254) * 16384 + // 1 << 14
    (i[17] & 255) * 128 + // 1 << 7
    (i[18] & 254) / 2, a - o > 60 * 9e4 && (e.warn(`${Math.round((a - o) / 9e4)}s delta between PTS and DTS, align them`), a = o)) : o = a), r = i[8];
    let d = r + 9;
    if (n.size <= d)
      return null;
    n.size -= d;
    const f = new Uint8Array(n.size);
    for (let p = 0, h = l.length; p < h; p++) {
      i = l[p];
      let g = i.byteLength;
      if (d)
        if (d > g) {
          d -= g;
          continue;
        } else
          i = i.subarray(d), g -= d, d = 0;
      f.set(i, t), t += g;
    }
    return s && (s -= r + 3), {
      data: f,
      pts: a,
      dts: o,
      len: s
    };
  }
  return null;
}
class xT {
  static getSilentFrame(e, t) {
    switch (e) {
      case "mp4a.40.2":
        if (t === 1)
          return new Uint8Array([0, 200, 0, 128, 35, 128]);
        if (t === 2)
          return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
        if (t === 3)
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
        if (t === 4)
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
        if (t === 5)
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
        if (t === 6)
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
        break;
      // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)
      default:
        if (t === 1)
          return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        if (t === 2)
          return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        if (t === 3)
          return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        break;
    }
  }
}
const Rs = Math.pow(2, 32) - 1;
class G {
  static init() {
    G.types = {
      avc1: [],
      // codingname
      avcC: [],
      hvc1: [],
      hvcC: [],
      btrt: [],
      dinf: [],
      dref: [],
      esds: [],
      ftyp: [],
      hdlr: [],
      mdat: [],
      mdhd: [],
      mdia: [],
      mfhd: [],
      minf: [],
      moof: [],
      moov: [],
      mp4a: [],
      ".mp3": [],
      dac3: [],
      "ac-3": [],
      mvex: [],
      mvhd: [],
      pasp: [],
      sdtp: [],
      stbl: [],
      stco: [],
      stsc: [],
      stsd: [],
      stsz: [],
      stts: [],
      tfdt: [],
      tfhd: [],
      traf: [],
      trak: [],
      trun: [],
      trex: [],
      tkhd: [],
      vmhd: [],
      smhd: []
    };
    let e;
    for (e in G.types)
      G.types.hasOwnProperty(e) && (G.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]);
    const t = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // pre_defined
      118,
      105,
      100,
      101,
      // handler_type: 'vide'
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      86,
      105,
      100,
      101,
      111,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
      // name: 'VideoHandler'
    ]), i = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // pre_defined
      115,
      111,
      117,
      110,
      // handler_type: 'soun'
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      83,
      111,
      117,
      110,
      100,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
      // name: 'SoundHandler'
    ]);
    G.HDLR_TYPES = {
      video: t,
      audio: i
    };
    const s = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1,
      // entry_count
      0,
      0,
      0,
      12,
      // entry_size
      117,
      114,
      108,
      32,
      // 'url' type
      0,
      // version 0
      0,
      0,
      1
      // entry_flags
    ]), r = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0
      // entry_count
    ]);
    G.STTS = G.STSC = G.STCO = r, G.STSZ = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // sample_size
      0,
      0,
      0,
      0
      // sample_count
    ]), G.VMHD = new Uint8Array([
      0,
      // version
      0,
      0,
      1,
      // flags
      0,
      0,
      // graphicsmode
      0,
      0,
      0,
      0,
      0,
      0
      // opcolor
    ]), G.SMHD = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      // balance
      0,
      0
      // reserved
    ]), G.STSD = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1
    ]);
    const a = new Uint8Array([105, 115, 111, 109]), o = new Uint8Array([97, 118, 99, 49]), l = new Uint8Array([0, 0, 0, 1]);
    G.FTYP = G.box(G.types.ftyp, a, l, a, o), G.DINF = G.box(G.types.dinf, G.box(G.types.dref, s));
  }
  static box(e, ...t) {
    let i = 8, s = t.length;
    const r = s;
    for (; s--; )
      i += t[s].byteLength;
    const a = new Uint8Array(i);
    for (a[0] = i >> 24 & 255, a[1] = i >> 16 & 255, a[2] = i >> 8 & 255, a[3] = i & 255, a.set(e, 4), s = 0, i = 8; s < r; s++)
      a.set(t[s], i), i += t[s].byteLength;
    return a;
  }
  static hdlr(e) {
    return G.box(G.types.hdlr, G.HDLR_TYPES[e]);
  }
  static mdat(e) {
    return G.box(G.types.mdat, e);
  }
  static mdhd(e, t) {
    t *= e;
    const i = Math.floor(t / (Rs + 1)), s = Math.floor(t % (Rs + 1));
    return G.box(G.types.mdhd, new Uint8Array([
      1,
      // version 1
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      // modification_time
      e >> 24 & 255,
      e >> 16 & 255,
      e >> 8 & 255,
      e & 255,
      // timescale
      i >> 24,
      i >> 16 & 255,
      i >> 8 & 255,
      i & 255,
      s >> 24,
      s >> 16 & 255,
      s >> 8 & 255,
      s & 255,
      85,
      196,
      // 'und' language (undetermined)
      0,
      0
    ]));
  }
  static mdia(e) {
    return G.box(G.types.mdia, G.mdhd(e.timescale || 0, e.duration || 0), G.hdlr(e.type), G.minf(e));
  }
  static mfhd(e) {
    return G.box(G.types.mfhd, new Uint8Array([
      0,
      0,
      0,
      0,
      // flags
      e >> 24,
      e >> 16 & 255,
      e >> 8 & 255,
      e & 255
      // sequence_number
    ]));
  }
  static minf(e) {
    return e.type === "audio" ? G.box(G.types.minf, G.box(G.types.smhd, G.SMHD), G.DINF, G.stbl(e)) : G.box(G.types.minf, G.box(G.types.vmhd, G.VMHD), G.DINF, G.stbl(e));
  }
  static moof(e, t, i) {
    return G.box(G.types.moof, G.mfhd(e), G.traf(i, t));
  }
  static moov(e) {
    let t = e.length;
    const i = [];
    for (; t--; )
      i[t] = G.trak(e[t]);
    return G.box.apply(null, [G.types.moov, G.mvhd(e[0].timescale || 0, e[0].duration || 0)].concat(i).concat(G.mvex(e)));
  }
  static mvex(e) {
    let t = e.length;
    const i = [];
    for (; t--; )
      i[t] = G.trex(e[t]);
    return G.box.apply(null, [G.types.mvex, ...i]);
  }
  static mvhd(e, t) {
    t *= e;
    const i = Math.floor(t / (Rs + 1)), s = Math.floor(t % (Rs + 1)), r = new Uint8Array([
      1,
      // version 1
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      // modification_time
      e >> 24 & 255,
      e >> 16 & 255,
      e >> 8 & 255,
      e & 255,
      // timescale
      i >> 24,
      i >> 16 & 255,
      i >> 8 & 255,
      i & 255,
      s >> 24,
      s >> 16 & 255,
      s >> 8 & 255,
      s & 255,
      0,
      1,
      0,
      0,
      // 1.0 rate
      1,
      0,
      // 1.0 volume
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // pre_defined
      255,
      255,
      255,
      255
      // next_track_ID
    ]);
    return G.box(G.types.mvhd, r);
  }
  static sdtp(e) {
    const t = e.samples || [], i = new Uint8Array(4 + t.length);
    let s, r;
    for (s = 0; s < t.length; s++)
      r = t[s].flags, i[s + 4] = r.dependsOn << 4 | r.isDependedOn << 2 | r.hasRedundancy;
    return G.box(G.types.sdtp, i);
  }
  static stbl(e) {
    return G.box(G.types.stbl, G.stsd(e), G.box(G.types.stts, G.STTS), G.box(G.types.stsc, G.STSC), G.box(G.types.stsz, G.STSZ), G.box(G.types.stco, G.STCO));
  }
  static avc1(e) {
    let t = [], i = [], s, r, a;
    for (s = 0; s < e.sps.length; s++)
      r = e.sps[s], a = r.byteLength, t.push(a >>> 8 & 255), t.push(a & 255), t = t.concat(Array.prototype.slice.call(r));
    for (s = 0; s < e.pps.length; s++)
      r = e.pps[s], a = r.byteLength, i.push(a >>> 8 & 255), i.push(a & 255), i = i.concat(Array.prototype.slice.call(r));
    const o = G.box(G.types.avcC, new Uint8Array([
      1,
      // version
      t[3],
      // profile
      t[4],
      // profile compat
      t[5],
      // level
      255,
      // lengthSizeMinusOne, hard-coded to 4 bytes
      224 | e.sps.length
      // 3bit reserved (111) + numOfSequenceParameterSets
    ].concat(t).concat([
      e.pps.length
      // numOfPictureParameterSets
    ]).concat(i))), l = e.width, c = e.height, u = e.pixelRatio[0], d = e.pixelRatio[1];
    return G.box(
      G.types.avc1,
      new Uint8Array([
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // pre_defined
        l >> 8 & 255,
        l & 255,
        // width
        c >> 8 & 255,
        c & 255,
        // height
        0,
        72,
        0,
        0,
        // horizresolution
        0,
        72,
        0,
        0,
        // vertresolution
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // frame_count
        18,
        100,
        97,
        105,
        108,
        // dailymotion/hls.js
        121,
        109,
        111,
        116,
        105,
        111,
        110,
        47,
        104,
        108,
        115,
        46,
        106,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // compressorname
        0,
        24,
        // depth = 24
        17,
        17
      ]),
      // pre_defined = -1
      o,
      G.box(G.types.btrt, new Uint8Array([
        0,
        28,
        156,
        128,
        // bufferSizeDB
        0,
        45,
        198,
        192,
        // maxBitrate
        0,
        45,
        198,
        192
      ])),
      // avgBitrate
      G.box(G.types.pasp, new Uint8Array([
        u >> 24,
        // hSpacing
        u >> 16 & 255,
        u >> 8 & 255,
        u & 255,
        d >> 24,
        // vSpacing
        d >> 16 & 255,
        d >> 8 & 255,
        d & 255
      ]))
    );
  }
  static esds(e) {
    const t = e.config;
    return new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      3,
      // descriptor_type
      25,
      // length
      0,
      1,
      // es_id
      0,
      // stream_priority
      4,
      // descriptor_type
      17,
      // length
      64,
      // codec : mpeg4_audio
      21,
      // stream_type
      0,
      0,
      0,
      // buffer_size
      0,
      0,
      0,
      0,
      // maxBitrate
      0,
      0,
      0,
      0,
      // avgBitrate
      5,
      // descriptor_type
      2,
      // length
      ...t,
      6,
      1,
      2
      // GASpecificConfig)); // length + audio config descriptor
    ]);
  }
  static audioStsd(e) {
    const t = e.samplerate || 0;
    return new Uint8Array([
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      // reserved
      0,
      1,
      // data_reference_index
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // reserved
      0,
      e.channelCount || 0,
      // channelcount
      0,
      16,
      // sampleSize:16bits
      0,
      0,
      0,
      0,
      // reserved2
      t >> 8 & 255,
      t & 255,
      //
      0,
      0
    ]);
  }
  static mp4a(e) {
    return G.box(G.types.mp4a, G.audioStsd(e), G.box(G.types.esds, G.esds(e)));
  }
  static mp3(e) {
    return G.box(G.types[".mp3"], G.audioStsd(e));
  }
  static ac3(e) {
    return G.box(G.types["ac-3"], G.audioStsd(e), G.box(G.types.dac3, e.config));
  }
  static stsd(e) {
    const {
      segmentCodec: t
    } = e;
    if (e.type === "audio") {
      if (t === "aac")
        return G.box(G.types.stsd, G.STSD, G.mp4a(e));
      if (t === "ac3" && e.config)
        return G.box(G.types.stsd, G.STSD, G.ac3(e));
      if (t === "mp3" && e.codec === "mp3")
        return G.box(G.types.stsd, G.STSD, G.mp3(e));
    } else if (e.pps && e.sps) {
      if (t === "avc")
        return G.box(G.types.stsd, G.STSD, G.avc1(e));
      if (t === "hevc" && e.vps)
        return G.box(G.types.stsd, G.STSD, G.hvc1(e));
    } else
      throw new Error("video track missing pps or sps");
    throw new Error(`unsupported ${e.type} segment codec (${t}/${e.codec})`);
  }
  static tkhd(e) {
    const t = e.id, i = (e.duration || 0) * (e.timescale || 0), s = e.width || 0, r = e.height || 0, a = Math.floor(i / (Rs + 1)), o = Math.floor(i % (Rs + 1));
    return G.box(G.types.tkhd, new Uint8Array([
      1,
      // version 1
      0,
      0,
      7,
      // flags
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      // modification_time
      t >> 24 & 255,
      t >> 16 & 255,
      t >> 8 & 255,
      t & 255,
      // track_ID
      0,
      0,
      0,
      0,
      // reserved
      a >> 24,
      a >> 16 & 255,
      a >> 8 & 255,
      a & 255,
      o >> 24,
      o >> 16 & 255,
      o >> 8 & 255,
      o & 255,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      // layer
      0,
      0,
      // alternate_group
      0,
      0,
      // non-audio track volume
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      s >> 8 & 255,
      s & 255,
      0,
      0,
      // width
      r >> 8 & 255,
      r & 255,
      0,
      0
      // height
    ]));
  }
  static traf(e, t) {
    const i = G.sdtp(e), s = e.id, r = Math.floor(t / (Rs + 1)), a = Math.floor(t % (Rs + 1));
    return G.box(
      G.types.traf,
      G.box(G.types.tfhd, new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        s >> 24,
        s >> 16 & 255,
        s >> 8 & 255,
        s & 255
        // track_ID
      ])),
      G.box(G.types.tfdt, new Uint8Array([
        1,
        // version 1
        0,
        0,
        0,
        // flags
        r >> 24,
        r >> 16 & 255,
        r >> 8 & 255,
        r & 255,
        a >> 24,
        a >> 16 & 255,
        a >> 8 & 255,
        a & 255
      ])),
      G.trun(e, i.length + 16 + // tfhd
      20 + // tfdt
      8 + // traf header
      16 + // mfhd
      8 + // moof header
      8),
      // mdat header
      i
    );
  }
  /**
   * Generate a track box.
   * @param track a track definition
   */
  static trak(e) {
    return e.duration = e.duration || 4294967295, G.box(G.types.trak, G.tkhd(e), G.mdia(e));
  }
  static trex(e) {
    const t = e.id;
    return G.box(G.types.trex, new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      t >> 24,
      t >> 16 & 255,
      t >> 8 & 255,
      t & 255,
      // track_ID
      0,
      0,
      0,
      1,
      // default_sample_description_index
      0,
      0,
      0,
      0,
      // default_sample_duration
      0,
      0,
      0,
      0,
      // default_sample_size
      0,
      1,
      0,
      1
      // default_sample_flags
    ]));
  }
  static trun(e, t) {
    const i = e.samples || [], s = i.length, r = 12 + 16 * s, a = new Uint8Array(r);
    let o, l, c, u, d, f;
    for (t += 8 + r, a.set([
      e.type === "video" ? 1 : 0,
      // version 1 for video with signed-int sample_composition_time_offset
      0,
      15,
      1,
      // flags
      s >>> 24 & 255,
      s >>> 16 & 255,
      s >>> 8 & 255,
      s & 255,
      // sample_count
      t >>> 24 & 255,
      t >>> 16 & 255,
      t >>> 8 & 255,
      t & 255
      // data_offset
    ], 0), o = 0; o < s; o++)
      l = i[o], c = l.duration, u = l.size, d = l.flags, f = l.cts, a.set([
        c >>> 24 & 255,
        c >>> 16 & 255,
        c >>> 8 & 255,
        c & 255,
        // sample_duration
        u >>> 24 & 255,
        u >>> 16 & 255,
        u >>> 8 & 255,
        u & 255,
        // sample_size
        d.isLeading << 2 | d.dependsOn,
        d.isDependedOn << 6 | d.hasRedundancy << 4 | d.paddingValue << 1 | d.isNonSync,
        d.degradPrio & 61440,
        d.degradPrio & 15,
        // sample_flags
        f >>> 24 & 255,
        f >>> 16 & 255,
        f >>> 8 & 255,
        f & 255
        // sample_composition_time_offset
      ], 12 + 16 * o);
    return G.box(G.types.trun, a);
  }
  static initSegment(e) {
    G.types || G.init();
    const t = G.moov(e);
    return Oi(G.FTYP, t);
  }
  static hvc1(e) {
    const t = e.params, i = [e.vps, e.sps, e.pps], s = 4, r = new Uint8Array([1, t.general_profile_space << 6 | (t.general_tier_flag ? 32 : 0) | t.general_profile_idc, t.general_profile_compatibility_flags[0], t.general_profile_compatibility_flags[1], t.general_profile_compatibility_flags[2], t.general_profile_compatibility_flags[3], t.general_constraint_indicator_flags[0], t.general_constraint_indicator_flags[1], t.general_constraint_indicator_flags[2], t.general_constraint_indicator_flags[3], t.general_constraint_indicator_flags[4], t.general_constraint_indicator_flags[5], t.general_level_idc, 240 | t.min_spatial_segmentation_idc >> 8, 255 & t.min_spatial_segmentation_idc, 252 | t.parallelismType, 252 | t.chroma_format_idc, 248 | t.bit_depth_luma_minus8, 248 | t.bit_depth_chroma_minus8, 0, parseInt(t.frame_rate.fps), s - 1 | t.temporal_id_nested << 2 | t.num_temporal_layers << 3 | (t.frame_rate.fixed ? 64 : 0), i.length]);
    let a = r.length;
    for (let h = 0; h < i.length; h += 1) {
      a += 3;
      for (let g = 0; g < i[h].length; g += 1)
        a += 2 + i[h][g].length;
    }
    const o = new Uint8Array(a);
    o.set(r, 0), a = r.length;
    const l = i.length - 1;
    for (let h = 0; h < i.length; h += 1) {
      o.set(new Uint8Array([32 + h | (h === l ? 128 : 0), 0, i[h].length]), a), a += 3;
      for (let g = 0; g < i[h].length; g += 1)
        o.set(new Uint8Array([i[h][g].length >> 8, i[h][g].length & 255]), a), a += 2, o.set(i[h][g], a), a += i[h][g].length;
    }
    const c = G.box(G.types.hvcC, o), u = e.width, d = e.height, f = e.pixelRatio[0], p = e.pixelRatio[1];
    return G.box(
      G.types.hvc1,
      new Uint8Array([
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // pre_defined
        u >> 8 & 255,
        u & 255,
        // width
        d >> 8 & 255,
        d & 255,
        // height
        0,
        72,
        0,
        0,
        // horizresolution
        0,
        72,
        0,
        0,
        // vertresolution
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // frame_count
        18,
        100,
        97,
        105,
        108,
        // dailymotion/hls.js
        121,
        109,
        111,
        116,
        105,
        111,
        110,
        47,
        104,
        108,
        115,
        46,
        106,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // compressorname
        0,
        24,
        // depth = 24
        17,
        17
      ]),
      // pre_defined = -1
      c,
      G.box(G.types.btrt, new Uint8Array([
        0,
        28,
        156,
        128,
        // bufferSizeDB
        0,
        45,
        198,
        192,
        // maxBitrate
        0,
        45,
        198,
        192
      ])),
      // avgBitrate
      G.box(G.types.pasp, new Uint8Array([
        f >> 24,
        // hSpacing
        f >> 16 & 255,
        f >> 8 & 255,
        f & 255,
        p >> 24,
        // vSpacing
        p >> 16 & 255,
        p >> 8 & 255,
        p & 255
      ]))
    );
  }
}
G.types = void 0;
G.HDLR_TYPES = void 0;
G.STTS = void 0;
G.STSC = void 0;
G.STCO = void 0;
G.STSZ = void 0;
G.VMHD = void 0;
G.SMHD = void 0;
G.STSD = void 0;
G.FTYP = void 0;
G.DINF = void 0;
const Hg = 9e4;
function Yu(n, e, t = 1, i = !1) {
  const s = n * e * t;
  return i ? Math.round(s) : s;
}
function bT(n, e, t = 1, i = !1) {
  return Yu(n, e, 1 / t, i);
}
function In(n, e = !1) {
  return Yu(n, 1e3, 1 / Hg, e);
}
function _T(n, e = 1) {
  return Yu(n, Hg, 1 / e);
}
function kf(n) {
  const {
    baseTime: e,
    timescale: t,
    trackId: i
  } = n;
  return `${e / t} (${e}/${t}) trackId: ${i}`;
}
const AT = 10 * 1e3, wT = 1024, LT = 1152, IT = 1536;
let Vr = null, Ol = null;
function Mf(n, e, t, i) {
  return {
    duration: e,
    size: t,
    cts: i,
    flags: {
      isLeading: 0,
      isDependedOn: 0,
      hasRedundancy: 0,
      degradPrio: 0,
      dependsOn: n ? 2 : 1,
      isNonSync: n ? 0 : 1
    }
  };
}
class mo extends Fi {
  constructor(e, t, i, s) {
    if (super("mp4-remuxer", s), this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = null, this._initDTS = null, this.nextVideoTs = null, this.nextAudioTs = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.videoTrackConfig = void 0, this.observer = e, this.config = t, this.typeSupported = i, this.ISGenerated = !1, Vr === null) {
      const a = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
      Vr = a ? parseInt(a[1]) : 0;
    }
    if (Ol === null) {
      const r = navigator.userAgent.match(/Safari\/(\d+)/i);
      Ol = r ? parseInt(r[1]) : 0;
    }
  }
  destroy() {
    this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;
  }
  resetTimeStamp(e) {
    const t = this._initPTS;
    (!t || !e || e.trackId !== t.trackId || e.baseTime !== t.baseTime || e.timescale !== t.timescale) && this.log(`Reset initPTS: ${t && kf(t)} > ${e && kf(e)}`), this._initPTS = this._initDTS = e;
  }
  resetNextTimestamp() {
    this.log("reset next timestamp"), this.isVideoContiguous = !1, this.isAudioContiguous = !1;
  }
  resetInitSegment() {
    this.log("ISGenerated flag reset"), this.ISGenerated = !1, this.videoTrackConfig = void 0;
  }
  getVideoStartPts(e) {
    let t = !1;
    const i = e[0].pts, s = e.reduce((r, a) => {
      let o = a.pts, l = o - r;
      return l < -4294967296 && (t = !0, o = di(o, i), l = o - r), l > 0 ? r : o;
    }, i);
    return t && this.debug("PTS rollover detected"), s;
  }
  remux(e, t, i, s, r, a, o, l) {
    let c, u, d, f, p, h, g = r, m = r;
    const v = e.pid > -1, y = t.pid > -1, E = t.samples.length, T = e.samples.length > 0, S = o && E > 0 || E > 1;
    if ((!v || T) && (!y || S) || this.ISGenerated || o) {
      if (this.ISGenerated) {
        var b, L, A, _;
        const M = this.videoTrackConfig;
        (M && (t.width !== M.width || t.height !== M.height || ((b = t.pixelRatio) == null ? void 0 : b[0]) !== ((L = M.pixelRatio) == null ? void 0 : L[0]) || ((A = t.pixelRatio) == null ? void 0 : A[1]) !== ((_ = M.pixelRatio) == null ? void 0 : _[1])) || !M && S || this.nextAudioTs === null && T) && this.resetInitSegment();
      }
      this.ISGenerated || (d = this.generateIS(e, t, r, a));
      const R = this.isVideoContiguous;
      let I = -1, k;
      if (S && (I = RT(t.samples), !R && this.config.forceKeyFrameOnDiscontinuity))
        if (h = !0, I > 0) {
          this.warn(`Dropped ${I} out of ${E} video samples due to a missing keyframe`);
          const M = this.getVideoStartPts(t.samples);
          t.samples = t.samples.slice(I), t.dropped += I, m += (t.samples[0].pts - M) / t.inputTimeScale, k = m;
        } else I === -1 && (this.warn(`No keyframe found out of ${E} video samples`), h = !1);
      if (this.ISGenerated) {
        if (T && S) {
          const M = this.getVideoStartPts(t.samples), F = (di(e.samples[0].pts, M) - M) / t.inputTimeScale;
          g += Math.max(0, F), m += Math.max(0, -F);
        }
        if (T) {
          if (e.samplerate || (this.warn("regenerate InitSegment as audio detected"), d = this.generateIS(e, t, r, a)), u = this.remuxAudio(e, g, this.isAudioContiguous, a, y || S || l === te.AUDIO ? m : void 0), S) {
            const M = u ? u.endPTS - u.startPTS : 0;
            t.inputTimeScale || (this.warn("regenerate InitSegment as video detected"), d = this.generateIS(e, t, r, a)), c = this.remuxVideo(t, m, R, M);
          }
        } else S && (c = this.remuxVideo(t, m, R, 0));
        c && (c.firstKeyFrame = I, c.independent = I !== -1, c.firstKeyFramePTS = k);
      }
    }
    return this.ISGenerated && this._initPTS && this._initDTS && (i.samples.length && (p = Vg(i, r, this._initPTS, this._initDTS)), s.samples.length && (f = zg(s, r, this._initPTS))), {
      audio: u,
      video: c,
      initSegment: d,
      independent: h,
      text: f,
      id3: p
    };
  }
  computeInitPts(e, t, i, s) {
    const r = Math.round(i * t);
    let a = di(e, r);
    if (a < r + t)
      for (this.log(`Adjusting PTS for rollover in timeline near ${(r - a) / t} ${s}`); a < r + t; )
        a += 8589934592;
    return a - r;
  }
  generateIS(e, t, i, s) {
    const r = e.samples, a = t.samples, o = this.typeSupported, l = {}, c = this._initPTS;
    let u = !c || s, d = "audio/mp4", f, p, h, g = -1;
    if (u && (f = p = 1 / 0), e.config && r.length) {
      switch (e.timescale = e.samplerate, e.segmentCodec) {
        case "mp3":
          o.mpeg ? (d = "audio/mpeg", e.codec = "") : o.mp3 && (e.codec = "mp3");
          break;
        case "ac3":
          e.codec = "ac-3";
          break;
      }
      l.audio = {
        id: "audio",
        container: d,
        codec: e.codec,
        initSegment: e.segmentCodec === "mp3" && o.mpeg ? new Uint8Array(0) : G.initSegment([e]),
        metadata: {
          channelCount: e.channelCount
        }
      }, u && (g = e.id, h = e.inputTimeScale, !c || h !== c.timescale ? f = p = this.computeInitPts(r[0].pts, h, i, "audio") : u = !1);
    }
    if (t.sps && t.pps && a.length) {
      if (t.timescale = t.inputTimeScale, l.video = {
        id: "main",
        container: "video/mp4",
        codec: t.codec,
        initSegment: G.initSegment([t]),
        metadata: {
          width: t.width,
          height: t.height
        }
      }, u)
        if (g = t.id, h = t.inputTimeScale, !c || h !== c.timescale) {
          const m = this.getVideoStartPts(a), v = di(a[0].dts, m), y = this.computeInitPts(v, h, i, "video"), E = this.computeInitPts(m, h, i, "video");
          p = Math.min(p, y), f = Math.min(f, E);
        } else
          u = !1;
      this.videoTrackConfig = {
        width: t.width,
        height: t.height,
        pixelRatio: t.pixelRatio
      };
    }
    if (Object.keys(l).length)
      return this.ISGenerated = !0, u ? (c && this.warn(`Timestamps at playlist time: ${s ? "" : "~"}${i} ${f / h} != initPTS: ${c.baseTime / c.timescale} (${c.baseTime}/${c.timescale}) trackId: ${c.trackId}`), this.log(`Found initPTS at playlist time: ${i} offset: ${f / h} (${f}/${h}) trackId: ${g}`), this._initPTS = {
        baseTime: f,
        timescale: h,
        trackId: g
      }, this._initDTS = {
        baseTime: p,
        timescale: h,
        trackId: g
      }) : f = h = void 0, {
        tracks: l,
        initPTS: f,
        timescale: h,
        trackId: g
      };
  }
  remuxVideo(e, t, i, s) {
    const r = e.inputTimeScale, a = e.samples, o = [], l = a.length, c = this._initPTS, u = c.baseTime * r / c.timescale;
    let d = this.nextVideoTs, f = 8, p = this.videoSampleDuration, h, g, m = Number.POSITIVE_INFINITY, v = Number.NEGATIVE_INFINITY, y = !1;
    if (!i || d === null) {
      const K = u + t * r, X = a[0].pts - di(a[0].dts, a[0].pts);
      Vr && d !== null && Math.abs(K - X - (d + u)) < 15e3 ? i = !0 : d = K - X - u;
    }
    const E = d + u;
    for (let K = 0; K < l; K++) {
      const X = a[K];
      X.pts = di(X.pts, E), X.dts = di(X.dts, E), X.dts < a[K > 0 ? K - 1 : K].dts && (y = !0);
    }
    y && a.sort(function(K, X) {
      const W = K.dts - X.dts, Y = K.pts - X.pts;
      return W || Y;
    }), h = a[0].dts, g = a[a.length - 1].dts;
    const T = g - h, S = T ? Math.round(T / (l - 1)) : p || e.inputTimeScale / 30;
    if (i) {
      const K = h - E, X = K > S, W = K < -1;
      if ((X || W) && (X ? this.warn(`${(e.segmentCodec || "").toUpperCase()}: ${In(K, !0)} ms (${K}dts) hole between fragments detected at ${t.toFixed(3)}`) : this.warn(`${(e.segmentCodec || "").toUpperCase()}: ${In(-K, !0)} ms (${K}dts) overlapping between fragments detected at ${t.toFixed(3)}`), !W || E >= a[0].pts || Vr)) {
        h = E;
        const Y = a[0].pts - K;
        if (X)
          a[0].dts = h, a[0].pts = Y;
        else {
          let N = !0;
          for (let U = 0; U < a.length && !(a[U].dts > Y && N); U++) {
            const V = a[U].pts;
            if (a[U].dts -= K, a[U].pts -= K, U < a.length - 1) {
              const j = a[U + 1].pts, ee = a[U].pts, ce = j <= ee, oe = j <= V;
              N = ce == oe;
            }
          }
        }
        this.log(`Video: Initial PTS/DTS adjusted: ${In(Y, !0)}/${In(h, !0)}, delta: ${In(K, !0)} ms`);
      }
    }
    h = Math.max(0, h);
    let w = 0, b = 0, L = h;
    for (let K = 0; K < l; K++) {
      const X = a[K], W = X.units, Y = W.length;
      let N = 0;
      for (let U = 0; U < Y; U++)
        N += W[U].data.length;
      b += N, w += Y, X.length = N, X.dts < L ? (X.dts = L, L += S / 4 | 0 || 1) : L = X.dts, m = Math.min(X.pts, m), v = Math.max(X.pts, v);
    }
    g = a[l - 1].dts;
    const A = b + 4 * w + 8;
    let _;
    try {
      _ = new Uint8Array(A);
    } catch (K) {
      this.observer.emit(x.ERROR, x.ERROR, {
        type: se.MUX_ERROR,
        details: H.REMUX_ALLOC_ERROR,
        fatal: !1,
        error: K,
        bytes: A,
        reason: `fail allocating video mdat ${A}`
      });
      return;
    }
    const R = new DataView(_.buffer);
    R.setUint32(0, A), _.set(G.types.mdat, 4);
    let I = !1, k = Number.POSITIVE_INFINITY, M = Number.POSITIVE_INFINITY, O = Number.NEGATIVE_INFINITY, F = Number.NEGATIVE_INFINITY;
    for (let K = 0; K < l; K++) {
      const X = a[K], W = X.units;
      let Y = 0;
      for (let V = 0, j = W.length; V < j; V++) {
        const ee = W[V], ce = ee.data, oe = ee.data.byteLength;
        R.setUint32(f, oe), f += 4, _.set(ce, f), f += oe, Y += 4 + oe;
      }
      let N;
      if (K < l - 1)
        p = a[K + 1].dts - X.dts, N = a[K + 1].pts - X.pts;
      else {
        const V = this.config, j = K > 0 ? X.dts - a[K - 1].dts : S;
        if (N = K > 0 ? X.pts - a[K - 1].pts : S, V.stretchShortVideoTrack && this.nextAudioTs !== null) {
          const ee = Math.floor(V.maxBufferHole * r), ce = (s ? m + s * r : this.nextAudioTs + u) - X.pts;
          ce > ee ? (p = ce - j, p < 0 ? p = j : I = !0, this.log(`It is approximately ${ce / 90} ms to the next segment; using duration ${p / 90} ms for the last video frame.`)) : p = j;
        } else
          p = j;
      }
      const U = Math.round(X.pts - X.dts);
      k = Math.min(k, p), O = Math.max(O, p), M = Math.min(M, N), F = Math.max(F, N), o.push(Mf(X.key, p, Y, U));
    }
    if (o.length) {
      if (Vr) {
        if (Vr < 70) {
          const K = o[0].flags;
          K.dependsOn = 2, K.isNonSync = 0;
        }
      } else if (Ol && F - M < O - k && S / O < 0.025 && o[0].cts === 0) {
        this.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
        let K = h;
        for (let X = 0, W = o.length; X < W; X++) {
          const Y = K + o[X].duration, N = K + o[X].cts;
          if (X < W - 1) {
            const U = Y + o[X + 1].cts;
            o[X].duration = U - N;
          } else
            o[X].duration = X ? o[X - 1].duration : S;
          o[X].cts = 0, K = Y;
        }
      }
    }
    p = I || !p ? S : p;
    const C = g + p;
    this.nextVideoTs = d = C - u, this.videoSampleDuration = p, this.isVideoContiguous = !0;
    const P = {
      data1: G.moof(e.sequenceNumber++, h, Fe(e, {
        samples: o
      })),
      data2: _,
      startPTS: (m - u) / r,
      endPTS: (v + p - u) / r,
      startDTS: (h - u) / r,
      endDTS: d / r,
      type: "video",
      hasAudio: !1,
      hasVideo: !0,
      nb: o.length,
      dropped: e.dropped
    };
    return e.samples = [], e.dropped = 0, P;
  }
  getSamplesPerFrame(e) {
    switch (e.segmentCodec) {
      case "mp3":
        return LT;
      case "ac3":
        return IT;
      default:
        return wT;
    }
  }
  remuxAudio(e, t, i, s, r) {
    const a = e.inputTimeScale, o = e.samplerate ? e.samplerate : a, l = a / o, c = this.getSamplesPerFrame(e), u = c * l, d = this._initPTS, f = e.segmentCodec === "mp3" && this.typeSupported.mpeg, p = [], h = r !== void 0;
    let g = e.samples, m = f ? 0 : 8, v = this.nextAudioTs || -1;
    const y = d.baseTime * a / d.timescale, E = y + t * a;
    if (this.isAudioContiguous = i = i || g.length && v > 0 && (s && Math.abs(E - (v + y)) < 9e3 || Math.abs(di(g[0].pts, E) - (v + y)) < 20 * u), g.forEach(function(F) {
      F.pts = di(F.pts, E);
    }), !i || v < 0) {
      const F = g.length;
      if (g = g.filter((C) => C.pts >= 0), F !== g.length && this.warn(`Removed ${g.length - F} of ${F} samples (initPTS ${y} / ${a})`), !g.length)
        return;
      r === 0 ? v = 0 : s && !h ? v = Math.max(0, E - y) : v = g[0].pts - y;
    }
    if (e.segmentCodec === "aac") {
      const F = this.config.maxAudioFramesDrift;
      for (let C = 0, D = v + y; C < g.length; C++) {
        const B = g[C], P = B.pts, K = P - D, X = Math.abs(1e3 * K / a);
        if (K <= -F * u && h)
          C === 0 && (this.warn(`Audio frame @ ${(P / a).toFixed(3)}s overlaps marker by ${Math.round(1e3 * K / a)} ms.`), this.nextAudioTs = v = P - y, D = P);
        else if (K >= F * u && X < AT && h) {
          let W = Math.round(K / u);
          for (D = P - W * u; D < 0 && W && u; )
            W--, D += u;
          C === 0 && (this.nextAudioTs = v = D - y), this.warn(`Injecting ${W} audio frames @ ${((D - y) / a).toFixed(3)}s due to ${Math.round(1e3 * K / a)} ms gap.`);
          for (let Y = 0; Y < W; Y++) {
            let N = xT.getSilentFrame(e.parsedCodec || e.manifestCodec || e.codec, e.channelCount);
            N || (this.log("Unable to get silent frame for given audio codec; duplicating last frame instead."), N = B.unit.subarray()), g.splice(C, 0, {
              unit: N,
              pts: D
            }), D += u, C++;
          }
        }
        B.pts = D, D += u;
      }
    }
    let T = null, S = null, w, b = 0, L = g.length;
    for (; L--; )
      b += g[L].unit.byteLength;
    for (let F = 0, C = g.length; F < C; F++) {
      const D = g[F], B = D.unit;
      let P = D.pts;
      if (S !== null) {
        const X = p[F - 1];
        X.duration = Math.round((P - S) / l);
      } else if (i && e.segmentCodec === "aac" && (P = v + y), T = P, b > 0) {
        b += m;
        try {
          w = new Uint8Array(b);
        } catch (X) {
          this.observer.emit(x.ERROR, x.ERROR, {
            type: se.MUX_ERROR,
            details: H.REMUX_ALLOC_ERROR,
            fatal: !1,
            error: X,
            bytes: b,
            reason: `fail allocating audio mdat ${b}`
          });
          return;
        }
        f || (new DataView(w.buffer).setUint32(0, b), w.set(G.types.mdat, 4));
      } else
        return;
      w.set(B, m);
      const K = B.byteLength;
      m += K, p.push(Mf(!0, c, K, 0)), S = P;
    }
    const A = p.length;
    if (!A)
      return;
    const _ = p[p.length - 1];
    v = S - y, this.nextAudioTs = v + l * _.duration;
    const R = f ? new Uint8Array(0) : G.moof(e.sequenceNumber++, T / l, Fe({}, e, {
      samples: p
    }));
    e.samples = [];
    const I = (T - y) / a, k = this.nextAudioTs / a, O = {
      data1: R,
      data2: w,
      startPTS: I,
      endPTS: k,
      startDTS: I,
      endDTS: k,
      type: "audio",
      hasAudio: !0,
      hasVideo: !1,
      nb: A
    };
    return this.isAudioContiguous = !0, O;
  }
}
function di(n, e) {
  let t;
  if (e === null)
    return n;
  for (e < n ? t = -8589934592 : t = 8589934592; Math.abs(n - e) > 4294967296; )
    n += t;
  return n;
}
function RT(n) {
  for (let e = 0; e < n.length; e++)
    if (n[e].key)
      return e;
  return -1;
}
function Vg(n, e, t, i) {
  const s = n.samples.length;
  if (!s)
    return;
  const r = n.inputTimeScale;
  for (let o = 0; o < s; o++) {
    const l = n.samples[o];
    l.pts = di(l.pts - t.baseTime * r / t.timescale, e * r) / r, l.dts = di(l.dts - i.baseTime * r / i.timescale, e * r) / r;
  }
  const a = n.samples;
  return n.samples = [], {
    samples: a
  };
}
function zg(n, e, t) {
  const i = n.samples.length;
  if (!i)
    return;
  const s = n.inputTimeScale;
  for (let a = 0; a < i; a++) {
    const o = n.samples[a];
    o.pts = di(o.pts - t.baseTime * s / t.timescale, e * s) / s;
  }
  n.samples.sort((a, o) => a.pts - o.pts);
  const r = n.samples;
  return n.samples = [], {
    samples: r
  };
}
class CT extends Fi {
  constructor(e, t, i, s) {
    super("passthrough-remuxer", s), this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = null, this.initTracks = void 0, this.lastEndTime = null, this.isVideoContiguous = !1;
  }
  destroy() {
  }
  resetTimeStamp(e) {
    this.lastEndTime = null;
    const t = this.initPTS;
    t && e && t.baseTime === e.baseTime && t.timescale === e.timescale || (this.initPTS = e);
  }
  resetNextTimestamp() {
    this.isVideoContiguous = !1, this.lastEndTime = null;
  }
  resetInitSegment(e, t, i, s) {
    this.audioCodec = t, this.videoCodec = i, this.generateInitSegment(e, s), this.emitInitSegment = !0;
  }
  generateInitSegment(e, t) {
    let {
      audioCodec: i,
      videoCodec: s
    } = this;
    if (!(e != null && e.byteLength)) {
      this.initTracks = void 0, this.initData = void 0;
      return;
    }
    const {
      audio: r,
      video: a
    } = this.initData = jp(e);
    if (t)
      vy(e, t);
    else {
      const l = r || a;
      l != null && l.encrypted && this.warn(`Init segment with encrypted track with has no key ("${l.codec}")!`);
    }
    r && (i = Of(r, Ue.AUDIO, this)), a && (s = Of(a, Ue.VIDEO, this));
    const o = {};
    r && a ? o.audiovideo = {
      container: "video/mp4",
      codec: i + "," + s,
      supplemental: a.supplemental,
      encrypted: a.encrypted,
      initSegment: e,
      id: "main"
    } : r ? o.audio = {
      container: "audio/mp4",
      codec: i,
      encrypted: r.encrypted,
      initSegment: e,
      id: "audio"
    } : a ? o.video = {
      container: "video/mp4",
      codec: s,
      supplemental: a.supplemental,
      encrypted: a.encrypted,
      initSegment: e,
      id: "main"
    } : this.warn("initSegment does not contain moov or trak boxes."), this.initTracks = o;
  }
  remux(e, t, i, s, r, a) {
    var o, l;
    let {
      initPTS: c,
      lastEndTime: u
    } = this;
    const d = {
      audio: void 0,
      video: void 0,
      text: s,
      id3: i,
      initSegment: void 0
    };
    Z(u) || (u = this.lastEndTime = r || 0);
    const f = t.samples;
    if (!f.length)
      return d;
    const p = {
      initPTS: void 0,
      timescale: void 0,
      trackId: void 0
    };
    let h = this.initData;
    if ((o = h) != null && o.length || (this.generateInitSegment(f), h = this.initData), !((l = h) != null && l.length))
      return this.warn("Failed to generate initSegment."), d;
    this.emitInitSegment && (p.tracks = this.initTracks, this.emitInitSegment = !1);
    const g = Ey(f, h, this), m = h.audio ? g[h.audio.id] : null, v = h.video ? g[h.video.id] : null, y = Ya(v, 1 / 0), E = Ya(m, 1 / 0), T = Ya(v, 0, !0), S = Ya(m, 0, !0);
    let w = r, b = 0;
    const L = m && (!v || !c && E < y || c && c.trackId === h.audio.id), A = L ? m : v;
    if (A) {
      const D = A.timescale, B = A.start - r * D, P = L ? h.audio.id : h.video.id;
      w = A.start / D, b = L ? S - E : T - y, (a || !c) && (PT(c, w, r, b) || D !== c.timescale) && (c && this.warn(`Timestamps at playlist time: ${a ? "" : "~"}${r} ${B / D} != initPTS: ${c.baseTime / c.timescale} (${c.baseTime}/${c.timescale}) trackId: ${c.trackId}`), this.log(`Found initPTS at playlist time: ${r} offset: ${w - r} (${B}/${D}) trackId: ${P}`), c = null, p.initPTS = B, p.timescale = D, p.trackId = P);
    } else
      this.warn(`No audio or video samples found for initPTS at playlist time: ${r}`);
    c ? (p.initPTS = c.baseTime, p.timescale = c.timescale, p.trackId = c.trackId) : ((!p.timescale || p.trackId === void 0 || p.initPTS === void 0) && (this.warn("Could not set initPTS"), p.initPTS = w, p.timescale = 1, p.trackId = -1), this.initPTS = c = {
      baseTime: p.initPTS,
      timescale: p.timescale,
      trackId: p.trackId
    });
    const _ = w - c.baseTime / c.timescale, R = _ + b;
    b > 0 ? this.lastEndTime = R : (this.warn("Duration parsed from mp4 should be greater than zero"), this.resetNextTimestamp());
    const I = !!h.audio, k = !!h.video;
    let M = "";
    I && (M += "audio"), k && (M += "video");
    const O = (h.audio ? h.audio.encrypted : !1) || (h.video ? h.video.encrypted : !1), F = {
      data1: f,
      startPTS: _,
      startDTS: _,
      endPTS: R,
      endDTS: R,
      type: M,
      hasAudio: I,
      hasVideo: k,
      nb: 1,
      dropped: 0,
      encrypted: O
    };
    d.audio = I && !k ? F : void 0, d.video = k ? F : void 0;
    const C = v?.sampleCount;
    if (C) {
      const D = v.keyFrameIndex, B = D !== -1;
      F.nb = C, F.dropped = D === 0 || this.isVideoContiguous ? 0 : B ? D : C, F.independent = B, F.firstKeyFrame = D, B && v.keyFrameStart && (F.firstKeyFramePTS = (v.keyFrameStart - c.baseTime) / c.timescale), this.isVideoContiguous || (d.independent = B), this.isVideoContiguous || (this.isVideoContiguous = B), F.dropped && this.warn(`fmp4 does not start with IDR: firstIDR ${D}/${C} dropped: ${F.dropped} start: ${F.firstKeyFramePTS || "NA"}`);
    }
    return d.initSegment = p, d.id3 = Vg(i, r, c, c), s.samples.length && (d.text = zg(s, r, c)), d;
  }
}
function Ya(n, e, t = !1) {
  return n?.start !== void 0 ? (n.start + (t ? n.duration : 0)) / n.timescale : e;
}
function PT(n, e, t, i) {
  if (n === null)
    return !0;
  const s = Math.max(i, 1), r = e - n.baseTime / n.timescale;
  return Math.abs(r - t) > s;
}
function Of(n, e, t) {
  const i = n.codec;
  return i && i.length > 4 ? i : e === Ue.AUDIO ? i === "ec-3" || i === "ac-3" || i === "alac" ? i : i === "fLaC" || i === "Opus" ? No(i, !1) : (t.warn(`Unhandled audio codec "${i}" in mp4 MAP`), i || "mp4a") : (t.warn(`Unhandled video codec "${i}" in mp4 MAP`), i || "avc1");
}
let vs;
try {
  vs = self.performance.now.bind(self.performance);
} catch {
  vs = Date.now;
}
const vo = [{
  demux: mT,
  remux: CT
}, {
  demux: Os,
  remux: mo
}, {
  demux: fT,
  remux: mo
}, {
  demux: pT,
  remux: mo
}];
vo.splice(2, 0, {
  demux: hT,
  remux: mo
});
class Ff {
  constructor(e, t, i, s, r, a) {
    this.asyncResult = !1, this.logger = void 0, this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = e, this.typeSupported = t, this.config = i, this.id = r, this.logger = a;
  }
  configure(e) {
    this.transmuxConfig = e, this.decrypter && this.decrypter.reset();
  }
  push(e, t, i, s) {
    const r = i.transmuxing;
    r.executeStart = vs();
    let a = new Uint8Array(e);
    const {
      currentTransmuxState: o,
      transmuxConfig: l
    } = this;
    s && (this.currentTransmuxState = s);
    const {
      contiguous: c,
      discontinuity: u,
      trackSwitch: d,
      accurateTimeOffset: f,
      timeOffset: p,
      initSegmentChange: h
    } = s || o, {
      audioCodec: g,
      videoCodec: m,
      defaultInitPts: v,
      duration: y,
      initSegmentData: E
    } = l, T = DT(a, t);
    if (T && an(T.method)) {
      const L = this.getDecrypter(), A = $u(T.method);
      if (L.isSync()) {
        let _ = L.softwareDecrypt(a, T.key.buffer, T.iv.buffer, A);
        if (i.part > -1) {
          const I = L.flush();
          _ = I && I.buffer;
        }
        if (!_)
          return r.executeEnd = vs(), Fl(i);
        a = new Uint8Array(_);
      } else
        return this.asyncResult = !0, this.decryptionPromise = L.webCryptoDecrypt(a, T.key.buffer, T.iv.buffer, A).then((_) => {
          const R = this.push(_, null, i);
          return this.decryptionPromise = null, R;
        }), this.decryptionPromise;
    }
    const S = this.needsProbing(u, d);
    if (S) {
      const L = this.configureTransmuxer(a);
      if (L)
        return this.logger.warn(`[transmuxer] ${L.message}`), this.observer.emit(x.ERROR, x.ERROR, {
          type: se.MEDIA_ERROR,
          details: H.FRAG_PARSING_ERROR,
          fatal: !1,
          error: L,
          reason: L.message
        }), r.executeEnd = vs(), Fl(i);
    }
    (u || d || h || S) && this.resetInitSegment(E, g, m, y, t), (u || h || S) && this.resetInitialTimestamp(v), c || this.resetContiguity();
    const w = this.transmux(a, T, p, f, i);
    this.asyncResult = ya(w);
    const b = this.currentTransmuxState;
    return b.contiguous = !0, b.discontinuity = !1, b.trackSwitch = !1, r.executeEnd = vs(), w;
  }
  // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)
  flush(e) {
    const t = e.transmuxing;
    t.executeStart = vs();
    const {
      decrypter: i,
      currentTransmuxState: s,
      decryptionPromise: r
    } = this;
    if (r)
      return this.asyncResult = !0, r.then(() => this.flush(e));
    const a = [], {
      timeOffset: o
    } = s;
    if (i) {
      const d = i.flush();
      d && a.push(this.push(d.buffer, null, e));
    }
    const {
      demuxer: l,
      remuxer: c
    } = this;
    if (!l || !c) {
      t.executeEnd = vs();
      const d = [Fl(e)];
      return this.asyncResult ? Promise.resolve(d) : d;
    }
    const u = l.flush(o);
    return ya(u) ? (this.asyncResult = !0, u.then((d) => (this.flushRemux(a, d, e), a))) : (this.flushRemux(a, u, e), this.asyncResult ? Promise.resolve(a) : a);
  }
  flushRemux(e, t, i) {
    const {
      audioTrack: s,
      videoTrack: r,
      id3Track: a,
      textTrack: o
    } = t, {
      accurateTimeOffset: l,
      timeOffset: c
    } = this.currentTransmuxState;
    this.logger.log(`[transmuxer.ts]: Flushed ${this.id} sn: ${i.sn}${i.part > -1 ? " part: " + i.part : ""} of ${this.id === te.MAIN ? "level" : "track"} ${i.level}`);
    const u = this.remuxer.remux(s, r, a, o, c, l, !0, this.id);
    e.push({
      remuxResult: u,
      chunkMeta: i
    }), i.transmuxing.executeEnd = vs();
  }
  resetInitialTimestamp(e) {
    const {
      demuxer: t,
      remuxer: i
    } = this;
    !t || !i || (t.resetTimeStamp(e), i.resetTimeStamp(e));
  }
  resetContiguity() {
    const {
      demuxer: e,
      remuxer: t
    } = this;
    !e || !t || (e.resetContiguity(), t.resetNextTimestamp());
  }
  resetInitSegment(e, t, i, s, r) {
    const {
      demuxer: a,
      remuxer: o
    } = this;
    !a || !o || (a.resetInitSegment(e, t, i, s), o.resetInitSegment(e, t, i, r));
  }
  destroy() {
    this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0);
  }
  transmux(e, t, i, s, r) {
    let a;
    return t && t.method === "SAMPLE-AES" ? a = this.transmuxSampleAes(e, t, i, s, r) : a = this.transmuxUnencrypted(e, i, s, r), a;
  }
  transmuxUnencrypted(e, t, i, s) {
    const {
      audioTrack: r,
      videoTrack: a,
      id3Track: o,
      textTrack: l
    } = this.demuxer.demux(e, t, !1, !this.config.progressive);
    return {
      remuxResult: this.remuxer.remux(r, a, o, l, t, i, !1, this.id),
      chunkMeta: s
    };
  }
  transmuxSampleAes(e, t, i, s, r) {
    return this.demuxer.demuxSampleAes(e, t, i).then((a) => ({
      remuxResult: this.remuxer.remux(a.audioTrack, a.videoTrack, a.id3Track, a.textTrack, i, s, !1, this.id),
      chunkMeta: r
    }));
  }
  configureTransmuxer(e) {
    const {
      config: t,
      observer: i,
      typeSupported: s
    } = this;
    let r;
    for (let d = 0, f = vo.length; d < f; d++) {
      var a;
      if ((a = vo[d].demux) != null && a.probe(e, this.logger)) {
        r = vo[d];
        break;
      }
    }
    if (!r)
      return new Error("Failed to find demuxer by probing fragment data");
    const o = this.demuxer, l = this.remuxer, c = r.remux, u = r.demux;
    (!l || !(l instanceof c)) && (this.remuxer = new c(i, t, s, this.logger)), (!o || !(o instanceof u)) && (this.demuxer = new u(i, t, s, this.logger), this.probe = u.probe);
  }
  needsProbing(e, t) {
    return !this.demuxer || !this.remuxer || e || t;
  }
  getDecrypter() {
    let e = this.decrypter;
    return e || (e = this.decrypter = new Fu(this.config)), e;
  }
}
function DT(n, e) {
  let t = null;
  return n.byteLength > 0 && e?.key != null && e.iv !== null && e.method != null && (t = e), t;
}
const Fl = (n) => ({
  remuxResult: {},
  chunkMeta: n
});
function ya(n) {
  return "then" in n && n.then instanceof Function;
}
class kT {
  constructor(e, t, i, s, r) {
    this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = e, this.videoCodec = t, this.initSegmentData = i, this.duration = s, this.defaultInitPts = r || null;
  }
}
class MT {
  constructor(e, t, i, s, r, a) {
    this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = e, this.contiguous = t, this.accurateTimeOffset = i, this.trackSwitch = s, this.timeOffset = r, this.initSegmentChange = a;
  }
}
let Nf = 0;
class Wg {
  constructor(e, t, i, s) {
    this.error = null, this.hls = void 0, this.id = void 0, this.instanceNo = Nf++, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.workerContext = null, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0, this.onWorkerMessage = (l) => {
      const c = l.data, u = this.hls;
      if (!(!u || !(c != null && c.event) || c.instanceNo !== this.instanceNo))
        switch (c.event) {
          case "init": {
            var d;
            const f = (d = this.workerContext) == null ? void 0 : d.objectURL;
            f && self.URL.revokeObjectURL(f);
            break;
          }
          case "transmuxComplete": {
            this.handleTransmuxComplete(c.data);
            break;
          }
          case "flush": {
            this.onFlush(c.data);
            break;
          }
          // pass logs from the worker thread to the main logger
          case "workerLog": {
            u.logger[c.data.logType] && u.logger[c.data.logType](c.data.message);
            break;
          }
          default: {
            c.data = c.data || {}, c.data.frag = this.frag, c.data.part = this.part, c.data.id = this.id, u.trigger(c.event, c.data);
            break;
          }
        }
    }, this.onWorkerError = (l) => {
      if (!this.hls)
        return;
      const c = new Error(`${l.message}  (${l.filename}:${l.lineno})`);
      this.hls.config.enableWorker = !1, this.hls.logger.warn(`Error in "${this.id}" Web Worker, fallback to inline`), this.hls.trigger(x.ERROR, {
        type: se.OTHER_ERROR,
        details: H.INTERNAL_EXCEPTION,
        fatal: !1,
        event: "demuxerWorker",
        error: c
      });
    };
    const r = e.config;
    this.hls = e, this.id = t, this.useWorker = !!r.enableWorker, this.onTransmuxComplete = i, this.onFlush = s;
    const a = (l, c) => {
      c = c || {}, c.frag = this.frag || void 0, l === x.ERROR && (c = c, c.parent = this.id, c.part = this.part, this.error = c.error), this.hls.trigger(l, c);
    };
    this.observer = new Gu(), this.observer.on(x.FRAG_DECRYPTED, a), this.observer.on(x.ERROR, a);
    const o = Qd(r.preferManagedMediaSource);
    if (this.useWorker && typeof Worker < "u") {
      const l = this.hls.logger;
      if (r.workerPath || $E()) {
        try {
          r.workerPath ? (l.log(`loading Web Worker ${r.workerPath} for "${t}"`), this.workerContext = UE(r.workerPath)) : (l.log(`injecting Web Worker for "${t}"`), this.workerContext = BE());
          const {
            worker: u
          } = this.workerContext;
          u.addEventListener("message", this.onWorkerMessage), u.addEventListener("error", this.onWorkerError), u.postMessage({
            instanceNo: this.instanceNo,
            cmd: "init",
            typeSupported: o,
            id: t,
            config: Ge(r)
          });
        } catch (u) {
          l.warn(`Error setting up "${t}" Web Worker, fallback to inline`, u), this.terminateWorker(), this.error = null, this.transmuxer = new Ff(this.observer, o, r, "", t, e.logger);
        }
        return;
      }
    }
    this.transmuxer = new Ff(this.observer, o, r, "", t, e.logger);
  }
  reset() {
    if (this.frag = null, this.part = null, this.workerContext) {
      const e = this.instanceNo;
      this.instanceNo = Nf++;
      const t = this.hls.config, i = Qd(t.preferManagedMediaSource);
      this.workerContext.worker.postMessage({
        instanceNo: this.instanceNo,
        cmd: "reset",
        resetNo: e,
        typeSupported: i,
        id: this.id,
        config: Ge(t)
      });
    }
  }
  terminateWorker() {
    if (this.workerContext) {
      const {
        worker: e
      } = this.workerContext;
      this.workerContext = null, e.removeEventListener("message", this.onWorkerMessage), e.removeEventListener("error", this.onWorkerError), GE(this.hls.config.workerPath);
    }
  }
  destroy() {
    if (this.workerContext)
      this.terminateWorker(), this.onWorkerMessage = this.onWorkerError = null;
    else {
      const t = this.transmuxer;
      t && (t.destroy(), this.transmuxer = null);
    }
    const e = this.observer;
    e && e.removeAllListeners(), this.frag = null, this.part = null, this.observer = null, this.hls = null;
  }
  push(e, t, i, s, r, a, o, l, c, u) {
    var d, f;
    c.transmuxing.start = self.performance.now();
    const {
      instanceNo: p,
      transmuxer: h
    } = this, g = a ? a.start : r.start, m = r.decryptdata, v = this.frag, y = !(v && r.cc === v.cc), E = !(v && c.level === v.level), T = v ? c.sn - v.sn : -1, S = this.part ? c.part - this.part.index : -1, w = T === 0 && c.id > 1 && c.id === v?.stats.chunkCount, b = !E && (T === 1 || T === 0 && (S === 1 || w && S <= 0)), L = self.performance.now();
    (E || T || r.stats.parsing.start === 0) && (r.stats.parsing.start = L), a && (S || !b) && (a.stats.parsing.start = L);
    const A = !(v && ((d = r.initSegment) == null ? void 0 : d.url) === ((f = v.initSegment) == null ? void 0 : f.url)), _ = new MT(y, b, l, E, g, A);
    if (!b || y || A) {
      this.hls.logger.log(`[transmuxer-interface]: Starting new transmux session for ${r.type} sn: ${c.sn}${c.part > -1 ? " part: " + c.part : ""} ${this.id === te.MAIN ? "level" : "track"}: ${c.level} id: ${c.id}
        discontinuity: ${y}
        trackSwitch: ${E}
        contiguous: ${b}
        accurateTimeOffset: ${l}
        timeOffset: ${g}
        initSegmentChange: ${A}`);
      const R = new kT(i, s, t, o, u);
      this.configureTransmuxer(R);
    }
    if (this.frag = r, this.part = a, this.workerContext)
      this.workerContext.worker.postMessage({
        instanceNo: p,
        cmd: "demux",
        data: e,
        decryptdata: m,
        chunkMeta: c,
        state: _
      }, e instanceof ArrayBuffer ? [e] : []);
    else if (h) {
      const R = h.push(e, m, c, _);
      ya(R) ? R.then((I) => {
        this.handleTransmuxComplete(I);
      }).catch((I) => {
        this.transmuxerError(I, c, "transmuxer-interface push error");
      }) : this.handleTransmuxComplete(R);
    }
  }
  flush(e) {
    e.transmuxing.start = self.performance.now();
    const {
      instanceNo: t,
      transmuxer: i
    } = this;
    if (this.workerContext)
      this.workerContext.worker.postMessage({
        instanceNo: t,
        cmd: "flush",
        chunkMeta: e
      });
    else if (i) {
      const s = i.flush(e);
      ya(s) ? s.then((r) => {
        this.handleFlushResult(r, e);
      }).catch((r) => {
        this.transmuxerError(r, e, "transmuxer-interface flush error");
      }) : this.handleFlushResult(s, e);
    }
  }
  transmuxerError(e, t, i) {
    this.hls && (this.error = e, this.hls.trigger(x.ERROR, {
      type: se.MEDIA_ERROR,
      details: H.FRAG_PARSING_ERROR,
      chunkMeta: t,
      frag: this.frag || void 0,
      part: this.part || void 0,
      fatal: !1,
      error: e,
      err: e,
      reason: i
    }));
  }
  handleFlushResult(e, t) {
    e.forEach((i) => {
      this.handleTransmuxComplete(i);
    }), this.onFlush(t);
  }
  configureTransmuxer(e) {
    const {
      instanceNo: t,
      transmuxer: i
    } = this;
    this.workerContext ? this.workerContext.worker.postMessage({
      instanceNo: t,
      cmd: "configure",
      config: e
    }) : i && i.configure(e);
  }
  handleTransmuxComplete(e) {
    e.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(e);
  }
}
const $f = 100;
class OT extends Uu {
  constructor(e, t, i) {
    super(e, t, i, "audio-stream-controller", te.AUDIO), this.mainAnchor = null, this.mainFragLoading = null, this.audioOnly = !1, this.bufferedTrack = null, this.switchingTrack = null, this.trackId = -1, this.waitingData = null, this.mainDetails = null, this.flushing = !1, this.bufferFlushed = !1, this.cachedTrackLoadedData = null, this.registerListeners();
  }
  onHandlerDestroying() {
    this.unregisterListeners(), super.onHandlerDestroying(), this.resetItem();
  }
  resetItem() {
    this.mainDetails = this.mainAnchor = this.mainFragLoading = this.bufferedTrack = this.switchingTrack = this.waitingData = this.cachedTrackLoadedData = null;
  }
  registerListeners() {
    super.registerListeners();
    const {
      hls: e
    } = this;
    e.on(x.LEVEL_LOADED, this.onLevelLoaded, this), e.on(x.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.on(x.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(x.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(x.BUFFER_RESET, this.onBufferReset, this), e.on(x.BUFFER_CREATED, this.onBufferCreated, this), e.on(x.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(x.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(x.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(x.FRAG_LOADING, this.onFragLoading, this), e.on(x.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (super.unregisterListeners(), e.off(x.LEVEL_LOADED, this.onLevelLoaded, this), e.off(x.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.off(x.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(x.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(x.BUFFER_RESET, this.onBufferReset, this), e.off(x.BUFFER_CREATED, this.onBufferCreated, this), e.off(x.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(x.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(x.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(x.FRAG_LOADING, this.onFragLoading, this), e.off(x.FRAG_BUFFERED, this.onFragBuffered, this));
  }
  // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value
  onInitPtsFound(e, {
    frag: t,
    id: i,
    initPTS: s,
    timescale: r,
    trackId: a
  }) {
    if (i === te.MAIN) {
      const o = t.cc, l = this.fragCurrent;
      if (this.initPTS[o] = {
        baseTime: s,
        timescale: r,
        trackId: a
      }, this.log(`InitPTS for cc: ${o} found from main: ${s / r} (${s}/${r}) trackId: ${a}`), this.mainAnchor = t, this.state === q.WAITING_INIT_PTS) {
        const c = this.waitingData;
        (!c && !this.loadingParts || c && c.frag.cc !== o) && this.syncWithAnchor(t, c?.frag);
      } else !this.hls.hasEnoughToStart && l && l.cc !== o ? (l.abortRequests(), this.syncWithAnchor(t, l)) : this.state === q.IDLE && this.tick();
    }
  }
  getLoadPosition() {
    return !this.startFragRequested && this.nextLoadPosition >= 0 ? this.nextLoadPosition : super.getLoadPosition();
  }
  syncWithAnchor(e, t) {
    var i;
    const s = ((i = this.mainFragLoading) == null ? void 0 : i.frag) || null;
    if (t && s?.cc === t.cc)
      return;
    const r = (s || e).cc, a = this.getLevelDetails(), o = this.getLoadPosition(), l = og(a, r, o);
    l && (this.log(`Syncing with main frag at ${l.start} cc ${l.cc}`), this.startFragRequested = !1, this.nextLoadPosition = l.start, this.resetLoadingState(), this.state === q.IDLE && this.doTickIdle());
  }
  startLoad(e, t) {
    if (!this.levels) {
      this.startPosition = e, this.state = q.STOPPED;
      return;
    }
    const i = this.lastCurrentTime;
    this.stopLoad(), this.setInterval($f), i > 0 && e === -1 ? (this.log(`Override startPosition with lastCurrentTime @${i.toFixed(3)}`), e = i, this.state = q.IDLE) : this.state = q.WAITING_TRACK, this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset, this.startPosition = t ? -1 : e, this.tick();
  }
  doTick() {
    switch (this.state) {
      case q.IDLE:
        this.doTickIdle();
        break;
      case q.WAITING_TRACK: {
        const {
          levels: e,
          trackId: t
        } = this, i = e?.[t], s = i?.details;
        if (s && !this.waitForLive(i)) {
          if (this.waitForCdnTuneIn(s))
            break;
          this.state = q.WAITING_INIT_PTS;
        }
        break;
      }
      case q.FRAG_LOADING_WAITING_RETRY: {
        this.checkRetryDate();
        break;
      }
      case q.WAITING_INIT_PTS: {
        const e = this.waitingData;
        if (e) {
          const {
            frag: t,
            part: i,
            cache: s,
            complete: r
          } = e, a = this.mainAnchor;
          if (this.initPTS[t.cc] !== void 0) {
            this.waitingData = null, this.state = q.FRAG_LOADING;
            const o = s.flush().buffer, l = {
              frag: t,
              part: i,
              payload: o,
              networkDetails: null
            };
            this._handleFragmentLoadProgress(l), r && super._handleFragmentLoadComplete(l);
          } else a && a.cc !== e.frag.cc && this.syncWithAnchor(a, e.frag);
        } else
          this.state = q.IDLE;
      }
    }
    this.onTickEnd();
  }
  resetLoadingState() {
    const e = this.waitingData;
    e && (this.fragmentTracker.removeFragment(e.frag), this.waitingData = null), super.resetLoadingState();
  }
  onTickEnd() {
    const {
      media: e
    } = this;
    e != null && e.readyState && (this.lastCurrentTime = e.currentTime);
  }
  doTickIdle() {
    var e;
    const {
      hls: t,
      levels: i,
      media: s,
      trackId: r
    } = this, a = t.config;
    if (!this.buffering || !s && !this.primaryPrefetch && (this.startFragRequested || !a.startFragPrefetch) || !(i != null && i[r]))
      return;
    const o = i[r], l = o.details;
    if (!l || this.waitForLive(o) || this.waitForCdnTuneIn(l)) {
      this.state = q.WAITING_TRACK, this.startFragRequested = !1;
      return;
    }
    const c = this.mediaBuffer ? this.mediaBuffer : this.media;
    this.bufferFlushed && c && (this.bufferFlushed = !1, this.afterBufferFlushed(c, Ue.AUDIO, te.AUDIO));
    const u = this.getFwdBufferInfo(c, te.AUDIO);
    if (u === null)
      return;
    if (!this.switchingTrack && this._streamEnded(u, l)) {
      t.trigger(x.BUFFER_EOS, {
        type: "audio"
      }), this.state = q.ENDED;
      return;
    }
    const d = u.len, f = t.maxBufferLength, p = l.fragments, h = p[0].start, g = this.getLoadPosition(), m = this.flushing ? g : u.end;
    if (this.switchingTrack && s) {
      const E = g;
      l.PTSKnown && E < h && (u.end > h || u.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"), s.currentTime = h + 0.05);
    }
    if (d >= f && !this.switchingTrack && m < p[p.length - 1].start)
      return;
    let v = this.getNextFragment(m, l);
    if (v && this.isLoopLoading(v, m) && (v = this.getNextFragmentLoopLoading(v, l, u, te.MAIN, f)), !v) {
      this.bufferFlushed = !0;
      return;
    }
    let y = ((e = this.mainFragLoading) == null ? void 0 : e.frag) || null;
    if (!this.audioOnly && this.startFragRequested && y && ot(v) && !v.endList && (!l.live || !this.loadingParts && m < this.hls.liveSyncPosition) && (this.fragmentTracker.getState(y) === yt.OK && (this.mainFragLoading = y = null), y && ot(y))) {
      if (v.start > y.end) {
        const T = this.fragmentTracker.getFragAtPos(m, te.MAIN);
        T && T.end > y.end && (y = T, this.mainFragLoading = {
          frag: T,
          targetBufferTime: null
        });
      }
      if (v.start > y.end)
        return;
    }
    this.loadFragment(v, o, m);
  }
  onMediaDetaching(e, t) {
    this.bufferFlushed = this.flushing = !1, super.onMediaDetaching(e, t);
  }
  onAudioTracksUpdated(e, {
    audioTracks: t
  }) {
    this.resetTransmuxer(), this.levels = t.map((i) => new ga(i));
  }
  onAudioTrackSwitching(e, t) {
    const i = !!t.url;
    this.trackId = t.id;
    const {
      fragCurrent: s
    } = this;
    s && (s.abortRequests(), this.removeUnbufferedFrags(s.start)), this.resetLoadingState(), i ? (this.switchingTrack = t, this.flushAudioIfNeeded(t), this.state !== q.STOPPED && (this.setInterval($f), this.state = q.IDLE, this.tick())) : (this.resetTransmuxer(), this.switchingTrack = null, this.bufferedTrack = t, this.clearInterval());
  }
  onManifestLoading() {
    super.onManifestLoading(), this.bufferFlushed = this.flushing = this.audioOnly = !1, this.resetItem(), this.trackId = -1;
  }
  onLevelLoaded(e, t) {
    this.mainDetails = t.details;
    const i = this.cachedTrackLoadedData;
    i && (this.cachedTrackLoadedData = null, this.onAudioTrackLoaded(x.AUDIO_TRACK_LOADED, i));
  }
  onAudioTrackLoaded(e, t) {
    var i;
    const {
      levels: s
    } = this, {
      details: r,
      id: a,
      groupId: o,
      track: l
    } = t;
    if (!s) {
      this.warn(`Audio tracks reset while loading track ${a} "${l.name}" of "${o}"`);
      return;
    }
    const c = this.mainDetails;
    if (!c || r.endCC > c.endCC || c.expired) {
      this.cachedTrackLoadedData = t, this.state !== q.STOPPED && (this.state = q.WAITING_TRACK);
      return;
    }
    this.cachedTrackLoadedData = null, this.log(`Audio track ${a} "${l.name}" of "${o}" loaded [${r.startSN},${r.endSN}]${r.lastPartSn ? `[part-${r.lastPartSn}-${r.lastPartIndex}]` : ""},duration:${r.totalduration}`);
    const u = s[a];
    let d = 0;
    if (r.live || (i = u.details) != null && i.live) {
      if (this.checkLiveUpdate(r), r.deltaUpdateFailed)
        return;
      if (u.details) {
        var f;
        d = this.alignPlaylists(r, u.details, (f = this.levelLastLoaded) == null ? void 0 : f.details);
      }
      r.alignedSliding || (Ag(r, c), r.alignedSliding || zo(r, c), d = r.fragmentStart);
    }
    u.details = r, this.levelLastLoaded = u, this.startFragRequested || this.setStartPosition(c, d), this.hls.trigger(x.AUDIO_TRACK_UPDATED, {
      details: r,
      id: a,
      groupId: t.groupId
    }), this.state === q.WAITING_TRACK && !this.waitForCdnTuneIn(r) && (this.state = q.IDLE), this.tick();
  }
  _handleFragmentLoadProgress(e) {
    var t;
    const i = e.frag, {
      part: s,
      payload: r
    } = e, {
      config: a,
      trackId: o,
      levels: l
    } = this;
    if (!l) {
      this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${i.sn} of level ${i.level} will not be buffered`);
      return;
    }
    const c = l[o];
    if (!c) {
      this.warn("Audio track is undefined on fragment load progress");
      return;
    }
    const u = c.details;
    if (!u) {
      this.warn("Audio track details undefined on fragment load progress"), this.removeUnbufferedFrags(i.start);
      return;
    }
    const d = a.defaultAudioCodec || c.audioCodec || "mp4a.40.2";
    let f = this.transmuxer;
    f || (f = this.transmuxer = new Wg(this.hls, te.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)));
    const p = this.initPTS[i.cc], h = (t = i.initSegment) == null ? void 0 : t.data;
    if (p !== void 0) {
      const m = s ? s.index : -1, v = m !== -1, y = new Nu(i.level, i.sn, i.stats.chunkCount, r.byteLength, m, v);
      f.push(r, h, d, "", i, s, u.totalduration, !1, y, p);
    } else {
      this.log(`Unknown video PTS for cc ${i.cc}, waiting for video PTS before demuxing audio frag ${i.sn} of [${u.startSN} ,${u.endSN}],track ${o}`);
      const {
        cache: g
      } = this.waitingData = this.waitingData || {
        frag: i,
        part: s,
        cache: new wg(),
        complete: !1
      };
      g.push(new Uint8Array(r)), this.state !== q.STOPPED && (this.state = q.WAITING_INIT_PTS);
    }
  }
  _handleFragmentLoadComplete(e) {
    if (this.waitingData) {
      this.waitingData.complete = !0;
      return;
    }
    super._handleFragmentLoadComplete(e);
  }
  onBufferReset() {
    this.mediaBuffer = null;
  }
  onBufferCreated(e, t) {
    this.bufferFlushed = this.flushing = !1;
    const i = t.tracks.audio;
    i && (this.mediaBuffer = i.buffer || null);
  }
  onFragLoading(e, t) {
    !this.audioOnly && t.frag.type === te.MAIN && ot(t.frag) && (this.mainFragLoading = t, this.state === q.IDLE && this.tick());
  }
  onFragBuffered(e, t) {
    const {
      frag: i,
      part: s
    } = t;
    if (i.type !== te.AUDIO) {
      !this.audioOnly && i.type === te.MAIN && !i.elementaryStreams.video && !i.elementaryStreams.audiovideo && (this.audioOnly = !0, this.mainFragLoading = null);
      return;
    }
    if (this.fragContextChanged(i)) {
      this.warn(`Fragment ${i.sn}${s ? " p: " + s.index : ""} of level ${i.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : "false"}`);
      return;
    }
    if (ot(i)) {
      this.fragPrevious = i;
      const r = this.switchingTrack;
      r && (this.bufferedTrack = r, this.switchingTrack = null, this.hls.trigger(x.AUDIO_TRACK_SWITCHED, Me({}, r)));
    }
    this.fragBufferedComplete(i, s), this.media && this.tick();
  }
  onError(e, t) {
    var i;
    if (t.fatal) {
      this.state = q.ERROR;
      return;
    }
    switch (t.details) {
      case H.FRAG_GAP:
      case H.FRAG_PARSING_ERROR:
      case H.FRAG_DECRYPT_ERROR:
      case H.FRAG_LOAD_ERROR:
      case H.FRAG_LOAD_TIMEOUT:
      case H.KEY_LOAD_ERROR:
      case H.KEY_LOAD_TIMEOUT:
        this.onFragmentOrKeyLoadError(te.AUDIO, t);
        break;
      case H.AUDIO_TRACK_LOAD_ERROR:
      case H.AUDIO_TRACK_LOAD_TIMEOUT:
      case H.LEVEL_PARSING_ERROR:
        !t.levelRetry && this.state === q.WAITING_TRACK && ((i = t.context) == null ? void 0 : i.type) === Ee.AUDIO_TRACK && (this.state = q.IDLE);
        break;
      case H.BUFFER_ADD_CODEC_ERROR:
      case H.BUFFER_APPEND_ERROR:
        if (t.parent !== "audio")
          return;
        this.reduceLengthAndFlushBuffer(t) || this.resetLoadingState();
        break;
      case H.BUFFER_FULL_ERROR:
        if (t.parent !== "audio")
          return;
        this.reduceLengthAndFlushBuffer(t) && (this.bufferedTrack = null, super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"));
        break;
      case H.INTERNAL_EXCEPTION:
        this.recoverWorkerError(t);
        break;
    }
  }
  onBufferFlushing(e, {
    type: t
  }) {
    t !== Ue.VIDEO && (this.flushing = !0);
  }
  onBufferFlushed(e, {
    type: t
  }) {
    if (t !== Ue.VIDEO) {
      this.flushing = !1, this.bufferFlushed = !0, this.state === q.ENDED && (this.state = q.IDLE);
      const i = this.mediaBuffer || this.media;
      i && (this.afterBufferFlushed(i, t, te.AUDIO), this.tick());
    }
  }
  _handleTransmuxComplete(e) {
    var t;
    const i = "audio", {
      hls: s
    } = this, {
      remuxResult: r,
      chunkMeta: a
    } = e, o = this.getCurrentContext(a);
    if (!o) {
      this.resetWhenMissingContext(a);
      return;
    }
    const {
      frag: l,
      part: c,
      level: u
    } = o, {
      details: d
    } = u, {
      audio: f,
      text: p,
      id3: h,
      initSegment: g
    } = r;
    if (this.fragContextChanged(l) || !d) {
      this.fragmentTracker.removeFragment(l);
      return;
    }
    if (this.state = q.PARSING, this.switchingTrack && f && this.completeAudioSwitch(this.switchingTrack), g != null && g.tracks) {
      const m = l.initSegment || l;
      if (this.unhandledEncryptionError(g, l))
        return;
      this._bufferInitSegment(u, g.tracks, m, a), s.trigger(x.FRAG_PARSING_INIT_SEGMENT, {
        frag: m,
        id: i,
        tracks: g.tracks
      });
    }
    if (f) {
      const {
        startPTS: m,
        endPTS: v,
        startDTS: y,
        endDTS: E
      } = f;
      c && (c.elementaryStreams[Ue.AUDIO] = {
        startPTS: m,
        endPTS: v,
        startDTS: y,
        endDTS: E
      }), l.setElementaryStreamInfo(Ue.AUDIO, m, v, y, E), this.bufferFragmentData(f, l, c, a);
    }
    if (h != null && (t = h.samples) != null && t.length) {
      const m = Fe({
        id: i,
        frag: l,
        details: d
      }, h);
      s.trigger(x.FRAG_PARSING_METADATA, m);
    }
    if (p) {
      const m = Fe({
        id: i,
        frag: l,
        details: d
      }, p);
      s.trigger(x.FRAG_PARSING_USERDATA, m);
    }
  }
  _bufferInitSegment(e, t, i, s) {
    if (this.state !== q.PARSING || (t.video && delete t.video, t.audiovideo && delete t.audiovideo, !t.audio))
      return;
    const r = t.audio;
    r.id = te.AUDIO;
    const a = e.audioCodec;
    this.log(`Init audio buffer, container:${r.container}, codecs[level/parsed]=[${a}/${r.codec}]`), a && a.split(",").length === 1 && (r.levelCodec = a), this.hls.trigger(x.BUFFER_CODECS, t);
    const o = r.initSegment;
    if (o != null && o.byteLength) {
      const l = {
        type: "audio",
        frag: i,
        part: null,
        chunkMeta: s,
        parent: i.type,
        data: o
      };
      this.hls.trigger(x.BUFFER_APPENDING, l);
    }
    this.tickImmediate();
  }
  loadFragment(e, t, i) {
    const s = this.fragmentTracker.getState(e);
    if (this.switchingTrack || s === yt.NOT_LOADED || s === yt.PARTIAL) {
      var r;
      if (!ot(e))
        this._loadInitSegment(e, t);
      else if ((r = t.details) != null && r.live && !this.initPTS[e.cc]) {
        this.log(`Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ${this.trackId}`), this.state = q.WAITING_INIT_PTS;
        const a = this.mainDetails;
        a && a.fragmentStart !== t.details.fragmentStart && zo(t.details, a);
      } else
        super.loadFragment(e, t, i);
    } else
      this.clearTrackerIfNeeded(e);
  }
  flushAudioIfNeeded(e) {
    if (this.media && this.bufferedTrack) {
      const {
        name: t,
        lang: i,
        assocLang: s,
        characteristics: r,
        audioCodec: a,
        channels: o
      } = this.bufferedTrack;
      br({
        name: t,
        lang: i,
        assocLang: s,
        characteristics: r,
        audioCodec: a,
        channels: o
      }, e, dr) || (Bo(e.url, this.hls) ? (this.log("Switching audio track : flushing all audio"), super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"), this.bufferedTrack = null) : this.bufferedTrack = e);
    }
  }
  completeAudioSwitch(e) {
    const {
      hls: t
    } = this;
    this.flushAudioIfNeeded(e), this.bufferedTrack = e, this.switchingTrack = null, t.trigger(x.AUDIO_TRACK_SWITCHED, Me({}, e));
  }
}
class qu extends Fi {
  constructor(e, t) {
    super(t, e.logger), this.hls = void 0, this.canLoad = !1, this.timer = -1, this.hls = e;
  }
  destroy() {
    this.clearTimer(), this.hls = this.log = this.warn = null;
  }
  clearTimer() {
    this.timer !== -1 && (self.clearTimeout(this.timer), this.timer = -1);
  }
  startLoad() {
    this.canLoad = !0, this.loadPlaylist();
  }
  stopLoad() {
    this.canLoad = !1, this.clearTimer();
  }
  switchParams(e, t, i) {
    const s = t?.renditionReports;
    if (s) {
      let r = -1;
      for (let a = 0; a < s.length; a++) {
        const o = s[a];
        let l;
        try {
          l = new self.URL(o.URI, t.url).href;
        } catch (c) {
          this.warn(`Could not construct new URL for Rendition Report: ${c}`), l = o.URI || "";
        }
        if (l === e) {
          r = a;
          break;
        } else l === e.substring(0, l.length) && (r = a);
      }
      if (r !== -1) {
        const a = s[r], o = parseInt(a["LAST-MSN"]) || t.lastPartSn;
        let l = parseInt(a["LAST-PART"]) || t.lastPartIndex;
        if (this.hls.config.lowLatencyMode) {
          const u = Math.min(t.age - t.partTarget, t.targetduration);
          l >= 0 && u > t.partTarget && (l += 1);
        }
        const c = i && Zd(i);
        return new Jd(o, l >= 0 ? l : void 0, c);
      }
    }
  }
  loadPlaylist(e) {
    this.clearTimer();
  }
  loadingPlaylist(e, t) {
    this.clearTimer();
  }
  shouldLoadPlaylist(e) {
    return this.canLoad && !!e && !!e.url && (!e.details || e.details.live);
  }
  getUrlWithDirectives(e, t) {
    if (t)
      try {
        return t.addDirectives(e);
      } catch (i) {
        this.warn(`Could not construct new URL with HLS Delivery Directives: ${i}`);
      }
    return e;
  }
  playlistLoaded(e, t, i) {
    const {
      details: s,
      stats: r
    } = t, a = self.performance.now(), o = r.loading.first ? Math.max(0, a - r.loading.first) : 0;
    s.advancedDateTime = Date.now() - o;
    const l = this.hls.config.timelineOffset;
    if (l !== s.appliedTimelineOffset) {
      const u = Math.max(l || 0, 0);
      s.appliedTimelineOffset = u, s.fragments.forEach((d) => {
        d.setStart(d.playlistOffset + u);
      });
    }
    if (s.live || i != null && i.live) {
      const u = "levelInfo" in t ? t.levelInfo : t.track;
      if (s.reloaded(i), i && s.fragments.length > 0) {
        LE(i, s, this);
        const y = s.playlistParsingError;
        if (y) {
          this.warn(y);
          const E = this.hls;
          if (!E.config.ignorePlaylistParsingErrors) {
            var c;
            const {
              networkDetails: T
            } = t;
            E.trigger(x.ERROR, {
              type: se.NETWORK_ERROR,
              details: H.LEVEL_PARSING_ERROR,
              fatal: !1,
              url: s.url,
              error: y,
              reason: y.message,
              level: t.level || void 0,
              parent: (c = s.fragments[0]) == null ? void 0 : c.type,
              networkDetails: T,
              stats: r
            });
            return;
          }
          s.playlistParsingError = null;
        }
      }
      s.requestScheduled === -1 && (s.requestScheduled = r.loading.start);
      const d = this.hls.mainForwardBufferInfo, f = d ? d.end - d.len : 0, p = (s.edge - f) * 1e3, h = Tg(s, p);
      if (s.requestScheduled + h < a ? s.requestScheduled = a : s.requestScheduled += h, this.log(`live playlist ${e} ${s.advanced ? "REFRESHED " + s.lastPartSn + "-" + s.lastPartIndex : s.updated ? "UPDATED" : "MISSED"}`), !this.canLoad || !s.live)
        return;
      let g, m, v;
      if (s.canBlockReload && s.endSN && s.advanced) {
        const y = this.hls.config.lowLatencyMode, E = s.lastPartSn, T = s.endSN, S = s.lastPartIndex, w = S !== -1, b = E === T;
        w ? b ? (m = T + 1, v = y ? 0 : S) : (m = E, v = y ? S + 1 : s.maxPartIndex) : m = T + 1;
        const L = s.age, A = L + s.ageHeader;
        let _ = Math.min(A - s.partTarget, s.targetduration * 1.5);
        if (_ > 0) {
          if (A > s.targetduration * 3)
            this.log(`Playlist last advanced ${L.toFixed(2)}s ago. Omitting segment and part directives.`), m = void 0, v = void 0;
          else if (i != null && i.tuneInGoal && A - s.partTarget > i.tuneInGoal)
            this.warn(`CDN Tune-in goal increased from: ${i.tuneInGoal} to: ${_} with playlist age: ${s.age}`), _ = 0;
          else {
            const R = Math.floor(_ / s.targetduration);
            if (m += R, v !== void 0) {
              const I = Math.round(_ % s.targetduration / s.partTarget);
              v += I;
            }
            this.log(`CDN Tune-in age: ${s.ageHeader}s last advanced ${L.toFixed(2)}s goal: ${_} skip sn ${R} to part ${v}`);
          }
          s.tuneInGoal = _;
        }
        if (g = this.getDeliveryDirectives(s, t.deliveryDirectives, m, v), y || !b) {
          s.requestScheduled = a, this.loadingPlaylist(u, g);
          return;
        }
      } else (s.canBlockReload || s.canSkipUntil) && (g = this.getDeliveryDirectives(s, t.deliveryDirectives, m, v));
      g && m !== void 0 && s.canBlockReload && (s.requestScheduled = r.loading.first + Math.max(h - o * 2, h / 2)), this.scheduleLoading(u, g, s);
    } else
      this.clearTimer();
  }
  scheduleLoading(e, t, i) {
    const s = i || e.details;
    if (!s) {
      this.loadingPlaylist(e, t);
      return;
    }
    const r = self.performance.now(), a = s.requestScheduled;
    if (r >= a) {
      this.loadingPlaylist(e, t);
      return;
    }
    const o = a - r;
    this.log(`reload live playlist ${e.name || e.bitrate + "bps"} in ${Math.round(o)} ms`), this.clearTimer(), this.timer = self.setTimeout(() => this.loadingPlaylist(e, t), o);
  }
  getDeliveryDirectives(e, t, i, s) {
    let r = Zd(e);
    return t != null && t.skip && e.deltaUpdateFailed && (i = t.msn, s = t.part, r = po.No), new Jd(i, s, r);
  }
  checkRetry(e) {
    const t = e.details, i = Uo(e), s = e.errorAction, {
      action: r,
      retryCount: a = 0,
      retryConfig: o
    } = s || {}, l = !!s && !!o && (r === It.RetryRequest || !s.resolved && r === It.SendAlternateToPenaltyBox);
    if (l) {
      var c;
      if (a >= o.maxNumRetry)
        return !1;
      if (i && (c = e.context) != null && c.deliveryDirectives)
        this.warn(`Retrying playlist loading ${a + 1}/${o.maxNumRetry} after "${t}" without delivery-directives`), this.loadPlaylist();
      else {
        const u = Ou(o, a);
        this.clearTimer(), this.timer = self.setTimeout(() => this.loadPlaylist(), u), this.warn(`Retrying playlist loading ${a + 1}/${o.maxNumRetry} after "${t}" in ${u}ms`);
      }
      e.levelRetry = !0, s.resolved = !0;
    }
    return l;
  }
}
function Kg(n, e) {
  if (n.length !== e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (!Ea(n[t].attrs, e[t].attrs))
      return !1;
  return !0;
}
function Ea(n, e, t) {
  const i = n["STABLE-RENDITION-ID"];
  return i && !t ? i === e["STABLE-RENDITION-ID"] : !(t || ["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED", "ASSOC-LANGUAGE"]).some((s) => n[s] !== e[s]);
}
function Hc(n, e) {
  return e.label.toLowerCase() === n.name.toLowerCase() && (!e.language || e.language.toLowerCase() === (n.lang || "").toLowerCase());
}
class FT extends qu {
  constructor(e) {
    super(e, "audio-track-controller"), this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.registerListeners();
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.MANIFEST_PARSED, this.onManifestParsed, this), e.on(x.LEVEL_LOADING, this.onLevelLoading, this), e.on(x.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(x.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(x.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.MANIFEST_PARSED, this.onManifestParsed, this), e.off(x.LEVEL_LOADING, this.onLevelLoading, this), e.off(x.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(x.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(x.ERROR, this.onError, this);
  }
  destroy() {
    this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, super.destroy();
  }
  onManifestLoading() {
    this.tracks = [], this.tracksInGroup = [], this.groupIds = null, this.currentTrack = null, this.trackId = -1, this.selectDefaultTrack = !0;
  }
  onManifestParsed(e, t) {
    this.tracks = t.audioTracks || [];
  }
  onAudioTrackLoaded(e, t) {
    const {
      id: i,
      groupId: s,
      details: r
    } = t, a = this.tracksInGroup[i];
    if (!a || a.groupId !== s) {
      this.warn(`Audio track with id:${i} and group:${s} not found in active group ${a?.groupId}`);
      return;
    }
    const o = a.details;
    a.details = t.details, this.log(`Audio track ${i} "${a.name}" lang:${a.lang} group:${s} loaded [${r.startSN}-${r.endSN}]`), i === this.trackId && this.playlistLoaded(i, t, o);
  }
  onLevelLoading(e, t) {
    this.switchLevel(t.level);
  }
  onLevelSwitching(e, t) {
    this.switchLevel(t.level);
  }
  switchLevel(e) {
    const t = this.hls.levels[e];
    if (!t)
      return;
    const i = t.audioGroups || null, s = this.groupIds;
    let r = this.currentTrack;
    if (!i || s?.length !== i?.length || i != null && i.some((o) => s?.indexOf(o) === -1)) {
      this.groupIds = i, this.trackId = -1, this.currentTrack = null;
      const o = this.tracks.filter((f) => !i || i.indexOf(f.groupId) !== -1);
      if (o.length)
        this.selectDefaultTrack && !o.some((f) => f.default) && (this.selectDefaultTrack = !1), o.forEach((f, p) => {
          f.id = p;
        });
      else if (!r && !this.tracksInGroup.length)
        return;
      this.tracksInGroup = o;
      const l = this.hls.config.audioPreference;
      if (!r && l) {
        const f = rs(l, o, dr);
        if (f > -1)
          r = o[f];
        else {
          const p = rs(l, this.tracks);
          r = this.tracks[p];
        }
      }
      let c = this.findTrackId(r);
      c === -1 && r && (c = this.findTrackId(null));
      const u = {
        audioTracks: o
      };
      this.log(`Updating audio tracks, ${o.length} track(s) found in group(s): ${i?.join(",")}`), this.hls.trigger(x.AUDIO_TRACKS_UPDATED, u);
      const d = this.trackId;
      if (c !== -1 && d === -1)
        this.setAudioTrack(c);
      else if (o.length && d === -1) {
        var a;
        const f = new Error(`No audio track selected for current audio group-ID(s): ${(a = this.groupIds) == null ? void 0 : a.join(",")} track count: ${o.length}`);
        this.warn(f.message), this.hls.trigger(x.ERROR, {
          type: se.MEDIA_ERROR,
          details: H.AUDIO_TRACK_LOAD_ERROR,
          fatal: !0,
          error: f
        });
      }
    }
  }
  onError(e, t) {
    t.fatal || !t.context || t.context.type === Ee.AUDIO_TRACK && t.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(t.context.groupId) !== -1) && this.checkRetry(t);
  }
  get allAudioTracks() {
    return this.tracks;
  }
  get audioTracks() {
    return this.tracksInGroup;
  }
  get audioTrack() {
    return this.trackId;
  }
  set audioTrack(e) {
    this.selectDefaultTrack = !1, this.setAudioTrack(e);
  }
  setAudioOption(e) {
    const t = this.hls;
    if (t.config.audioPreference = e, e) {
      const i = this.allAudioTracks;
      if (this.selectDefaultTrack = !1, i.length) {
        const s = this.currentTrack;
        if (s && br(e, s, dr))
          return s;
        const r = rs(e, this.tracksInGroup, dr);
        if (r > -1) {
          const a = this.tracksInGroup[r];
          return this.setAudioTrack(r), a;
        } else if (s) {
          let a = t.loadLevel;
          a === -1 && (a = t.firstAutoLevel);
          const o = qy(e, t.levels, i, a, dr);
          if (o === -1)
            return null;
          t.nextLoadLevel = o;
        }
        if (e.channels || e.audioCodec) {
          const a = rs(e, i);
          if (a > -1)
            return i[a];
        }
      }
    }
    return null;
  }
  setAudioTrack(e) {
    const t = this.tracksInGroup;
    if (e < 0 || e >= t.length) {
      this.warn(`Invalid audio track id: ${e}`);
      return;
    }
    this.selectDefaultTrack = !1;
    const i = this.currentTrack, s = t[e], r = s.details && !s.details.live;
    if (e === this.trackId && s === i && r || (this.log(`Switching to audio-track ${e} "${s.name}" lang:${s.lang} group:${s.groupId} channels:${s.channels}`), this.trackId = e, this.currentTrack = s, this.hls.trigger(x.AUDIO_TRACK_SWITCHING, Me({}, s)), r))
      return;
    const a = this.switchParams(s.url, i?.details, s.details);
    this.loadPlaylist(a);
  }
  findTrackId(e) {
    const t = this.tracksInGroup;
    for (let i = 0; i < t.length; i++) {
      const s = t[i];
      if (!(this.selectDefaultTrack && !s.default) && (!e || br(e, s, dr)))
        return i;
    }
    if (e) {
      const {
        name: i,
        lang: s,
        assocLang: r,
        characteristics: a,
        audioCodec: o,
        channels: l
      } = e;
      for (let c = 0; c < t.length; c++) {
        const u = t[c];
        if (br({
          name: i,
          lang: s,
          assocLang: r,
          characteristics: a,
          audioCodec: o,
          channels: l
        }, u, dr))
          return c;
      }
      for (let c = 0; c < t.length; c++) {
        const u = t[c];
        if (Ea(e.attrs, u.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"]))
          return c;
      }
      for (let c = 0; c < t.length; c++) {
        const u = t[c];
        if (Ea(e.attrs, u.attrs, ["LANGUAGE"]))
          return c;
      }
    }
    return -1;
  }
  loadPlaylist(e) {
    super.loadPlaylist();
    const t = this.currentTrack;
    this.shouldLoadPlaylist(t) && Bo(t.url, this.hls) && this.scheduleLoading(t, e);
  }
  loadingPlaylist(e, t) {
    super.loadingPlaylist(e, t);
    const i = e.id, s = e.groupId, r = this.getUrlWithDirectives(e.url, t), a = e.details, o = a?.age;
    this.log(`Loading audio-track ${i} "${e.name}" lang:${e.lang} group:${s}${t?.msn !== void 0 ? " at sn " + t.msn + " part " + t.part : ""}${o && a.live ? " age " + o.toFixed(1) + (a.type && " " + a.type || "") : ""} ${r}`), this.hls.trigger(x.AUDIO_TRACK_LOADING, {
      url: r,
      id: i,
      groupId: s,
      deliveryDirectives: t || null,
      track: e
    });
  }
}
class NT {
  constructor(e) {
    this.tracks = void 0, this.queues = {
      video: [],
      audio: [],
      audiovideo: []
    }, this.tracks = e;
  }
  destroy() {
    this.tracks = this.queues = null;
  }
  append(e, t, i) {
    if (this.queues === null || this.tracks === null)
      return;
    const s = this.queues[t];
    s.push(e), s.length === 1 && !i && this.executeNext(t);
  }
  appendBlocker(e) {
    return new Promise((t) => {
      const i = {
        label: "async-blocker",
        execute: t,
        onStart: () => {
        },
        onComplete: () => {
        },
        onError: () => {
        }
      };
      this.append(i, e);
    });
  }
  prependBlocker(e) {
    return new Promise((t) => {
      if (this.queues) {
        const i = {
          label: "async-blocker-prepend",
          execute: t,
          onStart: () => {
          },
          onComplete: () => {
          },
          onError: () => {
          }
        };
        this.queues[e].unshift(i);
      }
    });
  }
  removeBlockers() {
    this.queues !== null && [this.queues.video, this.queues.audio, this.queues.audiovideo].forEach((e) => {
      var t;
      const i = (t = e[0]) == null ? void 0 : t.label;
      (i === "async-blocker" || i === "async-blocker-prepend") && (e[0].execute(), e.splice(0, 1));
    });
  }
  unblockAudio(e) {
    if (this.queues === null)
      return;
    this.queues.audio[0] === e && this.shiftAndExecuteNext("audio");
  }
  executeNext(e) {
    if (this.queues === null || this.tracks === null)
      return;
    const t = this.queues[e];
    if (t.length) {
      const s = t[0];
      try {
        s.execute();
      } catch (r) {
        var i;
        if (s.onError(r), this.queues === null || this.tracks === null)
          return;
        const a = (i = this.tracks[e]) == null ? void 0 : i.buffer;
        a != null && a.updating || this.shiftAndExecuteNext(e);
      }
    }
  }
  shiftAndExecuteNext(e) {
    this.queues !== null && (this.queues[e].shift(), this.executeNext(e));
  }
  current(e) {
    var t;
    return ((t = this.queues) == null ? void 0 : t[e][0]) || null;
  }
  toString() {
    const {
      queues: e,
      tracks: t
    } = this;
    return e === null || t === null ? "<destroyed>" : `
${this.list("video")}
${this.list("audio")}
${this.list("audiovideo")}}`;
  }
  list(e) {
    var t, i;
    return (t = this.queues) != null && t[e] || (i = this.tracks) != null && i[e] ? `${e}: (${this.listSbInfo(e)}) ${this.listOps(e)}` : "";
  }
  listSbInfo(e) {
    var t;
    const i = (t = this.tracks) == null ? void 0 : t[e], s = i?.buffer;
    return s ? `SourceBuffer${s.updating ? " updating" : ""}${i.ended ? " ended" : ""}${i.ending ? " ending" : ""}` : "none";
  }
  listOps(e) {
    var t;
    return ((t = this.queues) == null ? void 0 : t[e].map((i) => i.label).join(", ")) || "";
  }
}
const Bf = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/, Yg = "HlsJsTrackRemovedError";
class $T extends Error {
  constructor(e) {
    super(e), this.name = Yg;
  }
}
class BT extends Fi {
  constructor(e, t) {
    super("buffer-controller", e.logger), this.hls = void 0, this.fragmentTracker = void 0, this.details = null, this._objectUrl = null, this.operationQueue = null, this.bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.lastMpegAudioChunk = null, this.blockedAudioAppend = null, this.lastVideoAppendEnd = 0, this.appendSource = void 0, this.transferData = void 0, this.overrides = void 0, this.appendErrors = {
      audio: 0,
      video: 0,
      audiovideo: 0
    }, this.tracks = {}, this.sourceBuffers = [[null, null], [null, null]], this._onEndStreaming = (i) => {
      var s;
      this.hls && ((s = this.mediaSource) == null ? void 0 : s.readyState) === "open" && this.hls.pauseBuffering();
    }, this._onStartStreaming = (i) => {
      this.hls && this.hls.resumeBuffering();
    }, this._onMediaSourceOpen = (i) => {
      const {
        media: s,
        mediaSource: r
      } = this;
      i && this.log("Media source opened"), !(!s || !r) && (r.removeEventListener("sourceopen", this._onMediaSourceOpen), s.removeEventListener("emptied", this._onMediaEmptied), this.updateDuration(), this.hls.trigger(x.MEDIA_ATTACHED, {
        media: s,
        mediaSource: r
      }), this.mediaSource !== null && this.checkPendingTracks());
    }, this._onMediaSourceClose = () => {
      this.log("Media source closed");
    }, this._onMediaSourceEnded = () => {
      this.log("Media source ended");
    }, this._onMediaEmptied = () => {
      const {
        mediaSrc: i,
        _objectUrl: s
      } = this;
      i !== s && this.error(`Media element src was set while attaching MediaSource (${s} > ${i})`);
    }, this.hls = e, this.fragmentTracker = t, this.appendSource = oy(Qs(e.config.preferManagedMediaSource)), this.initTracks(), this.registerListeners();
  }
  hasSourceTypes() {
    return Object.keys(this.tracks).length > 0;
  }
  destroy() {
    this.unregisterListeners(), this.details = null, this.lastMpegAudioChunk = this.blockedAudioAppend = null, this.transferData = this.overrides = void 0, this.operationQueue && (this.operationQueue.destroy(), this.operationQueue = null), this.hls = this.fragmentTracker = null, this._onMediaSourceOpen = this._onMediaSourceClose = null, this._onMediaSourceEnded = null, this._onStartStreaming = this._onEndStreaming = null;
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.MANIFEST_PARSED, this.onManifestParsed, this), e.on(x.BUFFER_RESET, this.onBufferReset, this), e.on(x.BUFFER_APPENDING, this.onBufferAppending, this), e.on(x.BUFFER_CODECS, this.onBufferCodecs, this), e.on(x.BUFFER_EOS, this.onBufferEos, this), e.on(x.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(x.FRAG_PARSED, this.onFragParsed, this), e.on(x.FRAG_CHANGED, this.onFragChanged, this), e.on(x.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.MANIFEST_PARSED, this.onManifestParsed, this), e.off(x.BUFFER_RESET, this.onBufferReset, this), e.off(x.BUFFER_APPENDING, this.onBufferAppending, this), e.off(x.BUFFER_CODECS, this.onBufferCodecs, this), e.off(x.BUFFER_EOS, this.onBufferEos, this), e.off(x.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(x.FRAG_PARSED, this.onFragParsed, this), e.off(x.FRAG_CHANGED, this.onFragChanged, this), e.off(x.ERROR, this.onError, this);
  }
  transferMedia() {
    const {
      media: e,
      mediaSource: t
    } = this;
    if (!e)
      return null;
    const i = {};
    if (this.operationQueue) {
      const r = this.isUpdating();
      r || this.operationQueue.removeBlockers();
      const a = this.isQueued();
      (r || a) && this.warn(`Transfering MediaSource with${a ? " operations in queue" : ""}${r ? " updating SourceBuffer(s)" : ""} ${this.operationQueue}`), this.operationQueue.destroy();
    }
    const s = this.transferData;
    return !this.sourceBufferCount && s && s.mediaSource === t ? Fe(i, s.tracks) : this.sourceBuffers.forEach((r) => {
      const [a] = r;
      a && (i[a] = Fe({}, this.tracks[a]), this.removeBuffer(a)), r[0] = r[1] = null;
    }), {
      media: e,
      mediaSource: t,
      tracks: i
    };
  }
  initTracks() {
    const e = {};
    this.sourceBuffers = [[null, null], [null, null]], this.tracks = e, this.resetQueue(), this.resetAppendErrors(), this.lastMpegAudioChunk = this.blockedAudioAppend = null, this.lastVideoAppendEnd = 0;
  }
  onManifestLoading() {
    this.bufferCodecEventsTotal = 0, this.details = null;
  }
  onManifestParsed(e, t) {
    var i;
    let s = 2;
    (t.audio && !t.video || !t.altAudio) && (s = 1), this.bufferCodecEventsTotal = s, this.log(`${s} bufferCodec event(s) expected.`), (i = this.transferData) != null && i.mediaSource && this.sourceBufferCount && s && this.bufferCreated();
  }
  onMediaAttaching(e, t) {
    const i = this.media = t.media;
    this.transferData = this.overrides = void 0;
    const s = Qs(this.appendSource);
    if (s) {
      const r = !!t.mediaSource;
      (r || t.overrides) && (this.transferData = t, this.overrides = t.overrides);
      const a = this.mediaSource = t.mediaSource || new s();
      if (this.assignMediaSource(a), r)
        this._objectUrl = i.src, this.attachTransferred();
      else {
        const o = this._objectUrl = self.URL.createObjectURL(a);
        if (this.appendSource)
          try {
            i.removeAttribute("src");
            const l = self.ManagedMediaSource;
            i.disableRemotePlayback = i.disableRemotePlayback || l && a instanceof l, Uf(i), UT(i, o), i.load();
          } catch {
            i.src = o;
          }
        else
          i.src = o;
      }
      i.addEventListener("emptied", this._onMediaEmptied);
    }
  }
  assignMediaSource(e) {
    var t, i;
    this.log(`${((t = this.transferData) == null ? void 0 : t.mediaSource) === e ? "transferred" : "created"} media source: ${(i = e.constructor) == null ? void 0 : i.name}`), e.addEventListener("sourceopen", this._onMediaSourceOpen), e.addEventListener("sourceended", this._onMediaSourceEnded), e.addEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (e.addEventListener("startstreaming", this._onStartStreaming), e.addEventListener("endstreaming", this._onEndStreaming));
  }
  attachTransferred() {
    const e = this.media, t = this.transferData;
    if (!t || !e)
      return;
    const i = this.tracks, s = t.tracks, r = s ? Object.keys(s) : null, a = r ? r.length : 0, o = () => {
      Promise.resolve().then(() => {
        this.media && this.mediaSourceOpenOrEnded && this._onMediaSourceOpen();
      });
    };
    if (s && r && a) {
      if (!this.tracksReady) {
        this.hls.config.startFragPrefetch = !0, this.log("attachTransferred: waiting for SourceBuffer track info");
        return;
      }
      if (this.log(`attachTransferred: (bufferCodecEventsTotal ${this.bufferCodecEventsTotal})
required tracks: ${Ge(i, (l, c) => l === "initSegment" ? void 0 : c)};
transfer tracks: ${Ge(s, (l, c) => l === "initSegment" ? void 0 : c)}}`), !Vp(s, i)) {
        t.mediaSource = null, t.tracks = void 0;
        const l = e.currentTime, c = this.details, u = Math.max(l, c?.fragments[0].start || 0);
        if (u - l > 1) {
          this.log(`attachTransferred: waiting for playback to reach new tracks start time ${l} -> ${u}`);
          return;
        }
        this.warn(`attachTransferred: resetting MediaSource for incompatible tracks ("${Object.keys(s)}"->"${Object.keys(i)}") start time: ${u} currentTime: ${l}`), this.onMediaDetaching(x.MEDIA_DETACHING, {}), this.onMediaAttaching(x.MEDIA_ATTACHING, t), e.currentTime = u;
        return;
      }
      this.transferData = void 0, r.forEach((l) => {
        const c = l, u = s[c];
        if (u) {
          const d = u.buffer;
          if (d) {
            const f = this.fragmentTracker, p = u.id;
            if (f.hasFragments(p) || f.hasParts(p)) {
              const m = de.getBuffered(d);
              f.detectEvictedFragments(c, m, p, null, !0);
            }
            const h = Nl(c), g = [c, d];
            this.sourceBuffers[h] = g, d.updating && this.operationQueue && this.operationQueue.prependBlocker(c), this.trackSourceBuffer(c, u);
          }
        }
      }), o(), this.bufferCreated();
    } else
      this.log("attachTransferred: MediaSource w/o SourceBuffers"), o();
  }
  get mediaSourceOpenOrEnded() {
    var e;
    const t = (e = this.mediaSource) == null ? void 0 : e.readyState;
    return t === "open" || t === "ended";
  }
  onMediaDetaching(e, t) {
    const i = !!t.transferMedia;
    this.transferData = this.overrides = void 0;
    const {
      media: s,
      mediaSource: r,
      _objectUrl: a
    } = this;
    if (r) {
      if (this.log(`media source ${i ? "transferring" : "detaching"}`), i)
        this.sourceBuffers.forEach(([o]) => {
          o && this.removeBuffer(o);
        }), this.resetQueue();
      else {
        if (this.mediaSourceOpenOrEnded) {
          const o = r.readyState === "open";
          try {
            const l = r.sourceBuffers;
            for (let c = l.length; c--; )
              o && l[c].abort(), r.removeSourceBuffer(l[c]);
            o && r.endOfStream();
          } catch (l) {
            this.warn(`onMediaDetaching: ${l.message} while calling endOfStream`);
          }
        }
        this.sourceBufferCount && this.onBufferReset();
      }
      r.removeEventListener("sourceopen", this._onMediaSourceOpen), r.removeEventListener("sourceended", this._onMediaSourceEnded), r.removeEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (r.removeEventListener("startstreaming", this._onStartStreaming), r.removeEventListener("endstreaming", this._onEndStreaming)), this.mediaSource = null, this._objectUrl = null;
    }
    s && (s.removeEventListener("emptied", this._onMediaEmptied), i || (a && self.URL.revokeObjectURL(a), this.mediaSrc === a ? (s.removeAttribute("src"), this.appendSource && Uf(s), s.load()) : this.warn("media|source.src was changed by a third party - skip cleanup")), this.media = null), this.hls.trigger(x.MEDIA_DETACHED, t);
  }
  onBufferReset() {
    this.sourceBuffers.forEach(([e]) => {
      e && this.resetBuffer(e);
    }), this.initTracks();
  }
  resetBuffer(e) {
    var t;
    const i = (t = this.tracks[e]) == null ? void 0 : t.buffer;
    if (this.removeBuffer(e), i)
      try {
        var s;
        (s = this.mediaSource) != null && s.sourceBuffers.length && this.mediaSource.removeSourceBuffer(i);
      } catch (r) {
        this.warn(`onBufferReset ${e}`, r);
      }
    delete this.tracks[e];
  }
  removeBuffer(e) {
    this.removeBufferListeners(e), this.sourceBuffers[Nl(e)] = [null, null];
    const t = this.tracks[e];
    t && (t.buffer = void 0);
  }
  resetQueue() {
    this.operationQueue && this.operationQueue.destroy(), this.operationQueue = new NT(this.tracks);
  }
  onBufferCodecs(e, t) {
    var i;
    const s = this.tracks, r = Object.keys(t);
    this.log(`BUFFER_CODECS: "${r}" (current SB count ${this.sourceBufferCount})`);
    const a = "audiovideo" in t && (s.audio || s.video) || s.audiovideo && ("audio" in t || "video" in t), o = !a && this.sourceBufferCount && this.media && r.some((l) => !s[l]);
    if (a || o) {
      this.warn(`Unsupported transition between "${Object.keys(s)}" and "${r}" SourceBuffers`);
      return;
    }
    r.forEach((l) => {
      var c, u;
      const d = t[l], {
        id: f,
        codec: p,
        levelCodec: h,
        container: g,
        metadata: m,
        supplemental: v
      } = d;
      let y = s[l];
      const E = (c = this.transferData) == null || (c = c.tracks) == null ? void 0 : c[l], T = E != null && E.buffer ? E : y, S = T?.pendingCodec || T?.codec, w = T?.levelCodec;
      y || (y = s[l] = {
        buffer: void 0,
        listeners: [],
        codec: p,
        supplemental: v,
        container: g,
        levelCodec: h,
        metadata: m,
        id: f
      });
      const b = ho(S, w), L = b?.replace(Bf, "$1");
      let A = ho(p, h);
      const _ = (u = A) == null ? void 0 : u.replace(Bf, "$1");
      A && b && L !== _ && (l.slice(0, 5) === "audio" && (A = No(A, this.appendSource)), this.log(`switching codec ${S} to ${A}`), A !== (y.pendingCodec || y.codec) && (y.pendingCodec = A), y.container = g, this.appendChangeType(l, g, A));
    }), (this.tracksReady || this.sourceBufferCount) && (t.tracks = this.sourceBufferTracks), !this.sourceBufferCount && (this.bufferCodecEventsTotal > 1 && !this.tracks.video && !t.video && ((i = t.audio) == null ? void 0 : i.id) === "main" && (this.log("Main audio-only"), this.bufferCodecEventsTotal = 1), this.mediaSourceOpenOrEnded && this.checkPendingTracks());
  }
  get sourceBufferTracks() {
    return Object.keys(this.tracks).reduce((e, t) => {
      const i = this.tracks[t];
      return e[t] = {
        id: i.id,
        container: i.container,
        codec: i.codec,
        levelCodec: i.levelCodec
      }, e;
    }, {});
  }
  appendChangeType(e, t, i) {
    const s = `${t};codecs=${i}`, r = {
      label: `change-type=${s}`,
      execute: () => {
        const a = this.tracks[e];
        if (a) {
          const o = a.buffer;
          o != null && o.changeType && (this.log(`changing ${e} sourceBuffer type to ${s}`), o.changeType(s), a.codec = i, a.container = t);
        }
        this.shiftAndExecuteNext(e);
      },
      onStart: () => {
      },
      onComplete: () => {
      },
      onError: (a) => {
        this.warn(`Failed to change ${e} SourceBuffer type`, a);
      }
    };
    this.append(r, e, this.isPending(this.tracks[e]));
  }
  blockAudio(e) {
    var t;
    const i = e.start, s = i + e.duration * 0.05;
    if (((t = this.fragmentTracker.getAppendedFrag(i, te.MAIN)) == null ? void 0 : t.gap) === !0)
      return;
    const a = {
      label: "block-audio",
      execute: () => {
        var o;
        const l = this.tracks.video;
        (this.lastVideoAppendEnd > s || l != null && l.buffer && de.isBuffered(l.buffer, s) || ((o = this.fragmentTracker.getAppendedFrag(s, te.MAIN)) == null ? void 0 : o.gap) === !0) && (this.blockedAudioAppend = null, this.shiftAndExecuteNext("audio"));
      },
      onStart: () => {
      },
      onComplete: () => {
      },
      onError: (o) => {
        this.warn("Error executing block-audio operation", o);
      }
    };
    this.blockedAudioAppend = {
      op: a,
      frag: e
    }, this.append(a, "audio", !0);
  }
  unblockAudio() {
    const {
      blockedAudioAppend: e,
      operationQueue: t
    } = this;
    e && t && (this.blockedAudioAppend = null, t.unblockAudio(e.op));
  }
  onBufferAppending(e, t) {
    const {
      tracks: i
    } = this, {
      data: s,
      type: r,
      parent: a,
      frag: o,
      part: l,
      chunkMeta: c,
      offset: u
    } = t, d = c.buffering[r], {
      sn: f,
      cc: p
    } = o, h = self.performance.now();
    d.start = h;
    const g = o.stats.buffering, m = l ? l.stats.buffering : null;
    g.start === 0 && (g.start = h), m && m.start === 0 && (m.start = h);
    const v = i.audio;
    let y = !1;
    r === "audio" && v?.container === "audio/mpeg" && (y = !this.lastMpegAudioChunk || c.id === 1 || this.lastMpegAudioChunk.sn !== c.sn, this.lastMpegAudioChunk = c);
    const E = i.video, T = E?.buffer;
    if (T && f !== "initSegment") {
      const b = l || o, L = this.blockedAudioAppend;
      if (r === "audio" && a !== "main" && !this.blockedAudioAppend && !(E.ending || E.ended)) {
        const _ = b.start + b.duration * 0.05, R = T.buffered, I = this.currentOp("video");
        !R.length && !I ? this.blockAudio(b) : !I && !de.isBuffered(T, _) && this.lastVideoAppendEnd < _ && this.blockAudio(b);
      } else if (r === "video") {
        const A = b.end;
        if (L) {
          const _ = L.frag.start;
          (A > _ || A < this.lastVideoAppendEnd || de.isBuffered(T, _)) && this.unblockAudio();
        }
        this.lastVideoAppendEnd = A;
      }
    }
    const S = (l || o).start, w = {
      label: `append-${r}`,
      execute: () => {
        var b;
        d.executeStart = self.performance.now();
        const L = (b = this.tracks[r]) == null ? void 0 : b.buffer;
        L && (y ? this.updateTimestampOffset(L, S, 0.1, r, f, p) : u !== void 0 && Z(u) && this.updateTimestampOffset(L, u, 1e-6, r, f, p)), this.appendExecutor(s, r);
      },
      onStart: () => {
      },
      onComplete: () => {
        const b = self.performance.now();
        d.executeEnd = d.end = b, g.first === 0 && (g.first = b), m && m.first === 0 && (m.first = b);
        const L = {};
        this.sourceBuffers.forEach(([A, _]) => {
          A && (L[A] = de.getBuffered(_));
        }), this.appendErrors[r] = 0, r === "audio" || r === "video" ? this.appendErrors.audiovideo = 0 : (this.appendErrors.audio = 0, this.appendErrors.video = 0), this.hls.trigger(x.BUFFER_APPENDED, {
          type: r,
          frag: o,
          part: l,
          chunkMeta: c,
          parent: o.type,
          timeRanges: L
        });
      },
      onError: (b) => {
        var L;
        const A = {
          type: se.MEDIA_ERROR,
          parent: o.type,
          details: H.BUFFER_APPEND_ERROR,
          sourceBufferName: r,
          frag: o,
          part: l,
          chunkMeta: c,
          error: b,
          err: b,
          fatal: !1
        }, _ = (L = this.media) == null ? void 0 : L.error;
        if (b.code === DOMException.QUOTA_EXCEEDED_ERR || b.name == "QuotaExceededError" || "quota" in b)
          A.details = H.BUFFER_FULL_ERROR;
        else if (b.code === DOMException.INVALID_STATE_ERR && this.mediaSourceOpenOrEnded && !_)
          A.errorAction = nn(!0);
        else if (b.name === Yg && this.sourceBufferCount === 0)
          A.errorAction = nn(!0);
        else {
          const R = ++this.appendErrors[r];
          this.warn(`Failed ${R}/${this.hls.config.appendErrorMaxRetry} times to append segment in "${r}" sourceBuffer (${_ || "no media error"})`), (R >= this.hls.config.appendErrorMaxRetry || _) && (A.fatal = !0);
        }
        this.hls.trigger(x.ERROR, A);
      }
    };
    this.log(`queuing "${r}" append sn: ${f}${l ? " p: " + l.index : ""} of ${o.type === te.MAIN ? "level" : "track"} ${o.level} cc: ${p}`), this.append(w, r, this.isPending(this.tracks[r]));
  }
  getFlushOp(e, t, i) {
    return this.log(`queuing "${e}" remove ${t}-${i}`), {
      label: "remove",
      execute: () => {
        this.removeExecutor(e, t, i);
      },
      onStart: () => {
      },
      onComplete: () => {
        this.hls.trigger(x.BUFFER_FLUSHED, {
          type: e
        });
      },
      onError: (s) => {
        this.warn(`Failed to remove ${t}-${i} from "${e}" SourceBuffer`, s);
      }
    };
  }
  onBufferFlushing(e, t) {
    const {
      type: i,
      startOffset: s,
      endOffset: r
    } = t;
    i ? this.append(this.getFlushOp(i, s, r), i) : this.sourceBuffers.forEach(([a]) => {
      a && this.append(this.getFlushOp(a, s, r), a);
    });
  }
  onFragParsed(e, t) {
    const {
      frag: i,
      part: s
    } = t, r = [], a = s ? s.elementaryStreams : i.elementaryStreams;
    a[Ue.AUDIOVIDEO] ? r.push("audiovideo") : (a[Ue.AUDIO] && r.push("audio"), a[Ue.VIDEO] && r.push("video"));
    const o = () => {
      const l = self.performance.now();
      i.stats.buffering.end = l, s && (s.stats.buffering.end = l);
      const c = s ? s.stats : i.stats;
      this.hls.trigger(x.FRAG_BUFFERED, {
        frag: i,
        part: s,
        stats: c,
        id: i.type
      });
    };
    r.length === 0 && this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${i.type} level: ${i.level} sn: ${i.sn}`), this.blockBuffers(o, r).catch((l) => {
      this.warn(`Fragment buffered callback ${l}`), this.stepOperationQueue(this.sourceBufferTypes);
    });
  }
  onFragChanged(e, t) {
    this.trimBuffers();
  }
  get bufferedToEnd() {
    return this.sourceBufferCount > 0 && !this.sourceBuffers.some(([e]) => {
      if (e) {
        const t = this.tracks[e];
        if (t)
          return !t.ended || t.ending;
      }
      return !1;
    });
  }
  // on BUFFER_EOS mark matching sourcebuffer(s) as "ending" and "ended" and queue endOfStream after remaining operations(s)
  // an undefined data.type will mark all buffers as EOS.
  onBufferEos(e, t) {
    var i;
    this.sourceBuffers.forEach(([a]) => {
      if (a) {
        const o = this.tracks[a];
        (!t.type || t.type === a) && (o.ending = !0, o.ended || (o.ended = !0, this.log(`${a} buffer reached EOS`)));
      }
    });
    const s = ((i = this.overrides) == null ? void 0 : i.endOfStream) !== !1;
    this.sourceBufferCount > 0 && !this.sourceBuffers.some(([a]) => {
      var o;
      return a && !((o = this.tracks[a]) != null && o.ended);
    }) ? s ? (this.log("Queueing EOS"), this.blockUntilOpen(() => {
      this.tracksEnded();
      const {
        mediaSource: a
      } = this;
      if (!a || a.readyState !== "open") {
        a && this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${a.readyState}`);
        return;
      }
      this.log("Calling mediaSource.endOfStream()"), a.endOfStream(), this.hls.trigger(x.BUFFERED_TO_END, void 0);
    })) : (this.tracksEnded(), this.hls.trigger(x.BUFFERED_TO_END, void 0)) : t.type === "video" && this.unblockAudio();
  }
  tracksEnded() {
    this.sourceBuffers.forEach(([e]) => {
      if (e !== null) {
        const t = this.tracks[e];
        t && (t.ending = !1);
      }
    });
  }
  onLevelUpdated(e, {
    details: t
  }) {
    t.fragments.length && (this.details = t, this.updateDuration());
  }
  updateDuration() {
    this.blockUntilOpen(() => {
      const e = this.getDurationAndRange();
      e && this.updateMediaSource(e);
    });
  }
  onError(e, t) {
    if (t.details === H.BUFFER_APPEND_ERROR && t.frag) {
      var i;
      const s = (i = t.errorAction) == null ? void 0 : i.nextAutoLevel;
      Z(s) && s !== t.frag.level && this.resetAppendErrors();
    }
  }
  resetAppendErrors() {
    this.appendErrors = {
      audio: 0,
      video: 0,
      audiovideo: 0
    };
  }
  trimBuffers() {
    const {
      hls: e,
      details: t,
      media: i
    } = this;
    if (!i || t === null || !this.sourceBufferCount)
      return;
    const s = e.config, r = i.currentTime, a = t.levelTargetDuration, o = t.live && s.liveBackBufferLength !== null ? s.liveBackBufferLength : s.backBufferLength;
    if (Z(o) && o >= 0) {
      const c = Math.max(o, a), u = Math.floor(r / a) * a - c;
      this.flushBackBuffer(r, a, u);
    }
    const l = s.frontBufferFlushThreshold;
    if (Z(l) && l > 0) {
      const c = Math.max(s.maxBufferLength, l), u = Math.max(c, a), d = Math.floor(r / a) * a + u;
      this.flushFrontBuffer(r, a, d);
    }
  }
  flushBackBuffer(e, t, i) {
    this.sourceBuffers.forEach(([s, r]) => {
      if (r) {
        const o = de.getBuffered(r);
        if (o.length > 0 && i > o.start(0)) {
          var a;
          this.hls.trigger(x.BACK_BUFFER_REACHED, {
            bufferEnd: i
          });
          const l = this.tracks[s];
          if ((a = this.details) != null && a.live)
            this.hls.trigger(x.LIVE_BACK_BUFFER_REACHED, {
              bufferEnd: i
            });
          else if (l != null && l.ended) {
            this.log(`Cannot flush ${s} back buffer while SourceBuffer is in ended state`);
            return;
          }
          this.hls.trigger(x.BUFFER_FLUSHING, {
            startOffset: 0,
            endOffset: i,
            type: s
          });
        }
      }
    });
  }
  flushFrontBuffer(e, t, i) {
    this.sourceBuffers.forEach(([s, r]) => {
      if (r) {
        const a = de.getBuffered(r), o = a.length;
        if (o < 2)
          return;
        const l = a.start(o - 1), c = a.end(o - 1);
        if (i > l || e >= l && e <= c)
          return;
        this.hls.trigger(x.BUFFER_FLUSHING, {
          startOffset: l,
          endOffset: 1 / 0,
          type: s
        });
      }
    });
  }
  /**
   * Update Media Source duration to current level duration or override to Infinity if configuration parameter
   * 'liveDurationInfinity` is set to `true`
   * More details: https://github.com/video-dev/hls.js/issues/355
   */
  getDurationAndRange() {
    var e;
    const {
      details: t,
      mediaSource: i
    } = this;
    if (!t || !this.media || i?.readyState !== "open")
      return null;
    const s = t.edge;
    if (t.live && this.hls.config.liveDurationInfinity) {
      if (t.fragments.length && i.setLiveSeekableRange) {
        const c = Math.max(0, t.fragmentStart), u = Math.max(c, s);
        return {
          duration: 1 / 0,
          start: c,
          end: u
        };
      }
      return {
        duration: 1 / 0
      };
    }
    const r = (e = this.overrides) == null ? void 0 : e.duration;
    if (r)
      return Z(r) ? {
        duration: r
      } : null;
    const a = this.media.duration, o = Z(i.duration) ? i.duration : 0;
    return s > o && s > a || !Z(a) ? {
      duration: s
    } : null;
  }
  updateMediaSource({
    duration: e,
    start: t,
    end: i
  }) {
    const s = this.mediaSource;
    !this.media || !s || s.readyState !== "open" || (s.duration !== e && (Z(e) && this.log(`Updating MediaSource duration to ${e.toFixed(3)}`), s.duration = e), t !== void 0 && i !== void 0 && (this.log(`MediaSource duration is set to ${s.duration}. Setting seekable range to ${t}-${i}.`), s.setLiveSeekableRange(t, i)));
  }
  get tracksReady() {
    const e = this.pendingTrackCount;
    return e > 0 && (e >= this.bufferCodecEventsTotal || this.isPending(this.tracks.audiovideo));
  }
  checkPendingTracks() {
    const {
      bufferCodecEventsTotal: e,
      pendingTrackCount: t,
      tracks: i
    } = this;
    if (this.log(`checkPendingTracks (pending: ${t} codec events expected: ${e}) ${Ge(i)}`), this.tracksReady) {
      var s;
      const r = (s = this.transferData) == null ? void 0 : s.tracks;
      r && Object.keys(r).length ? this.attachTransferred() : this.createSourceBuffers();
    }
  }
  bufferCreated() {
    if (this.sourceBufferCount) {
      const e = {};
      this.sourceBuffers.forEach(([t, i]) => {
        if (t) {
          const s = this.tracks[t];
          e[t] = {
            buffer: i,
            container: s.container,
            codec: s.codec,
            supplemental: s.supplemental,
            levelCodec: s.levelCodec,
            id: s.id,
            metadata: s.metadata
          };
        }
      }), this.hls.trigger(x.BUFFER_CREATED, {
        tracks: e
      }), this.log(`SourceBuffers created. Running queue: ${this.operationQueue}`), this.sourceBuffers.forEach(([t]) => {
        this.executeNext(t);
      });
    } else {
      const e = new Error("could not create source buffer for media codec(s)");
      this.hls.trigger(x.ERROR, {
        type: se.MEDIA_ERROR,
        details: H.BUFFER_INCOMPATIBLE_CODECS_ERROR,
        fatal: !0,
        error: e,
        reason: e.message
      });
    }
  }
  createSourceBuffers() {
    const {
      tracks: e,
      sourceBuffers: t,
      mediaSource: i
    } = this;
    if (!i)
      throw new Error("createSourceBuffers called when mediaSource was null");
    for (const r in e) {
      const a = r, o = e[a];
      if (this.isPending(o)) {
        const l = this.getTrackCodec(o, a), c = `${o.container};codecs=${l}`;
        o.codec = l, this.log(`creating sourceBuffer(${c})${this.currentOp(a) ? " Queued" : ""} ${Ge(o)}`);
        try {
          const u = i.addSourceBuffer(c), d = Nl(a), f = [a, u];
          t[d] = f, o.buffer = u;
        } catch (u) {
          var s;
          this.error(`error while trying to add sourceBuffer: ${u.message}`), this.shiftAndExecuteNext(a), (s = this.operationQueue) == null || s.removeBlockers(), delete this.tracks[a], this.hls.trigger(x.ERROR, {
            type: se.MEDIA_ERROR,
            details: H.BUFFER_ADD_CODEC_ERROR,
            fatal: !1,
            error: u,
            sourceBufferName: a,
            mimeType: c,
            parent: o.id
          });
          return;
        }
        this.trackSourceBuffer(a, o);
      }
    }
    this.bufferCreated();
  }
  getTrackCodec(e, t) {
    const i = e.supplemental;
    let s = e.codec;
    i && (t === "video" || t === "audiovideo") && ha(i, "video") && (s = Ry(s, i));
    const r = ho(s, e.levelCodec);
    return r ? t.slice(0, 5) === "audio" ? No(r, this.appendSource) : r : "";
  }
  trackSourceBuffer(e, t) {
    const i = t.buffer;
    if (!i)
      return;
    const s = this.getTrackCodec(t, e);
    this.tracks[e] = {
      buffer: i,
      codec: s,
      container: t.container,
      levelCodec: t.levelCodec,
      supplemental: t.supplemental,
      metadata: t.metadata,
      id: t.id,
      listeners: []
    }, this.removeBufferListeners(e), this.addBufferListener(e, "updatestart", this.onSBUpdateStart), this.addBufferListener(e, "updateend", this.onSBUpdateEnd), this.addBufferListener(e, "error", this.onSBUpdateError), this.appendSource && this.addBufferListener(e, "bufferedchange", (r, a) => {
      const o = a.removedRanges;
      o != null && o.length && this.hls.trigger(x.BUFFER_FLUSHED, {
        type: r
      });
    });
  }
  get mediaSrc() {
    var e, t;
    const i = ((e = this.media) == null || (t = e.querySelector) == null ? void 0 : t.call(e, "source")) || this.media;
    return i?.src;
  }
  onSBUpdateStart(e) {
    const t = this.currentOp(e);
    t && t.onStart();
  }
  onSBUpdateEnd(e) {
    var t;
    if (((t = this.mediaSource) == null ? void 0 : t.readyState) === "closed") {
      this.resetBuffer(e);
      return;
    }
    const i = this.currentOp(e);
    i && (i.onComplete(), this.shiftAndExecuteNext(e));
  }
  onSBUpdateError(e, t) {
    var i;
    const s = new Error(`${e} SourceBuffer error. MediaSource readyState: ${(i = this.mediaSource) == null ? void 0 : i.readyState}`);
    this.error(`${s}`, t), this.hls.trigger(x.ERROR, {
      type: se.MEDIA_ERROR,
      details: H.BUFFER_APPENDING_ERROR,
      sourceBufferName: e,
      error: s,
      fatal: !1
    });
    const r = this.currentOp(e);
    r && r.onError(s);
  }
  updateTimestampOffset(e, t, i, s, r, a) {
    const o = t - e.timestampOffset;
    Math.abs(o) >= i && (this.log(`Updating ${s} SourceBuffer timestampOffset to ${t} (sn: ${r} cc: ${a})`), e.timestampOffset = t);
  }
  // This method must result in an updateend event; if remove is not called, onSBUpdateEnd must be called manually
  removeExecutor(e, t, i) {
    const {
      media: s,
      mediaSource: r
    } = this, a = this.tracks[e], o = a?.buffer;
    if (!s || !r || !o) {
      this.warn(`Attempting to remove from the ${e} SourceBuffer, but it does not exist`), this.shiftAndExecuteNext(e);
      return;
    }
    const l = Z(s.duration) ? s.duration : 1 / 0, c = Z(r.duration) ? r.duration : 1 / 0, u = Math.max(0, t), d = Math.min(i, l, c);
    d > u && (!a.ending || a.ended) ? (a.ended = !1, this.log(`Removing [${u},${d}] from the ${e} SourceBuffer`), o.remove(u, d)) : this.shiftAndExecuteNext(e);
  }
  // This method must result in an updateend event; if append is not called, onSBUpdateEnd must be called manually
  appendExecutor(e, t) {
    const i = this.tracks[t], s = i?.buffer;
    if (!s)
      throw new $T(`Attempting to append to the ${t} SourceBuffer, but it does not exist`);
    i.ending = !1, i.ended = !1, s.appendBuffer(e);
  }
  blockUntilOpen(e) {
    if (this.isUpdating() || this.isQueued())
      this.blockBuffers(e).catch((t) => {
        this.warn(`SourceBuffer blocked callback ${t}`), this.stepOperationQueue(this.sourceBufferTypes);
      });
    else
      try {
        e();
      } catch (t) {
        this.warn(`Callback run without blocking ${this.operationQueue} ${t}`);
      }
  }
  isUpdating() {
    return this.sourceBuffers.some(([e, t]) => e && t.updating);
  }
  isQueued() {
    return this.sourceBuffers.some(([e]) => e && !!this.currentOp(e));
  }
  isPending(e) {
    return !!e && !e.buffer;
  }
  // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises
  // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue
  // upon completion, since we already do it here
  blockBuffers(e, t = this.sourceBufferTypes) {
    if (!t.length)
      return this.log("Blocking operation requested, but no SourceBuffers exist"), Promise.resolve().then(e);
    const {
      operationQueue: i
    } = this, s = t.map((a) => this.appendBlocker(a));
    return t.length > 1 && !!this.blockedAudioAppend && this.unblockAudio(), Promise.all(s).then((a) => {
      i === this.operationQueue && (e(), this.stepOperationQueue(this.sourceBufferTypes));
    });
  }
  stepOperationQueue(e) {
    e.forEach((t) => {
      var i;
      const s = (i = this.tracks[t]) == null ? void 0 : i.buffer;
      !s || s.updating || this.shiftAndExecuteNext(t);
    });
  }
  append(e, t, i) {
    this.operationQueue && this.operationQueue.append(e, t, i);
  }
  appendBlocker(e) {
    if (this.operationQueue)
      return this.operationQueue.appendBlocker(e);
  }
  currentOp(e) {
    return this.operationQueue ? this.operationQueue.current(e) : null;
  }
  executeNext(e) {
    e && this.operationQueue && this.operationQueue.executeNext(e);
  }
  shiftAndExecuteNext(e) {
    this.operationQueue && this.operationQueue.shiftAndExecuteNext(e);
  }
  get pendingTrackCount() {
    return Object.keys(this.tracks).reduce((e, t) => e + (this.isPending(this.tracks[t]) ? 1 : 0), 0);
  }
  get sourceBufferCount() {
    return this.sourceBuffers.reduce((e, [t]) => e + (t ? 1 : 0), 0);
  }
  get sourceBufferTypes() {
    return this.sourceBuffers.map(([e]) => e).filter((e) => !!e);
  }
  addBufferListener(e, t, i) {
    const s = this.tracks[e];
    if (!s)
      return;
    const r = s.buffer;
    if (!r)
      return;
    const a = i.bind(this, e);
    s.listeners.push({
      event: t,
      listener: a
    }), r.addEventListener(t, a);
  }
  removeBufferListeners(e) {
    const t = this.tracks[e];
    if (!t)
      return;
    const i = t.buffer;
    i && (t.listeners.forEach((s) => {
      i.removeEventListener(s.event, s.listener);
    }), t.listeners.length = 0);
  }
}
function Uf(n) {
  const e = n.querySelectorAll("source");
  [].slice.call(e).forEach((t) => {
    n.removeChild(t);
  });
}
function UT(n, e) {
  const t = self.document.createElement("source");
  t.type = "video/mp4", t.src = e, n.appendChild(t);
}
function Nl(n) {
  return n === "audio" ? 1 : 0;
}
class Xu {
  constructor(e) {
    this.hls = void 0, this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.clientRect = void 0, this.streamController = void 0, this.hls = e, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners();
  }
  setStreamController(e) {
    this.streamController = e;
  }
  destroy() {
    this.hls && this.unregisterListener(), this.timer && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null;
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.on(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(x.MANIFEST_PARSED, this.onManifestParsed, this), e.on(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(x.BUFFER_CODECS, this.onBufferCodecs, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  unregisterListener() {
    const {
      hls: e
    } = this;
    e.off(x.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.off(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(x.MANIFEST_PARSED, this.onManifestParsed, this), e.off(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(x.BUFFER_CODECS, this.onBufferCodecs, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  onFpsDropLevelCapping(e, t) {
    const i = this.hls.levels[t.droppedLevel];
    this.isLevelAllowed(i) && this.restrictedLevels.push({
      bitrate: i.bitrate,
      height: i.height,
      width: i.width
    });
  }
  onMediaAttaching(e, t) {
    this.media = t.media instanceof HTMLVideoElement ? t.media : null, this.clientRect = null, this.timer && this.hls.levels.length && this.detectPlayerSize();
  }
  onManifestParsed(e, t) {
    const i = this.hls;
    this.restrictedLevels = [], this.firstLevel = t.firstLevel, i.config.capLevelToPlayerSize && t.video && this.startCapping();
  }
  onLevelsUpdated(e, t) {
    this.timer && Z(this.autoLevelCapping) && this.detectPlayerSize();
  }
  // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted
  // to the first level
  onBufferCodecs(e, t) {
    this.hls.config.capLevelToPlayerSize && t.video && this.startCapping();
  }
  onMediaDetaching() {
    this.stopCapping(), this.media = null;
  }
  detectPlayerSize() {
    if (this.media) {
      if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {
        this.clientRect = null;
        return;
      }
      const e = this.hls.levels;
      if (e.length) {
        const t = this.hls, i = this.getMaxLevel(e.length - 1);
        i !== this.autoLevelCapping && t.logger.log(`Setting autoLevelCapping to ${i}: ${e[i].height}p@${e[i].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`), t.autoLevelCapping = i, t.autoLevelEnabled && t.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = t.autoLevelCapping;
      }
    }
  }
  /*
   * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
   */
  getMaxLevel(e) {
    const t = this.hls.levels;
    if (!t.length)
      return -1;
    const i = t.filter((s, r) => this.isLevelAllowed(s) && r <= e);
    return this.clientRect = null, Xu.getMaxLevelByMediaSize(i, this.mediaWidth, this.mediaHeight);
  }
  startCapping() {
    this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize());
  }
  stopCapping() {
    this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0);
  }
  getDimensions() {
    if (this.clientRect)
      return this.clientRect;
    const e = this.media, t = {
      width: 0,
      height: 0
    };
    if (e) {
      const i = e.getBoundingClientRect();
      t.width = i.width, t.height = i.height, !t.width && !t.height && (t.width = i.right - i.left || e.width || 0, t.height = i.bottom - i.top || e.height || 0);
    }
    return this.clientRect = t, t;
  }
  get mediaWidth() {
    return this.getDimensions().width * this.contentScaleFactor;
  }
  get mediaHeight() {
    return this.getDimensions().height * this.contentScaleFactor;
  }
  get contentScaleFactor() {
    let e = 1;
    if (!this.hls.config.ignoreDevicePixelRatio)
      try {
        e = self.devicePixelRatio;
      } catch {
      }
    return Math.min(e, this.hls.config.maxDevicePixelRatio);
  }
  isLevelAllowed(e) {
    return !this.restrictedLevels.some((i) => e.bitrate === i.bitrate && e.width === i.width && e.height === i.height);
  }
  static getMaxLevelByMediaSize(e, t, i) {
    if (!(e != null && e.length))
      return -1;
    const s = (o, l) => l ? o.width !== l.width || o.height !== l.height : !0;
    let r = e.length - 1;
    const a = Math.max(t, i);
    for (let o = 0; o < e.length; o += 1) {
      const l = e[o];
      if ((l.width >= a || l.height >= a) && s(l, e[o + 1])) {
        r = o;
        break;
      }
    }
    return r;
  }
}
const GT = {
  /**
   * text file, such as a manifest or playlist
   */
  MANIFEST: "m",
  /**
   * audio only
   */
  AUDIO: "a",
  /**
   * video only
   */
  VIDEO: "v",
  /**
   * muxed audio and video
   */
  MUXED: "av",
  /**
   * init segment
   */
  INIT: "i",
  /**
   * caption or subtitle
   */
  CAPTION: "c",
  /**
   * ISOBMFF timed text track
   */
  TIMED_TEXT: "tt",
  /**
   * cryptographic key, license or certificate.
   */
  KEY: "k",
  /**
   * other
   */
  OTHER: "o"
}, Jt = GT, HT = {
  /**
   * HTTP Live Streaming (HLS)
   */
  HLS: "h"
}, VT = HT;
class cs {
  constructor(e, t) {
    Array.isArray(e) && (e = e.map((i) => i instanceof cs ? i : new cs(i))), this.value = e, this.params = t;
  }
}
const zT = "Dict";
function WT(n) {
  return Array.isArray(n) ? JSON.stringify(n) : n instanceof Map ? "Map{}" : n instanceof Set ? "Set{}" : typeof n == "object" ? JSON.stringify(n) : String(n);
}
function KT(n, e, t, i) {
  return new Error(`failed to ${n} "${WT(e)}" as ${t}`, {
    cause: i
  });
}
function us(n, e, t) {
  return KT("serialize", n, e, t);
}
class qg {
  constructor(e) {
    this.description = e;
  }
}
const Gf = "Bare Item", YT = "Boolean";
function qT(n) {
  if (typeof n != "boolean")
    throw us(n, YT);
  return n ? "?1" : "?0";
}
function XT(n) {
  return btoa(String.fromCharCode(...n));
}
const jT = "Byte Sequence";
function QT(n) {
  if (ArrayBuffer.isView(n) === !1)
    throw us(n, jT);
  return `:${XT(n)}:`;
}
const ZT = "Integer";
function JT(n) {
  return n < -999999999999999 || 999999999999999 < n;
}
function Xg(n) {
  if (JT(n))
    throw us(n, ZT);
  return n.toString();
}
function eS(n) {
  return `@${Xg(n.getTime() / 1e3)}`;
}
function jg(n, e) {
  if (n < 0)
    return -jg(-n, e);
  const t = Math.pow(10, e);
  if (Math.abs(n * t % 1 - 0.5) < Number.EPSILON) {
    const s = Math.floor(n * t);
    return (s % 2 === 0 ? s : s + 1) / t;
  } else
    return Math.round(n * t) / t;
}
const tS = "Decimal";
function iS(n) {
  const e = jg(n, 3);
  if (Math.floor(Math.abs(e)).toString().length > 12)
    throw us(n, tS);
  const t = e.toString();
  return t.includes(".") ? t : `${t}.0`;
}
const sS = "String", rS = /[\x00-\x1f\x7f]+/;
function nS(n) {
  if (rS.test(n))
    throw us(n, sS);
  return `"${n.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
}
function aS(n) {
  return n.description || n.toString().slice(7, -1);
}
const oS = "Token";
function Hf(n) {
  const e = aS(n);
  if (/^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(e) === !1)
    throw us(e, oS);
  return e;
}
function Vc(n) {
  switch (typeof n) {
    case "number":
      if (!Z(n))
        throw us(n, Gf);
      return Number.isInteger(n) ? Xg(n) : iS(n);
    case "string":
      return nS(n);
    case "symbol":
      return Hf(n);
    case "boolean":
      return qT(n);
    case "object":
      if (n instanceof Date)
        return eS(n);
      if (n instanceof Uint8Array)
        return QT(n);
      if (n instanceof qg)
        return Hf(n);
    default:
      throw us(n, Gf);
  }
}
const lS = "Key";
function zc(n) {
  if (/^[a-z*][a-z0-9\-_.*]*$/.test(n) === !1)
    throw us(n, lS);
  return n;
}
function ju(n) {
  return n == null ? "" : Object.entries(n).map(([e, t]) => t === !0 ? `;${zc(e)}` : `;${zc(e)}=${Vc(t)}`).join("");
}
function Qg(n) {
  return n instanceof cs ? `${Vc(n.value)}${ju(n.params)}` : Vc(n);
}
function cS(n) {
  return `(${n.value.map(Qg).join(" ")})${ju(n.params)}`;
}
function uS(n, e = {
  whitespace: !0
}) {
  if (typeof n != "object" || n == null)
    throw us(n, zT);
  const t = n instanceof Map ? n.entries() : Object.entries(n), i = e?.whitespace ? " " : "";
  return Array.from(t).map(([s, r]) => {
    r instanceof cs || (r = new cs(r));
    let a = zc(s);
    return r.value === !0 ? a += ju(r.params) : (a += "=", Array.isArray(r.value) ? a += cS(r) : a += Qg(r)), a;
  }).join(`,${i}`);
}
function Zg(n, e) {
  return uS(n, e);
}
const Xi = "CMCD-Object", tt = "CMCD-Request", ar = "CMCD-Session", Cs = "CMCD-Status", dS = {
  // Object
  br: Xi,
  ab: Xi,
  d: Xi,
  ot: Xi,
  tb: Xi,
  tpb: Xi,
  lb: Xi,
  tab: Xi,
  lab: Xi,
  url: Xi,
  // Request
  pb: tt,
  bl: tt,
  tbl: tt,
  dl: tt,
  ltc: tt,
  mtp: tt,
  nor: tt,
  nrr: tt,
  rc: tt,
  sn: tt,
  sta: tt,
  su: tt,
  ttfb: tt,
  ttfbb: tt,
  ttlb: tt,
  cmsdd: tt,
  cmsds: tt,
  smrt: tt,
  df: tt,
  cs: tt,
  // TODO: Which header to put the `ts` field is not defined yet.
  ts: tt,
  // Session
  cid: ar,
  pr: ar,
  sf: ar,
  sid: ar,
  st: ar,
  v: ar,
  msd: ar,
  // Status
  bs: Cs,
  bsd: Cs,
  cdn: Cs,
  rtp: Cs,
  bg: Cs,
  pt: Cs,
  ec: Cs,
  e: Cs
}, fS = {
  /**
   * keys whose values vary with each request.
   */
  REQUEST: tt
};
function hS(n) {
  return Object.keys(n).reduce((e, t) => {
    var i;
    return (i = n[t]) === null || i === void 0 || i.forEach((s) => e[s] = t), e;
  }, {});
}
function pS(n, e) {
  const t = {};
  if (!n)
    return t;
  const i = Object.keys(n), s = e ? hS(e) : {};
  return i.reduce((r, a) => {
    var o;
    const l = dS[a] || s[a] || fS.REQUEST, c = (o = r[l]) !== null && o !== void 0 ? o : r[l] = {};
    return c[a] = n[a], r;
  }, t);
}
function gS(n) {
  return ["ot", "sf", "st", "e", "sta"].includes(n);
}
function mS(n) {
  return typeof n == "number" ? Z(n) : n != null && n !== "" && n !== !1;
}
const Jg = "event";
function vS(n, e) {
  const t = new URL(n), i = new URL(e);
  if (t.origin !== i.origin)
    return n;
  const s = t.pathname.split("/").slice(1), r = i.pathname.split("/").slice(1, -1);
  for (; s[0] === r[0]; )
    s.shift(), r.shift();
  for (; r.length; )
    r.shift(), s.unshift("..");
  return s.join("/") + t.search + t.hash;
}
const yo = (n) => Math.round(n), Wc = (n, e) => Array.isArray(n) ? n.map((t) => Wc(t, e)) : n instanceof cs && typeof n.value == "string" ? new cs(Wc(n.value, e), n.params) : (e.baseUrl && (n = vS(n, e.baseUrl)), e.version === 1 ? encodeURIComponent(n) : n), qa = (n) => yo(n / 100) * 100, yS = (n, e) => {
  let t = n;
  return e.version >= 2 && (n instanceof cs && typeof n.value == "string" ? t = new cs([n]) : typeof n == "string" && (t = [n])), Wc(t, e);
}, ES = {
  /**
   * Bitrate (kbps) rounded integer
   */
  br: yo,
  /**
   * Duration (milliseconds) rounded integer
   */
  d: yo,
  /**
   * Buffer Length (milliseconds) rounded nearest 100ms
   */
  bl: qa,
  /**
   * Deadline (milliseconds) rounded nearest 100ms
   */
  dl: qa,
  /**
   * Measured Throughput (kbps) rounded nearest 100kbps
   */
  mtp: qa,
  /**
   * Next Object Request URL encoded
   */
  nor: yS,
  /**
   * Requested maximum throughput (kbps) rounded nearest 100kbps
   */
  rtp: qa,
  /**
   * Top Bitrate (kbps) rounded integer
   */
  tb: yo
}, em = "request", tm = "response", Qu = ["ab", "bg", "bl", "br", "bs", "bsd", "cdn", "cid", "cs", "df", "ec", "lab", "lb", "ltc", "msd", "mtp", "pb", "pr", "pt", "sf", "sid", "sn", "st", "sta", "tab", "tb", "tbl", "tpb", "ts", "v"], TS = ["e"], SS = /^[a-zA-Z0-9-.]+-[a-zA-Z0-9-.]+$/;
function rl(n) {
  return SS.test(n);
}
function xS(n) {
  return Qu.includes(n) || TS.includes(n) || rl(n);
}
const im = ["d", "dl", "nor", "ot", "rtp", "su"];
function bS(n) {
  return Qu.includes(n) || im.includes(n) || rl(n);
}
const _S = ["cmsdd", "cmsds", "rc", "smrt", "ttfb", "ttfbb", "ttlb", "url"];
function AS(n) {
  return Qu.includes(n) || im.includes(n) || _S.includes(n) || rl(n);
}
const wS = ["bl", "br", "bs", "cid", "d", "dl", "mtp", "nor", "nrr", "ot", "pr", "rtp", "sf", "sid", "st", "su", "tb", "v"];
function LS(n) {
  return wS.includes(n) || rl(n);
}
const IS = {
  [tm]: AS,
  [Jg]: xS,
  [em]: bS
};
function sm(n, e = {}) {
  const t = {};
  if (n == null || typeof n != "object")
    return t;
  const i = e.version || n.v || 1, s = e.reportingMode || em, r = i === 1 ? LS : IS[s];
  let a = Object.keys(n).filter(r);
  const o = e.filter;
  typeof o == "function" && (a = a.filter(o));
  const l = s === tm || s === Jg;
  l && !a.includes("ts") && a.push("ts"), i > 1 && !a.includes("v") && a.push("v");
  const c = Fe({}, ES, e.formatters), u = {
    version: i,
    reportingMode: s,
    baseUrl: e.baseUrl
  };
  return a.sort().forEach((d) => {
    let f = n[d];
    const p = c[d];
    if (typeof p == "function" && (f = p(f, u)), d === "v") {
      if (i === 1)
        return;
      f = i;
    }
    d == "pr" && f === 1 || (l && d === "ts" && !Z(f) && (f = Date.now()), mS(f) && (gS(d) && typeof f == "string" && (f = new qg(f)), t[d] = f));
  }), t;
}
function RS(n, e = {}) {
  const t = {};
  if (!n)
    return t;
  const i = sm(n, e), s = pS(i, e?.customHeaderMap);
  return Object.entries(s).reduce((r, [a, o]) => {
    const l = Zg(o, {
      whitespace: !1
    });
    return l && (r[a] = l), r;
  }, t);
}
function CS(n, e, t) {
  return Fe(n, RS(e, t));
}
const PS = "CMCD";
function DS(n, e = {}) {
  return n ? Zg(sm(n, e), {
    whitespace: !1
  }) : "";
}
function kS(n, e = {}) {
  if (!n)
    return "";
  const t = DS(n, e);
  return encodeURIComponent(t);
}
function MS(n, e = {}) {
  if (!n)
    return "";
  const t = kS(n, e);
  return `${PS}=${t}`;
}
const Vf = /CMCD=[^&#]+/;
function OS(n, e, t) {
  const i = MS(e, t);
  if (!i)
    return n;
  if (Vf.test(n))
    return n.replace(Vf, i);
  const s = n.includes("?") ? "&" : "?";
  return `${n}${s}${i}`;
}
class FS {
  constructor(e) {
    this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.includeKeys = void 0, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = () => {
      this.initialized && (this.starved = !0), this.buffering = !0;
    }, this.onPlaying = () => {
      this.initialized || (this.initialized = !0), this.buffering = !1;
    }, this.applyPlaylistData = (s) => {
      try {
        this.apply(s, {
          ot: Jt.MANIFEST,
          su: !this.initialized
        });
      } catch (r) {
        this.hls.logger.warn("Could not generate manifest CMCD data.", r);
      }
    }, this.applyFragmentData = (s) => {
      try {
        const {
          frag: r,
          part: a
        } = s, o = this.hls.levels[r.level], l = this.getObjectType(r), c = {
          d: (a || r).duration * 1e3,
          ot: l
        };
        (l === Jt.VIDEO || l === Jt.AUDIO || l == Jt.MUXED) && (c.br = o.bitrate / 1e3, c.tb = this.getTopBandwidth(l) / 1e3, c.bl = this.getBufferLength(l));
        const u = a ? this.getNextPart(a) : this.getNextFrag(r);
        u != null && u.url && u.url !== r.url && (c.nor = u.url), this.apply(s, c);
      } catch (r) {
        this.hls.logger.warn("Could not generate segment CMCD data.", r);
      }
    }, this.hls = e;
    const t = this.config = e.config, {
      cmcd: i
    } = t;
    i != null && (t.pLoader = this.createPlaylistLoader(), t.fLoader = this.createFragmentLoader(), this.sid = i.sessionId || e.sessionId, this.cid = i.contentId, this.useHeaders = i.useHeaders === !0, this.includeKeys = i.includeKeys, this.registerListeners());
  }
  registerListeners() {
    const e = this.hls;
    e.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(x.MEDIA_DETACHED, this.onMediaDetached, this), e.on(x.BUFFER_CREATED, this.onBufferCreated, this);
  }
  unregisterListeners() {
    const e = this.hls;
    e.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(x.MEDIA_DETACHED, this.onMediaDetached, this), e.off(x.BUFFER_CREATED, this.onBufferCreated, this);
  }
  destroy() {
    this.unregisterListeners(), this.onMediaDetached(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null, this.onWaiting = this.onPlaying = this.media = null;
  }
  onMediaAttached(e, t) {
    this.media = t.media, this.media.addEventListener("waiting", this.onWaiting), this.media.addEventListener("playing", this.onPlaying);
  }
  onMediaDetached() {
    this.media && (this.media.removeEventListener("waiting", this.onWaiting), this.media.removeEventListener("playing", this.onPlaying), this.media = null);
  }
  onBufferCreated(e, t) {
    var i, s;
    this.audioBuffer = (i = t.tracks.audio) == null ? void 0 : i.buffer, this.videoBuffer = (s = t.tracks.video) == null ? void 0 : s.buffer;
  }
  /**
   * Create baseline CMCD data
   */
  createData() {
    var e;
    return {
      v: 1,
      sf: VT.HLS,
      sid: this.sid,
      cid: this.cid,
      pr: (e = this.media) == null ? void 0 : e.playbackRate,
      mtp: this.hls.bandwidthEstimate / 1e3
    };
  }
  /**
   * Apply CMCD data to a request.
   */
  apply(e, t = {}) {
    Fe(t, this.createData());
    const i = t.ot === Jt.INIT || t.ot === Jt.VIDEO || t.ot === Jt.MUXED;
    this.starved && i && (t.bs = !0, t.su = !0, this.starved = !1), t.su == null && (t.su = this.buffering);
    const {
      includeKeys: s
    } = this;
    s && (t = Object.keys(t).reduce((a, o) => (s.includes(o) && (a[o] = t[o]), a), {}));
    const r = {
      baseUrl: e.url
    };
    this.useHeaders ? (e.headers || (e.headers = {}), CS(e.headers, t, r)) : e.url = OS(e.url, t, r);
  }
  getNextFrag(e) {
    var t;
    const i = (t = this.hls.levels[e.level]) == null ? void 0 : t.details;
    if (i) {
      const s = e.sn - i.startSN;
      return i.fragments[s + 1];
    }
  }
  getNextPart(e) {
    var t;
    const {
      index: i,
      fragment: s
    } = e, r = (t = this.hls.levels[s.level]) == null || (t = t.details) == null ? void 0 : t.partList;
    if (r) {
      const {
        sn: a
      } = s;
      for (let o = r.length - 1; o >= 0; o--) {
        const l = r[o];
        if (l.index === i && l.fragment.sn === a)
          return r[o + 1];
      }
    }
  }
  /**
   * The CMCD object type.
   */
  getObjectType(e) {
    const {
      type: t
    } = e;
    if (t === "subtitle")
      return Jt.TIMED_TEXT;
    if (e.sn === "initSegment")
      return Jt.INIT;
    if (t === "audio")
      return Jt.AUDIO;
    if (t === "main")
      return this.hls.audioTracks.length ? Jt.VIDEO : Jt.MUXED;
  }
  /**
   * Get the highest bitrate.
   */
  getTopBandwidth(e) {
    let t = 0, i;
    const s = this.hls;
    if (e === Jt.AUDIO)
      i = s.audioTracks;
    else {
      const r = s.maxAutoLevel, a = r > -1 ? r + 1 : s.levels.length;
      i = s.levels.slice(0, a);
    }
    return i.forEach((r) => {
      r.bitrate > t && (t = r.bitrate);
    }), t > 0 ? t : NaN;
  }
  /**
   * Get the buffer length for a media type in milliseconds
   */
  getBufferLength(e) {
    const t = this.media, i = e === Jt.AUDIO ? this.audioBuffer : this.videoBuffer;
    return !i || !t ? NaN : de.bufferInfo(i, t.currentTime, this.config.maxBufferHole).len * 1e3;
  }
  /**
   * Create a playlist loader
   */
  createPlaylistLoader() {
    const {
      pLoader: e
    } = this.config, t = this.applyPlaylistData, i = e || this.config.loader;
    return class {
      constructor(r) {
        this.loader = void 0, this.loader = new i(r);
      }
      get stats() {
        return this.loader.stats;
      }
      get context() {
        return this.loader.context;
      }
      destroy() {
        this.loader.destroy();
      }
      abort() {
        this.loader.abort();
      }
      load(r, a, o) {
        t(r), this.loader.load(r, a, o);
      }
    };
  }
  /**
   * Create a playlist loader
   */
  createFragmentLoader() {
    const {
      fLoader: e
    } = this.config, t = this.applyFragmentData, i = e || this.config.loader;
    return class {
      constructor(r) {
        this.loader = void 0, this.loader = new i(r);
      }
      get stats() {
        return this.loader.stats;
      }
      get context() {
        return this.loader.context;
      }
      destroy() {
        this.loader.destroy();
      }
      abort() {
        this.loader.abort();
      }
      load(r, a, o) {
        t(r), this.loader.load(r, a, o);
      }
    };
  }
}
const NS = 3e5;
class $S extends Fi {
  constructor(e) {
    super("content-steering", e.logger), this.hls = void 0, this.loader = null, this.uri = null, this.pathwayId = ".", this._pathwayPriority = null, this.timeToLoad = 300, this.reloadTimer = -1, this.updated = 0, this.started = !1, this.enabled = !0, this.levels = null, this.audioTracks = null, this.subtitleTracks = null, this.penalizedPathways = {}, this.hls = e, this.registerListeners();
  }
  registerListeners() {
    const e = this.hls;
    e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(x.MANIFEST_PARSED, this.onManifestParsed, this), e.on(x.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const e = this.hls;
    e && (e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(x.MANIFEST_PARSED, this.onManifestParsed, this), e.off(x.ERROR, this.onError, this));
  }
  pathways() {
    return (this.levels || []).reduce((e, t) => (e.indexOf(t.pathwayId) === -1 && e.push(t.pathwayId), e), []);
  }
  get pathwayPriority() {
    return this._pathwayPriority;
  }
  set pathwayPriority(e) {
    this.updatePathwayPriority(e);
  }
  startLoad() {
    if (this.started = !0, this.clearTimeout(), this.enabled && this.uri) {
      if (this.updated) {
        const e = this.timeToLoad * 1e3 - (performance.now() - this.updated);
        if (e > 0) {
          this.scheduleRefresh(this.uri, e);
          return;
        }
      }
      this.loadSteeringManifest(this.uri);
    }
  }
  stopLoad() {
    this.started = !1, this.loader && (this.loader.destroy(), this.loader = null), this.clearTimeout();
  }
  clearTimeout() {
    this.reloadTimer !== -1 && (self.clearTimeout(this.reloadTimer), this.reloadTimer = -1);
  }
  destroy() {
    this.unregisterListeners(), this.stopLoad(), this.hls = null, this.levels = this.audioTracks = this.subtitleTracks = null;
  }
  removeLevel(e) {
    const t = this.levels;
    t && (this.levels = t.filter((i) => i !== e));
  }
  onManifestLoading() {
    this.stopLoad(), this.enabled = !0, this.timeToLoad = 300, this.updated = 0, this.uri = null, this.pathwayId = ".", this.levels = this.audioTracks = this.subtitleTracks = null;
  }
  onManifestLoaded(e, t) {
    const {
      contentSteering: i
    } = t;
    i !== null && (this.pathwayId = i.pathwayId, this.uri = i.uri, this.started && this.startLoad());
  }
  onManifestParsed(e, t) {
    this.audioTracks = t.audioTracks, this.subtitleTracks = t.subtitleTracks;
  }
  onError(e, t) {
    const {
      errorAction: i
    } = t;
    if (i?.action === It.SendAlternateToPenaltyBox && i.flags === ci.MoveAllAlternatesMatchingHost) {
      const s = this.levels;
      let r = this._pathwayPriority, a = this.pathwayId;
      if (t.context) {
        const {
          groupId: o,
          pathwayId: l,
          type: c
        } = t.context;
        o && s ? a = this.getPathwayForGroupId(o, c, a) : l && (a = l);
      }
      a in this.penalizedPathways || (this.penalizedPathways[a] = performance.now()), !r && s && (r = this.pathways()), r && r.length > 1 && (this.updatePathwayPriority(r), i.resolved = this.pathwayId !== a), t.details === H.BUFFER_APPEND_ERROR && !t.fatal ? i.resolved = !0 : i.resolved || this.warn(`Could not resolve ${t.details} ("${t.error.message}") with content-steering for Pathway: ${a} levels: ${s && s.length} priorities: ${Ge(r)} penalized: ${Ge(this.penalizedPathways)}`);
    }
  }
  filterParsedLevels(e) {
    this.levels = e;
    let t = this.getLevelsForPathway(this.pathwayId);
    if (t.length === 0) {
      const i = e[0].pathwayId;
      this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${i}"`), t = this.getLevelsForPathway(i), this.pathwayId = i;
    }
    return t.length !== e.length && this.log(`Found ${t.length}/${e.length} levels in Pathway "${this.pathwayId}"`), t;
  }
  getLevelsForPathway(e) {
    return this.levels === null ? [] : this.levels.filter((t) => e === t.pathwayId);
  }
  updatePathwayPriority(e) {
    this._pathwayPriority = e;
    let t;
    const i = this.penalizedPathways, s = performance.now();
    Object.keys(i).forEach((r) => {
      s - i[r] > NS && delete i[r];
    });
    for (let r = 0; r < e.length; r++) {
      const a = e[r];
      if (a in i)
        continue;
      if (a === this.pathwayId)
        return;
      const o = this.hls.nextLoadLevel, l = this.hls.levels[o];
      if (t = this.getLevelsForPathway(a), t.length > 0) {
        this.log(`Setting Pathway to "${a}"`), this.pathwayId = a, bg(t), this.hls.trigger(x.LEVELS_UPDATED, {
          levels: t
        });
        const c = this.hls.levels[o];
        l && c && this.levels && (c.attrs["STABLE-VARIANT-ID"] !== l.attrs["STABLE-VARIANT-ID"] && c.bitrate !== l.bitrate && this.log(`Unstable Pathways change from bitrate ${l.bitrate} to ${c.bitrate}`), this.hls.nextLoadLevel = o);
        break;
      }
    }
  }
  getPathwayForGroupId(e, t, i) {
    const s = this.getLevelsForPathway(i).concat(this.levels || []);
    for (let r = 0; r < s.length; r++)
      if (t === Ee.AUDIO_TRACK && s[r].hasAudioGroup(e) || t === Ee.SUBTITLE_TRACK && s[r].hasSubtitleGroup(e))
        return s[r].pathwayId;
    return i;
  }
  clonePathways(e) {
    const t = this.levels;
    if (!t)
      return;
    const i = {}, s = {};
    e.forEach((r) => {
      const {
        ID: a,
        "BASE-ID": o,
        "URI-REPLACEMENT": l
      } = r;
      if (t.some((u) => u.pathwayId === a))
        return;
      const c = this.getLevelsForPathway(o).map((u) => {
        const d = new je(u.attrs);
        d["PATHWAY-ID"] = a;
        const f = d.AUDIO && `${d.AUDIO}_clone_${a}`, p = d.SUBTITLES && `${d.SUBTITLES}_clone_${a}`;
        f && (i[d.AUDIO] = f, d.AUDIO = f), p && (s[d.SUBTITLES] = p, d.SUBTITLES = p);
        const h = rm(u.uri, d["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", l), g = new ga({
          attrs: d,
          audioCodec: u.audioCodec,
          bitrate: u.bitrate,
          height: u.height,
          name: u.name,
          url: h,
          videoCodec: u.videoCodec,
          width: u.width
        });
        if (u.audioGroups)
          for (let m = 1; m < u.audioGroups.length; m++)
            g.addGroupId("audio", `${u.audioGroups[m]}_clone_${a}`);
        if (u.subtitleGroups)
          for (let m = 1; m < u.subtitleGroups.length; m++)
            g.addGroupId("text", `${u.subtitleGroups[m]}_clone_${a}`);
        return g;
      });
      t.push(...c), zf(this.audioTracks, i, l, a), zf(this.subtitleTracks, s, l, a);
    });
  }
  loadSteeringManifest(e) {
    const t = this.hls.config, i = t.loader;
    this.loader && this.loader.destroy(), this.loader = new i(t);
    let s;
    try {
      s = new self.URL(e);
    } catch {
      this.enabled = !1, this.log(`Failed to parse Steering Manifest URI: ${e}`);
      return;
    }
    if (s.protocol !== "data:") {
      const u = (this.hls.bandwidthEstimate || t.abrEwmaDefaultEstimate) | 0;
      s.searchParams.set("_HLS_pathway", this.pathwayId), s.searchParams.set("_HLS_throughput", "" + u);
    }
    const r = {
      responseType: "json",
      url: s.href
    }, a = t.steeringManifestLoadPolicy.default, o = a.errorRetry || a.timeoutRetry || {}, l = {
      loadPolicy: a,
      timeout: a.maxLoadTimeMs,
      maxRetry: o.maxNumRetry || 0,
      retryDelay: o.retryDelayMs || 0,
      maxRetryDelay: o.maxRetryDelayMs || 0
    }, c = {
      onSuccess: (u, d, f, p) => {
        this.log(`Loaded steering manifest: "${s}"`);
        const h = u.data;
        if (h?.VERSION !== 1) {
          this.log(`Steering VERSION ${h.VERSION} not supported!`);
          return;
        }
        this.updated = performance.now(), this.timeToLoad = h.TTL;
        const {
          "RELOAD-URI": g,
          "PATHWAY-CLONES": m,
          "PATHWAY-PRIORITY": v
        } = h;
        if (g)
          try {
            this.uri = new self.URL(g, s).href;
          } catch {
            this.enabled = !1, this.log(`Failed to parse Steering Manifest RELOAD-URI: ${g}`);
            return;
          }
        this.scheduleRefresh(this.uri || f.url), m && this.clonePathways(m);
        const y = {
          steeringManifest: h,
          url: s.toString()
        };
        this.hls.trigger(x.STEERING_MANIFEST_LOADED, y), v && this.updatePathwayPriority(v);
      },
      onError: (u, d, f, p) => {
        if (this.log(`Error loading steering manifest: ${u.code} ${u.text} (${d.url})`), this.stopLoad(), u.code === 410) {
          this.enabled = !1, this.log(`Steering manifest ${d.url} no longer available`);
          return;
        }
        let h = this.timeToLoad * 1e3;
        if (u.code === 429) {
          const g = this.loader;
          if (typeof g?.getResponseHeader == "function") {
            const m = g.getResponseHeader("Retry-After");
            m && (h = parseFloat(m) * 1e3);
          }
          this.log(`Steering manifest ${d.url} rate limited`);
          return;
        }
        this.scheduleRefresh(this.uri || d.url, h);
      },
      onTimeout: (u, d, f) => {
        this.log(`Timeout loading steering manifest (${d.url})`), this.scheduleRefresh(this.uri || d.url);
      }
    };
    this.log(`Requesting steering manifest: ${s}`), this.loader.load(r, l, c);
  }
  scheduleRefresh(e, t = this.timeToLoad * 1e3) {
    this.clearTimeout(), this.reloadTimer = self.setTimeout(() => {
      var i;
      const s = (i = this.hls) == null ? void 0 : i.media;
      if (s && !s.ended) {
        this.loadSteeringManifest(e);
        return;
      }
      this.scheduleRefresh(e, this.timeToLoad * 1e3);
    }, t);
  }
}
function zf(n, e, t, i) {
  n && Object.keys(e).forEach((s) => {
    const r = n.filter((a) => a.groupId === s).map((a) => {
      const o = Fe({}, a);
      return o.details = void 0, o.attrs = new je(o.attrs), o.url = o.attrs.URI = rm(a.url, a.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", t), o.groupId = o.attrs["GROUP-ID"] = e[s], o.attrs["PATHWAY-ID"] = i, o;
    });
    n.push(...r);
  });
}
function rm(n, e, t, i) {
  const {
    HOST: s,
    PARAMS: r,
    [t]: a
  } = i;
  let o;
  e && (o = a?.[e], o && (n = o));
  const l = new self.URL(n);
  return s && !o && (l.host = s), r && Object.keys(r).sort().forEach((c) => {
    c && l.searchParams.set(c, r[c]);
  }), l.href;
}
class on extends Fi {
  constructor(e) {
    super("eme", e.logger), this.hls = void 0, this.config = void 0, this.media = null, this.mediaResolved = void 0, this.keyFormatPromise = null, this.keySystemAccessPromises = {}, this._requestLicenseFailureCount = 0, this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, this.mediaKeys = null, this.setMediaKeysQueue = on.CDMCleanupPromise ? [on.CDMCleanupPromise] : [], this.bannedKeyIds = {}, this.onMediaEncrypted = (t) => {
      const {
        initDataType: i,
        initData: s
      } = t, r = `"${t.type}" event: init data type: "${i}"`;
      if (this.debug(r), s !== null) {
        if (!this.keyFormatPromise) {
          let a = Object.keys(this.keySystemAccessPromises);
          a.length || (a = Nn(this.config));
          const o = a.map(Rl).filter((l) => !!l);
          this.keyFormatPromise = this.getKeyFormatPromise(o);
        }
        this.keyFormatPromise.then((a) => {
          const o = go(a);
          if (i !== "sinf" || o !== Ze.FAIRPLAY) {
            this.log(`Ignoring "${t.type}" event with init data type: "${i}" for selected key-system ${o}`);
            return;
          }
          let l;
          try {
            const p = gt(new Uint8Array(s)), h = Bu(JSON.parse(p).sinf), g = Zp(h);
            if (!g)
              throw new Error("'schm' box missing or not cbcs/cenc with schi > tenc");
            l = new Uint8Array(g.subarray(8, 24));
          } catch (p) {
            this.warn(`${r} Failed to parse sinf: ${p}`);
            return;
          }
          const c = Rt(l), {
            keyIdToKeySessionPromise: u,
            mediaKeySessions: d
          } = this;
          let f = u[c];
          for (let p = 0; p < d.length; p++) {
            const h = d[p], g = h.decryptdata;
            if (!g.keyId)
              continue;
            const m = Rt(g.keyId);
            if (Ho(l, g.keyId) || g.uri.replace(/-/g, "").indexOf(c) !== -1) {
              if (f = u[m], !f)
                continue;
              if (g.pssh)
                break;
              delete u[m], g.pssh = new Uint8Array(s), g.keyId = l, f = u[c] = f.then(() => this.generateRequestWithPreferredKeySession(h, i, s, "encrypted-event-key-match")), f.catch((v) => this.handleError(v));
              break;
            }
          }
          f || this.handleError(new Error(`Key ID ${c} not encountered in playlist. Key-system sessions ${d.length}.`));
        }).catch((a) => this.handleError(a));
      }
    }, this.onWaitingForKey = (t) => {
      this.log(`"${t.type}" event`);
    }, this.hls = e, this.config = e.config, this.registerListeners();
  }
  destroy() {
    this.onDestroying(), this.onMediaDetached();
    const e = this.config;
    e.requestMediaKeySystemAccessFunc = null, e.licenseXhrSetup = e.licenseResponseCallback = void 0, e.drmSystems = e.drmSystemOptions = {}, this.hls = this.config = this.keyIdToKeySessionPromise = null, this.onMediaEncrypted = this.onWaitingForKey = null;
  }
  registerListeners() {
    this.hls.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(x.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(x.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(x.MANIFEST_LOADED, this.onManifestLoaded, this), this.hls.on(x.DESTROYING, this.onDestroying, this);
  }
  unregisterListeners() {
    this.hls.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(x.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(x.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(x.MANIFEST_LOADED, this.onManifestLoaded, this), this.hls.off(x.DESTROYING, this.onDestroying, this);
  }
  getLicenseServerUrl(e) {
    const {
      drmSystems: t,
      widevineLicenseUrl: i
    } = this.config, s = t?.[e];
    if (s)
      return s.licenseUrl;
    if (e === Ze.WIDEVINE && i)
      return i;
  }
  getLicenseServerUrlOrThrow(e) {
    const t = this.getLicenseServerUrl(e);
    if (t === void 0)
      throw new Error(`no license server URL configured for key-system "${e}"`);
    return t;
  }
  getServerCertificateUrl(e) {
    const {
      drmSystems: t
    } = this.config, i = t?.[e];
    if (i)
      return i.serverCertificateUrl;
    this.log(`No Server Certificate in config.drmSystems["${e}"]`);
  }
  attemptKeySystemAccess(e) {
    const t = this.hls.levels, i = (a, o, l) => !!a && l.indexOf(a) === o, s = t.map((a) => a.audioCodec).filter(i), r = t.map((a) => a.videoCodec).filter(i);
    return s.length + r.length === 0 && r.push("avc1.42e01e"), new Promise((a, o) => {
      const l = (c) => {
        const u = c.shift();
        this.getMediaKeysPromise(u, s, r).then((d) => a({
          keySystem: u,
          mediaKeys: d
        })).catch((d) => {
          c.length ? l(c) : d instanceof li ? o(d) : o(new li({
            type: se.KEY_SYSTEM_ERROR,
            details: H.KEY_SYSTEM_NO_ACCESS,
            error: d,
            fatal: !0
          }, d.message));
        });
      };
      l(e);
    });
  }
  requestMediaKeySystemAccess(e, t) {
    const {
      requestMediaKeySystemAccessFunc: i
    } = this.config;
    if (typeof i != "function") {
      let s = `Configured requestMediaKeySystemAccess is not a function ${i}`;
      return gg === null && self.location.protocol === "http:" && (s = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`), Promise.reject(new Error(s));
    }
    return i(e, t);
  }
  getMediaKeysPromise(e, t, i) {
    var s;
    const r = yE(e, t, i, this.config.drmSystemOptions || {});
    let a = this.keySystemAccessPromises[e], o = (s = a) == null ? void 0 : s.keySystemAccess;
    if (!o) {
      this.log(`Requesting encrypted media "${e}" key-system access with config: ${Ge(r)}`), o = this.requestMediaKeySystemAccess(e, r);
      const l = a = this.keySystemAccessPromises[e] = {
        keySystemAccess: o
      };
      return o.catch((c) => {
        this.log(`Failed to obtain access to key-system "${e}": ${c}`);
      }), o.then((c) => {
        this.log(`Access for key-system "${c.keySystem}" obtained`);
        const u = this.fetchServerCertificate(e);
        this.log(`Create media-keys for "${e}"`);
        const d = l.mediaKeys = c.createMediaKeys().then((f) => (this.log(`Media-keys created for "${e}"`), l.hasMediaKeys = !0, u.then((p) => p ? this.setMediaKeysServerCertificate(f, e, p) : f)));
        return d.catch((f) => {
          this.error(`Failed to create media-keys for "${e}"}: ${f}`);
        }), d;
      });
    }
    return o.then(() => a.mediaKeys);
  }
  createMediaKeySessionContext({
    decryptdata: e,
    keySystem: t,
    mediaKeys: i
  }) {
    this.log(`Creating key-system session "${t}" keyId: ${Rt(e.keyId || [])} keyUri: ${e.uri}`);
    const s = i.createSession(), r = {
      decryptdata: e,
      keySystem: t,
      mediaKeys: i,
      mediaKeysSession: s,
      keyStatus: "status-pending"
    };
    return this.mediaKeySessions.push(r), r;
  }
  renewKeySession(e) {
    const t = e.decryptdata;
    if (t.pssh) {
      const i = this.createMediaKeySessionContext(e), s = Xa(t), r = "cenc";
      this.keyIdToKeySessionPromise[s] = this.generateRequestWithPreferredKeySession(i, r, t.pssh.buffer, "expired");
    } else
      this.warn("Could not renew expired session. Missing pssh initData.");
    this.removeSession(e);
  }
  updateKeySession(e, t) {
    const i = e.mediaKeysSession;
    return this.log(`Updating key-session "${i.sessionId}" for keyId ${Rt(e.decryptdata.keyId || [])}
      } (data length: ${t.byteLength})`), i.update(t);
  }
  getSelectedKeySystemFormats() {
    return Object.keys(this.keySystemAccessPromises).map((e) => ({
      keySystem: e,
      hasMediaKeys: this.keySystemAccessPromises[e].hasMediaKeys
    })).filter(({
      hasMediaKeys: e
    }) => !!e).map(({
      keySystem: e
    }) => Rl(e)).filter((e) => !!e);
  }
  getKeySystemAccess(e) {
    return this.getKeySystemSelectionPromise(e).then(({
      keySystem: t,
      mediaKeys: i
    }) => this.attemptSetMediaKeys(t, i));
  }
  selectKeySystem(e) {
    return new Promise((t, i) => {
      this.getKeySystemSelectionPromise(e).then(({
        keySystem: s
      }) => {
        const r = Rl(s);
        r ? t(r) : i(new Error(`Unable to find format for key-system "${s}"`));
      }).catch(i);
    });
  }
  selectKeySystemFormat(e) {
    const t = Object.keys(e.levelkeys || {});
    return this.keyFormatPromise || (this.log(`Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${e.level}) key formats ${t.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(t)), this.keyFormatPromise;
  }
  getKeyFormatPromise(e) {
    const t = Nn(this.config), i = e.map(go).filter((s) => !!s && t.indexOf(s) !== -1);
    return this.selectKeySystem(i);
  }
  getKeyStatus(e) {
    const {
      mediaKeySessions: t
    } = this;
    for (let i = 0; i < t.length; i++) {
      const s = BS(e, t[i]);
      if (s)
        return s;
    }
  }
  loadKey(e) {
    const t = e.keyInfo.decryptdata, i = Xa(t), s = this.bannedKeyIds[i];
    if (s || this.getKeyStatus(t) === "internal-error") {
      const o = Wf(s || "internal-error", t);
      return this.handleError(o, e.frag), Promise.reject(o);
    }
    const r = `(keyId: ${i} format: "${t.keyFormat}" method: ${t.method} uri: ${t.uri})`;
    this.log(`Starting session for key ${r}`);
    const a = this.keyIdToKeySessionPromise[i];
    if (!a) {
      const o = this.getKeySystemForKeyPromise(t).then(({
        keySystem: l,
        mediaKeys: c
      }) => (this.throwIfDestroyed(), this.log(`Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ${r}`), this.attemptSetMediaKeys(l, c).then(() => (this.throwIfDestroyed(), this.createMediaKeySessionContext({
        keySystem: l,
        mediaKeys: c,
        decryptdata: t
      }))))).then((l) => {
        const c = "cenc", u = t.pssh ? t.pssh.buffer : null;
        return this.generateRequestWithPreferredKeySession(l, c, u, "playlist-key");
      });
      return o.catch((l) => this.handleError(l, e.frag)), this.keyIdToKeySessionPromise[i] = o, o;
    }
    return a.catch((o) => {
      if (o instanceof li) {
        const l = Me({}, o.data);
        this.getKeyStatus(t) === "internal-error" && (l.decryptdata = t);
        const c = new li(l, o.message);
        this.handleError(c, e.frag);
      }
    }), a;
  }
  throwIfDestroyed(e = "Invalid state") {
    if (!this.hls)
      throw new Error("invalid state");
  }
  handleError(e, t) {
    if (this.hls)
      if (e instanceof li) {
        t && (e.data.frag = t);
        const i = e.data.decryptdata;
        this.error(`${e.message}${i ? ` (${Rt(i.keyId || [])})` : ""}`), this.hls.trigger(x.ERROR, e.data);
      } else
        this.error(e.message), this.hls.trigger(x.ERROR, {
          type: se.KEY_SYSTEM_ERROR,
          details: H.KEY_SYSTEM_NO_KEYS,
          error: e,
          fatal: !0
        });
  }
  getKeySystemForKeyPromise(e) {
    const t = Xa(e), i = this.keyIdToKeySessionPromise[t];
    if (!i) {
      const s = go(e.keyFormat), r = s ? [s] : Nn(this.config);
      return this.attemptKeySystemAccess(r);
    }
    return i;
  }
  getKeySystemSelectionPromise(e) {
    if (e.length || (e = Nn(this.config)), e.length === 0)
      throw new li({
        type: se.KEY_SYSTEM_ERROR,
        details: H.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
        fatal: !0
      }, `Missing key-system license configuration options ${Ge({
        drmSystems: this.config.drmSystems
      })}`);
    return this.attemptKeySystemAccess(e);
  }
  attemptSetMediaKeys(e, t) {
    if (this.mediaResolved = void 0, this.mediaKeys === t)
      return Promise.resolve();
    const i = this.setMediaKeysQueue.slice();
    this.log(`Setting media-keys for "${e}"`);
    const s = Promise.all(i).then(() => this.media ? this.media.setMediaKeys(t) : new Promise((r, a) => {
      this.mediaResolved = () => {
        if (this.mediaResolved = void 0, !this.media)
          return a(new Error("Attempted to set mediaKeys without media element attached"));
        this.mediaKeys = t, this.media.setMediaKeys(t).then(r).catch(a);
      };
    }));
    return this.mediaKeys = t, this.setMediaKeysQueue.push(s), s.then(() => {
      this.log(`Media-keys set for "${e}"`), i.push(s), this.setMediaKeysQueue = this.setMediaKeysQueue.filter((r) => i.indexOf(r) === -1);
    });
  }
  generateRequestWithPreferredKeySession(e, t, i, s) {
    var r;
    const a = (r = this.config.drmSystems) == null || (r = r[e.keySystem]) == null ? void 0 : r.generateRequest;
    if (a)
      try {
        const h = a.call(this.hls, t, i, e);
        if (!h)
          throw new Error("Invalid response from configured generateRequest filter");
        t = h.initDataType, i = h.initData ? h.initData : null, e.decryptdata.pssh = i ? new Uint8Array(i) : null;
      } catch (h) {
        if (this.warn(h.message), this.hls && this.hls.config.debug)
          throw h;
      }
    if (i === null)
      return this.log(`Skipping key-session request for "${s}" (no initData)`), Promise.resolve(e);
    const o = Xa(e.decryptdata), l = e.decryptdata.uri;
    this.log(`Generating key-session request for "${s}" keyId: ${o} URI: ${l} (init data type: ${t} length: ${i.byteLength})`);
    const c = new Gu(), u = e._onmessage = (h) => {
      const g = e.mediaKeysSession;
      if (!g) {
        c.emit("error", new Error("invalid state"));
        return;
      }
      const {
        messageType: m,
        message: v
      } = h;
      this.log(`"${m}" message event for session "${g.sessionId}" message size: ${v.byteLength}`), m === "license-request" || m === "license-renewal" ? this.renewLicense(e, v).catch((y) => {
        c.eventNames().length ? c.emit("error", y) : this.handleError(y);
      }) : m === "license-release" ? e.keySystem === Ze.FAIRPLAY && this.updateKeySession(e, Nc("acknowledged")).then(() => this.removeSession(e)).catch((y) => this.handleError(y)) : this.warn(`unhandled media key message type "${m}"`);
    }, d = (h, g) => {
      g.keyStatus = h;
      let m;
      h.startsWith("usable") ? c.emit("resolved") : h === "internal-error" || h === "output-restricted" || h === "output-downscaled" ? m = Wf(h, g.decryptdata) : h === "expired" ? m = new Error(`key expired (keyId: ${o})`) : h === "released" ? m = new Error("key released") : h === "status-pending" || this.warn(`unhandled key status change "${h}" (keyId: ${o})`), m && (c.eventNames().length ? c.emit("error", m) : this.handleError(m));
    }, f = e._onkeystatuseschange = (h) => {
      if (!e.mediaKeysSession) {
        c.emit("error", new Error("invalid state"));
        return;
      }
      const m = this.getKeyStatuses(e);
      if (!Object.keys(m).some((T) => m[T] !== "status-pending"))
        return;
      if (m[o] === "expired") {
        this.log(`Expired key ${Ge(m)} in key-session "${e.mediaKeysSession.sessionId}"`), this.renewKeySession(e);
        return;
      }
      let y = m[o];
      if (y)
        d(y, e);
      else {
        var E;
        e.keyStatusTimeouts || (e.keyStatusTimeouts = {}), (E = e.keyStatusTimeouts)[o] || (E[o] = self.setTimeout(() => {
          if (!e.mediaKeysSession || !this.mediaKeys)
            return;
          const S = this.getKeyStatus(e.decryptdata);
          if (S && S !== "status-pending")
            return this.log(`No status for keyId ${o} in key-session "${e.mediaKeysSession.sessionId}". Using session key-status ${S} from other session.`), d(S, e);
          this.log(`key status for ${o} in key-session "${e.mediaKeysSession.sessionId}" timed out after 1000ms`), y = "internal-error", d(y, e);
        }, 1e3)), this.log(`No status for keyId ${o} (${Ge(m)}).`);
      }
    };
    Zt(e.mediaKeysSession, "message", u), Zt(e.mediaKeysSession, "keystatuseschange", f);
    const p = new Promise((h, g) => {
      c.on("error", g), c.on("resolved", h);
    });
    return e.mediaKeysSession.generateRequest(t, i).then(() => {
      this.log(`Request generated for key-session "${e.mediaKeysSession.sessionId}" keyId: ${o} URI: ${l}`);
    }).catch((h) => {
      throw new li({
        type: se.KEY_SYSTEM_ERROR,
        details: H.KEY_SYSTEM_NO_SESSION,
        error: h,
        decryptdata: e.decryptdata,
        fatal: !1
      }, `Error generating key-session request: ${h}`);
    }).then(() => p).catch((h) => (c.removeAllListeners(), this.removeSession(e).then(() => {
      throw h;
    }))).then(() => (c.removeAllListeners(), e));
  }
  getKeyStatuses(e) {
    const t = {};
    return e.mediaKeysSession.keyStatuses.forEach((i, s) => {
      if (typeof s == "string" && typeof i == "object") {
        const o = s;
        s = i, i = o;
      }
      const r = "buffer" in s ? new Uint8Array(s.buffer, s.byteOffset, s.byteLength) : new Uint8Array(s);
      if (e.keySystem === Ze.PLAYREADY && r.length === 16) {
        const o = Rt(r);
        t[o] = i, hg(r);
      }
      const a = Rt(r);
      i === "internal-error" && (this.bannedKeyIds[a] = i), this.log(`key status change "${i}" for keyStatuses keyId: ${a} key-session "${e.mediaKeysSession.sessionId}"`), t[a] = i;
    }), t;
  }
  fetchServerCertificate(e) {
    const t = this.config, i = t.loader, s = new i(t), r = this.getServerCertificateUrl(e);
    return r ? (this.log(`Fetching server certificate for "${e}"`), new Promise((a, o) => {
      const l = {
        responseType: "arraybuffer",
        url: r
      }, c = t.certLoadPolicy.default, u = {
        loadPolicy: c,
        timeout: c.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0
      }, d = {
        onSuccess: (f, p, h, g) => {
          a(f.data);
        },
        onError: (f, p, h, g) => {
          o(new li({
            type: se.KEY_SYSTEM_ERROR,
            details: H.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
            fatal: !0,
            networkDetails: h,
            response: Me({
              url: l.url,
              data: void 0
            }, f)
          }, `"${e}" certificate request failed (${r}). Status: ${f.code} (${f.text})`));
        },
        onTimeout: (f, p, h) => {
          o(new li({
            type: se.KEY_SYSTEM_ERROR,
            details: H.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
            fatal: !0,
            networkDetails: h,
            response: {
              url: l.url,
              data: void 0
            }
          }, `"${e}" certificate request timed out (${r})`));
        },
        onAbort: (f, p, h) => {
          o(new Error("aborted"));
        }
      };
      s.load(l, u, d);
    })) : Promise.resolve();
  }
  setMediaKeysServerCertificate(e, t, i) {
    return new Promise((s, r) => {
      e.setServerCertificate(i).then((a) => {
        this.log(`setServerCertificate ${a ? "success" : "not supported by CDM"} (${i.byteLength}) on "${t}"`), s(e);
      }).catch((a) => {
        r(new li({
          type: se.KEY_SYSTEM_ERROR,
          details: H.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
          error: a,
          fatal: !0
        }, a.message));
      });
    });
  }
  renewLicense(e, t) {
    return this.requestLicense(e, new Uint8Array(t)).then((i) => this.updateKeySession(e, new Uint8Array(i)).catch((s) => {
      throw new li({
        type: se.KEY_SYSTEM_ERROR,
        details: H.KEY_SYSTEM_SESSION_UPDATE_FAILED,
        decryptdata: e.decryptdata,
        error: s,
        fatal: !1
      }, s.message);
    }));
  }
  unpackPlayReadyKeyMessage(e, t) {
    const i = String.fromCharCode.apply(null, new Uint16Array(t.buffer));
    if (!i.includes("PlayReadyKeyMessage"))
      return e.setRequestHeader("Content-Type", "text/xml; charset=utf-8"), t;
    const s = new DOMParser().parseFromString(i, "application/xml"), r = s.querySelectorAll("HttpHeader");
    if (r.length > 0) {
      let u;
      for (let d = 0, f = r.length; d < f; d++) {
        var a, o;
        u = r[d];
        const p = (a = u.querySelector("name")) == null ? void 0 : a.textContent, h = (o = u.querySelector("value")) == null ? void 0 : o.textContent;
        p && h && e.setRequestHeader(p, h);
      }
    }
    const l = s.querySelector("Challenge"), c = l?.textContent;
    if (!c)
      throw new Error("Cannot find <Challenge> in key message");
    return Nc(atob(c));
  }
  setupLicenseXHR(e, t, i, s) {
    const r = this.config.licenseXhrSetup;
    return r ? Promise.resolve().then(() => {
      if (!i.decryptdata)
        throw new Error("Key removed");
      return r.call(this.hls, e, t, i, s);
    }).catch((a) => {
      if (!i.decryptdata)
        throw a;
      return e.open("POST", t, !0), r.call(this.hls, e, t, i, s);
    }).then((a) => (e.readyState || e.open("POST", t, !0), {
      xhr: e,
      licenseChallenge: a || s
    })) : (e.open("POST", t, !0), Promise.resolve({
      xhr: e,
      licenseChallenge: s
    }));
  }
  requestLicense(e, t) {
    const i = this.config.keyLoadPolicy.default;
    return new Promise((s, r) => {
      const a = this.getLicenseServerUrlOrThrow(e.keySystem);
      this.log(`Sending license request to URL: ${a}`);
      const o = new XMLHttpRequest();
      o.responseType = "arraybuffer", o.onreadystatechange = () => {
        if (!this.hls || !e.mediaKeysSession)
          return r(new Error("invalid state"));
        if (o.readyState === 4)
          if (o.status === 200) {
            this._requestLicenseFailureCount = 0;
            let l = o.response;
            this.log(`License received ${l instanceof ArrayBuffer ? l.byteLength : l}`);
            const c = this.config.licenseResponseCallback;
            if (c)
              try {
                l = c.call(this.hls, o, a, e);
              } catch (u) {
                this.error(u);
              }
            s(l);
          } else {
            const l = i.errorRetry, c = l ? l.maxNumRetry : 0;
            if (this._requestLicenseFailureCount++, this._requestLicenseFailureCount > c || o.status >= 400 && o.status < 500)
              r(new li({
                type: se.KEY_SYSTEM_ERROR,
                details: H.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                decryptdata: e.decryptdata,
                fatal: !0,
                networkDetails: o,
                response: {
                  url: a,
                  data: void 0,
                  code: o.status,
                  text: o.statusText
                }
              }, `License Request XHR failed (${a}). Status: ${o.status} (${o.statusText})`));
            else {
              const u = c - this._requestLicenseFailureCount + 1;
              this.warn(`Retrying license request, ${u} attempts left`), this.requestLicense(e, t).then(s, r);
            }
          }
      }, e.licenseXhr && e.licenseXhr.readyState !== XMLHttpRequest.DONE && e.licenseXhr.abort(), e.licenseXhr = o, this.setupLicenseXHR(o, a, e, t).then(({
        xhr: l,
        licenseChallenge: c
      }) => {
        e.keySystem == Ze.PLAYREADY && (c = this.unpackPlayReadyKeyMessage(l, c)), l.send(c);
      }).catch(r);
    });
  }
  onDestroying() {
    this.unregisterListeners(), this._clear();
  }
  onMediaAttached(e, t) {
    if (!this.config.emeEnabled)
      return;
    const i = t.media;
    this.media = i, Zt(i, "encrypted", this.onMediaEncrypted), Zt(i, "waitingforkey", this.onWaitingForKey);
    const s = this.mediaResolved;
    s ? s() : this.mediaKeys = i.mediaKeys;
  }
  onMediaDetached() {
    const e = this.media;
    e && (ti(e, "encrypted", this.onMediaEncrypted), ti(e, "waitingforkey", this.onWaitingForKey), this.media = null, this.mediaKeys = null);
  }
  _clear() {
    var e;
    this._requestLicenseFailureCount = 0, this.keyIdToKeySessionPromise = {}, this.bannedKeyIds = {};
    const t = this.mediaResolved;
    if (t && t(), !this.mediaKeys && !this.mediaKeySessions.length)
      return;
    const i = this.media, s = this.mediaKeySessions.slice();
    this.mediaKeySessions = [], this.mediaKeys = null, Ys.clearKeyUriToKeyIdMap();
    const r = s.length;
    on.CDMCleanupPromise = Promise.all(s.map((a) => this.removeSession(a)).concat((i == null || (e = i.setMediaKeys(null)) == null ? void 0 : e.catch((a) => {
      this.log(`Could not clear media keys: ${a}`), this.hls && this.hls.trigger(x.ERROR, {
        type: se.OTHER_ERROR,
        details: H.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR,
        fatal: !1,
        error: new Error(`Could not clear media keys: ${a}`)
      });
    })) || Promise.resolve())).catch((a) => {
      this.log(`Could not close sessions and clear media keys: ${a}`), this.hls && this.hls.trigger(x.ERROR, {
        type: se.OTHER_ERROR,
        details: H.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,
        fatal: !1,
        error: new Error(`Could not close sessions and clear media keys: ${a}`)
      });
    }).then(() => {
      r && this.log("finished closing key sessions and clearing media keys");
    });
  }
  onManifestLoading() {
    this._clear();
  }
  onManifestLoaded(e, {
    sessionKeys: t
  }) {
    if (!(!t || !this.config.emeEnabled) && !this.keyFormatPromise) {
      const i = t.reduce((s, r) => (s.indexOf(r.keyFormat) === -1 && s.push(r.keyFormat), s), []);
      this.log(`Selecting key-system from session-keys ${i.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(i);
    }
  }
  removeSession(e) {
    const {
      mediaKeysSession: t,
      licenseXhr: i,
      decryptdata: s
    } = e;
    if (t) {
      this.log(`Remove licenses and keys and close session "${t.sessionId}" keyId: ${Rt(s?.keyId || [])}`), e._onmessage && (t.removeEventListener("message", e._onmessage), e._onmessage = void 0), e._onkeystatuseschange && (t.removeEventListener("keystatuseschange", e._onkeystatuseschange), e._onkeystatuseschange = void 0), i && i.readyState !== XMLHttpRequest.DONE && i.abort(), e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0;
      const r = this.mediaKeySessions.indexOf(e);
      r > -1 && this.mediaKeySessions.splice(r, 1);
      const {
        keyStatusTimeouts: a
      } = e;
      a && Object.keys(a).forEach((c) => self.clearTimeout(a[c]));
      const {
        drmSystemOptions: o
      } = this.config;
      return (TE(o) ? new Promise((c, u) => {
        self.setTimeout(() => u(new Error("MediaKeySession.remove() timeout")), 8e3), t.remove().then(c).catch(u);
      }) : Promise.resolve()).catch((c) => {
        this.log(`Could not remove session: ${c}`), this.hls && this.hls.trigger(x.ERROR, {
          type: se.OTHER_ERROR,
          details: H.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR,
          fatal: !1,
          error: new Error(`Could not remove session: ${c}`)
        });
      }).then(() => t.close()).catch((c) => {
        this.log(`Could not close session: ${c}`), this.hls && this.hls.trigger(x.ERROR, {
          type: se.OTHER_ERROR,
          details: H.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,
          fatal: !1,
          error: new Error(`Could not close session: ${c}`)
        });
      });
    }
    return Promise.resolve();
  }
}
on.CDMCleanupPromise = void 0;
function Xa(n) {
  if (!n)
    throw new Error("Could not read keyId of undefined decryptdata");
  if (n.keyId === null)
    throw new Error("keyId is null");
  return Rt(n.keyId);
}
function BS(n, e) {
  if (n.keyId && e.mediaKeysSession.keyStatuses.has(n.keyId))
    return e.mediaKeysSession.keyStatuses.get(n.keyId);
  if (n.matches(e.decryptdata))
    return e.keyStatus;
}
class li extends Error {
  constructor(e, t) {
    super(t), this.data = void 0, e.error || (e.error = new Error(t)), this.data = e, e.err = e.error;
  }
}
function Wf(n, e) {
  const t = n === "output-restricted", i = t ? H.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED : H.KEY_SYSTEM_STATUS_INTERNAL_ERROR;
  return new li({
    type: se.KEY_SYSTEM_ERROR,
    details: i,
    fatal: !1,
    decryptdata: e
  }, t ? "HDCP level output restricted" : `key status changed to "${n}"`);
}
class US {
  constructor(e) {
    this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = e, this.registerListeners();
  }
  setStreamController(e) {
    this.streamController = e;
  }
  registerListeners() {
    this.hls.on(x.MEDIA_ATTACHING, this.onMediaAttaching, this), this.hls.on(x.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  unregisterListeners() {
    this.hls.off(x.MEDIA_ATTACHING, this.onMediaAttaching, this), this.hls.off(x.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  destroy() {
    this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null;
  }
  onMediaAttaching(e, t) {
    const i = this.hls.config;
    if (i.capLevelOnFPSDrop) {
      const s = t.media instanceof self.HTMLVideoElement ? t.media : null;
      this.media = s, s && typeof s.getVideoPlaybackQuality == "function" && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), i.fpsDroppedMonitoringPeriod);
    }
  }
  onMediaDetaching() {
    this.media = null;
  }
  checkFPS(e, t, i) {
    const s = performance.now();
    if (t) {
      if (this.lastTime) {
        const r = s - this.lastTime, a = i - this.lastDroppedFrames, o = t - this.lastDecodedFrames, l = 1e3 * a / r, c = this.hls;
        if (c.trigger(x.FPS_DROP, {
          currentDropped: a,
          currentDecoded: o,
          totalDroppedFrames: i
        }), l > 0 && a > c.config.fpsDroppedMonitoringThreshold * o) {
          let u = c.currentLevel;
          c.logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + u), u > 0 && (c.autoLevelCapping === -1 || c.autoLevelCapping >= u) && (u = u - 1, c.trigger(x.FPS_DROP_LEVEL_CAPPING, {
            level: u,
            droppedLevel: c.currentLevel
          }), c.autoLevelCapping = u, this.streamController.nextLevelSwitch());
        }
      }
      this.lastTime = s, this.lastDroppedFrames = i, this.lastDecodedFrames = t;
    }
  }
  checkFPSInterval() {
    const e = this.media;
    if (e)
      if (this.isVideoPlaybackQualityAvailable) {
        const t = e.getVideoPlaybackQuality();
        this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames);
      } else
        this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount);
  }
}
function nm(n, e) {
  let t;
  try {
    t = new Event("addtrack");
  } catch {
    t = document.createEvent("Event"), t.initEvent("addtrack", !1, !1);
  }
  t.track = n, e.dispatchEvent(t);
}
function am(n, e) {
  const t = n.mode;
  if (t === "disabled" && (n.mode = "hidden"), n.cues && !n.cues.getCueById(e.id))
    try {
      if (n.addCue(e), !n.cues.getCueById(e.id))
        throw new Error(`addCue is failed for: ${e}`);
    } catch (i) {
      Oe.debug(`[texttrack-utils]: ${i}`);
      try {
        const s = new self.TextTrackCue(e.startTime, e.endTime, e.text);
        s.id = e.id, n.addCue(s);
      } catch (s) {
        Oe.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${s}`);
      }
    }
  t === "disabled" && (n.mode = t);
}
function Qr(n, e) {
  const t = n.mode;
  if (t === "disabled" && (n.mode = "hidden"), n.cues)
    for (let i = n.cues.length; i--; )
      e && n.cues[i].removeEventListener("enter", e), n.removeCue(n.cues[i]);
  t === "disabled" && (n.mode = t);
}
function Kc(n, e, t, i) {
  const s = n.mode;
  if (s === "disabled" && (n.mode = "hidden"), n.cues && n.cues.length > 0) {
    const r = HS(n.cues, e, t);
    for (let a = 0; a < r.length; a++)
      (!i || i(r[a])) && n.removeCue(r[a]);
  }
  s === "disabled" && (n.mode = s);
}
function GS(n, e) {
  if (e <= n[0].startTime)
    return 0;
  const t = n.length - 1;
  if (e > n[t].endTime)
    return -1;
  let i = 0, s = t, r;
  for (; i <= s; )
    if (r = Math.floor((s + i) / 2), e < n[r].startTime)
      s = r - 1;
    else if (e > n[r].startTime && i < t)
      i = r + 1;
    else
      return r;
  return n[i].startTime - e < e - n[s].startTime ? i : s;
}
function HS(n, e, t) {
  const i = [], s = GS(n, e);
  if (s > -1)
    for (let r = s, a = n.length; r < a; r++) {
      const o = n[r];
      if (o.startTime >= e && o.endTime <= t)
        i.push(o);
      else if (o.startTime > t)
        return i;
    }
  return i;
}
function Eo(n) {
  const e = [];
  for (let t = 0; t < n.length; t++) {
    const i = n[t];
    (i.kind === "subtitles" || i.kind === "captions") && i.label && e.push(n[t]);
  }
  return e;
}
class VS extends qu {
  constructor(e) {
    super(e, "subtitle-track-controller"), this.media = null, this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.queuedDefaultTrack = -1, this.useTextTrackPolling = !1, this.subtitlePollingInterval = -1, this._subtitleDisplay = !0, this.asyncPollTrackChange = () => this.pollTrackChange(0), this.onTextTracksChanged = () => {
      if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), !this.media || !this.hls.config.renderTextTracksNatively)
        return;
      let t = null;
      const i = Eo(this.media.textTracks);
      for (let r = 0; r < i.length; r++)
        if (i[r].mode === "hidden")
          t = i[r];
        else if (i[r].mode === "showing") {
          t = i[r];
          break;
        }
      const s = this.findTrackForTextTrack(t);
      this.subtitleTrack !== s && this.setSubtitleTrack(s);
    }, this.registerListeners();
  }
  destroy() {
    this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, this.onTextTracksChanged = this.asyncPollTrackChange = null, super.destroy();
  }
  get subtitleDisplay() {
    return this._subtitleDisplay;
  }
  set subtitleDisplay(e) {
    this._subtitleDisplay = e, this.trackId > -1 && this.toggleTrackModes();
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.MANIFEST_PARSED, this.onManifestParsed, this), e.on(x.LEVEL_LOADING, this.onLevelLoading, this), e.on(x.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(x.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(x.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.MANIFEST_PARSED, this.onManifestParsed, this), e.off(x.LEVEL_LOADING, this.onLevelLoading, this), e.off(x.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(x.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(x.ERROR, this.onError, this);
  }
  // Listen for subtitle track change, then extract the current track ID.
  onMediaAttached(e, t) {
    this.media = t.media, this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange));
  }
  pollTrackChange(e) {
    self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, e);
  }
  onMediaDetaching(e, t) {
    const i = this.media;
    if (!i)
      return;
    const s = !!t.transferMedia;
    if (self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || i.textTracks.removeEventListener("change", this.asyncPollTrackChange), this.trackId > -1 && (this.queuedDefaultTrack = this.trackId), this.subtitleTrack = -1, this.media = null, s)
      return;
    Eo(i.textTracks).forEach((a) => {
      Qr(a);
    });
  }
  onManifestLoading() {
    this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0;
  }
  // Fired whenever a new manifest is loaded.
  onManifestParsed(e, t) {
    this.tracks = t.subtitleTracks;
  }
  onSubtitleTrackLoaded(e, t) {
    const {
      id: i,
      groupId: s,
      details: r
    } = t, a = this.tracksInGroup[i];
    if (!a || a.groupId !== s) {
      this.warn(`Subtitle track with id:${i} and group:${s} not found in active group ${a?.groupId}`);
      return;
    }
    const o = a.details;
    a.details = t.details, this.log(`Subtitle track ${i} "${a.name}" lang:${a.lang} group:${s} loaded [${r.startSN}-${r.endSN}]`), i === this.trackId && this.playlistLoaded(i, t, o);
  }
  onLevelLoading(e, t) {
    this.switchLevel(t.level);
  }
  onLevelSwitching(e, t) {
    this.switchLevel(t.level);
  }
  switchLevel(e) {
    const t = this.hls.levels[e];
    if (!t)
      return;
    const i = t.subtitleGroups || null, s = this.groupIds;
    let r = this.currentTrack;
    if (!i || s?.length !== i?.length || i != null && i.some((a) => s?.indexOf(a) === -1)) {
      this.groupIds = i, this.trackId = -1, this.currentTrack = null;
      const a = this.tracks.filter((u) => !i || i.indexOf(u.groupId) !== -1);
      if (a.length)
        this.selectDefaultTrack && !a.some((u) => u.default) && (this.selectDefaultTrack = !1), a.forEach((u, d) => {
          u.id = d;
        });
      else if (!r && !this.tracksInGroup.length)
        return;
      this.tracksInGroup = a;
      const o = this.hls.config.subtitlePreference;
      if (!r && o) {
        this.selectDefaultTrack = !1;
        const u = rs(o, a);
        if (u > -1)
          r = a[u];
        else {
          const d = rs(o, this.tracks);
          r = this.tracks[d];
        }
      }
      let l = this.findTrackId(r);
      l === -1 && r && (l = this.findTrackId(null));
      const c = {
        subtitleTracks: a
      };
      this.log(`Updating subtitle tracks, ${a.length} track(s) found in "${i?.join(",")}" group-id`), this.hls.trigger(x.SUBTITLE_TRACKS_UPDATED, c), l !== -1 && this.trackId === -1 && this.setSubtitleTrack(l);
    }
  }
  findTrackId(e) {
    const t = this.tracksInGroup, i = this.selectDefaultTrack;
    for (let s = 0; s < t.length; s++) {
      const r = t[s];
      if (!(i && !r.default || !i && !e) && (!e || br(r, e)))
        return s;
    }
    if (e) {
      for (let s = 0; s < t.length; s++) {
        const r = t[s];
        if (Ea(e.attrs, r.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"]))
          return s;
      }
      for (let s = 0; s < t.length; s++) {
        const r = t[s];
        if (Ea(e.attrs, r.attrs, ["LANGUAGE"]))
          return s;
      }
    }
    return -1;
  }
  findTrackForTextTrack(e) {
    if (e) {
      const t = this.tracksInGroup;
      for (let i = 0; i < t.length; i++) {
        const s = t[i];
        if (Hc(s, e))
          return i;
      }
    }
    return -1;
  }
  onError(e, t) {
    t.fatal || !t.context || t.context.type === Ee.SUBTITLE_TRACK && t.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(t.context.groupId) !== -1) && this.checkRetry(t);
  }
  get allSubtitleTracks() {
    return this.tracks;
  }
  /** get alternate subtitle tracks list from playlist **/
  get subtitleTracks() {
    return this.tracksInGroup;
  }
  /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/
  get subtitleTrack() {
    return this.trackId;
  }
  set subtitleTrack(e) {
    this.selectDefaultTrack = !1, this.setSubtitleTrack(e);
  }
  setSubtitleOption(e) {
    if (this.hls.config.subtitlePreference = e, e) {
      if (e.id === -1)
        return this.setSubtitleTrack(-1), null;
      const t = this.allSubtitleTracks;
      if (this.selectDefaultTrack = !1, t.length) {
        const i = this.currentTrack;
        if (i && br(e, i))
          return i;
        const s = rs(e, this.tracksInGroup);
        if (s > -1) {
          const r = this.tracksInGroup[s];
          return this.setSubtitleTrack(s), r;
        } else {
          if (i)
            return null;
          {
            const r = rs(e, t);
            if (r > -1)
              return t[r];
          }
        }
      }
    }
    return null;
  }
  loadPlaylist(e) {
    super.loadPlaylist(), this.shouldLoadPlaylist(this.currentTrack) && this.scheduleLoading(this.currentTrack, e);
  }
  loadingPlaylist(e, t) {
    super.loadingPlaylist(e, t);
    const i = e.id, s = e.groupId, r = this.getUrlWithDirectives(e.url, t), a = e.details, o = a?.age;
    this.log(`Loading subtitle ${i} "${e.name}" lang:${e.lang} group:${s}${t?.msn !== void 0 ? " at sn " + t.msn + " part " + t.part : ""}${o && a.live ? " age " + o.toFixed(1) + (a.type && " " + a.type || "") : ""} ${r}`), this.hls.trigger(x.SUBTITLE_TRACK_LOADING, {
      url: r,
      id: i,
      groupId: s,
      deliveryDirectives: t || null,
      track: e
    });
  }
  /**
   * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.
   * This operates on the DOM textTracks.
   * A value of -1 will disable all subtitle tracks.
   */
  toggleTrackModes() {
    const {
      media: e
    } = this;
    if (!e)
      return;
    const t = Eo(e.textTracks), i = this.currentTrack;
    let s;
    if (i && (s = t.filter((r) => Hc(i, r))[0], s || this.warn(`Unable to find subtitle TextTrack with name "${i.name}" and language "${i.lang}"`)), [].slice.call(t).forEach((r) => {
      r.mode !== "disabled" && r !== s && (r.mode = "disabled");
    }), s) {
      const r = this.subtitleDisplay ? "showing" : "hidden";
      s.mode !== r && (s.mode = r);
    }
  }
  /**
   * This method is responsible for validating the subtitle index and periodically reloading if live.
   * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.
   */
  setSubtitleTrack(e) {
    const t = this.tracksInGroup;
    if (!this.media) {
      this.queuedDefaultTrack = e;
      return;
    }
    if (e < -1 || e >= t.length || !Z(e)) {
      this.warn(`Invalid subtitle track id: ${e}`);
      return;
    }
    this.selectDefaultTrack = !1;
    const i = this.currentTrack, s = t[e] || null;
    if (this.trackId = e, this.currentTrack = s, this.toggleTrackModes(), !s) {
      this.hls.trigger(x.SUBTITLE_TRACK_SWITCH, {
        id: e
      });
      return;
    }
    const r = !!s.details && !s.details.live;
    if (e === this.trackId && s === i && r)
      return;
    this.log(`Switching to subtitle-track ${e}` + (s ? ` "${s.name}" lang:${s.lang} group:${s.groupId}` : ""));
    const {
      id: a,
      groupId: o = "",
      name: l,
      type: c,
      url: u
    } = s;
    this.hls.trigger(x.SUBTITLE_TRACK_SWITCH, {
      id: a,
      groupId: o,
      name: l,
      type: c,
      url: u
    });
    const d = this.switchParams(s.url, i?.details, s.details);
    this.loadPlaylist(d);
  }
}
function zS() {
  try {
    return crypto.randomUUID();
  } catch {
    try {
      const e = URL.createObjectURL(new Blob()), t = e.toString();
      return URL.revokeObjectURL(e), t.slice(t.lastIndexOf("/") + 1);
    } catch {
      let t = (/* @__PURE__ */ new Date()).getTime();
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (s) => {
        const r = (t + Math.random() * 16) % 16 | 0;
        return t = Math.floor(t / 16), (s == "x" ? r : r & 3 | 8).toString(16);
      });
    }
  }
}
function ea(n) {
  let e = 5381, t = n.length;
  for (; t; )
    e = e * 33 ^ n.charCodeAt(--t);
  return (e >>> 0).toString();
}
const ln = 0.025;
let Ko = /* @__PURE__ */ (function(n) {
  return n[n.Point = 0] = "Point", n[n.Range = 1] = "Range", n;
})({});
function WS(n, e, t) {
  return `${n.identifier}-${t + 1}-${ea(e)}`;
}
class KS {
  constructor(e, t) {
    this.base = void 0, this._duration = null, this._timelineStart = null, this.appendInPlaceDisabled = void 0, this.appendInPlaceStarted = void 0, this.dateRange = void 0, this.hasPlayed = !1, this.cumulativeDuration = 0, this.resumeOffset = NaN, this.playoutLimit = NaN, this.restrictions = {
      skip: !1,
      jump: !1
    }, this.snapOptions = {
      out: !1,
      in: !1
    }, this.assetList = [], this.assetListLoader = void 0, this.assetListResponse = null, this.resumeAnchor = void 0, this.error = void 0, this.resetOnResume = void 0, this.base = t, this.dateRange = e, this.setDateRange(e);
  }
  setDateRange(e) {
    this.dateRange = e, this.resumeOffset = e.attr.optionalFloat("X-RESUME-OFFSET", this.resumeOffset), this.playoutLimit = e.attr.optionalFloat("X-PLAYOUT-LIMIT", this.playoutLimit), this.restrictions = e.attr.enumeratedStringList("X-RESTRICT", this.restrictions), this.snapOptions = e.attr.enumeratedStringList("X-SNAP", this.snapOptions);
  }
  reset() {
    var e;
    this.appendInPlaceStarted = !1, (e = this.assetListLoader) == null || e.destroy(), this.assetListLoader = void 0, this.supplementsPrimary || (this.assetListResponse = null, this.assetList = [], this._duration = null);
  }
  isAssetPastPlayoutLimit(e) {
    var t;
    if (e > 0 && e >= this.assetList.length)
      return !0;
    const i = this.playoutLimit;
    return e <= 0 || isNaN(i) ? !1 : i === 0 ? !0 : (((t = this.assetList[e]) == null ? void 0 : t.startOffset) || 0) > i;
  }
  findAssetIndex(e) {
    return this.assetList.indexOf(e);
  }
  get identifier() {
    return this.dateRange.id;
  }
  get startDate() {
    return this.dateRange.startDate;
  }
  get startTime() {
    const e = this.dateRange.startTime;
    if (this.snapOptions.out) {
      const t = this.dateRange.tagAnchor;
      if (t)
        return $l(e, t);
    }
    return e;
  }
  get startOffset() {
    return this.cue.pre ? 0 : this.startTime;
  }
  get startIsAligned() {
    if (this.startTime === 0 || this.snapOptions.out)
      return !0;
    const e = this.dateRange.tagAnchor;
    if (e) {
      const t = this.dateRange.startTime, i = $l(t, e);
      return t - i < 0.1;
    }
    return !1;
  }
  get resumptionOffset() {
    const e = this.resumeOffset, t = Z(e) ? e : this.duration;
    return this.cumulativeDuration + t;
  }
  get resumeTime() {
    const e = this.startOffset + this.resumptionOffset;
    if (this.snapOptions.in) {
      const t = this.resumeAnchor;
      if (t)
        return $l(e, t);
    }
    return e;
  }
  get appendInPlace() {
    return this.appendInPlaceStarted ? !0 : this.appendInPlaceDisabled ? !1 : !!(!this.cue.once && !this.cue.pre && // preroll starts at startPosition before startPosition is known (live)
    this.startIsAligned && (isNaN(this.playoutLimit) && isNaN(this.resumeOffset) || this.resumeOffset && this.duration && Math.abs(this.resumeOffset - this.duration) < ln));
  }
  set appendInPlace(e) {
    if (this.appendInPlaceStarted) {
      this.resetOnResume = !e;
      return;
    }
    this.appendInPlaceDisabled = !e;
  }
  // Extended timeline start time
  get timelineStart() {
    return this._timelineStart !== null ? this._timelineStart : this.startTime;
  }
  set timelineStart(e) {
    this._timelineStart = e;
  }
  get duration() {
    const e = this.playoutLimit;
    let t;
    return this._duration !== null ? t = this._duration : this.dateRange.duration ? t = this.dateRange.duration : t = this.dateRange.plannedDuration || 0, !isNaN(e) && e < t && (t = e), t;
  }
  set duration(e) {
    this._duration = e;
  }
  get cue() {
    return this.dateRange.cue;
  }
  get timelineOccupancy() {
    return this.dateRange.attr["X-TIMELINE-OCCUPIES"] === "RANGE" ? Ko.Range : Ko.Point;
  }
  get supplementsPrimary() {
    return this.dateRange.attr["X-TIMELINE-STYLE"] === "PRIMARY";
  }
  get contentMayVary() {
    return this.dateRange.attr["X-CONTENT-MAY-VARY"] !== "NO";
  }
  get assetUrl() {
    return this.dateRange.attr["X-ASSET-URI"];
  }
  get assetListUrl() {
    return this.dateRange.attr["X-ASSET-LIST"];
  }
  get baseUrl() {
    return this.base.url;
  }
  get assetListLoaded() {
    return this.assetList.length > 0 || this.assetListResponse !== null;
  }
  toString() {
    return YS(this);
  }
}
function $l(n, e) {
  return n - e.start < e.duration / 2 && !(Math.abs(n - (e.start + e.duration)) < ln) ? e.start : e.start + e.duration;
}
function om(n, e, t) {
  const i = new self.URL(n, t);
  return i.protocol !== "data:" && i.searchParams.set("_HLS_primary_id", e), i;
}
function Bl(n, e) {
  for (; (t = n.assetList[++e]) != null && t.error; )
    var t;
  return e;
}
function YS(n) {
  return `["${n.identifier}" ${n.cue.pre ? "<pre>" : n.cue.post ? "<post>" : ""}${n.timelineStart.toFixed(2)}-${n.resumeTime.toFixed(2)}]`;
}
function Kr(n) {
  const e = n.timelineStart, t = n.duration || 0;
  return `["${n.identifier}" ${e.toFixed(2)}-${(e + t).toFixed(2)}]`;
}
class qS {
  constructor(e, t, i, s) {
    this.hls = void 0, this.interstitial = void 0, this.assetItem = void 0, this.tracks = null, this.hasDetails = !1, this.mediaAttached = null, this._currentTime = void 0, this._bufferedEosTime = void 0, this.checkPlayout = () => {
      this.reachedPlayout(this.currentTime) && this.hls && this.hls.trigger(x.PLAYOUT_LIMIT_REACHED, {});
    };
    const r = this.hls = new e(t);
    this.interstitial = i, this.assetItem = s;
    const a = () => {
      this.hasDetails = !0;
    };
    r.once(x.LEVEL_LOADED, a), r.once(x.AUDIO_TRACK_LOADED, a), r.once(x.SUBTITLE_TRACK_LOADED, a), r.on(x.MEDIA_ATTACHING, (o, {
      media: l
    }) => {
      this.removeMediaListeners(), this.mediaAttached = l, this.interstitial.playoutLimit && (l.addEventListener("timeupdate", this.checkPlayout), this.appendInPlace && r.on(x.BUFFER_APPENDED, () => {
        const u = this.bufferedEnd;
        this.reachedPlayout(u) && (this._bufferedEosTime = u, r.trigger(x.BUFFERED_TO_END, void 0));
      }));
    });
  }
  get appendInPlace() {
    return this.interstitial.appendInPlace;
  }
  loadSource() {
    const e = this.hls;
    if (e)
      if (e.url)
        e.levels.length && !e.started && e.startLoad(-1, !0);
      else {
        let t = this.assetItem.uri;
        try {
          t = om(t, e.config.primarySessionId || "").href;
        } catch {
        }
        e.loadSource(t);
      }
  }
  bufferedInPlaceToEnd(e) {
    var t;
    if (!this.appendInPlace)
      return !1;
    if ((t = this.hls) != null && t.bufferedToEnd)
      return !0;
    if (!e)
      return !1;
    const i = Math.min(this._bufferedEosTime || 1 / 0, this.duration), s = this.timelineOffset, r = de.bufferInfo(e, s, 0);
    return this.getAssetTime(r.end) >= i - 0.02;
  }
  reachedPlayout(e) {
    const i = this.interstitial.playoutLimit;
    return this.startOffset + e >= i;
  }
  get destroyed() {
    var e;
    return !((e = this.hls) != null && e.userConfig);
  }
  get assetId() {
    return this.assetItem.identifier;
  }
  get interstitialId() {
    return this.assetItem.parentIdentifier;
  }
  get media() {
    var e;
    return ((e = this.hls) == null ? void 0 : e.media) || null;
  }
  get bufferedEnd() {
    const e = this.media || this.mediaAttached;
    if (!e)
      return this._bufferedEosTime ? this._bufferedEosTime : this.currentTime;
    const t = de.bufferInfo(e, e.currentTime, 1e-3);
    return this.getAssetTime(t.end);
  }
  get currentTime() {
    const e = this.media || this.mediaAttached;
    return e ? this.getAssetTime(e.currentTime) : this._currentTime || 0;
  }
  get duration() {
    const e = this.assetItem.duration;
    if (!e)
      return 0;
    const t = this.interstitial.playoutLimit;
    if (t) {
      const i = t - this.startOffset;
      if (i > 0 && i < e)
        return i;
    }
    return e;
  }
  get remaining() {
    const e = this.duration;
    return e ? Math.max(0, e - this.currentTime) : 0;
  }
  get startOffset() {
    return this.assetItem.startOffset;
  }
  get timelineOffset() {
    var e;
    return ((e = this.hls) == null ? void 0 : e.config.timelineOffset) || 0;
  }
  set timelineOffset(e) {
    const t = this.timelineOffset;
    if (e !== t) {
      const i = e - t;
      if (Math.abs(i) > 1 / 9e4 && this.hls) {
        if (this.hasDetails)
          throw new Error("Cannot set timelineOffset after playlists are loaded");
        this.hls.config.timelineOffset = e;
      }
    }
  }
  getAssetTime(e) {
    const t = this.timelineOffset, i = this.duration;
    return Math.min(Math.max(0, e - t), i);
  }
  removeMediaListeners() {
    const e = this.mediaAttached;
    e && (this._currentTime = e.currentTime, this.bufferSnapShot(), e.removeEventListener("timeupdate", this.checkPlayout));
  }
  bufferSnapShot() {
    if (this.mediaAttached) {
      var e;
      (e = this.hls) != null && e.bufferedToEnd && (this._bufferedEosTime = this.bufferedEnd);
    }
  }
  destroy() {
    this.removeMediaListeners(), this.hls && this.hls.destroy(), this.hls = null, this.tracks = this.mediaAttached = this.checkPlayout = null;
  }
  attachMedia(e) {
    var t;
    this.loadSource(), (t = this.hls) == null || t.attachMedia(e);
  }
  detachMedia() {
    var e;
    this.removeMediaListeners(), this.mediaAttached = null, (e = this.hls) == null || e.detachMedia();
  }
  resumeBuffering() {
    var e;
    (e = this.hls) == null || e.resumeBuffering();
  }
  pauseBuffering() {
    var e;
    (e = this.hls) == null || e.pauseBuffering();
  }
  transferMedia() {
    var e;
    return this.bufferSnapShot(), ((e = this.hls) == null ? void 0 : e.transferMedia()) || null;
  }
  resetDetails() {
    const e = this.hls;
    if (e && this.hasDetails) {
      e.stopLoad();
      const t = (i) => delete i.details;
      e.levels.forEach(t), e.allAudioTracks.forEach(t), e.allSubtitleTracks.forEach(t), this.hasDetails = !1;
    }
  }
  on(e, t, i) {
    var s;
    (s = this.hls) == null || s.on(e, t);
  }
  once(e, t, i) {
    var s;
    (s = this.hls) == null || s.once(e, t);
  }
  off(e, t, i) {
    var s;
    (s = this.hls) == null || s.off(e, t);
  }
  toString() {
    var e;
    return `HlsAssetPlayer: ${Kr(this.assetItem)} ${(e = this.hls) == null ? void 0 : e.sessionId} ${this.appendInPlace ? "append-in-place" : ""}`;
  }
}
const Kf = 0.033;
class XS extends Fi {
  constructor(e, t) {
    super("interstitials-sched", t), this.onScheduleUpdate = void 0, this.eventMap = {}, this.events = null, this.items = null, this.durations = {
      primary: 0,
      playout: 0,
      integrated: 0
    }, this.onScheduleUpdate = e;
  }
  destroy() {
    this.reset(), this.onScheduleUpdate = null;
  }
  reset() {
    this.eventMap = {}, this.setDurations(0, 0, 0), this.events && this.events.forEach((e) => e.reset()), this.events = this.items = null;
  }
  resetErrorsInRange(e, t) {
    return this.events ? this.events.reduce((i, s) => e <= s.startOffset && t > s.startOffset ? (delete s.error, i + 1) : i, 0) : 0;
  }
  get duration() {
    const e = this.items;
    return e ? e[e.length - 1].end : 0;
  }
  get length() {
    return this.items ? this.items.length : 0;
  }
  getEvent(e) {
    return e && this.eventMap[e] || null;
  }
  hasEvent(e) {
    return e in this.eventMap;
  }
  findItemIndex(e, t) {
    if (e.event)
      return this.findEventIndex(e.event.identifier);
    let i = -1;
    e.nextEvent ? i = this.findEventIndex(e.nextEvent.identifier) - 1 : e.previousEvent && (i = this.findEventIndex(e.previousEvent.identifier) + 1);
    const s = this.items;
    if (s)
      for (s[i] || (t === void 0 && (t = e.start), i = this.findItemIndexAtTime(t)); i >= 0 && (r = s[i]) != null && r.event; ) {
        var r;
        i--;
      }
    return i;
  }
  findItemIndexAtTime(e, t) {
    const i = this.items;
    if (i)
      for (let s = 0; s < i.length; s++) {
        let r = i[s];
        if (t && t !== "primary" && (r = r[t]), e === r.start || e > r.start && e < r.end)
          return s;
      }
    return -1;
  }
  findJumpRestrictedIndex(e, t) {
    const i = this.items;
    if (i)
      for (let s = e; s <= t && i[s]; s++) {
        const r = i[s].event;
        if (r != null && r.restrictions.jump && !r.appendInPlace)
          return s;
      }
    return -1;
  }
  findEventIndex(e) {
    const t = this.items;
    if (t)
      for (let s = t.length; s--; ) {
        var i;
        if (((i = t[s].event) == null ? void 0 : i.identifier) === e)
          return s;
      }
    return -1;
  }
  findAssetIndex(e, t) {
    const i = e.assetList, s = i.length;
    if (s > 1)
      for (let r = 0; r < s; r++) {
        const a = i[r];
        if (!a.error) {
          const o = a.timelineStart;
          if (t === o || t > o && (t < o + (a.duration || 0) || r === s - 1))
            return r;
        }
      }
    return 0;
  }
  get assetIdAtEnd() {
    var e;
    const t = (e = this.items) == null || (e = e[this.length - 1]) == null ? void 0 : e.event;
    if (t) {
      const i = t.assetList, s = i[i.length - 1];
      if (s)
        return s.identifier;
    }
    return null;
  }
  parseInterstitialDateRanges(e, t) {
    const i = e.main.details, {
      dateRanges: s
    } = i, r = this.events, a = this.parseDateRanges(s, {
      url: i.url
    }, t), o = Object.keys(s), l = r ? r.filter((c) => !o.includes(c.identifier)) : [];
    a.length && a.sort((c, u) => {
      const d = c.cue.pre, f = c.cue.post, p = u.cue.pre, h = u.cue.post;
      if (d && !p)
        return -1;
      if (p && !d || f && !h)
        return 1;
      if (h && !f)
        return -1;
      if (!d && !p && !f && !h) {
        const g = c.startTime, m = u.startTime;
        if (g !== m)
          return g - m;
      }
      return c.dateRange.tagOrder - u.dateRange.tagOrder;
    }), this.events = a, l.forEach((c) => {
      this.removeEvent(c);
    }), this.updateSchedule(e, l);
  }
  updateSchedule(e, t = [], i = !1) {
    const s = this.events || [];
    if (s.length || t.length || this.length < 2) {
      const r = this.items, a = this.parseSchedule(s, e);
      (i || t.length || r?.length !== a.length || a.some((l, c) => Math.abs(l.playout.start - r[c].playout.start) > 5e-3 || Math.abs(l.playout.end - r[c].playout.end) > 5e-3)) && (this.items = a, this.onScheduleUpdate(t, r));
    }
  }
  parseDateRanges(e, t, i) {
    const s = [], r = Object.keys(e);
    for (let a = 0; a < r.length; a++) {
      const o = r[a], l = e[o];
      if (l.isInterstitial) {
        let c = this.eventMap[o];
        c ? c.setDateRange(l) : (c = new KS(l, t), this.eventMap[o] = c, i === !1 && (c.appendInPlace = i)), s.push(c);
      }
    }
    return s;
  }
  parseSchedule(e, t) {
    const i = [], s = t.main.details, r = s.live ? 1 / 0 : s.edge;
    let a = 0;
    if (e = e.filter((l) => !l.error && !(l.cue.once && l.hasPlayed)), e.length) {
      this.resolveOffsets(e, t);
      let l = 0, c = 0;
      if (e.forEach((u, d) => {
        const f = u.cue.pre, p = u.cue.post, h = e[d - 1] || null, g = u.appendInPlace, m = p ? r : u.startOffset, v = u.duration, y = u.timelineOccupancy === Ko.Range ? v : 0, E = u.resumptionOffset, T = h?.startTime === m, S = m + u.cumulativeDuration;
        let w = g ? S + v : m + E;
        if (f || !p && m <= 0) {
          const L = c;
          c += y, u.timelineStart = S;
          const A = a;
          a += v, i.push({
            event: u,
            start: S,
            end: w,
            playout: {
              start: A,
              end: a
            },
            integrated: {
              start: L,
              end: c
            }
          });
        } else if (m <= r) {
          if (!T) {
            const _ = m - l;
            if (_ > Kf) {
              const R = l, I = c;
              c += _;
              const k = a;
              a += _;
              const M = {
                previousEvent: e[d - 1] || null,
                nextEvent: u,
                start: R,
                end: R + _,
                playout: {
                  start: k,
                  end: a
                },
                integrated: {
                  start: I,
                  end: c
                }
              };
              i.push(M);
            } else _ > 0 && h && (h.cumulativeDuration += _, i[i.length - 1].end = m);
          }
          p && (w = S), u.timelineStart = S;
          const L = c;
          c += y;
          const A = a;
          a += v, i.push({
            event: u,
            start: S,
            end: w,
            playout: {
              start: A,
              end: a
            },
            integrated: {
              start: L,
              end: c
            }
          });
        } else
          return;
        const b = u.resumeTime;
        p || b > r ? l = r : l = b;
      }), l < r) {
        var o;
        const u = l, d = c, f = r - l;
        c += f;
        const p = a;
        a += f, i.push({
          previousEvent: ((o = i[i.length - 1]) == null ? void 0 : o.event) || null,
          nextEvent: null,
          start: l,
          end: u + f,
          playout: {
            start: p,
            end: a
          },
          integrated: {
            start: d,
            end: c
          }
        });
      }
      this.setDurations(r, a, c);
    } else
      i.push({
        previousEvent: null,
        nextEvent: null,
        start: 0,
        end: r,
        playout: {
          start: 0,
          end: r
        },
        integrated: {
          start: 0,
          end: r
        }
      }), this.setDurations(r, r, r);
    return i;
  }
  setDurations(e, t, i) {
    this.durations = {
      primary: e,
      playout: t,
      integrated: i
    };
  }
  resolveOffsets(e, t) {
    const i = t.main.details, s = i.live ? 1 / 0 : i.edge;
    let r = 0, a = -1;
    e.forEach((o, l) => {
      const c = o.cue.pre, u = o.cue.post, d = c ? 0 : u ? s : o.startTime;
      this.updateAssetDurations(o), a === d ? o.cumulativeDuration = r : (r = 0, a = d), !u && o.snapOptions.in && (o.resumeAnchor = Rr(null, i.fragments, o.startOffset + o.resumptionOffset, 0, 0) || void 0), o.appendInPlace && !o.appendInPlaceStarted && (this.primaryCanResumeInPlaceAt(o, t) || (o.appendInPlace = !1)), !o.appendInPlace && l + 1 < e.length && e[l + 1].startTime - e[l].resumeTime < Kf && (e[l + 1].appendInPlace = !1, e[l + 1].appendInPlace && this.warn(`Could not change append strategy for abutting event ${o}`));
      const p = Z(o.resumeOffset) ? o.resumeOffset : o.duration;
      r += p;
    });
  }
  primaryCanResumeInPlaceAt(e, t) {
    const i = e.resumeTime, s = e.startTime + e.resumptionOffset;
    return Math.abs(i - s) > ln ? (this.log(`"${e.identifier}" resumption ${i} not aligned with estimated timeline end ${s}`), !1) : !Object.keys(t).some((a) => {
      const o = t[a].details, l = o.edge;
      if (i >= l)
        return this.log(`"${e.identifier}" resumption ${i} past ${a} playlist end ${l}`), !1;
      const c = Rr(null, o.fragments, i);
      if (!c)
        return this.log(`"${e.identifier}" resumption ${i} does not align with any fragments in ${a} playlist (${o.fragStart}-${o.fragmentEnd})`), !0;
      const u = a === "audio" ? 0.175 : 0;
      return Math.abs(c.start - i) < ln + u || Math.abs(c.end - i) < ln + u ? !1 : (this.log(`"${e.identifier}" resumption ${i} not aligned with ${a} fragment bounds (${c.start}-${c.end} sn: ${c.sn} cc: ${c.cc})`), !0);
    });
  }
  updateAssetDurations(e) {
    if (!e.assetListLoaded)
      return;
    const t = e.timelineStart;
    let i = 0, s = !1, r = !1;
    for (let a = 0; a < e.assetList.length; a++) {
      const o = e.assetList[a], l = t + i;
      o.startOffset = i, o.timelineStart = l, s || (s = o.duration === null), r || (r = !!o.error);
      const c = o.error ? 0 : o.duration || 0;
      i += c;
    }
    s && !r ? e.duration = Math.max(i, e.duration) : e.duration = i;
  }
  removeEvent(e) {
    e.reset(), delete this.eventMap[e.identifier];
  }
}
function Hi(n) {
  return `[${n.event ? '"' + n.event.identifier + '"' : "primary"}: ${n.start.toFixed(2)}-${n.end.toFixed(2)}]`;
}
class jS {
  constructor(e) {
    this.hls = void 0, this.hls = e;
  }
  destroy() {
    this.hls = null;
  }
  loadAssetList(e, t) {
    const i = e.assetListUrl;
    let s;
    try {
      s = om(i, this.hls.sessionId, e.baseUrl);
    } catch (f) {
      const p = this.assignAssetListError(e, H.ASSET_LIST_LOAD_ERROR, f, i);
      this.hls.trigger(x.ERROR, p);
      return;
    }
    t && s.protocol !== "data:" && s.searchParams.set("_HLS_start_offset", "" + t);
    const r = this.hls.config, a = r.loader, o = new a(r), l = {
      responseType: "json",
      url: s.href
    }, c = r.interstitialAssetListLoadPolicy.default, u = {
      loadPolicy: c,
      timeout: c.maxLoadTimeMs,
      maxRetry: 0,
      retryDelay: 0,
      maxRetryDelay: 0
    }, d = {
      onSuccess: (f, p, h, g) => {
        const m = f.data, v = m?.ASSETS;
        if (!Array.isArray(v)) {
          const y = this.assignAssetListError(e, H.ASSET_LIST_PARSING_ERROR, new Error("Invalid interstitial asset list"), h.url, p, g);
          this.hls.trigger(x.ERROR, y);
          return;
        }
        e.assetListResponse = m, this.hls.trigger(x.ASSET_LIST_LOADED, {
          event: e,
          assetListResponse: m,
          networkDetails: g
        });
      },
      onError: (f, p, h, g) => {
        const m = this.assignAssetListError(e, H.ASSET_LIST_LOAD_ERROR, new Error(`Error loading X-ASSET-LIST: HTTP status ${f.code} ${f.text} (${p.url})`), p.url, g, h);
        this.hls.trigger(x.ERROR, m);
      },
      onTimeout: (f, p, h) => {
        const g = this.assignAssetListError(e, H.ASSET_LIST_LOAD_TIMEOUT, new Error(`Timeout loading X-ASSET-LIST (${p.url})`), p.url, f, h);
        this.hls.trigger(x.ERROR, g);
      }
    };
    return o.load(l, u, d), this.hls.trigger(x.ASSET_LIST_LOADING, {
      event: e
    }), o;
  }
  assignAssetListError(e, t, i, s, r, a) {
    return e.error = i, {
      type: se.NETWORK_ERROR,
      details: t,
      fatal: !1,
      interstitial: e,
      url: s,
      error: i,
      networkDetails: a,
      stats: r
    };
  }
}
function Yf(n) {
  var e;
  n == null || (e = n.play()) == null || e.catch(() => {
  });
}
function ja(n, e) {
  return `[${n}] Advancing timeline position to ${e}`;
}
class QS extends Fi {
  constructor(e, t) {
    super("interstitials", e.logger), this.HlsPlayerClass = void 0, this.hls = void 0, this.assetListLoader = void 0, this.mediaSelection = null, this.altSelection = null, this.media = null, this.detachedData = null, this.requiredTracks = null, this.manager = null, this.playerQueue = [], this.bufferedPos = -1, this.timelinePos = -1, this.schedule = void 0, this.playingItem = null, this.bufferingItem = null, this.waitingItem = null, this.endedItem = null, this.playingAsset = null, this.endedAsset = null, this.bufferingAsset = null, this.shouldPlay = !1, this.onPlay = () => {
      this.shouldPlay = !0;
    }, this.onPause = () => {
      this.shouldPlay = !1;
    }, this.onSeeking = () => {
      const i = this.currentTime;
      if (i === void 0 || this.playbackDisabled || !this.schedule)
        return;
      const s = i - this.timelinePos;
      if (Math.abs(s) < 1 / 7056e5)
        return;
      const a = s <= -0.01;
      this.timelinePos = i, this.bufferedPos = i;
      const o = this.playingItem;
      if (!o) {
        this.checkBuffer();
        return;
      }
      if (a && this.schedule.resetErrorsInRange(i, i - s) && this.updateSchedule(!0), this.checkBuffer(), a && i < o.start || i >= o.end) {
        var l;
        const p = this.findItemIndex(o);
        let h = this.schedule.findItemIndexAtTime(i);
        if (h === -1 && (h = p + (a ? -1 : 1), this.log(`seeked ${a ? "back " : ""}to position not covered by schedule ${i} (resolving from ${p} to ${h})`)), !this.isInterstitial(o) && (l = this.media) != null && l.paused && (this.shouldPlay = !1), !a && h > p) {
          const g = this.schedule.findJumpRestrictedIndex(p + 1, h);
          if (g > p) {
            this.setSchedulePosition(g);
            return;
          }
        }
        this.setSchedulePosition(h);
        return;
      }
      const c = this.playingAsset;
      if (!c) {
        if (this.playingLastItem && this.isInterstitial(o)) {
          const p = o.event.assetList[0];
          p && (this.endedItem = this.playingItem, this.playingItem = null, this.setScheduleToAssetAtTime(i, p));
        }
        return;
      }
      const u = c.timelineStart, d = c.duration || 0;
      if (a && i < u || i >= u + d) {
        var f;
        (f = o.event) != null && f.appendInPlace && (this.clearAssetPlayers(o.event, o), this.flushFrontBuffer(i)), this.setScheduleToAssetAtTime(i, c);
      }
    }, this.onTimeupdate = () => {
      const i = this.currentTime;
      if (i === void 0 || this.playbackDisabled)
        return;
      if (i > this.timelinePos)
        this.timelinePos = i, i > this.bufferedPos && this.checkBuffer();
      else
        return;
      const s = this.playingItem;
      if (!s || this.playingLastItem)
        return;
      if (i >= s.end) {
        this.timelinePos = s.end;
        const o = this.findItemIndex(s);
        this.setSchedulePosition(o + 1);
      }
      const r = this.playingAsset;
      if (!r)
        return;
      const a = r.timelineStart + (r.duration || 0);
      i >= a && this.setScheduleToAssetAtTime(i, r);
    }, this.onScheduleUpdate = (i, s) => {
      const r = this.schedule;
      if (!r)
        return;
      const a = this.playingItem, o = r.events || [], l = r.items || [], c = r.durations, u = i.map((g) => g.identifier), d = !!(o.length || u.length);
      (d || s) && this.log(`INTERSTITIALS_UPDATED (${o.length}): ${o}
Schedule: ${l.map((g) => Hi(g))} pos: ${this.timelinePos}`), u.length && this.log(`Removed events ${u}`);
      let f = null, p = null;
      a && (f = this.updateItem(a, this.timelinePos), this.itemsMatch(a, f) ? this.playingItem = f : this.waitingItem = this.endedItem = null), this.waitingItem = this.updateItem(this.waitingItem), this.endedItem = this.updateItem(this.endedItem);
      const h = this.bufferingItem;
      if (h && (p = this.updateItem(h, this.bufferedPos), this.itemsMatch(h, p) ? this.bufferingItem = p : h.event && (this.bufferingItem = this.playingItem, this.clearInterstitial(h.event, null))), i.forEach((g) => {
        g.assetList.forEach((m) => {
          this.clearAssetPlayer(m.identifier, null);
        });
      }), this.playerQueue.forEach((g) => {
        if (g.interstitial.appendInPlace) {
          const m = g.assetItem.timelineStart, v = g.timelineOffset - m;
          if (v)
            try {
              g.timelineOffset = m;
            } catch (y) {
              Math.abs(v) > ln && this.warn(`${y} ("${g.assetId}" ${g.timelineOffset}->${m})`);
            }
        }
      }), d || s) {
        if (this.hls.trigger(x.INTERSTITIALS_UPDATED, {
          events: o.slice(0),
          schedule: l.slice(0),
          durations: c,
          removedIds: u
        }), this.isInterstitial(a) && u.includes(a.event.identifier)) {
          this.warn(`Interstitial "${a.event.identifier}" removed while playing`), this.primaryFallback(a.event);
          return;
        }
        a && this.trimInPlace(f, a), h && p !== f && this.trimInPlace(p, h), this.checkBuffer();
      }
    }, this.hls = e, this.HlsPlayerClass = t, this.assetListLoader = new jS(e), this.schedule = new XS(this.onScheduleUpdate, e.logger), this.registerListeners();
  }
  registerListeners() {
    const e = this.hls;
    e && (e.on(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(x.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(x.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this), e.on(x.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(x.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this), e.on(x.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this), e.on(x.ASSET_LIST_LOADED, this.onAssetListLoaded, this), e.on(x.BUFFER_APPENDED, this.onBufferAppended, this), e.on(x.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(x.BUFFERED_TO_END, this.onBufferedToEnd, this), e.on(x.MEDIA_ENDED, this.onMediaEnded, this), e.on(x.ERROR, this.onError, this), e.on(x.DESTROYING, this.onDestroying, this));
  }
  unregisterListeners() {
    const e = this.hls;
    e && (e.off(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(x.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(x.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this), e.off(x.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(x.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this), e.off(x.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this), e.off(x.ASSET_LIST_LOADED, this.onAssetListLoaded, this), e.off(x.BUFFER_CODECS, this.onBufferCodecs, this), e.off(x.BUFFER_APPENDED, this.onBufferAppended, this), e.off(x.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(x.BUFFERED_TO_END, this.onBufferedToEnd, this), e.off(x.MEDIA_ENDED, this.onMediaEnded, this), e.off(x.ERROR, this.onError, this), e.off(x.DESTROYING, this.onDestroying, this));
  }
  startLoad() {
    this.resumeBuffering();
  }
  stopLoad() {
    this.pauseBuffering();
  }
  resumeBuffering() {
    var e;
    (e = this.getBufferingPlayer()) == null || e.resumeBuffering();
  }
  pauseBuffering() {
    var e;
    (e = this.getBufferingPlayer()) == null || e.pauseBuffering();
  }
  destroy() {
    this.unregisterListeners(), this.stopLoad(), this.assetListLoader && this.assetListLoader.destroy(), this.emptyPlayerQueue(), this.clearScheduleState(), this.schedule && this.schedule.destroy(), this.media = this.detachedData = this.mediaSelection = this.requiredTracks = this.altSelection = this.schedule = this.manager = null, this.hls = this.HlsPlayerClass = this.log = null, this.assetListLoader = null, this.onPlay = this.onPause = this.onSeeking = this.onTimeupdate = null, this.onScheduleUpdate = null;
  }
  onDestroying() {
    const e = this.primaryMedia || this.media;
    e && this.removeMediaListeners(e);
  }
  removeMediaListeners(e) {
    ti(e, "play", this.onPlay), ti(e, "pause", this.onPause), ti(e, "seeking", this.onSeeking), ti(e, "timeupdate", this.onTimeupdate);
  }
  onMediaAttaching(e, t) {
    const i = this.media = t.media;
    Zt(i, "seeking", this.onSeeking), Zt(i, "timeupdate", this.onTimeupdate), Zt(i, "play", this.onPlay), Zt(i, "pause", this.onPause);
  }
  onMediaAttached(e, t) {
    const i = this.effectivePlayingItem, s = this.detachedData;
    if (this.detachedData = null, i === null)
      this.checkStart();
    else if (!s) {
      this.clearScheduleState();
      const r = this.findItemIndex(i);
      this.setSchedulePosition(r);
    }
  }
  clearScheduleState() {
    this.log("clear schedule state"), this.playingItem = this.bufferingItem = this.waitingItem = this.endedItem = this.playingAsset = this.endedAsset = this.bufferingAsset = null;
  }
  onMediaDetaching(e, t) {
    const i = !!t.transferMedia, s = this.media;
    if (this.media = null, !i && (s && this.removeMediaListeners(s), this.detachedData)) {
      const r = this.getBufferingPlayer();
      r && (this.log(`Removing schedule state for detachedData and ${r}`), this.playingAsset = this.endedAsset = this.bufferingAsset = this.bufferingItem = this.waitingItem = this.detachedData = null, r.detachMedia()), this.shouldPlay = !1;
    }
  }
  get interstitialsManager() {
    if (!this.hls)
      return null;
    if (this.manager)
      return this.manager;
    const e = this, t = () => e.bufferingItem || e.waitingItem, i = (d) => d && e.getAssetPlayer(d.identifier), s = (d, f, p, h, g) => {
      if (d) {
        let m = d[f].start;
        const v = d.event;
        if (v) {
          if (f === "playout" || v.timelineOccupancy !== Ko.Point) {
            const y = i(p);
            y?.interstitial === v && (m += y.assetItem.startOffset + y[g]);
          }
        } else {
          const y = h === "bufferedPos" ? a() : e[h];
          m += y - d.start;
        }
        return m;
      }
      return 0;
    }, r = (d, f) => {
      var p;
      if (d !== 0 && f !== "primary" && (p = e.schedule) != null && p.length) {
        var h;
        const g = e.schedule.findItemIndexAtTime(d), m = (h = e.schedule.items) == null ? void 0 : h[g];
        if (m) {
          const v = m[f].start - m.start;
          return d + v;
        }
      }
      return d;
    }, a = () => {
      const d = e.bufferedPos;
      return d === Number.MAX_VALUE ? o("primary") : Math.max(d, 0);
    }, o = (d) => {
      var f, p;
      return (f = e.primaryDetails) != null && f.live ? e.primaryDetails.edge : ((p = e.schedule) == null ? void 0 : p.durations[d]) || 0;
    }, l = (d, f) => {
      var p, h;
      const g = e.effectivePlayingItem;
      if (g != null && (p = g.event) != null && p.restrictions.skip || !e.schedule)
        return;
      e.log(`seek to ${d} "${f}"`);
      const m = e.effectivePlayingItem, v = e.schedule.findItemIndexAtTime(d, f), y = (h = e.schedule.items) == null ? void 0 : h[v], E = e.getBufferingPlayer(), T = E?.interstitial, S = T?.appendInPlace, w = m && e.itemsMatch(m, y);
      if (m && (S || w)) {
        const b = i(e.playingAsset), L = b?.media || e.primaryMedia;
        if (L) {
          const A = f === "primary" ? L.currentTime : s(m, f, e.playingAsset, "timelinePos", "currentTime"), _ = d - A, R = (S ? A : L.currentTime) + _;
          if (R >= 0 && (!b || S || R <= b.duration)) {
            L.currentTime = R;
            return;
          }
        }
      }
      if (y) {
        let b = d;
        if (f !== "primary") {
          const A = y[f].start, _ = d - A;
          b = y.start + _;
        }
        const L = !e.isInterstitial(y);
        if ((!e.isInterstitial(m) || m.event.appendInPlace) && (L || y.event.appendInPlace)) {
          const A = e.media || (S ? E?.media : null);
          A && (A.currentTime = b);
        } else if (m) {
          const A = e.findItemIndex(m);
          if (v > A) {
            const R = e.schedule.findJumpRestrictedIndex(A + 1, v);
            if (R > A) {
              e.setSchedulePosition(R);
              return;
            }
          }
          let _ = 0;
          if (L)
            e.timelinePos = b, e.checkBuffer();
          else {
            const R = y.event.assetList, I = d - (y[f] || y).start;
            for (let k = R.length; k--; ) {
              const M = R[k];
              if (M.duration && I >= M.startOffset && I < M.startOffset + M.duration) {
                _ = k;
                break;
              }
            }
          }
          e.setSchedulePosition(v, _);
        }
      }
    }, c = () => {
      const d = e.effectivePlayingItem;
      if (e.isInterstitial(d))
        return d;
      const f = t();
      return e.isInterstitial(f) ? f : null;
    }, u = {
      get bufferedEnd() {
        const d = t(), f = e.bufferingItem;
        if (f && f === d) {
          var p;
          return s(f, "playout", e.bufferingAsset, "bufferedPos", "bufferedEnd") - f.playout.start || ((p = e.bufferingAsset) == null ? void 0 : p.startOffset) || 0;
        }
        return 0;
      },
      get currentTime() {
        const d = c(), f = e.effectivePlayingItem;
        return f && f === d ? s(f, "playout", e.effectivePlayingAsset, "timelinePos", "currentTime") - f.playout.start : 0;
      },
      set currentTime(d) {
        const f = c(), p = e.effectivePlayingItem;
        p && p === f && l(d + p.playout.start, "playout");
      },
      get duration() {
        const d = c();
        return d ? d.playout.end - d.playout.start : 0;
      },
      get assetPlayers() {
        var d;
        const f = (d = c()) == null ? void 0 : d.event.assetList;
        return f ? f.map((p) => e.getAssetPlayer(p.identifier)) : [];
      },
      get playingIndex() {
        var d;
        const f = (d = c()) == null ? void 0 : d.event;
        return f && e.effectivePlayingAsset ? f.findAssetIndex(e.effectivePlayingAsset) : -1;
      },
      get scheduleItem() {
        return c();
      }
    };
    return this.manager = {
      get events() {
        var d;
        return ((d = e.schedule) == null || (d = d.events) == null ? void 0 : d.slice(0)) || [];
      },
      get schedule() {
        var d;
        return ((d = e.schedule) == null || (d = d.items) == null ? void 0 : d.slice(0)) || [];
      },
      get interstitialPlayer() {
        return c() ? u : null;
      },
      get playerQueue() {
        return e.playerQueue.slice(0);
      },
      get bufferingAsset() {
        return e.bufferingAsset;
      },
      get bufferingItem() {
        return t();
      },
      get bufferingIndex() {
        const d = t();
        return e.findItemIndex(d);
      },
      get playingAsset() {
        return e.effectivePlayingAsset;
      },
      get playingItem() {
        return e.effectivePlayingItem;
      },
      get playingIndex() {
        const d = e.effectivePlayingItem;
        return e.findItemIndex(d);
      },
      primary: {
        get bufferedEnd() {
          return a();
        },
        get currentTime() {
          const d = e.timelinePos;
          return d > 0 ? d : 0;
        },
        set currentTime(d) {
          l(d, "primary");
        },
        get duration() {
          return o("primary");
        },
        get seekableStart() {
          var d;
          return ((d = e.primaryDetails) == null ? void 0 : d.fragmentStart) || 0;
        }
      },
      integrated: {
        get bufferedEnd() {
          return s(t(), "integrated", e.bufferingAsset, "bufferedPos", "bufferedEnd");
        },
        get currentTime() {
          return s(e.effectivePlayingItem, "integrated", e.effectivePlayingAsset, "timelinePos", "currentTime");
        },
        set currentTime(d) {
          l(d, "integrated");
        },
        get duration() {
          return o("integrated");
        },
        get seekableStart() {
          var d;
          return r(((d = e.primaryDetails) == null ? void 0 : d.fragmentStart) || 0, "integrated");
        }
      },
      skip: () => {
        const d = e.effectivePlayingItem, f = d?.event;
        if (f && !f.restrictions.skip) {
          const p = e.findItemIndex(d);
          if (f.appendInPlace) {
            const h = d.playout.start + d.event.duration;
            l(h + 1e-3, "playout");
          } else
            e.advanceAfterAssetEnded(f, p, 1 / 0);
        }
      }
    };
  }
  // Schedule getters
  get effectivePlayingItem() {
    return this.waitingItem || this.playingItem || this.endedItem;
  }
  get effectivePlayingAsset() {
    return this.playingAsset || this.endedAsset;
  }
  get playingLastItem() {
    var e;
    const t = this.playingItem, i = (e = this.schedule) == null ? void 0 : e.items;
    return !this.playbackStarted || !t || !i ? !1 : this.findItemIndex(t) === i.length - 1;
  }
  get playbackStarted() {
    return this.effectivePlayingItem !== null;
  }
  // Media getters and event callbacks
  get currentTime() {
    var e, t;
    if (this.mediaSelection === null)
      return;
    const i = this.waitingItem || this.playingItem;
    if (this.isInterstitial(i) && !i.event.appendInPlace)
      return;
    let s = this.media;
    !s && (e = this.bufferingItem) != null && (e = e.event) != null && e.appendInPlace && (s = this.primaryMedia);
    const r = (t = s) == null ? void 0 : t.currentTime;
    if (!(r === void 0 || !Z(r)))
      return r;
  }
  get primaryMedia() {
    var e;
    return this.media || ((e = this.detachedData) == null ? void 0 : e.media) || null;
  }
  isInterstitial(e) {
    return !!(e != null && e.event);
  }
  retreiveMediaSource(e, t) {
    const i = this.getAssetPlayer(e);
    i && this.transferMediaFromPlayer(i, t);
  }
  transferMediaFromPlayer(e, t) {
    const i = e.interstitial.appendInPlace, s = e.media;
    if (i && s === this.primaryMedia) {
      if (this.bufferingAsset = null, (!t || this.isInterstitial(t) && !t.event.appendInPlace) && t && s) {
        this.detachedData = {
          media: s
        };
        return;
      }
      const r = e.transferMedia();
      this.log(`transfer MediaSource from ${e} ${Ge(r)}`), this.detachedData = r;
    } else t && s && (this.shouldPlay || (this.shouldPlay = !s.paused));
  }
  transferMediaTo(e, t) {
    var i, s;
    if (e.media === t)
      return;
    let r = null;
    const a = this.hls, o = e !== a, l = o && e.interstitial.appendInPlace, c = (i = this.detachedData) == null ? void 0 : i.mediaSource;
    let u;
    if (a.media)
      l && (r = a.transferMedia(), this.detachedData = r), u = "Primary";
    else if (c) {
      const h = this.getBufferingPlayer();
      h ? (r = h.transferMedia(), u = `${h}`) : u = "detached MediaSource";
    } else
      u = "detached media";
    if (!r) {
      if (c)
        r = this.detachedData, this.log(`using detachedData: MediaSource ${Ge(r)}`);
      else if (!this.detachedData || a.media === t) {
        const h = this.playerQueue;
        h.length > 1 && h.forEach((g) => {
          if (o && g.interstitial.appendInPlace !== l) {
            const m = g.interstitial;
            this.clearInterstitial(g.interstitial, null), m.appendInPlace = !1, m.appendInPlace && this.warn(`Could not change append strategy for queued assets ${m}`);
          }
        }), this.hls.detachMedia(), this.detachedData = {
          media: t
        };
      }
    }
    const d = r && "mediaSource" in r && ((s = r.mediaSource) == null ? void 0 : s.readyState) !== "closed", f = d && r ? r : t;
    this.log(`${d ? "transfering MediaSource" : "attaching media"} to ${o ? e : "Primary"} from ${u} (media.currentTime: ${t.currentTime})`);
    const p = this.schedule;
    if (f === r && p) {
      const h = o && e.assetId === p.assetIdAtEnd;
      f.overrides = {
        duration: p.duration,
        endOfStream: !o || h,
        cueRemoval: !o
      };
    }
    e.attachMedia(f);
  }
  onInterstitialCueEnter() {
    this.onTimeupdate();
  }
  // Scheduling methods
  checkStart() {
    const e = this.schedule, t = e?.events;
    if (!t || this.playbackDisabled || !this.media)
      return;
    this.bufferedPos === -1 && (this.bufferedPos = 0);
    const i = this.timelinePos, s = this.effectivePlayingItem;
    if (i === -1) {
      const r = this.hls.startPosition;
      if (this.log(ja("checkStart", r)), this.timelinePos = r, t.length && t[0].cue.pre) {
        const a = e.findEventIndex(t[0].identifier);
        this.setSchedulePosition(a);
      } else if (r >= 0 || !this.primaryLive) {
        const a = this.timelinePos = r > 0 ? r : 0, o = e.findItemIndexAtTime(a);
        this.setSchedulePosition(o);
      }
    } else if (s && !this.playingItem) {
      const r = e.findItemIndex(s);
      this.setSchedulePosition(r);
    }
  }
  advanceAssetBuffering(e, t) {
    const i = e.event, s = i.findAssetIndex(t), r = Bl(i, s);
    if (!i.isAssetPastPlayoutLimit(r))
      this.bufferedToEvent(e, r);
    else if (this.schedule) {
      var a;
      const o = (a = this.schedule.items) == null ? void 0 : a[this.findItemIndex(e) + 1];
      o && this.bufferedToItem(o);
    }
  }
  advanceAfterAssetEnded(e, t, i) {
    const s = Bl(e, i);
    if (e.isAssetPastPlayoutLimit(s)) {
      if (this.schedule) {
        const r = this.schedule.items;
        if (r) {
          const a = t + 1, o = r.length;
          if (a >= o) {
            this.setSchedulePosition(-1);
            return;
          }
          const l = e.resumeTime;
          this.timelinePos < l && (this.log(ja("advanceAfterAssetEnded", l)), this.timelinePos = l, e.appendInPlace && this.advanceInPlace(l), this.checkBuffer(this.bufferedPos < l)), this.setSchedulePosition(a);
        }
      }
    } else {
      if (e.appendInPlace) {
        const r = e.assetList[s];
        r && this.advanceInPlace(r.timelineStart);
      }
      this.setSchedulePosition(t, s);
    }
  }
  setScheduleToAssetAtTime(e, t) {
    const i = this.schedule;
    if (!i)
      return;
    const s = t.parentIdentifier, r = i.getEvent(s);
    if (r) {
      const a = i.findEventIndex(s), o = i.findAssetIndex(r, e);
      this.advanceAfterAssetEnded(r, a, o - 1);
    }
  }
  setSchedulePosition(e, t) {
    var i;
    const s = (i = this.schedule) == null ? void 0 : i.items;
    if (!s || this.playbackDisabled)
      return;
    const r = e >= 0 ? s[e] : null;
    this.log(`setSchedulePosition ${e}, ${t} (${r && Hi(r)}) pos: ${this.timelinePos}`);
    const a = this.waitingItem || this.playingItem, o = this.playingLastItem;
    if (this.isInterstitial(a)) {
      const u = a.event, d = this.playingAsset, f = d?.identifier, p = f ? this.getAssetPlayer(f) : null;
      if (p && f && (!this.eventItemsMatch(a, r) || t !== void 0 && f !== u.assetList[t].identifier)) {
        var l;
        const h = u.findAssetIndex(d);
        if (this.log(`INTERSTITIAL_ASSET_ENDED ${h + 1}/${u.assetList.length} ${Kr(d)}`), this.endedAsset = d, this.playingAsset = null, this.hls.trigger(x.INTERSTITIAL_ASSET_ENDED, {
          asset: d,
          assetListIndex: h,
          event: u,
          schedule: s.slice(0),
          scheduleIndex: e,
          player: p
        }), a !== this.playingItem) {
          this.itemsMatch(a, this.playingItem) && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
          !this.playingAsset && this.advanceAfterAssetEnded(u, this.findItemIndex(this.playingItem), h);
          return;
        }
        this.retreiveMediaSource(f, r), p.media && !((l = this.detachedData) != null && l.mediaSource) && p.detachMedia();
      }
      if (!this.eventItemsMatch(a, r) && (this.endedItem = a, this.playingItem = null, this.log(`INTERSTITIAL_ENDED ${u} ${Hi(a)}`), u.hasPlayed = !0, this.hls.trigger(x.INTERSTITIAL_ENDED, {
        event: u,
        schedule: s.slice(0),
        scheduleIndex: e
      }), u.cue.once)) {
        var c;
        this.updateSchedule();
        const h = (c = this.schedule) == null ? void 0 : c.items;
        if (r && h) {
          const g = this.findItemIndex(r);
          this.advanceSchedule(g, h, t, a, o);
        }
        return;
      }
    }
    this.advanceSchedule(e, s, t, a, o);
  }
  advanceSchedule(e, t, i, s, r) {
    const a = this.schedule;
    if (!a)
      return;
    const o = t[e] || null, l = this.primaryMedia, c = this.playerQueue;
    if (c.length && c.forEach((u) => {
      const d = u.interstitial, f = a.findEventIndex(d.identifier);
      (f < e || f > e + 1) && this.clearInterstitial(d, o);
    }), this.isInterstitial(o)) {
      this.timelinePos = Math.min(Math.max(this.timelinePos, o.start), o.end);
      const u = o.event;
      if (i === void 0) {
        i = a.findAssetIndex(u, this.timelinePos);
        const h = Bl(u, i - 1);
        if (u.isAssetPastPlayoutLimit(h) || u.appendInPlace && this.timelinePos === o.end) {
          this.advanceAfterAssetEnded(u, e, i);
          return;
        }
        i = h;
      }
      const d = this.waitingItem;
      this.assetsBuffered(o, l) || this.setBufferingItem(o);
      let f = this.preloadAssets(u, i);
      if (this.eventItemsMatch(o, d || s) || (this.waitingItem = o, this.log(`INTERSTITIAL_STARTED ${Hi(o)} ${u.appendInPlace ? "append in place" : ""}`), this.hls.trigger(x.INTERSTITIAL_STARTED, {
        event: u,
        schedule: t.slice(0),
        scheduleIndex: e
      })), !u.assetListLoaded) {
        this.log(`Waiting for ASSET-LIST to complete loading ${u}`);
        return;
      }
      if (u.assetListLoader && (u.assetListLoader.destroy(), u.assetListLoader = void 0), !l) {
        this.log(`Waiting for attachMedia to start Interstitial ${u}`);
        return;
      }
      this.waitingItem = this.endedItem = null, this.playingItem = o;
      const p = u.assetList[i];
      if (!p) {
        this.advanceAfterAssetEnded(u, e, i || 0);
        return;
      }
      if (f || (f = this.getAssetPlayer(p.identifier)), f === null || f.destroyed) {
        const h = u.assetList.length;
        this.warn(`asset ${i + 1}/${h} player destroyed ${u}`), f = this.createAssetPlayer(u, p, i), f.loadSource();
      }
      if (!this.eventItemsMatch(o, this.bufferingItem) && u.appendInPlace && this.isAssetBuffered(p))
        return;
      this.startAssetPlayer(f, i, t, e, l), this.shouldPlay && Yf(f.media);
    } else o ? (this.resumePrimary(o, e, s), this.shouldPlay && Yf(this.hls.media)) : r && this.isInterstitial(s) && (this.endedItem = null, this.playingItem = s, s.event.appendInPlace || this.attachPrimary(a.durations.primary, null));
  }
  get playbackDisabled() {
    return this.hls.config.enableInterstitialPlayback === !1;
  }
  get primaryDetails() {
    var e;
    return (e = this.mediaSelection) == null ? void 0 : e.main.details;
  }
  get primaryLive() {
    var e;
    return !!((e = this.primaryDetails) != null && e.live);
  }
  resumePrimary(e, t, i) {
    var s, r;
    if (this.playingItem = e, this.playingAsset = this.endedAsset = null, this.waitingItem = this.endedItem = null, this.bufferedToItem(e), this.log(`resuming ${Hi(e)}`), !((s = this.detachedData) != null && s.mediaSource)) {
      let o = this.timelinePos;
      (o < e.start || o >= e.end) && (o = this.getPrimaryResumption(e, t), this.log(ja("resumePrimary", o)), this.timelinePos = o), this.attachPrimary(o, e);
    }
    if (!i)
      return;
    const a = (r = this.schedule) == null ? void 0 : r.items;
    a && (this.log(`INTERSTITIALS_PRIMARY_RESUMED ${Hi(e)}`), this.hls.trigger(x.INTERSTITIALS_PRIMARY_RESUMED, {
      schedule: a.slice(0),
      scheduleIndex: t
    }), this.checkBuffer());
  }
  getPrimaryResumption(e, t) {
    const i = e.start;
    if (this.primaryLive) {
      const s = this.primaryDetails;
      if (t === 0)
        return this.hls.startPosition;
      if (s && (i < s.fragmentStart || i > s.edge))
        return this.hls.liveSyncPosition || -1;
    }
    return i;
  }
  isAssetBuffered(e) {
    const t = this.getAssetPlayer(e.identifier);
    return t != null && t.hls ? t.hls.bufferedToEnd : de.bufferInfo(this.primaryMedia, this.timelinePos, 0).end + 1 >= e.timelineStart + (e.duration || 0);
  }
  attachPrimary(e, t, i) {
    t ? this.setBufferingItem(t) : this.bufferingItem = this.playingItem, this.bufferingAsset = null;
    const s = this.primaryMedia;
    if (!s)
      return;
    const r = this.hls;
    r.media ? this.checkBuffer() : (this.transferMediaTo(r, s), i && this.startLoadingPrimaryAt(e, i)), i || (this.log(ja("attachPrimary", e)), this.timelinePos = e, this.startLoadingPrimaryAt(e, i));
  }
  startLoadingPrimaryAt(e, t) {
    var i;
    const s = this.hls;
    !s.loadingEnabled || !s.media || Math.abs((((i = s.mainForwardBufferInfo) == null ? void 0 : i.start) || s.media.currentTime) - e) > 0.5 ? s.startLoad(e, t) : s.bufferingEnabled || s.resumeBuffering();
  }
  // HLS.js event callbacks
  onManifestLoading() {
    var e;
    this.stopLoad(), (e = this.schedule) == null || e.reset(), this.emptyPlayerQueue(), this.clearScheduleState(), this.shouldPlay = !1, this.bufferedPos = this.timelinePos = -1, this.mediaSelection = this.altSelection = this.manager = this.requiredTracks = null, this.hls.off(x.BUFFER_CODECS, this.onBufferCodecs, this), this.hls.on(x.BUFFER_CODECS, this.onBufferCodecs, this);
  }
  onLevelUpdated(e, t) {
    if (t.level === -1 || !this.schedule)
      return;
    const i = this.hls.levels[t.level];
    if (!i.details)
      return;
    const s = Me(Me({}, this.mediaSelection || this.altSelection), {}, {
      main: i
    });
    this.mediaSelection = s, this.schedule.parseInterstitialDateRanges(s, this.hls.config.interstitialAppendInPlace), !this.effectivePlayingItem && this.schedule.items && this.checkStart();
  }
  onAudioTrackUpdated(e, t) {
    const i = this.hls.audioTracks[t.id], s = this.mediaSelection;
    if (!s) {
      this.altSelection = Me(Me({}, this.altSelection), {}, {
        audio: i
      });
      return;
    }
    const r = Me(Me({}, s), {}, {
      audio: i
    });
    this.mediaSelection = r;
  }
  onSubtitleTrackUpdated(e, t) {
    const i = this.hls.subtitleTracks[t.id], s = this.mediaSelection;
    if (!s) {
      this.altSelection = Me(Me({}, this.altSelection), {}, {
        subtitles: i
      });
      return;
    }
    const r = Me(Me({}, s), {}, {
      subtitles: i
    });
    this.mediaSelection = r;
  }
  onAudioTrackSwitching(e, t) {
    const i = tf(t);
    this.playerQueue.forEach(({
      hls: s
    }) => s && (s.setAudioOption(t) || s.setAudioOption(i)));
  }
  onSubtitleTrackSwitch(e, t) {
    const i = tf(t);
    this.playerQueue.forEach(({
      hls: s
    }) => s && (s.setSubtitleOption(t) || t.id !== -1 && s.setSubtitleOption(i)));
  }
  onBufferCodecs(e, t) {
    const i = t.tracks;
    i && (this.requiredTracks = i);
  }
  onBufferAppended(e, t) {
    this.checkBuffer();
  }
  onBufferFlushed(e, t) {
    const i = this.playingItem;
    if (i && !this.itemsMatch(i, this.bufferingItem) && !this.isInterstitial(i)) {
      const s = this.timelinePos;
      this.bufferedPos = s, this.checkBuffer();
    }
  }
  onBufferedToEnd(e) {
    if (!this.schedule)
      return;
    const t = this.schedule.events;
    if (this.bufferedPos < Number.MAX_VALUE && t) {
      for (let s = 0; s < t.length; s++) {
        const r = t[s];
        if (r.cue.post) {
          var i;
          const a = this.schedule.findEventIndex(r.identifier), o = (i = this.schedule.items) == null ? void 0 : i[a];
          this.isInterstitial(o) && this.eventItemsMatch(o, this.bufferingItem) && this.bufferedToItem(o, 0);
          break;
        }
      }
      this.bufferedPos = Number.MAX_VALUE;
    }
  }
  onMediaEnded(e) {
    const t = this.playingItem;
    if (!this.playingLastItem && t) {
      const i = this.findItemIndex(t);
      this.setSchedulePosition(i + 1);
    } else
      this.shouldPlay = !1;
  }
  updateItem(e, t) {
    var i;
    const s = (i = this.schedule) == null ? void 0 : i.items;
    if (e && s) {
      const r = this.findItemIndex(e, t);
      return s[r] || null;
    }
    return null;
  }
  trimInPlace(e, t) {
    if (this.isInterstitial(e) && e.event.appendInPlace && t.end - e.end > 0.25) {
      e.event.assetList.forEach((r, a) => {
        e.event.isAssetPastPlayoutLimit(a) && this.clearAssetPlayer(r.identifier, null);
      });
      const i = e.end + 0.25, s = de.bufferInfo(this.primaryMedia, i, 0);
      (s.end > i || (s.nextStart || 0) > i) && (this.log(`trim buffered interstitial ${Hi(e)} (was ${Hi(t)})`), this.attachPrimary(i, null, !0), this.flushFrontBuffer(i));
    }
  }
  itemsMatch(e, t) {
    return !!t && (e === t || e.event && t.event && this.eventItemsMatch(e, t) || !e.event && !t.event && this.findItemIndex(e) === this.findItemIndex(t));
  }
  eventItemsMatch(e, t) {
    var i;
    return !!t && (e === t || e.event.identifier === ((i = t.event) == null ? void 0 : i.identifier));
  }
  findItemIndex(e, t) {
    return e && this.schedule ? this.schedule.findItemIndex(e, t) : -1;
  }
  updateSchedule(e = !1) {
    var t;
    const i = this.mediaSelection;
    i && ((t = this.schedule) == null || t.updateSchedule(i, [], e));
  }
  // Schedule buffer control
  checkBuffer(e) {
    var t;
    const i = (t = this.schedule) == null ? void 0 : t.items;
    if (!i)
      return;
    const s = de.bufferInfo(this.primaryMedia, this.timelinePos, 0);
    e && (this.bufferedPos = this.timelinePos), e || (e = s.len < 1), this.updateBufferedPos(s.end, i, e);
  }
  updateBufferedPos(e, t, i) {
    const s = this.schedule, r = this.bufferingItem;
    if (this.bufferedPos > e || !s)
      return;
    if (t.length === 1 && this.itemsMatch(t[0], r)) {
      this.bufferedPos = e;
      return;
    }
    const a = this.playingItem, o = this.findItemIndex(a);
    let l = s.findItemIndexAtTime(e);
    if (this.bufferedPos < e) {
      var c;
      const u = this.findItemIndex(r), d = Math.min(u + 1, t.length - 1), f = t[d];
      if ((l === -1 && r && e >= r.end || (c = f.event) != null && c.appendInPlace && e + 0.01 >= f.start) && (l = d), this.isInterstitial(r)) {
        const p = r.event;
        if (d - o > 1 && p.appendInPlace === !1 || p.assetList.length === 0 && p.assetListLoader)
          return;
      }
      if (this.bufferedPos = e, l > u && l > o)
        this.bufferedToItem(f);
      else {
        const p = this.primaryDetails;
        this.primaryLive && p && e > p.edge - p.targetduration && f.start < p.edge + this.hls.config.interstitialLiveLookAhead && this.isInterstitial(f) && this.preloadAssets(f.event, 0);
      }
    } else i && a && !this.itemsMatch(a, r) && (l === o ? this.bufferedToItem(a) : l === o + 1 && this.bufferedToItem(t[l]));
  }
  assetsBuffered(e, t) {
    return e.event.assetList.length === 0 ? !1 : !e.event.assetList.some((s) => {
      const r = this.getAssetPlayer(s.identifier);
      return !(r != null && r.bufferedInPlaceToEnd(t));
    });
  }
  setBufferingItem(e) {
    const t = this.bufferingItem, i = this.schedule;
    if (!this.itemsMatch(e, t) && i) {
      const {
        items: s,
        events: r
      } = i;
      if (!s || !r)
        return t;
      const a = this.isInterstitial(e), o = this.getBufferingPlayer();
      this.bufferingItem = e, this.bufferedPos = Math.max(e.start, Math.min(e.end, this.timelinePos));
      const l = o ? o.remaining : t ? t.end - this.timelinePos : 0;
      if (this.log(`INTERSTITIALS_BUFFERED_TO_BOUNDARY ${Hi(e)}` + (t ? ` (${l.toFixed(2)} remaining)` : "")), !this.playbackDisabled)
        if (a) {
          const c = i.findAssetIndex(e.event, this.bufferedPos);
          e.event.assetList.forEach((u, d) => {
            const f = this.getAssetPlayer(u.identifier);
            f && (d === c && f.loadSource(), f.resumeBuffering());
          });
        } else
          this.hls.resumeBuffering(), this.playerQueue.forEach((c) => c.pauseBuffering());
      this.hls.trigger(x.INTERSTITIALS_BUFFERED_TO_BOUNDARY, {
        events: r.slice(0),
        schedule: s.slice(0),
        bufferingIndex: this.findItemIndex(e),
        playingIndex: this.findItemIndex(this.playingItem)
      });
    } else this.bufferingItem !== e && (this.bufferingItem = e);
    return t;
  }
  bufferedToItem(e, t = 0) {
    const i = this.setBufferingItem(e);
    if (!this.playbackDisabled) {
      if (this.isInterstitial(e))
        this.bufferedToEvent(e, t);
      else if (i !== null) {
        this.bufferingAsset = null;
        const s = this.detachedData;
        s ? s.mediaSource ? this.attachPrimary(e.start, e, !0) : this.preloadPrimary(e) : this.preloadPrimary(e);
      }
    }
  }
  preloadPrimary(e) {
    const t = this.findItemIndex(e), i = this.getPrimaryResumption(e, t);
    this.startLoadingPrimaryAt(i);
  }
  bufferedToEvent(e, t) {
    const i = e.event, s = i.assetList.length === 0 && !i.assetListLoader, r = i.cue.once;
    if (s || !r) {
      const a = this.preloadAssets(i, t);
      if (a != null && a.interstitial.appendInPlace) {
        const o = this.primaryMedia;
        o && this.bufferAssetPlayer(a, o);
      }
    }
  }
  preloadAssets(e, t) {
    const i = e.assetUrl, s = e.assetList.length, r = s === 0 && !e.assetListLoader, a = e.cue.once;
    if (r) {
      const l = e.timelineStart;
      if (e.appendInPlace) {
        var o;
        const f = this.playingItem;
        !this.isInterstitial(f) && (f == null || (o = f.nextEvent) == null ? void 0 : o.identifier) === e.identifier && this.flushFrontBuffer(l + 0.25);
      }
      let c, u = 0;
      if (!this.playingItem && this.primaryLive && (u = this.hls.startPosition, u === -1 && (u = this.hls.liveSyncPosition || 0)), u && !(e.cue.pre || e.cue.post)) {
        const f = u - l;
        f > 0 && (c = Math.round(f * 1e3) / 1e3);
      }
      if (this.log(`Load interstitial asset ${t + 1}/${i ? 1 : s} ${e}${c ? ` live-start: ${u} start-offset: ${c}` : ""}`), i)
        return this.createAsset(e, 0, 0, l, e.duration, i);
      const d = this.assetListLoader.loadAssetList(e, c);
      d && (e.assetListLoader = d);
    } else if (!a && s) {
      for (let c = t; c < s; c++) {
        const u = e.assetList[c], d = this.getAssetPlayerQueueIndex(u.identifier);
        (d === -1 || this.playerQueue[d].destroyed) && !u.error && this.createAssetPlayer(e, u, c);
      }
      const l = e.assetList[t];
      if (l) {
        const c = this.getAssetPlayer(l.identifier);
        return c && c.loadSource(), c;
      }
    }
    return null;
  }
  flushFrontBuffer(e) {
    const t = this.requiredTracks;
    if (!t)
      return;
    this.log(`Removing front buffer starting at ${e}`), Object.keys(t).forEach((s) => {
      this.hls.trigger(x.BUFFER_FLUSHING, {
        startOffset: e,
        endOffset: 1 / 0,
        type: s
      });
    });
  }
  // Interstitial Asset Player control
  getAssetPlayerQueueIndex(e) {
    const t = this.playerQueue;
    for (let i = 0; i < t.length; i++)
      if (e === t[i].assetId)
        return i;
    return -1;
  }
  getAssetPlayer(e) {
    const t = this.getAssetPlayerQueueIndex(e);
    return this.playerQueue[t] || null;
  }
  getBufferingPlayer() {
    const {
      playerQueue: e,
      primaryMedia: t
    } = this;
    if (t) {
      for (let i = 0; i < e.length; i++)
        if (e[i].media === t)
          return e[i];
    }
    return null;
  }
  createAsset(e, t, i, s, r, a) {
    const o = {
      parentIdentifier: e.identifier,
      identifier: WS(e, a, t),
      duration: r,
      startOffset: i,
      timelineStart: s,
      uri: a
    };
    return this.createAssetPlayer(e, o, t);
  }
  createAssetPlayer(e, t, i) {
    const s = this.hls, r = s.userConfig;
    let a = r.videoPreference;
    const o = s.loadLevelObj || s.levels[s.currentLevel];
    (a || o) && (a = Fe({}, a), o.videoCodec && (a.videoCodec = o.videoCodec), o.videoRange && (a.allowedVideoRanges = [o.videoRange]));
    const l = s.audioTracks[s.audioTrack], c = s.subtitleTracks[s.subtitleTrack];
    let u = 0;
    if (this.primaryLive || e.appendInPlace) {
      const T = this.timelinePos - t.timelineStart;
      if (T > 1) {
        const S = t.duration;
        S && T < S && (u = T);
      }
    }
    const d = t.identifier, f = Me(Me({}, r), {}, {
      maxMaxBufferLength: Math.min(180, s.config.maxMaxBufferLength),
      autoStartLoad: !0,
      startFragPrefetch: !0,
      primarySessionId: s.sessionId,
      assetPlayerId: d,
      abrEwmaDefaultEstimate: s.bandwidthEstimate,
      interstitialsController: void 0,
      startPosition: u,
      liveDurationInfinity: !1,
      testBandwidth: !1,
      videoPreference: a,
      audioPreference: l || r.audioPreference,
      subtitlePreference: c || r.subtitlePreference
    });
    e.appendInPlace && (e.appendInPlaceStarted = !0, t.timelineStart && (f.timelineOffset = t.timelineStart));
    const p = f.cmcd;
    p != null && p.sessionId && p.contentId && (f.cmcd = Fe({}, p, {
      contentId: ea(t.uri)
    })), this.getAssetPlayer(d) && this.warn(`Duplicate date range identifier ${e} and asset ${d}`);
    const h = new qS(this.HlsPlayerClass, f, e, t);
    this.playerQueue.push(h), e.assetList[i] = t;
    let g = !0;
    const m = (T) => {
      if (T.live) {
        var S;
        const L = new Error(`Interstitials MUST be VOD assets ${e}`), A = {
          fatal: !0,
          type: se.OTHER_ERROR,
          details: H.INTERSTITIAL_ASSET_ITEM_ERROR,
          error: L
        }, _ = ((S = this.schedule) == null ? void 0 : S.findEventIndex(e.identifier)) || -1;
        this.handleAssetItemError(A, e, _, i, L.message);
        return;
      }
      const w = T.edge - T.fragmentStart, b = t.duration;
      (g || b === null || w > b) && (g = !1, this.log(`Interstitial asset "${d}" duration change ${b} > ${w}`), t.duration = w, this.updateSchedule());
    };
    h.on(x.LEVEL_UPDATED, (T, {
      details: S
    }) => m(S)), h.on(x.LEVEL_PTS_UPDATED, (T, {
      details: S
    }) => m(S)), h.on(x.EVENT_CUE_ENTER, () => this.onInterstitialCueEnter());
    const v = (T, S) => {
      const w = this.getAssetPlayer(d);
      if (w && S.tracks) {
        w.off(x.BUFFER_CODECS, v), w.tracks = S.tracks;
        const b = this.primaryMedia;
        this.bufferingAsset === w.assetItem && b && !w.media && this.bufferAssetPlayer(w, b);
      }
    };
    h.on(x.BUFFER_CODECS, v);
    const y = () => {
      var T;
      const S = this.getAssetPlayer(d);
      if (this.log(`buffered to end of asset ${S}`), !S || !this.schedule)
        return;
      const w = this.schedule.findEventIndex(e.identifier), b = (T = this.schedule.items) == null ? void 0 : T[w];
      this.isInterstitial(b) && this.advanceAssetBuffering(b, t);
    };
    h.on(x.BUFFERED_TO_END, y);
    const E = (T) => () => {
      if (!this.getAssetPlayer(d) || !this.schedule)
        return;
      this.shouldPlay = !0;
      const w = this.schedule.findEventIndex(e.identifier);
      this.advanceAfterAssetEnded(e, w, T);
    };
    return h.once(x.MEDIA_ENDED, E(i)), h.once(x.PLAYOUT_LIMIT_REACHED, E(1 / 0)), h.on(x.ERROR, (T, S) => {
      if (!this.schedule)
        return;
      const w = this.getAssetPlayer(d);
      if (S.details === H.BUFFER_STALLED_ERROR) {
        if (w != null && w.appendInPlace) {
          this.handleInPlaceStall(e);
          return;
        }
        this.onTimeupdate(), this.checkBuffer(!0);
        return;
      }
      this.handleAssetItemError(S, e, this.schedule.findEventIndex(e.identifier), i, `Asset player error ${S.error} ${e}`);
    }), h.on(x.DESTROYING, () => {
      if (!this.getAssetPlayer(d) || !this.schedule)
        return;
      const S = new Error(`Asset player destroyed unexpectedly ${d}`), w = {
        fatal: !0,
        type: se.OTHER_ERROR,
        details: H.INTERSTITIAL_ASSET_ITEM_ERROR,
        error: S
      };
      this.handleAssetItemError(w, e, this.schedule.findEventIndex(e.identifier), i, S.message);
    }), this.log(`INTERSTITIAL_ASSET_PLAYER_CREATED ${Kr(t)}`), this.hls.trigger(x.INTERSTITIAL_ASSET_PLAYER_CREATED, {
      asset: t,
      assetListIndex: i,
      event: e,
      player: h
    }), h;
  }
  clearInterstitial(e, t) {
    this.clearAssetPlayers(e, t), e.reset();
  }
  clearAssetPlayers(e, t) {
    e.assetList.forEach((i) => {
      this.clearAssetPlayer(i.identifier, t);
    });
  }
  resetAssetPlayer(e) {
    const t = this.getAssetPlayerQueueIndex(e);
    if (t !== -1) {
      this.log(`reset asset player "${e}" after error`);
      const i = this.playerQueue[t];
      this.transferMediaFromPlayer(i, null), i.resetDetails();
    }
  }
  clearAssetPlayer(e, t) {
    const i = this.getAssetPlayerQueueIndex(e);
    if (i !== -1) {
      const s = this.playerQueue[i];
      this.log(`clear ${s} toSegment: ${t && Hi(t)}`), this.transferMediaFromPlayer(s, t), this.playerQueue.splice(i, 1), s.destroy();
    }
  }
  emptyPlayerQueue() {
    let e;
    for (; e = this.playerQueue.pop(); )
      e.destroy();
    this.playerQueue = [];
  }
  startAssetPlayer(e, t, i, s, r) {
    const {
      interstitial: a,
      assetItem: o,
      assetId: l
    } = e, c = a.assetList.length, u = this.playingAsset;
    this.endedAsset = null, this.playingAsset = o, (!u || u.identifier !== l) && (u && (this.clearAssetPlayer(u.identifier, i[s]), delete u.error), this.log(`INTERSTITIAL_ASSET_STARTED ${t + 1}/${c} ${Kr(o)}`), this.hls.trigger(x.INTERSTITIAL_ASSET_STARTED, {
      asset: o,
      assetListIndex: t,
      event: a,
      schedule: i.slice(0),
      scheduleIndex: s,
      player: e
    })), this.bufferAssetPlayer(e, r);
  }
  bufferAssetPlayer(e, t) {
    var i, s;
    if (!this.schedule)
      return;
    const {
      interstitial: r,
      assetItem: a
    } = e, o = this.schedule.findEventIndex(r.identifier), l = (i = this.schedule.items) == null ? void 0 : i[o];
    if (!l)
      return;
    e.loadSource(), this.setBufferingItem(l), this.bufferingAsset = a;
    const c = this.getBufferingPlayer();
    if (c === e)
      return;
    const u = r.appendInPlace;
    if (u && c?.interstitial.appendInPlace === !1)
      return;
    const d = c?.tracks || ((s = this.detachedData) == null ? void 0 : s.tracks) || this.requiredTracks;
    if (u && a !== this.playingAsset) {
      if (!e.tracks) {
        this.log(`Waiting for track info before buffering ${e}`);
        return;
      }
      if (d && !Vp(d, e.tracks)) {
        const f = new Error(`Asset ${Kr(a)} SourceBuffer tracks ('${Object.keys(e.tracks)}') are not compatible with primary content tracks ('${Object.keys(d)}')`), p = {
          fatal: !0,
          type: se.OTHER_ERROR,
          details: H.INTERSTITIAL_ASSET_ITEM_ERROR,
          error: f
        }, h = r.findAssetIndex(a);
        this.handleAssetItemError(p, r, o, h, f.message);
        return;
      }
    }
    this.transferMediaTo(e, t);
  }
  handleInPlaceStall(e) {
    const t = this.schedule, i = this.primaryMedia;
    if (!t || !i)
      return;
    const s = i.currentTime, r = t.findAssetIndex(e, s), a = e.assetList[r];
    if (a) {
      const o = this.getAssetPlayer(a.identifier);
      if (o) {
        const l = o.currentTime || s - a.timelineStart, c = o.duration - l;
        if (this.warn(`Stalled at ${l} of ${l + c} in ${o} ${e} (media.currentTime: ${s})`), l && (c / i.playbackRate < 0.5 || o.bufferedInPlaceToEnd(i)) && o.hls) {
          const u = t.findEventIndex(e.identifier);
          this.advanceAfterAssetEnded(e, u, r);
        }
      }
    }
  }
  advanceInPlace(e) {
    const t = this.primaryMedia;
    t && t.currentTime < e && (t.currentTime = e);
  }
  handleAssetItemError(e, t, i, s, r) {
    if (e.details === H.BUFFER_STALLED_ERROR)
      return;
    const a = t.assetList[s] || null;
    if (this.warn(`INTERSTITIAL_ASSET_ERROR ${a && Kr(a)} ${e.error}`), !this.schedule)
      return;
    const o = a?.identifier || "", l = this.getAssetPlayerQueueIndex(o), c = this.playerQueue[l] || null, u = this.schedule.items, d = Fe({}, e, {
      fatal: !1,
      errorAction: nn(!0),
      asset: a,
      assetListIndex: s,
      event: t,
      schedule: u,
      scheduleIndex: i,
      player: c
    });
    if (this.hls.trigger(x.INTERSTITIAL_ASSET_ERROR, d), !e.fatal)
      return;
    const f = this.playingAsset, p = this.bufferingAsset, h = new Error(r);
    if (a && (this.clearAssetPlayer(o, null), a.error = h), !t.assetList.some((g) => !g.error))
      t.error = h;
    else
      for (let g = s; g < t.assetList.length; g++)
        this.resetAssetPlayer(t.assetList[g].identifier);
    this.updateSchedule(!0), t.error ? this.primaryFallback(t) : f && f.identifier === o ? this.advanceAfterAssetEnded(t, i, s) : p && p.identifier === o && this.isInterstitial(this.bufferingItem) && this.advanceAssetBuffering(this.bufferingItem, p);
  }
  primaryFallback(e) {
    const t = e.timelineStart, i = this.effectivePlayingItem;
    let s = this.timelinePos;
    if (i) {
      this.log(`Fallback to primary from event "${e.identifier}" start: ${t} pos: ${s} playing: ${Hi(i)} error: ${e.error}`), s === -1 && (s = this.hls.startPosition);
      const a = this.updateItem(i, s);
      this.itemsMatch(i, a) && this.clearInterstitial(e, null), e.appendInPlace && (this.attachPrimary(t, null), this.flushFrontBuffer(t));
    } else if (s === -1) {
      this.checkStart();
      return;
    }
    if (!this.schedule)
      return;
    const r = this.schedule.findItemIndexAtTime(s);
    this.setSchedulePosition(r);
  }
  // Asset List loading
  onAssetListLoaded(e, t) {
    var i, s;
    const r = t.event, a = r.identifier, o = t.assetListResponse.ASSETS;
    if (!((i = this.schedule) != null && i.hasEvent(a)))
      return;
    const l = r.timelineStart, c = r.duration;
    let u = 0;
    o.forEach((g, m) => {
      const v = parseFloat(g.DURATION);
      this.createAsset(r, m, u, l + u, v, g.URI), u += v;
    }), r.duration = u, this.log(`Loaded asset-list with duration: ${u} (was: ${c}) ${r}`);
    const d = this.waitingItem, f = d?.event.identifier === a;
    this.updateSchedule();
    const p = (s = this.bufferingItem) == null ? void 0 : s.event;
    if (f) {
      var h;
      const g = this.schedule.findEventIndex(a), m = (h = this.schedule.items) == null ? void 0 : h[g];
      if (m) {
        if (!this.playingItem && this.timelinePos > m.end && this.schedule.findItemIndexAtTime(this.timelinePos) !== g) {
          r.error = new Error(`Interstitial ${o.length ? "no longer within playback range" : "asset-list is empty"} ${this.timelinePos} ${r}`), this.log(r.error.message), this.updateSchedule(!0), this.primaryFallback(r);
          return;
        }
        this.setBufferingItem(m);
      }
      this.setSchedulePosition(g);
    } else if (p?.identifier === a) {
      const g = r.assetList[0];
      if (g) {
        const m = this.getAssetPlayer(g.identifier);
        if (p.appendInPlace) {
          const v = this.primaryMedia;
          m && v && this.bufferAssetPlayer(m, v);
        } else m && m.loadSource();
      }
    }
  }
  onError(e, t) {
    if (this.schedule)
      switch (t.details) {
        case H.ASSET_LIST_PARSING_ERROR:
        case H.ASSET_LIST_LOAD_ERROR:
        case H.ASSET_LIST_LOAD_TIMEOUT: {
          const i = t.interstitial;
          i && (this.updateSchedule(!0), this.primaryFallback(i));
          break;
        }
        case H.BUFFER_STALLED_ERROR: {
          const i = this.endedItem || this.waitingItem || this.playingItem;
          if (this.isInterstitial(i) && i.event.appendInPlace) {
            this.handleInPlaceStall(i.event);
            return;
          }
          this.log(`Primary player stall @${this.timelinePos} bufferedPos: ${this.bufferedPos}`), this.onTimeupdate(), this.checkBuffer(!0);
          break;
        }
      }
  }
}
const qf = 500;
class ZS extends Uu {
  constructor(e, t, i) {
    super(e, t, i, "subtitle-stream-controller", te.SUBTITLE), this.currentTrackId = -1, this.tracksBuffered = [], this.mainDetails = null, this.registerListeners();
  }
  onHandlerDestroying() {
    this.unregisterListeners(), super.onHandlerDestroying(), this.mainDetails = null;
  }
  registerListeners() {
    super.registerListeners();
    const {
      hls: e
    } = this;
    e.on(x.LEVEL_LOADED, this.onLevelLoaded, this), e.on(x.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(x.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(x.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(x.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.on(x.BUFFER_FLUSHING, this.onBufferFlushing, this);
  }
  unregisterListeners() {
    super.unregisterListeners();
    const {
      hls: e
    } = this;
    e.off(x.LEVEL_LOADED, this.onLevelLoaded, this), e.off(x.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(x.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(x.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(x.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.off(x.BUFFER_FLUSHING, this.onBufferFlushing, this);
  }
  startLoad(e, t) {
    this.stopLoad(), this.state = q.IDLE, this.setInterval(qf), this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset, this.startPosition = t ? -1 : e, this.tick();
  }
  onManifestLoading() {
    super.onManifestLoading(), this.mainDetails = null;
  }
  onMediaDetaching(e, t) {
    this.tracksBuffered = [], super.onMediaDetaching(e, t);
  }
  onLevelLoaded(e, t) {
    this.mainDetails = t.details;
  }
  onSubtitleFragProcessed(e, t) {
    const {
      frag: i,
      success: s
    } = t;
    if (this.fragContextChanged(i) || (ot(i) && (this.fragPrevious = i), this.state = q.IDLE), !s)
      return;
    const r = this.tracksBuffered[this.currentTrackId];
    if (!r)
      return;
    let a;
    const o = i.start;
    for (let c = 0; c < r.length; c++)
      if (o >= r[c].start && o <= r[c].end) {
        a = r[c];
        break;
      }
    const l = i.start + i.duration;
    a ? a.end = l : (a = {
      start: o,
      end: l
    }, r.push(a)), this.fragmentTracker.fragBuffered(i), this.fragBufferedComplete(i, null), this.media && this.tick();
  }
  onBufferFlushing(e, t) {
    const {
      startOffset: i,
      endOffset: s
    } = t;
    if (i === 0 && s !== Number.POSITIVE_INFINITY) {
      const r = s - 1;
      if (r <= 0)
        return;
      t.endOffsetSubtitles = Math.max(0, r), this.tracksBuffered.forEach((a) => {
        for (let o = 0; o < a.length; ) {
          if (a[o].end <= r) {
            a.shift();
            continue;
          } else if (a[o].start < r)
            a[o].start = r;
          else
            break;
          o++;
        }
      }), this.fragmentTracker.removeFragmentsInRange(i, r, te.SUBTITLE);
    }
  }
  // If something goes wrong, proceed to next frag, if we were processing one.
  onError(e, t) {
    const i = t.frag;
    i?.type === te.SUBTITLE && (t.details === H.FRAG_GAP && this.fragmentTracker.fragBuffered(i, !0), this.fragCurrent && this.fragCurrent.abortRequests(), this.state !== q.STOPPED && (this.state = q.IDLE));
  }
  // Got all new subtitle levels.
  onSubtitleTracksUpdated(e, {
    subtitleTracks: t
  }) {
    if (this.levels && Kg(this.levels, t)) {
      this.levels = t.map((i) => new ga(i));
      return;
    }
    this.tracksBuffered = [], this.levels = t.map((i) => {
      const s = new ga(i);
      return this.tracksBuffered[s.id] = [], s;
    }), this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, te.SUBTITLE), this.fragPrevious = null, this.mediaBuffer = null;
  }
  onSubtitleTrackSwitch(e, t) {
    var i;
    if (this.currentTrackId = t.id, !((i = this.levels) != null && i.length) || this.currentTrackId === -1) {
      this.clearInterval();
      return;
    }
    const s = this.levels[this.currentTrackId];
    s != null && s.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, s && this.state !== q.STOPPED && this.setInterval(qf);
  }
  // Got a new set of subtitle fragments.
  onSubtitleTrackLoaded(e, t) {
    var i;
    const {
      currentTrackId: s,
      levels: r
    } = this, {
      details: a,
      id: o
    } = t;
    if (!r) {
      this.warn(`Subtitle tracks were reset while loading level ${o}`);
      return;
    }
    const l = r[o];
    if (o >= r.length || !l)
      return;
    this.log(`Subtitle track ${o} loaded [${a.startSN},${a.endSN}]${a.lastPartSn ? `[part-${a.lastPartSn}-${a.lastPartIndex}]` : ""},duration:${a.totalduration}`), this.mediaBuffer = this.mediaBufferTimeRanges;
    let c = 0;
    if (a.live || (i = l.details) != null && i.live) {
      if (a.deltaUpdateFailed)
        return;
      const d = this.mainDetails;
      if (!d) {
        this.startFragRequested = !1;
        return;
      }
      const f = d.fragments[0];
      if (!l.details)
        a.hasProgramDateTime && d.hasProgramDateTime ? (zo(a, d), c = a.fragmentStart) : f && (c = f.start, Bc(a, c));
      else {
        var u;
        c = this.alignPlaylists(a, l.details, (u = this.levelLastLoaded) == null ? void 0 : u.details), c === 0 && f && (c = f.start, Bc(a, c));
      }
      d && !this.startFragRequested && this.setStartPosition(d, c);
    }
    l.details = a, this.levelLastLoaded = l, o === s && (this.hls.trigger(x.SUBTITLE_TRACK_UPDATED, {
      details: a,
      id: o,
      groupId: t.groupId
    }), this.tick(), a.live && !this.fragCurrent && this.media && this.state === q.IDLE && (Rr(null, a.fragments, this.media.currentTime, 0) || (this.warn("Subtitle playlist not aligned with playback"), l.details = void 0)));
  }
  _handleFragmentLoadComplete(e) {
    const {
      frag: t,
      payload: i
    } = e, s = t.decryptdata, r = this.hls;
    if (!this.fragContextChanged(t) && i && i.byteLength > 0 && s != null && s.key && s.iv && an(s.method)) {
      const a = performance.now();
      this.decrypter.decrypt(new Uint8Array(i), s.key.buffer, s.iv.buffer, $u(s.method)).catch((o) => {
        throw r.trigger(x.ERROR, {
          type: se.MEDIA_ERROR,
          details: H.FRAG_DECRYPT_ERROR,
          fatal: !1,
          error: o,
          reason: o.message,
          frag: t
        }), o;
      }).then((o) => {
        const l = performance.now();
        r.trigger(x.FRAG_DECRYPTED, {
          frag: t,
          payload: o,
          stats: {
            tstart: a,
            tdecrypt: l
          }
        });
      }).catch((o) => {
        this.warn(`${o.name}: ${o.message}`), this.state = q.IDLE;
      });
    }
  }
  doTick() {
    if (!this.media) {
      this.state = q.IDLE;
      return;
    }
    if (this.state === q.IDLE) {
      const {
        currentTrackId: e,
        levels: t
      } = this, i = t?.[e];
      if (!i || !t.length || !i.details || this.waitForLive(i))
        return;
      const {
        config: s
      } = this, r = this.getLoadPosition(), a = de.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], r, s.maxBufferHole), {
        end: o,
        len: l
      } = a, c = i.details, u = this.hls.maxBufferLength + c.levelTargetDuration;
      if (l > u)
        return;
      const d = c.fragments, f = d.length, p = c.edge;
      let h = null;
      const g = this.fragPrevious;
      if (o < p) {
        const y = s.maxFragLookUpTolerance, E = o > p - y ? 0 : y;
        h = Rr(g, d, Math.max(d[0].start, o), E), !h && g && g.start < d[0].start && (h = d[0]);
      } else
        h = d[f - 1];
      if (h = this.filterReplacedPrimary(h, i.details), !h)
        return;
      const m = h.sn - c.startSN, v = d[m - 1];
      if (v && v.cc === h.cc && this.fragmentTracker.getState(v) === yt.NOT_LOADED && (h = v), this.fragmentTracker.getState(h) === yt.NOT_LOADED) {
        const y = this.mapToInitFragWhenRequired(h);
        y && this.loadFragment(y, i, o);
      }
    }
  }
  loadFragment(e, t, i) {
    ot(e) ? super.loadFragment(e, t, i) : this._loadInitSegment(e, t);
  }
  get mediaBufferTimeRanges() {
    return new JS(this.tracksBuffered[this.currentTrackId] || []);
  }
}
class JS {
  constructor(e) {
    this.buffered = void 0;
    const t = (i, s, r) => {
      if (s = s >>> 0, s > r - 1)
        throw new DOMException(`Failed to execute '${i}' on 'TimeRanges': The index provided (${s}) is greater than the maximum bound (${r})`);
      return e[s][i];
    };
    this.buffered = {
      get length() {
        return e.length;
      },
      end(i) {
        return t("end", i, e.length);
      },
      start(i) {
        return t("start", i, e.length);
      }
    };
  }
}
const ex = {
  42: 225,
  // lowercase a, acute accent
  92: 233,
  // lowercase e, acute accent
  94: 237,
  // lowercase i, acute accent
  95: 243,
  // lowercase o, acute accent
  96: 250,
  // lowercase u, acute accent
  123: 231,
  // lowercase c with cedilla
  124: 247,
  // division symbol
  125: 209,
  // uppercase N tilde
  126: 241,
  // lowercase n tilde
  127: 9608,
  // Full block
  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
  // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
  128: 174,
  // Registered symbol (R)
  129: 176,
  // degree sign
  130: 189,
  // 1/2 symbol
  131: 191,
  // Inverted (open) question mark
  132: 8482,
  // Trademark symbol (TM)
  133: 162,
  // Cents symbol
  134: 163,
  // Pounds sterling
  135: 9834,
  // Music 8'th note
  136: 224,
  // lowercase a, grave accent
  137: 32,
  // transparent space (regular)
  138: 232,
  // lowercase e, grave accent
  139: 226,
  // lowercase a, circumflex accent
  140: 234,
  // lowercase e, circumflex accent
  141: 238,
  // lowercase i, circumflex accent
  142: 244,
  // lowercase o, circumflex accent
  143: 251,
  // lowercase u, circumflex accent
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
  144: 193,
  // capital letter A with acute
  145: 201,
  // capital letter E with acute
  146: 211,
  // capital letter O with acute
  147: 218,
  // capital letter U with acute
  148: 220,
  // capital letter U with diaresis
  149: 252,
  // lowercase letter U with diaeresis
  150: 8216,
  // opening single quote
  151: 161,
  // inverted exclamation mark
  152: 42,
  // asterisk
  153: 8217,
  // closing single quote
  154: 9473,
  // box drawings heavy horizontal
  155: 169,
  // copyright sign
  156: 8480,
  // Service mark
  157: 8226,
  // (round) bullet
  158: 8220,
  // Left double quotation mark
  159: 8221,
  // Right double quotation mark
  160: 192,
  // uppercase A, grave accent
  161: 194,
  // uppercase A, circumflex
  162: 199,
  // uppercase C with cedilla
  163: 200,
  // uppercase E, grave accent
  164: 202,
  // uppercase E, circumflex
  165: 203,
  // capital letter E with diaresis
  166: 235,
  // lowercase letter e with diaresis
  167: 206,
  // uppercase I, circumflex
  168: 207,
  // uppercase I, with diaresis
  169: 239,
  // lowercase i, with diaresis
  170: 212,
  // uppercase O, circumflex
  171: 217,
  // uppercase U, grave accent
  172: 249,
  // lowercase u, grave accent
  173: 219,
  // uppercase U, circumflex
  174: 171,
  // left-pointing double angle quotation mark
  175: 187,
  // right-pointing double angle quotation mark
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
  176: 195,
  // Uppercase A, tilde
  177: 227,
  // Lowercase a, tilde
  178: 205,
  // Uppercase I, acute accent
  179: 204,
  // Uppercase I, grave accent
  180: 236,
  // Lowercase i, grave accent
  181: 210,
  // Uppercase O, grave accent
  182: 242,
  // Lowercase o, grave accent
  183: 213,
  // Uppercase O, tilde
  184: 245,
  // Lowercase o, tilde
  185: 123,
  // Open curly brace
  186: 125,
  // Closing curly brace
  187: 92,
  // Backslash
  188: 94,
  // Caret
  189: 95,
  // Underscore
  190: 124,
  // Pipe (vertical line)
  191: 8764,
  // Tilde operator
  192: 196,
  // Uppercase A, umlaut
  193: 228,
  // Lowercase A, umlaut
  194: 214,
  // Uppercase O, umlaut
  195: 246,
  // Lowercase o, umlaut
  196: 223,
  // Esszett (sharp S)
  197: 165,
  // Yen symbol
  198: 164,
  // Generic currency sign
  199: 9475,
  // Box drawings heavy vertical
  200: 197,
  // Uppercase A, ring
  201: 229,
  // Lowercase A, ring
  202: 216,
  // Uppercase O, stroke
  203: 248,
  // Lowercase o, strok
  204: 9487,
  // Box drawings heavy down and right
  205: 9491,
  // Box drawings heavy down and left
  206: 9495,
  // Box drawings heavy up and right
  207: 9499
  // Box drawings heavy up and left
}, lm = (n) => String.fromCharCode(ex[n] || n), zi = 15, ps = 100, tx = {
  17: 1,
  18: 3,
  21: 5,
  22: 7,
  23: 9,
  16: 11,
  19: 12,
  20: 14
}, ix = {
  17: 2,
  18: 4,
  21: 6,
  22: 8,
  23: 10,
  19: 13,
  20: 15
}, sx = {
  25: 1,
  26: 3,
  29: 5,
  30: 7,
  31: 9,
  24: 11,
  27: 12,
  28: 14
}, rx = {
  25: 2,
  26: 4,
  29: 6,
  30: 8,
  31: 10,
  27: 13,
  28: 15
}, nx = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
class ax {
  constructor() {
    this.time = null, this.verboseLevel = 0;
  }
  log(e, t) {
    if (this.verboseLevel >= e) {
      const i = typeof t == "function" ? t() : t;
      Oe.log(`${this.time} [${e}] ${i}`);
    }
  }
}
const or = function(e) {
  const t = [];
  for (let i = 0; i < e.length; i++)
    t.push(e[i].toString(16));
  return t;
};
class cm {
  constructor() {
    this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1;
  }
  reset() {
    this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1;
  }
  setStyles(e) {
    const t = ["foreground", "underline", "italics", "background", "flash"];
    for (let i = 0; i < t.length; i++) {
      const s = t[i];
      e.hasOwnProperty(s) && (this[s] = e[s]);
    }
  }
  isDefault() {
    return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash;
  }
  equals(e) {
    return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash;
  }
  copy(e) {
    this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash;
  }
  toString() {
    return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash;
  }
}
class ox {
  constructor() {
    this.uchar = " ", this.penState = new cm();
  }
  reset() {
    this.uchar = " ", this.penState.reset();
  }
  setChar(e, t) {
    this.uchar = e, this.penState.copy(t);
  }
  setPenState(e) {
    this.penState.copy(e);
  }
  equals(e) {
    return this.uchar === e.uchar && this.penState.equals(e.penState);
  }
  copy(e) {
    this.uchar = e.uchar, this.penState.copy(e.penState);
  }
  isEmpty() {
    return this.uchar === " " && this.penState.isDefault();
  }
}
class lx {
  constructor(e) {
    this.chars = [], this.pos = 0, this.currPenState = new cm(), this.cueStartTime = null, this.logger = void 0;
    for (let t = 0; t < ps; t++)
      this.chars.push(new ox());
    this.logger = e;
  }
  equals(e) {
    for (let t = 0; t < ps; t++)
      if (!this.chars[t].equals(e.chars[t]))
        return !1;
    return !0;
  }
  copy(e) {
    for (let t = 0; t < ps; t++)
      this.chars[t].copy(e.chars[t]);
  }
  isEmpty() {
    let e = !0;
    for (let t = 0; t < ps; t++)
      if (!this.chars[t].isEmpty()) {
        e = !1;
        break;
      }
    return e;
  }
  /**
   *  Set the cursor to a valid column.
   */
  setCursor(e) {
    this.pos !== e && (this.pos = e), this.pos < 0 ? (this.logger.log(3, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > ps && (this.logger.log(3, "Too large cursor position " + this.pos), this.pos = ps);
  }
  /**
   * Move the cursor relative to current position.
   */
  moveCursor(e) {
    const t = this.pos + e;
    if (e > 1)
      for (let i = this.pos + 1; i < t + 1; i++)
        this.chars[i].setPenState(this.currPenState);
    this.setCursor(t);
  }
  /**
   * Backspace, move one step back and clear character.
   */
  backSpace() {
    this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState);
  }
  insertChar(e) {
    e >= 144 && this.backSpace();
    const t = lm(e);
    if (this.pos >= ps) {
      this.logger.log(0, () => "Cannot insert " + e.toString(16) + " (" + t + ") at position " + this.pos + ". Skipping it!");
      return;
    }
    this.chars[this.pos].setChar(t, this.currPenState), this.moveCursor(1);
  }
  clearFromPos(e) {
    let t;
    for (t = e; t < ps; t++)
      this.chars[t].reset();
  }
  clear() {
    this.clearFromPos(0), this.pos = 0, this.currPenState.reset();
  }
  clearToEndOfRow() {
    this.clearFromPos(this.pos);
  }
  getTextString() {
    const e = [];
    let t = !0;
    for (let i = 0; i < ps; i++) {
      const s = this.chars[i].uchar;
      s !== " " && (t = !1), e.push(s);
    }
    return t ? "" : e.join("");
  }
  setPenStyles(e) {
    this.currPenState.setStyles(e), this.chars[this.pos].setPenState(this.currPenState);
  }
}
class Ul {
  constructor(e) {
    this.rows = [], this.currRow = zi - 1, this.nrRollUpRows = null, this.lastOutputScreen = null, this.logger = void 0;
    for (let t = 0; t < zi; t++)
      this.rows.push(new lx(e));
    this.logger = e;
  }
  reset() {
    for (let e = 0; e < zi; e++)
      this.rows[e].clear();
    this.currRow = zi - 1;
  }
  equals(e) {
    let t = !0;
    for (let i = 0; i < zi; i++)
      if (!this.rows[i].equals(e.rows[i])) {
        t = !1;
        break;
      }
    return t;
  }
  copy(e) {
    for (let t = 0; t < zi; t++)
      this.rows[t].copy(e.rows[t]);
  }
  isEmpty() {
    let e = !0;
    for (let t = 0; t < zi; t++)
      if (!this.rows[t].isEmpty()) {
        e = !1;
        break;
      }
    return e;
  }
  backSpace() {
    this.rows[this.currRow].backSpace();
  }
  clearToEndOfRow() {
    this.rows[this.currRow].clearToEndOfRow();
  }
  /**
   * Insert a character (without styling) in the current row.
   */
  insertChar(e) {
    this.rows[this.currRow].insertChar(e);
  }
  setPen(e) {
    this.rows[this.currRow].setPenStyles(e);
  }
  moveCursor(e) {
    this.rows[this.currRow].moveCursor(e);
  }
  setCursor(e) {
    this.logger.log(2, "setCursor: " + e), this.rows[this.currRow].setCursor(e);
  }
  setPAC(e) {
    this.logger.log(2, () => "pacData = " + Ge(e));
    let t = e.row - 1;
    if (this.nrRollUpRows && t < this.nrRollUpRows - 1 && (t = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== t) {
      for (let o = 0; o < zi; o++)
        this.rows[o].clear();
      const r = this.currRow + 1 - this.nrRollUpRows, a = this.lastOutputScreen;
      if (a) {
        const o = a.rows[r].cueStartTime, l = this.logger.time;
        if (o !== null && l !== null && o < l)
          for (let c = 0; c < this.nrRollUpRows; c++)
            this.rows[t - this.nrRollUpRows + c + 1].copy(a.rows[r + c]);
      }
    }
    this.currRow = t;
    const i = this.rows[this.currRow];
    if (e.indent !== null) {
      const r = e.indent, a = Math.max(r - 1, 0);
      i.setCursor(e.indent), e.color = i.chars[a].penState.foreground;
    }
    const s = {
      foreground: e.color,
      underline: e.underline,
      italics: e.italics,
      background: "black",
      flash: !1
    };
    this.setPen(s);
  }
  /**
   * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
   */
  setBkgData(e) {
    this.logger.log(2, () => "bkgData = " + Ge(e)), this.backSpace(), this.setPen(e), this.insertChar(32);
  }
  setRollUpRows(e) {
    this.nrRollUpRows = e;
  }
  rollUp() {
    if (this.nrRollUpRows === null) {
      this.logger.log(3, "roll_up but nrRollUpRows not set yet");
      return;
    }
    this.logger.log(1, () => this.getDisplayText());
    const e = this.currRow + 1 - this.nrRollUpRows, t = this.rows.splice(e, 1)[0];
    t.clear(), this.rows.splice(this.currRow, 0, t), this.logger.log(2, "Rolling up");
  }
  /**
   * Get all non-empty rows with as unicode text.
   */
  getDisplayText(e) {
    e = e || !1;
    const t = [];
    let i = "", s = -1;
    for (let r = 0; r < zi; r++) {
      const a = this.rows[r].getTextString();
      a && (s = r + 1, e ? t.push("Row " + s + ": '" + a + "'") : t.push(a.trim()));
    }
    return t.length > 0 && (e ? i = "[" + t.join(" | ") + "]" : i = t.join(`
`)), i;
  }
  getTextAndFormat() {
    return this.rows;
  }
}
class Xf {
  constructor(e, t, i) {
    this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = e, this.outputFilter = t, this.mode = null, this.verbose = 0, this.displayedMemory = new Ul(i), this.nonDisplayedMemory = new Ul(i), this.lastOutputScreen = new Ul(i), this.currRollUpRow = this.displayedMemory.rows[zi - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = i;
  }
  reset() {
    this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[zi - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null;
  }
  getHandler() {
    return this.outputFilter;
  }
  setHandler(e) {
    this.outputFilter = e;
  }
  setPAC(e) {
    this.writeScreen.setPAC(e);
  }
  setBkgData(e) {
    this.writeScreen.setBkgData(e);
  }
  setMode(e) {
    e !== this.mode && (this.mode = e, this.logger.log(2, () => "MODE=" + e), this.mode === "MODE_POP-ON" ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), this.mode !== "MODE_ROLL-UP" && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e);
  }
  insertChars(e) {
    for (let i = 0; i < e.length; i++)
      this.writeScreen.insertChar(e[i]);
    const t = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
    this.logger.log(2, () => t + ": " + this.writeScreen.getDisplayText(!0)), (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") && (this.logger.log(1, () => "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate());
  }
  ccRCL() {
    this.logger.log(2, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON");
  }
  ccBS() {
    this.logger.log(2, "BS - BackSpace"), this.mode !== "MODE_TEXT" && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate());
  }
  ccAOF() {
  }
  ccAON() {
  }
  ccDER() {
    this.logger.log(2, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate();
  }
  ccRU(e) {
    this.logger.log(2, "RU(" + e + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(e);
  }
  ccFON() {
    this.logger.log(2, "FON - Flash On"), this.writeScreen.setPen({
      flash: !0
    });
  }
  ccRDC() {
    this.logger.log(2, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON");
  }
  ccTR() {
    this.logger.log(2, "TR"), this.setMode("MODE_TEXT");
  }
  ccRTD() {
    this.logger.log(2, "RTD"), this.setMode("MODE_TEXT");
  }
  ccEDM() {
    this.logger.log(2, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0);
  }
  ccCR() {
    this.logger.log(2, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0);
  }
  ccENM() {
    this.logger.log(2, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset();
  }
  ccEOC() {
    if (this.logger.log(2, "EOC - End Of Caption"), this.mode === "MODE_POP-ON") {
      const e = this.displayedMemory;
      this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, this.logger.log(1, () => "DISP: " + this.displayedMemory.getDisplayText());
    }
    this.outputDataUpdate(!0);
  }
  ccTO(e) {
    this.logger.log(2, "TO(" + e + ") - Tab Offset"), this.writeScreen.moveCursor(e);
  }
  ccMIDROW(e) {
    const t = {
      flash: !1
    };
    if (t.underline = e % 2 === 1, t.italics = e >= 46, t.italics)
      t.foreground = "white";
    else {
      const i = Math.floor(e / 2) - 16, s = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
      t.foreground = s[i];
    }
    this.logger.log(2, "MIDROW: " + Ge(t)), this.writeScreen.setPen(t);
  }
  outputDataUpdate(e = !1) {
    const t = this.logger.time;
    t !== null && this.outputFilter && (this.cueStartTime === null && !this.displayedMemory.isEmpty() ? this.cueStartTime = t : this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen), e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : t), this.lastOutputScreen.copy(this.displayedMemory));
  }
  cueSplitAtTime(e) {
    this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e));
  }
}
class jf {
  constructor(e, t, i) {
    this.channels = void 0, this.currentChannel = 0, this.cmdHistory = ux(), this.logger = void 0;
    const s = this.logger = new ax();
    this.channels = [null, new Xf(e, t, s), new Xf(e + 1, i, s)];
  }
  getHandler(e) {
    return this.channels[e].getHandler();
  }
  setHandler(e, t) {
    this.channels[e].setHandler(t);
  }
  /**
   * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
   */
  addData(e, t) {
    this.logger.time = e;
    for (let i = 0; i < t.length; i += 2) {
      const s = t[i] & 127, r = t[i + 1] & 127;
      let a = !1, o = null;
      if (s === 0 && r === 0)
        continue;
      this.logger.log(3, () => "[" + or([t[i], t[i + 1]]) + "] -> (" + or([s, r]) + ")");
      const l = this.cmdHistory;
      if (s >= 16 && s <= 31) {
        if (cx(s, r, l)) {
          Qa(null, null, l), this.logger.log(3, () => "Repeated command (" + or([s, r]) + ") is dropped");
          continue;
        }
        Qa(s, r, this.cmdHistory), a = this.parseCmd(s, r), a || (a = this.parseMidrow(s, r)), a || (a = this.parsePAC(s, r)), a || (a = this.parseBackgroundAttributes(s, r));
      } else
        Qa(null, null, l);
      if (!a && (o = this.parseChars(s, r), o)) {
        const u = this.currentChannel;
        u && u > 0 ? this.channels[u].insertChars(o) : this.logger.log(2, "No channel found yet. TEXT-MODE?");
      }
      !a && !o && this.logger.log(2, () => "Couldn't parse cleaned data " + or([s, r]) + " orig: " + or([t[i], t[i + 1]]));
    }
  }
  /**
   * Parse Command.
   * @returns True if a command was found
   */
  parseCmd(e, t) {
    const i = (e === 20 || e === 28 || e === 21 || e === 29) && t >= 32 && t <= 47, s = (e === 23 || e === 31) && t >= 33 && t <= 35;
    if (!(i || s))
      return !1;
    const r = e === 20 || e === 21 || e === 23 ? 1 : 2, a = this.channels[r];
    return e === 20 || e === 21 || e === 28 || e === 29 ? t === 32 ? a.ccRCL() : t === 33 ? a.ccBS() : t === 34 ? a.ccAOF() : t === 35 ? a.ccAON() : t === 36 ? a.ccDER() : t === 37 ? a.ccRU(2) : t === 38 ? a.ccRU(3) : t === 39 ? a.ccRU(4) : t === 40 ? a.ccFON() : t === 41 ? a.ccRDC() : t === 42 ? a.ccTR() : t === 43 ? a.ccRTD() : t === 44 ? a.ccEDM() : t === 45 ? a.ccCR() : t === 46 ? a.ccENM() : t === 47 && a.ccEOC() : a.ccTO(t - 32), this.currentChannel = r, !0;
  }
  /**
   * Parse midrow styling command
   */
  parseMidrow(e, t) {
    let i = 0;
    if ((e === 17 || e === 25) && t >= 32 && t <= 47) {
      if (e === 17 ? i = 1 : i = 2, i !== this.currentChannel)
        return this.logger.log(0, "Mismatch channel in midrow parsing"), !1;
      const s = this.channels[i];
      return s ? (s.ccMIDROW(t), this.logger.log(3, () => "MIDROW (" + or([e, t]) + ")"), !0) : !1;
    }
    return !1;
  }
  /**
   * Parse Preable Access Codes (Table 53).
   * @returns {Boolean} Tells if PAC found
   */
  parsePAC(e, t) {
    let i;
    const s = (e >= 17 && e <= 23 || e >= 25 && e <= 31) && t >= 64 && t <= 127, r = (e === 16 || e === 24) && t >= 64 && t <= 95;
    if (!(s || r))
      return !1;
    const a = e <= 23 ? 1 : 2;
    t >= 64 && t <= 95 ? i = a === 1 ? tx[e] : sx[e] : i = a === 1 ? ix[e] : rx[e];
    const o = this.channels[a];
    return o ? (o.setPAC(this.interpretPAC(i, t)), this.currentChannel = a, !0) : !1;
  }
  /**
   * Interpret the second byte of the pac, and return the information.
   * @returns pacData with style parameters
   */
  interpretPAC(e, t) {
    let i;
    const s = {
      color: null,
      italics: !1,
      indent: null,
      underline: !1,
      row: e
    };
    return t > 95 ? i = t - 96 : i = t - 64, s.underline = (i & 1) === 1, i <= 13 ? s.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(i / 2)] : i <= 15 ? (s.italics = !0, s.color = "white") : s.indent = Math.floor((i - 16) / 2) * 4, s;
  }
  /**
   * Parse characters.
   * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
   */
  parseChars(e, t) {
    let i, s = null, r = null;
    if (e >= 25 ? (i = 2, r = e - 8) : (i = 1, r = e), r >= 17 && r <= 19) {
      let a;
      r === 17 ? a = t + 80 : r === 18 ? a = t + 112 : a = t + 144, this.logger.log(2, () => "Special char '" + lm(a) + "' in channel " + i), s = [a];
    } else e >= 32 && e <= 127 && (s = t === 0 ? [e] : [e, t]);
    return s && this.logger.log(3, () => "Char codes =  " + or(s).join(",")), s;
  }
  /**
   * Parse extended background attributes as well as new foreground color black.
   * @returns True if background attributes are found
   */
  parseBackgroundAttributes(e, t) {
    const i = (e === 16 || e === 24) && t >= 32 && t <= 47, s = (e === 23 || e === 31) && t >= 45 && t <= 47;
    if (!(i || s))
      return !1;
    let r;
    const a = {};
    e === 16 || e === 24 ? (r = Math.floor((t - 32) / 2), a.background = nx[r], t % 2 === 1 && (a.background = a.background + "_semi")) : t === 45 ? a.background = "transparent" : (a.foreground = "black", t === 47 && (a.underline = !0));
    const o = e <= 23 ? 1 : 2;
    return this.channels[o].setBkgData(a), !0;
  }
  /**
   * Reset state of parser and its channels.
   */
  reset() {
    for (let e = 0; e < Object.keys(this.channels).length; e++) {
      const t = this.channels[e];
      t && t.reset();
    }
    Qa(null, null, this.cmdHistory);
  }
  /**
   * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
   */
  cueSplitAtTime(e) {
    for (let t = 0; t < this.channels.length; t++) {
      const i = this.channels[t];
      i && i.cueSplitAtTime(e);
    }
  }
}
function Qa(n, e, t) {
  t.a = n, t.b = e;
}
function cx(n, e, t) {
  return t.a === n && t.b === e;
}
function ux() {
  return {
    a: null,
    b: null
  };
}
var Zu = (function() {
  if (Vo != null && Vo.VTTCue)
    return self.VTTCue;
  const n = ["", "lr", "rl"], e = ["start", "middle", "end", "left", "right"];
  function t(o, l) {
    if (typeof l != "string" || !Array.isArray(o))
      return !1;
    const c = l.toLowerCase();
    return ~o.indexOf(c) ? c : !1;
  }
  function i(o) {
    return t(n, o);
  }
  function s(o) {
    return t(e, o);
  }
  function r(o, ...l) {
    let c = 1;
    for (; c < arguments.length; c++) {
      const u = arguments[c];
      for (const d in u)
        o[d] = u[d];
    }
    return o;
  }
  function a(o, l, c) {
    const u = this, d = {
      enumerable: !0
    };
    u.hasBeenReset = !1;
    let f = "", p = !1, h = o, g = l, m = c, v = null, y = "", E = !0, T = "auto", S = "start", w = 50, b = "middle", L = 50, A = "middle";
    Object.defineProperty(u, "id", r({}, d, {
      get: function() {
        return f;
      },
      set: function(_) {
        f = "" + _;
      }
    })), Object.defineProperty(u, "pauseOnExit", r({}, d, {
      get: function() {
        return p;
      },
      set: function(_) {
        p = !!_;
      }
    })), Object.defineProperty(u, "startTime", r({}, d, {
      get: function() {
        return h;
      },
      set: function(_) {
        if (typeof _ != "number")
          throw new TypeError("Start time must be set to a number.");
        h = _, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "endTime", r({}, d, {
      get: function() {
        return g;
      },
      set: function(_) {
        if (typeof _ != "number")
          throw new TypeError("End time must be set to a number.");
        g = _, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "text", r({}, d, {
      get: function() {
        return m;
      },
      set: function(_) {
        m = "" + _, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "region", r({}, d, {
      get: function() {
        return v;
      },
      set: function(_) {
        v = _, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "vertical", r({}, d, {
      get: function() {
        return y;
      },
      set: function(_) {
        const R = i(_);
        if (R === !1)
          throw new SyntaxError("An invalid or illegal string was specified.");
        y = R, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "snapToLines", r({}, d, {
      get: function() {
        return E;
      },
      set: function(_) {
        E = !!_, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "line", r({}, d, {
      get: function() {
        return T;
      },
      set: function(_) {
        if (typeof _ != "number" && _ !== "auto")
          throw new SyntaxError("An invalid number or illegal string was specified.");
        T = _, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "lineAlign", r({}, d, {
      get: function() {
        return S;
      },
      set: function(_) {
        const R = s(_);
        if (!R)
          throw new SyntaxError("An invalid or illegal string was specified.");
        S = R, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "position", r({}, d, {
      get: function() {
        return w;
      },
      set: function(_) {
        if (_ < 0 || _ > 100)
          throw new Error("Position must be between 0 and 100.");
        w = _, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "positionAlign", r({}, d, {
      get: function() {
        return b;
      },
      set: function(_) {
        const R = s(_);
        if (!R)
          throw new SyntaxError("An invalid or illegal string was specified.");
        b = R, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "size", r({}, d, {
      get: function() {
        return L;
      },
      set: function(_) {
        if (_ < 0 || _ > 100)
          throw new Error("Size must be between 0 and 100.");
        L = _, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(u, "align", r({}, d, {
      get: function() {
        return A;
      },
      set: function(_) {
        const R = s(_);
        if (!R)
          throw new SyntaxError("An invalid or illegal string was specified.");
        A = R, this.hasBeenReset = !0;
      }
    })), u.displayState = void 0;
  }
  return a.prototype.getCueAsHTML = function() {
    return self.WebVTT.convertCueToDOMTree(self, this.text);
  }, a;
})();
class dx {
  decode(e, t) {
    if (!e)
      return "";
    if (typeof e != "string")
      throw new Error("Error - expected string data.");
    return decodeURIComponent(encodeURIComponent(e));
  }
}
function um(n) {
  function e(i, s, r, a) {
    return (i | 0) * 3600 + (s | 0) * 60 + (r | 0) + parseFloat(a || 0);
  }
  const t = n.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
  return t ? parseFloat(t[2]) > 59 ? e(t[2], t[3], 0, t[4]) : e(t[1], t[2], t[3], t[4]) : null;
}
class fx {
  constructor() {
    this.values = /* @__PURE__ */ Object.create(null);
  }
  // Only accept the first assignment to any key.
  set(e, t) {
    !this.get(e) && t !== "" && (this.values[e] = t);
  }
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get(e, t, i) {
    return i ? this.has(e) ? this.values[e] : t[i] : this.has(e) ? this.values[e] : t;
  }
  // Check whether we have a value for a key.
  has(e) {
    return e in this.values;
  }
  // Accept a setting if its one of the given alternatives.
  alt(e, t, i) {
    for (let s = 0; s < i.length; ++s)
      if (t === i[s]) {
        this.set(e, t);
        break;
      }
  }
  // Accept a setting if its a valid (signed) integer.
  integer(e, t) {
    /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10));
  }
  // Accept a setting if its a valid percentage.
  percent(e, t) {
    if (/^([\d]{1,3})(\.[\d]*)?%$/.test(t)) {
      const i = parseFloat(t);
      if (i >= 0 && i <= 100)
        return this.set(e, i), !0;
    }
    return !1;
  }
}
function dm(n, e, t, i) {
  const s = i ? n.split(i) : [n];
  for (const r in s) {
    if (typeof s[r] != "string")
      continue;
    const a = s[r].split(t);
    if (a.length !== 2)
      continue;
    const o = a[0], l = a[1];
    e(o, l);
  }
}
const Yc = new Zu(0, 0, ""), Za = Yc.align === "middle" ? "middle" : "center";
function hx(n, e, t) {
  const i = n;
  function s() {
    const o = um(n);
    if (o === null)
      throw new Error("Malformed timestamp: " + i);
    return n = n.replace(/^[^\sa-zA-Z-]+/, ""), o;
  }
  function r(o, l) {
    const c = new fx();
    dm(o, function(f, p) {
      let h;
      switch (f) {
        case "region":
          for (let g = t.length - 1; g >= 0; g--)
            if (t[g].id === p) {
              c.set(f, t[g].region);
              break;
            }
          break;
        case "vertical":
          c.alt(f, p, ["rl", "lr"]);
          break;
        case "line":
          h = p.split(","), c.integer(f, h[0]), c.percent(f, h[0]) && c.set("snapToLines", !1), c.alt(f, h[0], ["auto"]), h.length === 2 && c.alt("lineAlign", h[1], ["start", Za, "end"]);
          break;
        case "position":
          h = p.split(","), c.percent(f, h[0]), h.length === 2 && c.alt("positionAlign", h[1], ["start", Za, "end", "line-left", "line-right", "auto"]);
          break;
        case "size":
          c.percent(f, p);
          break;
        case "align":
          c.alt(f, p, ["start", Za, "end", "left", "right"]);
          break;
      }
    }, /:/, /\s/), l.region = c.get("region", null), l.vertical = c.get("vertical", "");
    let u = c.get("line", "auto");
    u === "auto" && Yc.line === -1 && (u = -1), l.line = u, l.lineAlign = c.get("lineAlign", "start"), l.snapToLines = c.get("snapToLines", !0), l.size = c.get("size", 100), l.align = c.get("align", Za);
    let d = c.get("position", "auto");
    d === "auto" && Yc.position === 50 && (d = l.align === "start" || l.align === "left" ? 0 : l.align === "end" || l.align === "right" ? 100 : 50), l.position = d;
  }
  function a() {
    n = n.replace(/^\s+/, "");
  }
  if (a(), e.startTime = s(), a(), n.slice(0, 3) !== "-->")
    throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + i);
  n = n.slice(3), a(), e.endTime = s(), a(), r(n, e);
}
function fm(n) {
  return n.replace(/<br(?: \/)?>/gi, `
`);
}
class px {
  constructor() {
    this.state = "INITIAL", this.buffer = "", this.decoder = new dx(), this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0;
  }
  parse(e) {
    const t = this;
    e && (t.buffer += t.decoder.decode(e, {
      stream: !0
    }));
    function i() {
      let r = t.buffer, a = 0;
      for (r = fm(r); a < r.length && r[a] !== "\r" && r[a] !== `
`; )
        ++a;
      const o = r.slice(0, a);
      return r[a] === "\r" && ++a, r[a] === `
` && ++a, t.buffer = r.slice(a), o;
    }
    function s(r) {
      dm(r, function(a, o) {
      }, /:/);
    }
    try {
      let r = "";
      if (t.state === "INITIAL") {
        if (!/\r\n|\n/.test(t.buffer))
          return this;
        r = i();
        const o = r.match(/^(√Ø¬ª¬ø)?WEBVTT([ \t].*)?$/);
        if (!(o != null && o[0]))
          throw new Error("Malformed WebVTT signature.");
        t.state = "HEADER";
      }
      let a = !1;
      for (; t.buffer; ) {
        if (!/\r\n|\n/.test(t.buffer))
          return this;
        switch (a ? a = !1 : r = i(), t.state) {
          case "HEADER":
            /:/.test(r) ? s(r) : r || (t.state = "ID");
            continue;
          case "NOTE":
            r || (t.state = "ID");
            continue;
          case "ID":
            if (/^NOTE($|[ \t])/.test(r)) {
              t.state = "NOTE";
              break;
            }
            if (!r)
              continue;
            if (t.cue = new Zu(0, 0, ""), t.state = "CUE", r.indexOf("-->") === -1) {
              t.cue.id = r;
              continue;
            }
          // Process line as start of a cue.
          /* falls through */
          case "CUE":
            if (!t.cue) {
              t.state = "BADCUE";
              continue;
            }
            try {
              hx(r, t.cue, t.regionList);
            } catch {
              t.cue = null, t.state = "BADCUE";
              continue;
            }
            t.state = "CUETEXT";
            continue;
          case "CUETEXT":
            {
              const o = r.indexOf("-->") !== -1;
              if (!r || o && (a = !0)) {
                t.oncue && t.cue && t.oncue(t.cue), t.cue = null, t.state = "ID";
                continue;
              }
              if (t.cue === null)
                continue;
              t.cue.text && (t.cue.text += `
`), t.cue.text += r;
            }
            continue;
          case "BADCUE":
            r || (t.state = "ID");
        }
      }
    } catch {
      t.state === "CUETEXT" && t.cue && t.oncue && t.oncue(t.cue), t.cue = null, t.state = t.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
    }
    return this;
  }
  flush() {
    const e = this;
    try {
      if ((e.cue || e.state === "HEADER") && (e.buffer += `

`, e.parse()), e.state === "INITIAL" || e.state === "BADWEBVTT")
        throw new Error("Malformed WebVTT signature.");
    } catch (t) {
      e.onparsingerror && e.onparsingerror(t);
    }
    return e.onflush && e.onflush(), this;
  }
}
const gx = /\r\n|\n\r|\n|\r/g, Gl = function(e, t, i = 0) {
  return e.slice(i, i + t.length) === t;
}, mx = function(e) {
  let t = parseInt(e.slice(-3));
  const i = parseInt(e.slice(-6, -4)), s = parseInt(e.slice(-9, -7)), r = e.length > 9 ? parseInt(e.substring(0, e.indexOf(":"))) : 0;
  if (!Z(t) || !Z(i) || !Z(s) || !Z(r))
    throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`);
  return t += 1e3 * i, t += 60 * 1e3 * s, t += 3600 * 1e3 * r, t;
};
function Ju(n, e, t) {
  return ea(n.toString()) + ea(e.toString()) + ea(t);
}
const vx = function(e, t, i) {
  let s = e[t], r = e[s.prevCC];
  if (!r || !r.new && s.new) {
    e.ccOffset = e.presentationOffset = s.start, s.new = !1;
    return;
  }
  for (; (a = r) != null && a.new; ) {
    var a;
    e.ccOffset += s.start - r.start, s.new = !1, s = r, r = e[s.prevCC];
  }
  e.presentationOffset = i;
};
function yx(n, e, t, i, s, r, a) {
  const o = new px(), l = bi(new Uint8Array(n)).trim().replace(gx, `
`).split(`
`), c = [], u = e ? _T(e.baseTime, e.timescale) : 0;
  let d = "00:00.000", f = 0, p = 0, h, g = !0;
  o.oncue = function(m) {
    const v = t[i];
    let y = t.ccOffset;
    const E = (f - u) / 9e4;
    if (v != null && v.new && (p !== void 0 ? y = t.ccOffset = v.start : vx(t, i, E)), E) {
      if (!e) {
        h = new Error("Missing initPTS for VTT MPEGTS");
        return;
      }
      y = E - t.presentationOffset;
    }
    const T = m.endTime - m.startTime, S = di((m.startTime + y - p) * 9e4, s * 9e4) / 9e4;
    m.startTime = Math.max(S, 0), m.endTime = Math.max(S + T, 0);
    const w = m.text.trim();
    m.text = decodeURIComponent(encodeURIComponent(w)), m.id || (m.id = Ju(m.startTime, m.endTime, w)), m.endTime > 0 && c.push(m);
  }, o.onparsingerror = function(m) {
    h = m;
  }, o.onflush = function() {
    if (h) {
      a(h);
      return;
    }
    r(c);
  }, l.forEach((m) => {
    if (g)
      if (Gl(m, "X-TIMESTAMP-MAP=")) {
        g = !1, m.slice(16).split(",").forEach((v) => {
          Gl(v, "LOCAL:") ? d = v.slice(6) : Gl(v, "MPEGTS:") && (f = parseInt(v.slice(7)));
        });
        try {
          p = mx(d) / 1e3;
        } catch (v) {
          h = v;
        }
        return;
      } else m === "" && (g = !1);
    o.parse(m + `
`);
  }), o.flush();
}
const Hl = "stpp.ttml.im1t", hm = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/, pm = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/, Ex = {
  left: "start",
  center: "center",
  right: "end",
  start: "start",
  end: "end"
};
function Qf(n, e, t, i) {
  const s = ye(new Uint8Array(n), ["mdat"]);
  if (s.length === 0) {
    i(new Error("Could not parse IMSC1 mdat"));
    return;
  }
  const r = s.map((o) => bi(o)), a = bT(e.baseTime, 1, e.timescale);
  try {
    r.forEach((o) => t(Tx(o, a)));
  } catch (o) {
    i(o);
  }
}
function Tx(n, e) {
  const s = new DOMParser().parseFromString(n, "text/xml").getElementsByTagName("tt")[0];
  if (!s)
    throw new Error("Invalid ttml");
  const r = {
    frameRate: 30,
    subFrameRate: 1,
    frameRateMultiplier: 0,
    tickRate: 0
  }, a = Object.keys(r).reduce((d, f) => (d[f] = s.getAttribute(`ttp:${f}`) || r[f], d), {}), o = s.getAttribute("xml:space") !== "preserve", l = Zf(Vl(s, "styling", "style")), c = Zf(Vl(s, "layout", "region")), u = Vl(s, "body", "[begin]");
  return [].map.call(u, (d) => {
    const f = gm(d, o);
    if (!f || !d.hasAttribute("begin"))
      return null;
    const p = Wl(d.getAttribute("begin"), a), h = Wl(d.getAttribute("dur"), a);
    let g = Wl(d.getAttribute("end"), a);
    if (p === null)
      throw Jf(d);
    if (g === null) {
      if (h === null)
        throw Jf(d);
      g = p + h;
    }
    const m = new Zu(p - e, g - e, f);
    m.id = Ju(m.startTime, m.endTime, m.text);
    const v = c[d.getAttribute("region")], y = l[d.getAttribute("style")], E = Sx(v, y, l), {
      textAlign: T
    } = E;
    if (T) {
      const S = Ex[T];
      S && (m.lineAlign = S), m.align = T;
    }
    return Fe(m, E), m;
  }).filter((d) => d !== null);
}
function Vl(n, e, t) {
  const i = n.getElementsByTagName(e)[0];
  return i ? [].slice.call(i.querySelectorAll(t)) : [];
}
function Zf(n) {
  return n.reduce((e, t) => {
    const i = t.getAttribute("xml:id");
    return i && (e[i] = t), e;
  }, {});
}
function gm(n, e) {
  return [].slice.call(n.childNodes).reduce((t, i, s) => {
    var r;
    return i.nodeName === "br" && s ? t + `
` : (r = i.childNodes) != null && r.length ? gm(i, e) : e ? t + i.textContent.trim().replace(/\s+/g, " ") : t + i.textContent;
  }, "");
}
function Sx(n, e, t) {
  const i = "http://www.w3.org/ns/ttml#styling";
  let s = null;
  const r = [
    "displayAlign",
    "textAlign",
    "color",
    "backgroundColor",
    "fontSize",
    "fontFamily"
    // 'fontWeight',
    // 'lineHeight',
    // 'wrapOption',
    // 'fontStyle',
    // 'direction',
    // 'writingMode'
  ], a = n != null && n.hasAttribute("style") ? n.getAttribute("style") : null;
  return a && t.hasOwnProperty(a) && (s = t[a]), r.reduce((o, l) => {
    const c = zl(e, i, l) || zl(n, i, l) || zl(s, i, l);
    return c && (o[l] = c), o;
  }, {});
}
function zl(n, e, t) {
  return n && n.hasAttributeNS(e, t) ? n.getAttributeNS(e, t) : null;
}
function Jf(n) {
  return new Error(`Could not parse ttml timestamp ${n}`);
}
function Wl(n, e) {
  if (!n)
    return null;
  let t = um(n);
  return t === null && (hm.test(n) ? t = xx(n, e) : pm.test(n) && (t = bx(n, e))), t;
}
function xx(n, e) {
  const t = hm.exec(n), i = (t[4] | 0) + (t[5] | 0) / e.subFrameRate;
  return (t[1] | 0) * 3600 + (t[2] | 0) * 60 + (t[3] | 0) + i / e.frameRate;
}
function bx(n, e) {
  const t = pm.exec(n), i = Number(t[1]);
  switch (t[2]) {
    case "h":
      return i * 3600;
    case "m":
      return i * 60;
    case "ms":
      return i * 1e3;
    case "f":
      return i / e.frameRate;
    case "t":
      return i / e.tickRate;
  }
  return i;
}
class Ja {
  constructor(e, t) {
    this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = e, this.trackName = t;
  }
  dispatchCue() {
    this.startTime !== null && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null);
  }
  newCue(e, t, i) {
    (this.startTime === null || this.startTime > e) && (this.startTime = e), this.endTime = t, this.screen = i, this.timelineController.createCaptionsTrack(this.trackName);
  }
  reset() {
    this.cueRanges = [], this.startTime = null;
  }
}
class _x {
  constructor(e) {
    this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = th(), this.captionsProperties = void 0, this.hls = e, this.config = e.config, this.Cues = e.config.cueHandler, this.captionsProperties = {
      textTrack1: {
        label: this.config.captionsTextTrack1Label,
        languageCode: this.config.captionsTextTrack1LanguageCode
      },
      textTrack2: {
        label: this.config.captionsTextTrack2Label,
        languageCode: this.config.captionsTextTrack2LanguageCode
      },
      textTrack3: {
        label: this.config.captionsTextTrack3Label,
        languageCode: this.config.captionsTextTrack3LanguageCode
      },
      textTrack4: {
        label: this.config.captionsTextTrack4Label,
        languageCode: this.config.captionsTextTrack4LanguageCode
      }
    }, e.on(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(x.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(x.FRAG_LOADING, this.onFragLoading, this), e.on(x.FRAG_LOADED, this.onFragLoaded, this), e.on(x.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.on(x.FRAG_DECRYPTED, this.onFragDecrypted, this), e.on(x.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(x.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.on(x.BUFFER_FLUSHING, this.onBufferFlushing, this);
  }
  destroy() {
    const {
      hls: e
    } = this;
    e.off(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(x.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(x.FRAG_LOADING, this.onFragLoading, this), e.off(x.FRAG_LOADED, this.onFragLoaded, this), e.off(x.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.off(x.FRAG_DECRYPTED, this.onFragDecrypted, this), e.off(x.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(x.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.off(x.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = this.media = null, this.cea608Parser1 = this.cea608Parser2 = void 0;
  }
  initCea608Parsers() {
    const e = new Ja(this, "textTrack1"), t = new Ja(this, "textTrack2"), i = new Ja(this, "textTrack3"), s = new Ja(this, "textTrack4");
    this.cea608Parser1 = new jf(1, e, t), this.cea608Parser2 = new jf(3, i, s);
  }
  addCues(e, t, i, s, r) {
    let a = !1;
    for (let o = r.length; o--; ) {
      const l = r[o], c = Ax(l[0], l[1], t, i);
      if (c >= 0 && (l[0] = Math.min(l[0], t), l[1] = Math.max(l[1], i), a = !0, c / (i - t) > 0.5))
        return;
    }
    if (a || r.push([t, i]), this.config.renderTextTracksNatively) {
      const o = this.captionsTracks[e];
      this.Cues.newCue(o, t, i, s);
    } else {
      const o = this.Cues.newCue(null, t, i, s);
      this.hls.trigger(x.CUES_PARSED, {
        type: "captions",
        cues: o,
        track: e
      });
    }
  }
  // Triggered when an initial PTS is found; used for synchronisation of WebVTT.
  onInitPtsFound(e, {
    frag: t,
    id: i,
    initPTS: s,
    timescale: r,
    trackId: a
  }) {
    const {
      unparsedVttFrags: o
    } = this;
    i === te.MAIN && (this.initPTS[t.cc] = {
      baseTime: s,
      timescale: r,
      trackId: a
    }), o.length && (this.unparsedVttFrags = [], o.forEach((l) => {
      this.initPTS[l.frag.cc] ? this.onFragLoaded(x.FRAG_LOADED, l) : this.hls.trigger(x.SUBTITLE_FRAG_PROCESSED, {
        success: !1,
        frag: l.frag,
        error: new Error("Subtitle discontinuity domain does not match main")
      });
    }));
  }
  getExistingTrack(e, t) {
    const {
      media: i
    } = this;
    if (i)
      for (let s = 0; s < i.textTracks.length; s++) {
        const r = i.textTracks[s];
        if (eh(r, {
          name: e,
          lang: t,
          characteristics: "transcribes-spoken-dialog,describes-music-and-sound"
        }))
          return r;
      }
    return null;
  }
  createCaptionsTrack(e) {
    this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e);
  }
  createNativeTrack(e) {
    if (this.captionsTracks[e])
      return;
    const {
      captionsProperties: t,
      captionsTracks: i,
      media: s
    } = this, {
      label: r,
      languageCode: a
    } = t[e], o = this.getExistingTrack(r, a);
    if (o)
      i[e] = o, Qr(i[e]), nm(i[e], s);
    else {
      const l = this.createTextTrack("captions", r, a);
      l && (l[e] = !0, i[e] = l);
    }
  }
  createNonNativeTrack(e) {
    if (this.nonNativeCaptionsTracks[e])
      return;
    const t = this.captionsProperties[e];
    if (!t)
      return;
    const i = t.label, s = {
      _id: e,
      label: i,
      kind: "captions",
      default: t.media ? !!t.media.default : !1,
      closedCaptions: t.media
    };
    this.nonNativeCaptionsTracks[e] = s, this.hls.trigger(x.NON_NATIVE_TEXT_TRACKS_FOUND, {
      tracks: [s]
    });
  }
  createTextTrack(e, t, i) {
    const s = this.media;
    if (s)
      return s.addTextTrack(e, t, i);
  }
  onMediaAttaching(e, t) {
    this.media = t.media, t.mediaSource || this._cleanTracks();
  }
  onMediaDetaching(e, t) {
    const i = !!t.transferMedia;
    if (this.media = null, i)
      return;
    const {
      captionsTracks: s
    } = this;
    Object.keys(s).forEach((r) => {
      Qr(s[r]), delete s[r];
    }), this.nonNativeCaptionsTracks = {};
  }
  onManifestLoading() {
    this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = th(), this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = [], this.initPTS = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset());
  }
  _cleanTracks() {
    const {
      media: e
    } = this;
    if (!e)
      return;
    const t = e.textTracks;
    if (t)
      for (let i = 0; i < t.length; i++)
        Qr(t[i]);
  }
  onSubtitleTracksUpdated(e, t) {
    const i = t.subtitleTracks || [], s = i.some((r) => r.textCodec === Hl);
    if (this.config.enableWebVTT || s && this.config.enableIMSC1) {
      if (Kg(this.tracks, i)) {
        this.tracks = i;
        return;
      }
      if (this.textTracks = [], this.tracks = i, this.config.renderTextTracksNatively) {
        const a = this.media, o = a ? Eo(a.textTracks) : null;
        if (this.tracks.forEach((l, c) => {
          let u;
          if (o) {
            let d = null;
            for (let f = 0; f < o.length; f++)
              if (o[f] && eh(o[f], l)) {
                d = o[f], o[f] = null;
                break;
              }
            d && (u = d);
          }
          if (u)
            Qr(u);
          else {
            const d = mm(l);
            u = this.createTextTrack(d, l.name, l.lang), u && (u.mode = "disabled");
          }
          u && this.textTracks.push(u);
        }), o != null && o.length) {
          const l = o.filter((c) => c !== null).map((c) => c.label);
          l.length && this.hls.logger.warn(`Media element contains unused subtitle tracks: ${l.join(", ")}. Replace media element for each source to clear TextTracks and captions menu.`);
        }
      } else if (this.tracks.length) {
        const a = this.tracks.map((o) => ({
          label: o.name,
          kind: o.type.toLowerCase(),
          default: o.default,
          subtitleTrack: o
        }));
        this.hls.trigger(x.NON_NATIVE_TEXT_TRACKS_FOUND, {
          tracks: a
        });
      }
    }
  }
  onManifestLoaded(e, t) {
    this.config.enableCEA708Captions && t.captions && t.captions.forEach((i) => {
      const s = /(?:CC|SERVICE)([1-4])/.exec(i.instreamId);
      if (!s)
        return;
      const r = `textTrack${s[1]}`, a = this.captionsProperties[r];
      a && (a.label = i.name, i.lang && (a.languageCode = i.lang), a.media = i);
    });
  }
  closedCaptionsForLevel(e) {
    const t = this.hls.levels[e.level];
    return t?.attrs["CLOSED-CAPTIONS"];
  }
  onFragLoading(e, t) {
    if (this.enabled && t.frag.type === te.MAIN) {
      var i, s;
      const {
        cea608Parser1: r,
        cea608Parser2: a,
        lastSn: o
      } = this, {
        cc: l,
        sn: c
      } = t.frag, u = (i = (s = t.part) == null ? void 0 : s.index) != null ? i : -1;
      r && a && (c !== o + 1 || c === o && u !== this.lastPartIndex + 1 || l !== this.lastCc) && (r.reset(), a.reset()), this.lastCc = l, this.lastSn = c, this.lastPartIndex = u;
    }
  }
  onFragLoaded(e, t) {
    const {
      frag: i,
      payload: s
    } = t;
    if (i.type === te.SUBTITLE)
      if (s.byteLength) {
        const r = i.decryptdata, a = "stats" in t;
        if (r == null || !r.encrypted || a) {
          const o = this.tracks[i.level], l = this.vttCCs;
          l[i.cc] || (l[i.cc] = {
            start: i.start,
            prevCC: this.prevCC,
            new: !0
          }, this.prevCC = i.cc), o && o.textCodec === Hl ? this._parseIMSC1(i, s) : this._parseVTTs(t);
        }
      } else
        this.hls.trigger(x.SUBTITLE_FRAG_PROCESSED, {
          success: !1,
          frag: i,
          error: new Error("Empty subtitle payload")
        });
  }
  _parseIMSC1(e, t) {
    const i = this.hls;
    Qf(t, this.initPTS[e.cc], (s) => {
      this._appendCues(s, e.level), i.trigger(x.SUBTITLE_FRAG_PROCESSED, {
        success: !0,
        frag: e
      });
    }, (s) => {
      i.logger.log(`Failed to parse IMSC1: ${s}`), i.trigger(x.SUBTITLE_FRAG_PROCESSED, {
        success: !1,
        frag: e,
        error: s
      });
    });
  }
  _parseVTTs(e) {
    var t;
    const {
      frag: i,
      payload: s
    } = e, {
      initPTS: r,
      unparsedVttFrags: a
    } = this, o = r.length - 1;
    if (!r[i.cc] && o === -1) {
      a.push(e);
      return;
    }
    const l = this.hls, c = (t = i.initSegment) != null && t.data ? Oi(i.initSegment.data, new Uint8Array(s)).buffer : s;
    yx(c, this.initPTS[i.cc], this.vttCCs, i.cc, i.start, (u) => {
      this._appendCues(u, i.level), l.trigger(x.SUBTITLE_FRAG_PROCESSED, {
        success: !0,
        frag: i
      });
    }, (u) => {
      const d = u.message === "Missing initPTS for VTT MPEGTS";
      d ? a.push(e) : this._fallbackToIMSC1(i, s), l.logger.log(`Failed to parse VTT cue: ${u}`), !(d && o > i.cc) && l.trigger(x.SUBTITLE_FRAG_PROCESSED, {
        success: !1,
        frag: i,
        error: u
      });
    });
  }
  _fallbackToIMSC1(e, t) {
    const i = this.tracks[e.level];
    i.textCodec || Qf(t, this.initPTS[e.cc], () => {
      i.textCodec = Hl, this._parseIMSC1(e, t);
    }, () => {
      i.textCodec = "wvtt";
    });
  }
  _appendCues(e, t) {
    const i = this.hls;
    if (this.config.renderTextTracksNatively) {
      const s = this.textTracks[t];
      if (!s || s.mode === "disabled")
        return;
      e.forEach((r) => am(s, r));
    } else {
      const s = this.tracks[t];
      if (!s)
        return;
      const r = s.default ? "default" : "subtitles" + t;
      i.trigger(x.CUES_PARSED, {
        type: "subtitles",
        cues: e,
        track: r
      });
    }
  }
  onFragDecrypted(e, t) {
    const {
      frag: i
    } = t;
    i.type === te.SUBTITLE && this.onFragLoaded(x.FRAG_LOADED, t);
  }
  onSubtitleTracksCleared() {
    this.tracks = [], this.captionsTracks = {};
  }
  onFragParsingUserdata(e, t) {
    if (!this.enabled || !this.config.enableCEA708Captions)
      return;
    const {
      frag: i,
      samples: s
    } = t;
    if (!(i.type === te.MAIN && this.closedCaptionsForLevel(i) === "NONE"))
      for (let r = 0; r < s.length; r++) {
        const a = s[r].bytes;
        if (a) {
          this.cea608Parser1 || this.initCea608Parsers();
          const o = this.extractCea608Data(a);
          this.cea608Parser1.addData(s[r].pts, o[0]), this.cea608Parser2.addData(s[r].pts, o[1]);
        }
      }
  }
  onBufferFlushing(e, {
    startOffset: t,
    endOffset: i,
    endOffsetSubtitles: s,
    type: r
  }) {
    const {
      media: a
    } = this;
    if (!(!a || a.currentTime < i)) {
      if (!r || r === "video") {
        const {
          captionsTracks: o
        } = this;
        Object.keys(o).forEach((l) => Kc(o[l], t, i));
      }
      if (this.config.renderTextTracksNatively && t === 0 && s !== void 0) {
        const {
          textTracks: o
        } = this;
        Object.keys(o).forEach((l) => Kc(o[l], t, s));
      }
    }
  }
  extractCea608Data(e) {
    const t = [[], []], i = e[0] & 31;
    let s = 2;
    for (let r = 0; r < i; r++) {
      const a = e[s++], o = 127 & e[s++], l = 127 & e[s++];
      if (o === 0 && l === 0)
        continue;
      if ((4 & a) !== 0) {
        const u = 3 & a;
        (u === 0 || u === 1) && (t[u].push(o), t[u].push(l));
      }
    }
    return t;
  }
}
function mm(n) {
  return n.characteristics && /transcribes-spoken-dialog/gi.test(n.characteristics) && /describes-music-and-sound/gi.test(n.characteristics) ? "captions" : "subtitles";
}
function eh(n, e) {
  return !!n && n.kind === mm(e) && Hc(e, n);
}
function Ax(n, e, t, i) {
  return Math.min(e, i) - Math.max(n, t);
}
function th() {
  return {
    ccOffset: 0,
    presentationOffset: 0,
    0: {
      start: 0,
      prevCC: -1,
      new: !0
    }
  };
}
const wx = /\s/, Lx = {
  newCue(n, e, t, i) {
    const s = [];
    let r, a, o, l, c;
    const u = self.VTTCue || self.TextTrackCue;
    for (let f = 0; f < i.rows.length; f++)
      if (r = i.rows[f], o = !0, l = 0, c = "", !r.isEmpty()) {
        var d;
        for (let g = 0; g < r.chars.length; g++)
          wx.test(r.chars[g].uchar) && o ? l++ : (c += r.chars[g].uchar, o = !1);
        r.cueStartTime = e, e === t && (t += 1e-4), l >= 16 ? l-- : l++;
        const p = fm(c.trim()), h = Ju(e, t, p);
        n != null && (d = n.cues) != null && d.getCueById(h) || (a = new u(e, t, p), a.id = h, a.line = f + 1, a.align = "left", a.position = 10 + Math.min(80, Math.floor(l * 8 / 32) * 10), s.push(a));
      }
    return n && s.length && (s.sort((f, p) => f.line === "auto" || p.line === "auto" ? 0 : f.line > 8 && p.line > 8 ? p.line - f.line : f.line - p.line), s.forEach((f) => am(n, f))), s;
  }
};
function Ix() {
  if (
    // @ts-ignore
    self.fetch && self.AbortController && self.ReadableStream && self.Request
  )
    try {
      return new self.ReadableStream({}), !0;
    } catch {
    }
  return !1;
}
const Rx = /(\d+)-(\d+)\/(\d+)/;
class ih {
  constructor(e) {
    this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = null, this.response = null, this.controller = void 0, this.context = null, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = e.fetchSetup || kx, this.controller = new self.AbortController(), this.stats = new Pu();
  }
  destroy() {
    this.loader = this.callbacks = this.context = this.config = this.request = null, this.abortInternal(), this.response = null, this.fetchSetup = this.controller = this.stats = null;
  }
  abortInternal() {
    this.controller && !this.stats.loading.end && (this.stats.aborted = !0, this.controller.abort());
  }
  abort() {
    var e;
    this.abortInternal(), (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response);
  }
  load(e, t, i) {
    const s = this.stats;
    if (s.loading.start)
      throw new Error("Loader can only be used once.");
    s.loading.start = self.performance.now();
    const r = Cx(e, this.controller.signal), a = e.responseType === "arraybuffer", o = a ? "byteLength" : "length", {
      maxTimeToFirstByteMs: l,
      maxLoadTimeMs: c
    } = t.loadPolicy;
    this.context = e, this.config = t, this.callbacks = i, this.request = this.fetchSetup(e, r), self.clearTimeout(this.requestTimeout), t.timeout = l && Z(l) ? l : c, this.requestTimeout = self.setTimeout(() => {
      this.callbacks && (this.abortInternal(), this.callbacks.onTimeout(s, e, this.response));
    }, t.timeout), (ya(this.request) ? this.request.then(self.fetch) : self.fetch(this.request)).then((d) => {
      var f;
      this.response = this.loader = d;
      const p = Math.max(self.performance.now(), s.loading.start);
      if (self.clearTimeout(this.requestTimeout), t.timeout = c, this.requestTimeout = self.setTimeout(() => {
        this.callbacks && (this.abortInternal(), this.callbacks.onTimeout(s, e, this.response));
      }, c - (p - s.loading.start)), !d.ok) {
        const {
          status: g,
          statusText: m
        } = d;
        throw new Mx(m || "fetch, bad network response", g, d);
      }
      s.loading.first = p, s.total = Dx(d.headers) || s.total;
      const h = (f = this.callbacks) == null ? void 0 : f.onProgress;
      return h && Z(t.highWaterMark) ? this.loadProgressively(d, s, e, t.highWaterMark, h) : a ? d.arrayBuffer() : e.responseType === "json" ? d.json() : d.text();
    }).then((d) => {
      var f, p;
      const h = this.response;
      if (!h)
        throw new Error("loader destroyed");
      self.clearTimeout(this.requestTimeout), s.loading.end = Math.max(self.performance.now(), s.loading.first);
      const g = d[o];
      g && (s.loaded = s.total = g);
      const m = {
        url: h.url,
        data: d,
        code: h.status
      }, v = (f = this.callbacks) == null ? void 0 : f.onProgress;
      v && !Z(t.highWaterMark) && v(s, e, d, h), (p = this.callbacks) == null || p.onSuccess(m, s, e, h);
    }).catch((d) => {
      var f;
      if (self.clearTimeout(this.requestTimeout), s.aborted)
        return;
      const p = d && d.code || 0, h = d ? d.message : null;
      (f = this.callbacks) == null || f.onError({
        code: p,
        text: h
      }, e, d ? d.details : null, s);
    });
  }
  getCacheAge() {
    let e = null;
    if (this.response) {
      const t = this.response.headers.get("age");
      e = t ? parseFloat(t) : null;
    }
    return e;
  }
  getResponseHeader(e) {
    return this.response ? this.response.headers.get(e) : null;
  }
  loadProgressively(e, t, i, s = 0, r) {
    const a = new wg(), o = e.body.getReader(), l = () => o.read().then((c) => {
      if (c.done)
        return a.dataLength && r(t, i, a.flush().buffer, e), Promise.resolve(new ArrayBuffer(0));
      const u = c.value, d = u.length;
      return t.loaded += d, d < s || a.dataLength ? (a.push(u), a.dataLength >= s && r(t, i, a.flush().buffer, e)) : r(t, i, u.buffer, e), l();
    }).catch(() => Promise.reject());
    return l();
  }
}
function Cx(n, e) {
  const t = {
    method: "GET",
    mode: "cors",
    credentials: "same-origin",
    signal: e,
    headers: new self.Headers(Fe({}, n.headers))
  };
  return n.rangeEnd && t.headers.set("Range", "bytes=" + n.rangeStart + "-" + String(n.rangeEnd - 1)), t;
}
function Px(n) {
  const e = Rx.exec(n);
  if (e)
    return parseInt(e[2]) - parseInt(e[1]) + 1;
}
function Dx(n) {
  const e = n.get("Content-Range");
  if (e) {
    const i = Px(e);
    if (Z(i))
      return i;
  }
  const t = n.get("Content-Length");
  if (t)
    return parseInt(t);
}
function kx(n, e) {
  return new self.Request(n.url, e);
}
class Mx extends Error {
  constructor(e, t, i) {
    super(e), this.code = void 0, this.details = void 0, this.code = t, this.details = i;
  }
}
const Ox = /^age:\s*[\d.]+\s*$/im;
class vm {
  constructor(e) {
    this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = null, this.loader = null, this.stats = void 0, this.xhrSetup = e && e.xhrSetup || null, this.stats = new Pu(), this.retryDelay = 0;
  }
  destroy() {
    this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null, this.context = null, this.xhrSetup = null;
  }
  abortInternal() {
    const e = this.loader;
    self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), e && (e.onreadystatechange = null, e.onprogress = null, e.readyState !== 4 && (this.stats.aborted = !0, e.abort()));
  }
  abort() {
    var e;
    this.abortInternal(), (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader);
  }
  load(e, t, i) {
    if (this.stats.loading.start)
      throw new Error("Loader can only be used once.");
    this.stats.loading.start = self.performance.now(), this.context = e, this.config = t, this.callbacks = i, this.loadInternal();
  }
  loadInternal() {
    const {
      config: e,
      context: t
    } = this;
    if (!e || !t)
      return;
    const i = this.loader = new self.XMLHttpRequest(), s = this.stats;
    s.loading.first = 0, s.loaded = 0, s.aborted = !1;
    const r = this.xhrSetup;
    r ? Promise.resolve().then(() => {
      if (!(this.loader !== i || this.stats.aborted))
        return r(i, t.url);
    }).catch((a) => {
      if (!(this.loader !== i || this.stats.aborted))
        return i.open("GET", t.url, !0), r(i, t.url);
    }).then(() => {
      this.loader !== i || this.stats.aborted || this.openAndSendXhr(i, t, e);
    }).catch((a) => {
      var o;
      (o = this.callbacks) == null || o.onError({
        code: i.status,
        text: a.message
      }, t, i, s);
    }) : this.openAndSendXhr(i, t, e);
  }
  openAndSendXhr(e, t, i) {
    e.readyState || e.open("GET", t.url, !0);
    const s = t.headers, {
      maxTimeToFirstByteMs: r,
      maxLoadTimeMs: a
    } = i.loadPolicy;
    if (s)
      for (const o in s)
        e.setRequestHeader(o, s[o]);
    t.rangeEnd && e.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.responseType = t.responseType, self.clearTimeout(this.requestTimeout), i.timeout = r && Z(r) ? r : a, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), i.timeout), e.send();
  }
  readystatechange() {
    const {
      context: e,
      loader: t,
      stats: i
    } = this;
    if (!e || !t)
      return;
    const s = t.readyState, r = this.config;
    if (!i.aborted && s >= 2 && (i.loading.first === 0 && (i.loading.first = Math.max(self.performance.now(), i.loading.start), r.timeout !== r.loadPolicy.maxLoadTimeMs && (self.clearTimeout(this.requestTimeout), r.timeout = r.loadPolicy.maxLoadTimeMs, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), r.loadPolicy.maxLoadTimeMs - (i.loading.first - i.loading.start)))), s === 4)) {
      self.clearTimeout(this.requestTimeout), t.onreadystatechange = null, t.onprogress = null;
      const c = t.status, u = t.responseType === "text" ? t.responseText : null;
      if (c >= 200 && c < 300) {
        const h = u ?? t.response;
        if (h != null) {
          var a, o;
          i.loading.end = Math.max(self.performance.now(), i.loading.first);
          const g = t.responseType === "arraybuffer" ? h.byteLength : h.length;
          i.loaded = i.total = g, i.bwEstimate = i.total * 8e3 / (i.loading.end - i.loading.first);
          const m = (a = this.callbacks) == null ? void 0 : a.onProgress;
          m && m(i, e, h, t);
          const v = {
            url: t.responseURL,
            data: h,
            code: c
          };
          (o = this.callbacks) == null || o.onSuccess(v, i, e, t);
          return;
        }
      }
      const d = r.loadPolicy.errorRetry, f = i.retry, p = {
        url: e.url,
        data: void 0,
        code: c
      };
      if (Go(d, f, !1, p))
        this.retry(d);
      else {
        var l;
        Oe.error(`${c} while loading ${e.url}`), (l = this.callbacks) == null || l.onError({
          code: c,
          text: t.statusText
        }, e, t, i);
      }
    }
  }
  loadtimeout() {
    if (!this.config) return;
    const e = this.config.loadPolicy.timeoutRetry, t = this.stats.retry;
    if (Go(e, t, !0))
      this.retry(e);
    else {
      var i;
      Oe.warn(`timeout while loading ${(i = this.context) == null ? void 0 : i.url}`);
      const s = this.callbacks;
      s && (this.abortInternal(), s.onTimeout(this.stats, this.context, this.loader));
    }
  }
  retry(e) {
    const {
      context: t,
      stats: i
    } = this;
    this.retryDelay = Ou(e, i.retry), i.retry++, Oe.warn(`${status ? "HTTP Status " + status : "Timeout"} while loading ${t?.url}, retrying ${i.retry}/${e.maxNumRetry} in ${this.retryDelay}ms`), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);
  }
  loadprogress(e) {
    const t = this.stats;
    t.loaded = e.loaded, e.lengthComputable && (t.total = e.total);
  }
  getCacheAge() {
    let e = null;
    if (this.loader && Ox.test(this.loader.getAllResponseHeaders())) {
      const t = this.loader.getResponseHeader("age");
      e = t ? parseFloat(t) : null;
    }
    return e;
  }
  getResponseHeader(e) {
    return this.loader && new RegExp(`^${e}:\\s*[\\d.]+\\s*$`, "im").test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(e) : null;
  }
}
const Fx = {
  maxTimeToFirstByteMs: 8e3,
  maxLoadTimeMs: 2e4,
  timeoutRetry: null,
  errorRetry: null
}, Nx = Me(Me({
  autoStartLoad: !0,
  // used by stream-controller
  startPosition: -1,
  // used by stream-controller
  defaultAudioCodec: void 0,
  // used by stream-controller
  debug: !1,
  // used by logger
  capLevelOnFPSDrop: !1,
  // used by fps-controller
  capLevelToPlayerSize: !1,
  // used by cap-level-controller
  ignoreDevicePixelRatio: !1,
  // used by cap-level-controller
  maxDevicePixelRatio: Number.POSITIVE_INFINITY,
  // used by cap-level-controller
  preferManagedMediaSource: !0,
  initialLiveManifestSize: 1,
  // used by stream-controller
  maxBufferLength: 30,
  // used by stream-controller
  backBufferLength: 1 / 0,
  // used by buffer-controller
  frontBufferFlushThreshold: 1 / 0,
  startOnSegmentBoundary: !1,
  // used by stream-controller
  maxBufferSize: 60 * 1e3 * 1e3,
  // used by stream-controller
  maxFragLookUpTolerance: 0.25,
  // used by stream-controller
  maxBufferHole: 0.1,
  // used by stream-controller and gap-controller
  detectStallWithCurrentTimeMs: 1250,
  // used by gap-controller
  highBufferWatchdogPeriod: 2,
  // used by gap-controller
  nudgeOffset: 0.1,
  // used by gap-controller
  nudgeMaxRetry: 3,
  // used by gap-controller
  nudgeOnVideoHole: !0,
  // used by gap-controller
  liveSyncMode: "edge",
  // used by stream-controller
  liveSyncDurationCount: 3,
  // used by latency-controller
  liveSyncOnStallIncrease: 1,
  // used by latency-controller
  liveMaxLatencyDurationCount: 1 / 0,
  // used by latency-controller
  liveSyncDuration: void 0,
  // used by latency-controller
  liveMaxLatencyDuration: void 0,
  // used by latency-controller
  maxLiveSyncPlaybackRate: 1,
  // used by latency-controller
  liveDurationInfinity: !1,
  // used by buffer-controller
  /**
   * @deprecated use backBufferLength
   */
  liveBackBufferLength: null,
  // used by buffer-controller
  maxMaxBufferLength: 600,
  // used by stream-controller
  enableWorker: !0,
  // used by transmuxer
  workerPath: null,
  // used by transmuxer
  enableSoftwareAES: !0,
  // used by decrypter
  startLevel: void 0,
  // used by level-controller
  startFragPrefetch: !1,
  // used by stream-controller
  fpsDroppedMonitoringPeriod: 5e3,
  // used by fps-controller
  fpsDroppedMonitoringThreshold: 0.2,
  // used by fps-controller
  appendErrorMaxRetry: 3,
  // used by buffer-controller
  ignorePlaylistParsingErrors: !1,
  loader: vm,
  // loader: FetchLoader,
  fLoader: void 0,
  // used by fragment-loader
  pLoader: void 0,
  // used by playlist-loader
  xhrSetup: void 0,
  // used by xhr-loader
  licenseXhrSetup: void 0,
  // used by eme-controller
  licenseResponseCallback: void 0,
  // used by eme-controller
  abrController: Xy,
  bufferController: BT,
  capLevelController: Xu,
  errorController: eE,
  fpsController: US,
  stretchShortVideoTrack: !1,
  // used by mp4-remuxer
  maxAudioFramesDrift: 1,
  // used by mp4-remuxer
  forceKeyFrameOnDiscontinuity: !0,
  // used by ts-demuxer
  abrEwmaFastLive: 3,
  // used by abr-controller
  abrEwmaSlowLive: 9,
  // used by abr-controller
  abrEwmaFastVoD: 3,
  // used by abr-controller
  abrEwmaSlowVoD: 9,
  // used by abr-controller
  abrEwmaDefaultEstimate: 5e5,
  // 500 kbps  // used by abr-controller
  abrEwmaDefaultEstimateMax: 5e6,
  // 5 mbps
  abrBandWidthFactor: 0.95,
  // used by abr-controller
  abrBandWidthUpFactor: 0.7,
  // used by abr-controller
  abrMaxWithRealBitrate: !1,
  // used by abr-controller
  maxStarvationDelay: 4,
  // used by abr-controller
  maxLoadingDelay: 4,
  // used by abr-controller
  minAutoBitrate: 0,
  // used by hls
  emeEnabled: !1,
  // used by eme-controller
  widevineLicenseUrl: void 0,
  // used by eme-controller
  drmSystems: {},
  // used by eme-controller
  drmSystemOptions: {},
  // used by eme-controller
  requestMediaKeySystemAccessFunc: gg,
  // used by eme-controller
  requireKeySystemAccessOnStart: !1,
  // used by eme-controller
  testBandwidth: !0,
  progressive: !1,
  lowLatencyMode: !0,
  cmcd: void 0,
  enableDateRangeMetadataCues: !0,
  enableEmsgMetadataCues: !0,
  enableEmsgKLVMetadata: !1,
  enableID3MetadataCues: !0,
  enableInterstitialPlayback: !0,
  interstitialAppendInPlace: !0,
  interstitialLiveLookAhead: 10,
  useMediaCapabilities: !0,
  preserveManualLevelOnError: !1,
  certLoadPolicy: {
    default: Fx
  },
  keyLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 8e3,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 2e4,
        backoff: "linear"
      },
      errorRetry: {
        maxNumRetry: 8,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 2e4,
        backoff: "linear"
      }
    }
  },
  manifestLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1 / 0,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  playlistLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 2,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  fragLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 12e4,
      timeoutRetry: {
        maxNumRetry: 4,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 6,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  steeringManifestLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  interstitialAssetListLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 3e4,
      timeoutRetry: {
        maxNumRetry: 0,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 0,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  // These default settings are deprecated in favor of the above policies
  // and are maintained for backwards compatibility
  manifestLoadingTimeOut: 1e4,
  manifestLoadingMaxRetry: 1,
  manifestLoadingRetryDelay: 1e3,
  manifestLoadingMaxRetryTimeout: 64e3,
  levelLoadingTimeOut: 1e4,
  levelLoadingMaxRetry: 4,
  levelLoadingRetryDelay: 1e3,
  levelLoadingMaxRetryTimeout: 64e3,
  fragLoadingTimeOut: 2e4,
  fragLoadingMaxRetry: 6,
  fragLoadingRetryDelay: 1e3,
  fragLoadingMaxRetryTimeout: 64e3
}, $x()), {}, {
  subtitleStreamController: ZS,
  subtitleTrackController: VS,
  timelineController: _x,
  audioStreamController: OT,
  audioTrackController: FT,
  emeController: on,
  cmcdController: FS,
  contentSteeringController: $S,
  interstitialsController: QS
});
function $x() {
  return {
    cueHandler: Lx,
    // used by timeline-controller
    enableWebVTT: !0,
    // used by timeline-controller
    enableIMSC1: !0,
    // used by timeline-controller
    enableCEA708Captions: !0,
    // used by timeline-controller
    captionsTextTrack1Label: "English",
    // used by timeline-controller
    captionsTextTrack1LanguageCode: "en",
    // used by timeline-controller
    captionsTextTrack2Label: "Spanish",
    // used by timeline-controller
    captionsTextTrack2LanguageCode: "es",
    // used by timeline-controller
    captionsTextTrack3Label: "Unknown CC",
    // used by timeline-controller
    captionsTextTrack3LanguageCode: "",
    // used by timeline-controller
    captionsTextTrack4Label: "Unknown CC",
    // used by timeline-controller
    captionsTextTrack4LanguageCode: "",
    // used by timeline-controller
    renderTextTracksNatively: !0
  };
}
function Bx(n, e, t) {
  if ((e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) && (e.liveSyncDuration || e.liveMaxLatencyDuration))
    throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
  if (e.liveMaxLatencyDurationCount !== void 0 && (e.liveSyncDurationCount === void 0 || e.liveMaxLatencyDurationCount <= e.liveSyncDurationCount))
    throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
  if (e.liveMaxLatencyDuration !== void 0 && (e.liveSyncDuration === void 0 || e.liveMaxLatencyDuration <= e.liveSyncDuration))
    throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
  const i = qc(n), s = ["manifest", "level", "frag"], r = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
  return s.forEach((a) => {
    const o = `${a === "level" ? "playlist" : a}LoadPolicy`, l = e[o] === void 0, c = [];
    r.forEach((u) => {
      const d = `${a}Loading${u}`, f = e[d];
      if (f !== void 0 && l) {
        c.push(d);
        const p = i[o].default;
        switch (e[o] = {
          default: p
        }, u) {
          case "TimeOut":
            p.maxLoadTimeMs = f, p.maxTimeToFirstByteMs = f;
            break;
          case "MaxRetry":
            p.errorRetry.maxNumRetry = f, p.timeoutRetry.maxNumRetry = f;
            break;
          case "RetryDelay":
            p.errorRetry.retryDelayMs = f, p.timeoutRetry.retryDelayMs = f;
            break;
          case "MaxRetryTimeout":
            p.errorRetry.maxRetryDelayMs = f, p.timeoutRetry.maxRetryDelayMs = f;
            break;
        }
      }
    }), c.length && t.warn(`hls.js config: "${c.join('", "')}" setting(s) are deprecated, use "${o}": ${Ge(e[o])}`);
  }), Me(Me({}, i), e);
}
function qc(n) {
  return n && typeof n == "object" ? Array.isArray(n) ? n.map(qc) : Object.keys(n).reduce((e, t) => (e[t] = qc(n[t]), e), {}) : n;
}
function Ux(n, e) {
  const t = n.loader;
  t !== ih && t !== vm ? (e.log("[config]: Custom loader detected, cannot enable progressive streaming"), n.progressive = !1) : Ix() && (n.loader = ih, n.progressive = !0, n.enableSoftwareAES = !0, e.log("[config]: Progressive streaming enabled, using FetchLoader"));
}
const To = 2, Gx = 0.1, Hx = 0.05, Vx = 100;
class zx extends ug {
  constructor(e, t) {
    super("gap-controller", e.logger), this.hls = void 0, this.fragmentTracker = void 0, this.media = null, this.mediaSource = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.buffered = {}, this.lastCurrentTime = 0, this.ended = 0, this.waiting = 0, this.onMediaPlaying = () => {
      this.ended = 0, this.waiting = 0;
    }, this.onMediaWaiting = () => {
      var i;
      (i = this.media) != null && i.seeking || (this.waiting = self.performance.now(), this.tick());
    }, this.onMediaEnded = () => {
      if (this.hls) {
        var i;
        this.ended = ((i = this.media) == null ? void 0 : i.currentTime) || 1, this.hls.trigger(x.MEDIA_ENDED, {
          stalled: !1
        });
      }
    }, this.hls = e, this.fragmentTracker = t, this.registerListeners();
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e && (e.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.BUFFER_APPENDED, this.onBufferAppended, this));
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (e.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.BUFFER_APPENDED, this.onBufferAppended, this));
  }
  destroy() {
    super.destroy(), this.unregisterListeners(), this.media = this.hls = this.fragmentTracker = null, this.mediaSource = void 0;
  }
  onMediaAttached(e, t) {
    this.setInterval(Vx), this.mediaSource = t.mediaSource;
    const i = this.media = t.media;
    Zt(i, "playing", this.onMediaPlaying), Zt(i, "waiting", this.onMediaWaiting), Zt(i, "ended", this.onMediaEnded);
  }
  onMediaDetaching(e, t) {
    this.clearInterval();
    const {
      media: i
    } = this;
    i && (ti(i, "playing", this.onMediaPlaying), ti(i, "waiting", this.onMediaWaiting), ti(i, "ended", this.onMediaEnded), this.media = null), this.mediaSource = void 0;
  }
  onBufferAppended(e, t) {
    this.buffered = t.timeRanges;
  }
  get hasBuffered() {
    return Object.keys(this.buffered).length > 0;
  }
  tick() {
    var e;
    if (!((e = this.media) != null && e.readyState) || !this.hasBuffered)
      return;
    const t = this.media.currentTime;
    this.poll(t, this.lastCurrentTime), this.lastCurrentTime = t;
  }
  /**
   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.
   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).
   *
   * @param lastCurrentTime - Previously read playhead position
   */
  poll(e, t) {
    var i, s;
    const r = (i = this.hls) == null ? void 0 : i.config;
    if (!r)
      return;
    const a = this.media;
    if (!a)
      return;
    const {
      seeking: o
    } = a, l = this.seeking && !o, c = !this.seeking && o, u = a.paused && !o || a.ended || a.playbackRate === 0;
    if (this.seeking = o, e !== t) {
      t && (this.ended = 0), this.moved = !0, o || (this.nudgeRetry = 0, r.nudgeOnVideoHole && !u && e > t && this.nudgeOnVideoHole(e, t)), this.waiting === 0 && this.stallResolved(e);
      return;
    }
    if (c || l) {
      l && this.stallResolved(e);
      return;
    }
    if (u) {
      this.nudgeRetry = 0, this.stallResolved(e), !this.ended && a.ended && this.hls && (this.ended = e || 1, this.hls.trigger(x.MEDIA_ENDED, {
        stalled: !1
      }));
      return;
    }
    if (!de.getBuffered(a).length) {
      this.nudgeRetry = 0;
      return;
    }
    const d = de.bufferInfo(a, e, 0), f = d.nextStart || 0, p = this.fragmentTracker;
    if (o && p && this.hls) {
      const w = sh(this.hls.inFlightFragments, e), b = d.len > To, L = !f || w || f - e > To && !p.getPartialFragment(e);
      if (b || L)
        return;
      this.moved = !1;
    }
    const h = (s = this.hls) == null ? void 0 : s.latestLevelDetails;
    if (!this.moved && this.stalled !== null && p) {
      if (!(d.len > 0) && !f)
        return;
      const b = Math.max(f, d.start || 0) - e, A = !!(h != null && h.live) ? h.targetduration * 2 : To, _ = eo(e, p);
      if (b > 0 && (b <= A || _)) {
        a.paused || this._trySkipBufferHole(_);
        return;
      }
    }
    const g = r.detectStallWithCurrentTimeMs, m = self.performance.now(), v = this.waiting;
    let y = this.stalled;
    if (y === null)
      if (v > 0 && m - v < g)
        y = this.stalled = v;
      else {
        this.stalled = m;
        return;
      }
    const E = m - y;
    if (!o && (E >= g || v) && this.hls) {
      var T;
      if (((T = this.mediaSource) == null ? void 0 : T.readyState) === "ended" && !(h != null && h.live) && Math.abs(e - (h?.edge || 0)) < 1) {
        if (this.ended)
          return;
        this.ended = e || 1, this.hls.trigger(x.MEDIA_ENDED, {
          stalled: !0
        });
        return;
      }
      if (this._reportStall(d), !this.media || !this.hls)
        return;
    }
    const S = de.bufferInfo(a, e, r.maxBufferHole);
    this._tryFixBufferStall(S, E, e);
  }
  stallResolved(e) {
    const t = this.stalled;
    if (t && this.hls && (this.stalled = null, this.stallReported)) {
      const i = self.performance.now() - t;
      this.log(`playback not stuck anymore @${e}, after ${Math.round(i)}ms`), this.stallReported = !1, this.waiting = 0, this.hls.trigger(x.STALL_RESOLVED, {});
    }
  }
  nudgeOnVideoHole(e, t) {
    var i;
    const s = this.buffered.video;
    if (this.hls && this.media && this.fragmentTracker && (i = this.buffered.audio) != null && i.length && s && s.length > 1 && e > s.end(0)) {
      const r = de.bufferedInfo(de.timeRangesToArray(this.buffered.audio), e, 0);
      if (r.len > 1 && t >= r.start) {
        const a = de.timeRangesToArray(s), o = de.bufferedInfo(a, t, 0).bufferedIndex;
        if (o > -1 && o < a.length - 1) {
          const l = de.bufferedInfo(a, e, 0).bufferedIndex, c = a[o].end, u = a[o + 1].start;
          if ((l === -1 || l > o) && u - c < 1 && // `maxBufferHole` may be too small and setting it to 0 should not disable this feature
          e - c < 2) {
            const d = new Error(`nudging playhead to flush pipeline after video hole. currentTime: ${e} hole: ${c} -> ${u} buffered index: ${l}`);
            this.warn(d.message), this.media.currentTime += 1e-6;
            let f = eo(e, this.fragmentTracker);
            f && "fragment" in f ? f = f.fragment : f || (f = void 0);
            const p = de.bufferInfo(this.media, e, 0);
            this.hls.trigger(x.ERROR, {
              type: se.MEDIA_ERROR,
              details: H.BUFFER_SEEK_OVER_HOLE,
              fatal: !1,
              error: d,
              reason: d.message,
              frag: f,
              buffer: p.len,
              bufferInfo: p
            });
          }
        }
      }
    }
  }
  /**
   * Detects and attempts to fix known buffer stalling issues.
   * @param bufferInfo - The properties of the current buffer.
   * @param stalledDurationMs - The amount of time Hls.js has been stalling for.
   * @private
   */
  _tryFixBufferStall(e, t, i) {
    var s, r;
    const {
      fragmentTracker: a,
      media: o
    } = this, l = (s = this.hls) == null ? void 0 : s.config;
    if (!o || !a || !l)
      return;
    const c = (r = this.hls) == null ? void 0 : r.latestLevelDetails, u = eo(i, a);
    if ((u || c != null && c.live && i < c.fragmentStart) && (this._trySkipBufferHole(u) || !this.media))
      return;
    const d = e.buffered, f = this.adjacentTraversal(e, i);
    (d && d.length > 1 && e.len > l.maxBufferHole || e.nextStart && (e.nextStart - i < l.maxBufferHole || f)) && (t > l.highBufferWatchdogPeriod * 1e3 || this.waiting) && (this.warn("Trying to nudge playhead over buffer-hole"), this._tryNudgeBuffer(e));
  }
  adjacentTraversal(e, t) {
    const i = this.fragmentTracker, s = e.nextStart;
    if (i && s) {
      const r = i.getFragAtPos(t, te.MAIN), a = i.getFragAtPos(s, te.MAIN);
      if (r && a)
        return a.sn - r.sn < 2;
    }
    return !1;
  }
  /**
   * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.
   * @param bufferLen - The playhead distance from the end of the current buffer segment.
   * @private
   */
  _reportStall(e) {
    const {
      hls: t,
      media: i,
      stallReported: s,
      stalled: r
    } = this;
    if (!s && r !== null && i && t) {
      this.stallReported = !0;
      const a = new Error(`Playback stalling at @${i.currentTime} due to low buffer (${Ge(e)})`);
      this.warn(a.message), t.trigger(x.ERROR, {
        type: se.MEDIA_ERROR,
        details: H.BUFFER_STALLED_ERROR,
        fatal: !1,
        error: a,
        buffer: e.len,
        bufferInfo: e,
        stalled: {
          start: r
        }
      });
    }
  }
  /**
   * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments
   * @param appended - The fragment or part found at the current time (where playback is stalling).
   * @private
   */
  _trySkipBufferHole(e) {
    var t;
    const {
      fragmentTracker: i,
      media: s
    } = this, r = (t = this.hls) == null ? void 0 : t.config;
    if (!s || !i || !r)
      return 0;
    const a = s.currentTime, o = de.bufferInfo(s, a, 0), l = a < o.start ? o.start : o.nextStart;
    if (l && this.hls) {
      const u = o.len <= r.maxBufferHole, d = o.len > 0 && o.len < 1 && s.readyState < 3, f = l - a;
      if (f > 0 && (u || d)) {
        if (f > r.maxBufferHole) {
          let h = !1;
          if (a === 0) {
            const g = i.getAppendedFrag(0, te.MAIN);
            g && l < g.end && (h = !0);
          }
          if (!h && e) {
            var c;
            if (!((c = this.hls.loadLevelObj) != null && c.details) || sh(this.hls.inFlightFragments, l))
              return 0;
            let m = !1, v = e.end;
            for (; v < l; ) {
              const y = eo(v, i);
              if (y)
                v += y.duration;
              else {
                m = !0;
                break;
              }
            }
            if (m)
              return 0;
          }
        }
        const p = Math.max(l + Hx, a + Gx);
        if (this.warn(`skipping hole, adjusting currentTime from ${a} to ${p}`), this.moved = !0, s.currentTime = p, !(e != null && e.gap)) {
          const h = new Error(`fragment loaded with buffer holes, seeking from ${a} to ${p}`), g = {
            type: se.MEDIA_ERROR,
            details: H.BUFFER_SEEK_OVER_HOLE,
            fatal: !1,
            error: h,
            reason: h.message,
            buffer: o.len,
            bufferInfo: o
          };
          e && ("fragment" in e ? g.part = e : g.frag = e), this.hls.trigger(x.ERROR, g);
        }
        return p;
      }
    }
    return 0;
  }
  /**
   * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.
   * @private
   */
  _tryNudgeBuffer(e) {
    const {
      hls: t,
      media: i,
      nudgeRetry: s
    } = this, r = t?.config;
    if (!i || !r)
      return 0;
    const a = i.currentTime;
    if (this.nudgeRetry++, s < r.nudgeMaxRetry) {
      const o = a + (s + 1) * r.nudgeOffset, l = new Error(`Nudging 'currentTime' from ${a} to ${o}`);
      this.warn(l.message), i.currentTime = o, t.trigger(x.ERROR, {
        type: se.MEDIA_ERROR,
        details: H.BUFFER_NUDGE_ON_STALL,
        error: l,
        fatal: !1,
        buffer: e.len,
        bufferInfo: e
      });
    } else {
      const o = new Error(`Playhead still not moving while enough data buffered @${a} after ${r.nudgeMaxRetry} nudges`);
      this.error(o.message), t.trigger(x.ERROR, {
        type: se.MEDIA_ERROR,
        details: H.BUFFER_STALLED_ERROR,
        error: o,
        fatal: !0,
        buffer: e.len,
        bufferInfo: e
      });
    }
  }
}
function sh(n, e) {
  const t = rh(n.main);
  if (t && t.start <= e)
    return t;
  const i = rh(n.audio);
  return i && i.start <= e ? i : null;
}
function rh(n) {
  if (!n)
    return null;
  switch (n.state) {
    case q.IDLE:
    case q.STOPPED:
    case q.ENDED:
    case q.ERROR:
      return null;
  }
  return n.frag;
}
function eo(n, e) {
  return e.getAppendedFrag(n, te.MAIN) || e.getPartialFragment(n);
}
const Wx = 0.25;
function Xc() {
  if (!(typeof self > "u"))
    return self.VTTCue || self.TextTrackCue;
}
function Kl(n, e, t, i, s) {
  let r = new n(e, t, "");
  try {
    r.value = i, s && (r.type = s);
  } catch {
    r = new n(e, t, Ge(s ? Me({
      type: s
    }, i) : i));
  }
  return r;
}
const to = (() => {
  const n = Xc();
  try {
    n && new n(0, Number.POSITIVE_INFINITY, "");
  } catch {
    return Number.MAX_VALUE;
  }
  return Number.POSITIVE_INFINITY;
})();
class Kx {
  constructor(e) {
    this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.removeCues = !0, this.assetCue = void 0, this.onEventCueEnter = () => {
      this.hls && this.hls.trigger(x.EVENT_CUE_ENTER, {});
    }, this.hls = e, this._registerListeners();
  }
  destroy() {
    this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = this.onEventCueEnter = null;
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e && (e.on(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.on(x.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(x.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this));
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (e.off(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.off(x.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(x.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this));
  }
  // Add ID3 metatadata text track.
  onMediaAttaching(e, t) {
    var i;
    this.media = t.media, ((i = t.overrides) == null ? void 0 : i.cueRemoval) === !1 && (this.removeCues = !1);
  }
  onMediaAttached() {
    var e;
    const t = (e = this.hls) == null ? void 0 : e.latestLevelDetails;
    t && this.updateDateRangeCues(t);
  }
  onMediaDetaching(e, t) {
    this.media = null, !t.transferMedia && (this.id3Track && (this.removeCues && Qr(this.id3Track, this.onEventCueEnter), this.id3Track = null), this.dateRangeCuesAppended = {});
  }
  onManifestLoading() {
    this.dateRangeCuesAppended = {};
  }
  createTrack(e) {
    const t = this.getID3Track(e.textTracks);
    return t.mode = "hidden", t;
  }
  getID3Track(e) {
    if (this.media) {
      for (let t = 0; t < e.length; t++) {
        const i = e[t];
        if (i.kind === "metadata" && i.label === "id3")
          return nm(i, this.media), i;
      }
      return this.media.addTextTrack("metadata", "id3");
    }
  }
  onFragParsingMetadata(e, t) {
    if (!this.media || !this.hls)
      return;
    const {
      enableEmsgMetadataCues: i,
      enableID3MetadataCues: s
    } = this.hls.config;
    if (!i && !s)
      return;
    const {
      samples: r
    } = t;
    this.id3Track || (this.id3Track = this.createTrack(this.media));
    const a = Xc();
    if (a)
      for (let o = 0; o < r.length; o++) {
        const l = r[o].type;
        if (l === vi.emsg && !i || !s)
          continue;
        const c = kg(r[o].data), u = r[o].pts;
        let d = u + r[o].duration;
        d > to && (d = to), d - u <= 0 && (d = u + Wx);
        for (let p = 0; p < c.length; p++) {
          const h = c[p];
          if (!Mg(h)) {
            this.updateId3CueEnds(u, l);
            const g = Kl(a, u, d, h, l);
            g && this.id3Track.addCue(g);
          }
        }
      }
  }
  updateId3CueEnds(e, t) {
    var i;
    const s = (i = this.id3Track) == null ? void 0 : i.cues;
    if (s)
      for (let r = s.length; r--; ) {
        const a = s[r];
        a.type === t && a.startTime < e && a.endTime === to && (a.endTime = e);
      }
  }
  onBufferFlushing(e, {
    startOffset: t,
    endOffset: i,
    type: s
  }) {
    const {
      id3Track: r,
      hls: a
    } = this;
    if (!a)
      return;
    const {
      config: {
        enableEmsgMetadataCues: o,
        enableID3MetadataCues: l
      }
    } = a;
    if (r && (o || l)) {
      let c;
      s === "audio" ? c = (u) => u.type === vi.audioId3 && l : s === "video" ? c = (u) => u.type === vi.emsg && o : c = (u) => u.type === vi.audioId3 && l || u.type === vi.emsg && o, Kc(r, t, i, c);
    }
  }
  onLevelUpdated(e, {
    details: t
  }) {
    this.updateDateRangeCues(t, !0);
  }
  onLevelPtsUpdated(e, t) {
    Math.abs(t.drift) > 0.01 && this.updateDateRangeCues(t.details);
  }
  updateDateRangeCues(e, t) {
    if (!this.hls || !this.media)
      return;
    const {
      assetPlayerId: i,
      timelineOffset: s,
      enableDateRangeMetadataCues: r,
      interstitialsController: a
    } = this.hls.config;
    if (!r)
      return;
    const o = Xc();
    if (i && s && !a) {
      const {
        fragmentStart: g,
        fragmentEnd: m
      } = e;
      let v = this.assetCue;
      v ? (v.startTime = g, v.endTime = m) : o && (v = this.assetCue = Kl(o, g, m, {
        assetPlayerId: this.hls.config.assetPlayerId
      }, "hlsjs.interstitial.asset"), v && (v.id = i, this.id3Track || (this.id3Track = this.createTrack(this.media)), this.id3Track.addCue(v), v.addEventListener("enter", this.onEventCueEnter)));
    }
    if (!e.hasProgramDateTime)
      return;
    const {
      id3Track: l
    } = this, {
      dateRanges: c
    } = e, u = Object.keys(c);
    let d = this.dateRangeCuesAppended;
    if (l && t) {
      var f;
      if ((f = l.cues) != null && f.length) {
        const g = Object.keys(d).filter((m) => !u.includes(m));
        for (let m = g.length; m--; ) {
          var p;
          const v = g[m], y = (p = d[v]) == null ? void 0 : p.cues;
          delete d[v], y && Object.keys(y).forEach((E) => {
            const T = y[E];
            if (T) {
              T.removeEventListener("enter", this.onEventCueEnter);
              try {
                l.removeCue(T);
              } catch {
              }
            }
          });
        }
      } else
        d = this.dateRangeCuesAppended = {};
    }
    const h = e.fragments[e.fragments.length - 1];
    if (!(u.length === 0 || !Z(h?.programDateTime))) {
      this.id3Track || (this.id3Track = this.createTrack(this.media));
      for (let g = 0; g < u.length; g++) {
        const m = u[g], v = c[m], y = v.startTime, E = d[m], T = E?.cues || {};
        let S = E?.durationKnown || !1, w = to;
        const {
          duration: b,
          endDate: L
        } = v;
        if (L && b !== null)
          w = y + b, S = !0;
        else if (v.endOnNext && !S) {
          const _ = u.reduce((R, I) => {
            if (I !== v.id) {
              const k = c[I];
              if (k.class === v.class && k.startDate > v.startDate && (!R || v.startDate < R.startDate))
                return k;
            }
            return R;
          }, null);
          _ && (w = _.startTime, S = !0);
        }
        const A = Object.keys(v.attr);
        for (let _ = 0; _ < A.length; _++) {
          const R = A[_];
          if (!hE(R))
            continue;
          const I = T[R];
          if (I)
            S && !(E != null && E.durationKnown) ? I.endTime = w : Math.abs(I.startTime - y) > 0.01 && (I.startTime = y, I.endTime = w);
          else if (o) {
            let k = v.attr[R];
            pE(R) && (k = zp(k));
            const O = Kl(o, y, w, {
              key: R,
              data: k
            }, vi.dateRange);
            O && (O.id = m, this.id3Track.addCue(O), T[R] = O, a && (R === "X-ASSET-LIST" || R === "X-ASSET-URL") && O.addEventListener("enter", this.onEventCueEnter));
          }
        }
        d[m] = {
          cues: T,
          dateRange: v,
          durationKnown: S
        };
      }
    }
  }
}
class Yx {
  constructor(e) {
    this.hls = void 0, this.config = void 0, this.media = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this._targetLatencyUpdated = !1, this.onTimeupdate = () => {
      const {
        media: t
      } = this, i = this.levelDetails;
      if (!t || !i)
        return;
      this.currentTime = t.currentTime;
      const s = this.computeLatency();
      if (s === null)
        return;
      this._latency = s;
      const {
        lowLatencyMode: r,
        maxLiveSyncPlaybackRate: a
      } = this.config;
      if (!r || a === 1 || !i.live)
        return;
      const o = this.targetLatency;
      if (o === null)
        return;
      const l = s - o, c = Math.min(this.maxLatency, o + i.targetduration);
      if (l < c && l > 0.05 && this.forwardBufferLength > 1) {
        const d = Math.min(2, Math.max(1, a)), f = Math.round(2 / (1 + Math.exp(-0.75 * l - this.edgeStalled)) * 20) / 20, p = Math.min(d, Math.max(1, f));
        this.changeMediaPlaybackRate(t, p);
      } else t.playbackRate !== 1 && t.playbackRate !== 0 && this.changeMediaPlaybackRate(t, 1);
    }, this.hls = e, this.config = e.config, this.registerListeners();
  }
  get levelDetails() {
    var e;
    return ((e = this.hls) == null ? void 0 : e.latestLevelDetails) || null;
  }
  get latency() {
    return this._latency || 0;
  }
  get maxLatency() {
    const {
      config: e
    } = this;
    if (e.liveMaxLatencyDuration !== void 0)
      return e.liveMaxLatencyDuration;
    const t = this.levelDetails;
    return t ? e.liveMaxLatencyDurationCount * t.targetduration : 0;
  }
  get targetLatency() {
    const e = this.levelDetails;
    if (e === null || this.hls === null)
      return null;
    const {
      holdBack: t,
      partHoldBack: i,
      targetduration: s
    } = e, {
      liveSyncDuration: r,
      liveSyncDurationCount: a,
      lowLatencyMode: o
    } = this.config, l = this.hls.userConfig;
    let c = o && i || t;
    (this._targetLatencyUpdated || l.liveSyncDuration || l.liveSyncDurationCount || c === 0) && (c = r !== void 0 ? r : a * s);
    const u = s;
    return c + Math.min(this.stallCount * this.config.liveSyncOnStallIncrease, u);
  }
  set targetLatency(e) {
    this.stallCount = 0, this.config.liveSyncDuration = e, this._targetLatencyUpdated = !0;
  }
  get liveSyncPosition() {
    const e = this.estimateLiveEdge(), t = this.targetLatency;
    if (e === null || t === null)
      return null;
    const i = this.levelDetails;
    if (i === null)
      return null;
    const s = i.edge, r = e - t - this.edgeStalled, a = s - i.totalduration, o = s - (this.config.lowLatencyMode && i.partTarget || i.targetduration);
    return Math.min(Math.max(a, r), o);
  }
  get drift() {
    const e = this.levelDetails;
    return e === null ? 1 : e.drift;
  }
  get edgeStalled() {
    const e = this.levelDetails;
    if (e === null)
      return 0;
    const t = (this.config.lowLatencyMode && e.partTarget || e.targetduration) * 3;
    return Math.max(e.age - t, 0);
  }
  get forwardBufferLength() {
    const {
      media: e
    } = this, t = this.levelDetails;
    if (!e || !t)
      return 0;
    const i = e.buffered.length;
    return (i ? e.buffered.end(i - 1) : t.edge) - this.currentTime;
  }
  destroy() {
    this.unregisterListeners(), this.onMediaDetaching(), this.hls = null;
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e && (e.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(x.ERROR, this.onError, this));
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (e.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(x.ERROR, this.onError, this));
  }
  onMediaAttached(e, t) {
    this.media = t.media, this.media.addEventListener("timeupdate", this.onTimeupdate);
  }
  onMediaDetaching() {
    this.media && (this.media.removeEventListener("timeupdate", this.onTimeupdate), this.media = null);
  }
  onManifestLoading() {
    this._latency = null, this.stallCount = 0;
  }
  onLevelUpdated(e, {
    details: t
  }) {
    t.advanced && this.onTimeupdate(), !t.live && this.media && this.media.removeEventListener("timeupdate", this.onTimeupdate);
  }
  onError(e, t) {
    var i;
    t.details === H.BUFFER_STALLED_ERROR && (this.stallCount++, this.hls && (i = this.levelDetails) != null && i.live && this.hls.logger.warn("[latency-controller]: Stall detected, adjusting target latency"));
  }
  changeMediaPlaybackRate(e, t) {
    var i, s;
    e.playbackRate !== t && ((i = this.hls) == null || i.logger.debug(`[latency-controller]: latency=${this.latency.toFixed(3)}, targetLatency=${(s = this.targetLatency) == null ? void 0 : s.toFixed(3)}, forwardBufferLength=${this.forwardBufferLength.toFixed(3)}: adjusting playback rate from ${e.playbackRate} to ${t}`), e.playbackRate = t);
  }
  estimateLiveEdge() {
    const e = this.levelDetails;
    return e === null ? null : e.edge + e.age;
  }
  computeLatency() {
    const e = this.estimateLiveEdge();
    return e === null ? null : e - this.currentTime;
  }
}
class qx extends qu {
  constructor(e, t) {
    super(e, "level-controller"), this._levels = [], this._firstLevel = -1, this._maxAutoLevel = -1, this._startLevel = void 0, this.currentLevel = null, this.currentLevelIndex = -1, this.manualLevelIndex = -1, this.steering = void 0, this.onParsedComplete = void 0, this.steering = t, this._registerListeners();
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(x.LEVEL_LOADED, this.onLevelLoaded, this), e.on(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(x.FRAG_BUFFERED, this.onFragBuffered, this), e.on(x.ERROR, this.onError, this);
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(x.LEVEL_LOADED, this.onLevelLoaded, this), e.off(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(x.FRAG_BUFFERED, this.onFragBuffered, this), e.off(x.ERROR, this.onError, this);
  }
  destroy() {
    this._unregisterListeners(), this.steering = null, this.resetLevels(), super.destroy();
  }
  stopLoad() {
    this._levels.forEach((t) => {
      t.loadError = 0, t.fragmentError = 0;
    }), super.stopLoad();
  }
  resetLevels() {
    this._startLevel = void 0, this.manualLevelIndex = -1, this.currentLevelIndex = -1, this.currentLevel = null, this._levels = [], this._maxAutoLevel = -1;
  }
  onManifestLoading(e, t) {
    this.resetLevels();
  }
  onManifestLoaded(e, t) {
    const i = this.hls.config.preferManagedMediaSource, s = [], r = {}, a = {};
    let o = !1, l = !1, c = !1;
    t.levels.forEach((u) => {
      const d = u.attrs;
      let {
        audioCodec: f,
        videoCodec: p
      } = u;
      f && (u.audioCodec = f = No(f, i) || void 0), p && (p = u.videoCodec = Cy(p));
      const {
        width: h,
        height: g,
        unknownCodecs: m
      } = u, v = m?.length || 0;
      if (o || (o = !!(h && g)), l || (l = !!p), c || (c = !!f), v || f && !this.isAudioSupported(f) || p && !this.isVideoSupported(p)) {
        this.log(`Some or all CODECS not supported "${d.CODECS}"`);
        return;
      }
      const {
        CODECS: y,
        "FRAME-RATE": E,
        "HDCP-LEVEL": T,
        "PATHWAY-ID": S,
        RESOLUTION: w,
        "VIDEO-RANGE": b
      } = d, A = `${`${S || "."}-`}${u.bitrate}-${w}-${E}-${y}-${b}-${T}`;
      if (r[A])
        if (r[A].uri !== u.url && !u.attrs["PATHWAY-ID"]) {
          const _ = a[A] += 1;
          u.attrs["PATHWAY-ID"] = new Array(_ + 1).join(".");
          const R = this.createLevel(u);
          r[A] = R, s.push(R);
        } else
          r[A].addGroupId("audio", d.AUDIO), r[A].addGroupId("text", d.SUBTITLES);
      else {
        const _ = this.createLevel(u);
        r[A] = _, a[A] = 1, s.push(_);
      }
    }), this.filterAndSortMediaOptions(s, t, o, l, c);
  }
  createLevel(e) {
    const t = new ga(e), i = e.supplemental;
    if (i != null && i.videoCodec && !this.isVideoSupported(i.videoCodec)) {
      const s = new Error(`SUPPLEMENTAL-CODECS not supported "${i.videoCodec}"`);
      this.log(s.message), t.supportedResult = ig(s, []);
    }
    return t;
  }
  isAudioSupported(e) {
    return ha(e, "audio", this.hls.config.preferManagedMediaSource);
  }
  isVideoSupported(e) {
    return ha(e, "video", this.hls.config.preferManagedMediaSource);
  }
  filterAndSortMediaOptions(e, t, i, s, r) {
    var a;
    let o = [], l = [], c = e;
    const u = ((a = t.stats) == null ? void 0 : a.parsing) || {};
    if ((i || s) && r && (c = c.filter(({
      videoCodec: y,
      videoRange: E,
      width: T,
      height: S
    }) => (!!y || !!(T && S)) && Uy(E))), c.length === 0) {
      Promise.resolve().then(() => {
        if (this.hls) {
          let y = "no level with compatible codecs found in manifest", E = y;
          t.levels.length && (E = `one or more CODECS in variant not supported: ${Ge(t.levels.map((S) => S.attrs.CODECS).filter((S, w, b) => b.indexOf(S) === w))}`, this.warn(E), y += ` (${E})`);
          const T = new Error(y);
          this.hls.trigger(x.ERROR, {
            type: se.MEDIA_ERROR,
            details: H.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
            fatal: !0,
            url: t.url,
            error: T,
            reason: E
          });
        }
      }), u.end = performance.now();
      return;
    }
    t.audioTracks && (o = t.audioTracks.filter((y) => !y.audioCodec || this.isAudioSupported(y.audioCodec)), nh(o)), t.subtitles && (l = t.subtitles, nh(l));
    const d = c.slice(0);
    c.sort((y, E) => {
      if (y.attrs["HDCP-LEVEL"] !== E.attrs["HDCP-LEVEL"])
        return (y.attrs["HDCP-LEVEL"] || "") > (E.attrs["HDCP-LEVEL"] || "") ? 1 : -1;
      if (i && y.height !== E.height)
        return y.height - E.height;
      if (y.frameRate !== E.frameRate)
        return y.frameRate - E.frameRate;
      if (y.videoRange !== E.videoRange)
        return $o.indexOf(y.videoRange) - $o.indexOf(E.videoRange);
      if (y.videoCodec !== E.videoCodec) {
        const T = Xd(y.videoCodec), S = Xd(E.videoCodec);
        if (T !== S)
          return S - T;
      }
      if (y.uri === E.uri && y.codecSet !== E.codecSet) {
        const T = Fo(y.codecSet), S = Fo(E.codecSet);
        if (T !== S)
          return S - T;
      }
      return y.averageBitrate !== E.averageBitrate ? y.averageBitrate - E.averageBitrate : 0;
    });
    let f = d[0];
    if (this.steering && (c = this.steering.filterParsedLevels(c), c.length !== d.length)) {
      for (let y = 0; y < d.length; y++)
        if (d[y].pathwayId === c[0].pathwayId) {
          f = d[y];
          break;
        }
    }
    this._levels = c;
    for (let y = 0; y < c.length; y++)
      if (c[y] === f) {
        var p;
        this._firstLevel = y;
        const E = f.bitrate, T = this.hls.bandwidthEstimate;
        if (this.log(`manifest loaded, ${c.length} level(s) found, first bitrate: ${E}`), ((p = this.hls.userConfig) == null ? void 0 : p.abrEwmaDefaultEstimate) === void 0) {
          const S = Math.min(E, this.hls.config.abrEwmaDefaultEstimateMax);
          S > T && T === this.hls.abrEwmaDefaultEstimate && (this.hls.bandwidthEstimate = S);
        }
        break;
      }
    const h = r && !s, g = this.hls.config, m = !!(g.audioStreamController && g.audioTrackController), v = {
      levels: c,
      audioTracks: o,
      subtitleTracks: l,
      sessionData: t.sessionData,
      sessionKeys: t.sessionKeys,
      firstLevel: this._firstLevel,
      stats: t.stats,
      audio: r,
      video: s,
      altAudio: m && !h && o.some((y) => !!y.url)
    };
    u.end = performance.now(), this.hls.trigger(x.MANIFEST_PARSED, v);
  }
  get levels() {
    return this._levels.length === 0 ? null : this._levels;
  }
  get loadLevelObj() {
    return this.currentLevel;
  }
  get level() {
    return this.currentLevelIndex;
  }
  set level(e) {
    const t = this._levels;
    if (t.length === 0)
      return;
    if (e < 0 || e >= t.length) {
      const u = new Error("invalid level idx"), d = e < 0;
      if (this.hls.trigger(x.ERROR, {
        type: se.OTHER_ERROR,
        details: H.LEVEL_SWITCH_ERROR,
        level: e,
        fatal: d,
        error: u,
        reason: u.message
      }), d)
        return;
      e = Math.min(e, t.length - 1);
    }
    const i = this.currentLevelIndex, s = this.currentLevel, r = s ? s.attrs["PATHWAY-ID"] : void 0, a = t[e], o = a.attrs["PATHWAY-ID"];
    if (this.currentLevelIndex = e, this.currentLevel = a, i === e && s && r === o)
      return;
    this.log(`Switching to level ${e} (${a.height ? a.height + "p " : ""}${a.videoRange ? a.videoRange + " " : ""}${a.codecSet ? a.codecSet + " " : ""}@${a.bitrate})${o ? " with Pathway " + o : ""} from level ${i}${r ? " with Pathway " + r : ""}`);
    const l = {
      level: e,
      attrs: a.attrs,
      details: a.details,
      bitrate: a.bitrate,
      averageBitrate: a.averageBitrate,
      maxBitrate: a.maxBitrate,
      realBitrate: a.realBitrate,
      width: a.width,
      height: a.height,
      codecSet: a.codecSet,
      audioCodec: a.audioCodec,
      videoCodec: a.videoCodec,
      audioGroups: a.audioGroups,
      subtitleGroups: a.subtitleGroups,
      loaded: a.loaded,
      loadError: a.loadError,
      fragmentError: a.fragmentError,
      name: a.name,
      id: a.id,
      uri: a.uri,
      url: a.url,
      urlId: 0,
      audioGroupIds: a.audioGroupIds,
      textGroupIds: a.textGroupIds
    };
    this.hls.trigger(x.LEVEL_SWITCHING, l);
    const c = a.details;
    if (!c || c.live) {
      const u = this.switchParams(a.uri, s?.details, c);
      this.loadPlaylist(u);
    }
  }
  get manualLevel() {
    return this.manualLevelIndex;
  }
  set manualLevel(e) {
    this.manualLevelIndex = e, this._startLevel === void 0 && (this._startLevel = e), e !== -1 && (this.level = e);
  }
  get firstLevel() {
    return this._firstLevel;
  }
  set firstLevel(e) {
    this._firstLevel = e;
  }
  get startLevel() {
    if (this._startLevel === void 0) {
      const e = this.hls.config.startLevel;
      return e !== void 0 ? e : this.hls.firstAutoLevel;
    }
    return this._startLevel;
  }
  set startLevel(e) {
    this._startLevel = e;
  }
  get pathways() {
    return this.steering ? this.steering.pathways() : [];
  }
  get pathwayPriority() {
    return this.steering ? this.steering.pathwayPriority : null;
  }
  set pathwayPriority(e) {
    if (this.steering) {
      const t = this.steering.pathways(), i = e.filter((s) => t.indexOf(s) !== -1);
      if (e.length < 1) {
        this.warn(`pathwayPriority ${e} should contain at least one pathway from list: ${t}`);
        return;
      }
      this.steering.pathwayPriority = i;
    }
  }
  onError(e, t) {
    t.fatal || !t.context || t.context.type === Ee.LEVEL && t.context.level === this.level && this.checkRetry(t);
  }
  // reset errors on the successful load of a fragment
  onFragBuffered(e, {
    frag: t
  }) {
    if (t !== void 0 && t.type === te.MAIN) {
      const i = t.elementaryStreams;
      if (!Object.keys(i).some((r) => !!i[r]))
        return;
      const s = this._levels[t.level];
      s != null && s.loadError && (this.log(`Resetting level error count of ${s.loadError} on frag buffered`), s.loadError = 0);
    }
  }
  onLevelLoaded(e, t) {
    var i;
    const {
      level: s,
      details: r
    } = t, a = t.levelInfo;
    if (!a) {
      var o;
      this.warn(`Invalid level index ${s}`), (o = t.deliveryDirectives) != null && o.skip && (r.deltaUpdateFailed = !0);
      return;
    }
    if (a === this.currentLevel || t.withoutMultiVariant) {
      a.fragmentError === 0 && (a.loadError = 0);
      let l = a.details;
      l === t.details && l.advanced && (l = void 0), this.playlistLoaded(s, t, l);
    } else (i = t.deliveryDirectives) != null && i.skip && (r.deltaUpdateFailed = !0);
  }
  loadPlaylist(e) {
    super.loadPlaylist(), this.shouldLoadPlaylist(this.currentLevel) && this.scheduleLoading(this.currentLevel, e);
  }
  loadingPlaylist(e, t) {
    super.loadingPlaylist(e, t);
    const i = this.getUrlWithDirectives(e.uri, t), s = this.currentLevelIndex, r = e.attrs["PATHWAY-ID"], a = e.details, o = a?.age;
    this.log(`Loading level index ${s}${t?.msn !== void 0 ? " at sn " + t.msn + " part " + t.part : ""}${r ? " Pathway " + r : ""}${o && a.live ? " age " + o.toFixed(1) + (a.type && " " + a.type || "") : ""} ${i}`), this.hls.trigger(x.LEVEL_LOADING, {
      url: i,
      level: s,
      levelInfo: e,
      pathwayId: e.attrs["PATHWAY-ID"],
      id: 0,
      // Deprecated Level urlId
      deliveryDirectives: t || null
    });
  }
  get nextLoadLevel() {
    return this.manualLevelIndex !== -1 ? this.manualLevelIndex : this.hls.nextAutoLevel;
  }
  set nextLoadLevel(e) {
    this.level = e, this.manualLevelIndex === -1 && (this.hls.nextAutoLevel = e);
  }
  removeLevel(e) {
    var t;
    if (this._levels.length === 1)
      return;
    const i = this._levels.filter((r, a) => a !== e ? !0 : (this.steering && this.steering.removeLevel(r), r === this.currentLevel && (this.currentLevel = null, this.currentLevelIndex = -1, r.details && r.details.fragments.forEach((o) => o.level = -1)), !1));
    bg(i), this._levels = i, this.currentLevelIndex > -1 && (t = this.currentLevel) != null && t.details && (this.currentLevelIndex = this.currentLevel.details.fragments[0].level), this.manualLevelIndex > -1 && (this.manualLevelIndex = this.currentLevelIndex);
    const s = i.length - 1;
    this._firstLevel = Math.min(this._firstLevel, s), this._startLevel && (this._startLevel = Math.min(this._startLevel, s)), this.hls.trigger(x.LEVELS_UPDATED, {
      levels: i
    });
  }
  onLevelsUpdated(e, {
    levels: t
  }) {
    this._levels = t;
  }
  checkMaxAutoUpdated() {
    const {
      autoLevelCapping: e,
      maxAutoLevel: t,
      maxHdcpLevel: i
    } = this.hls;
    this._maxAutoLevel !== t && (this._maxAutoLevel = t, this.hls.trigger(x.MAX_AUTO_LEVEL_UPDATED, {
      autoLevelCapping: e,
      levels: this.levels,
      maxAutoLevel: t,
      minAutoLevel: this.hls.minAutoLevel,
      maxHdcpLevel: i
    }));
  }
}
function nh(n) {
  const e = {};
  n.forEach((t) => {
    const i = t.groupId || "";
    t.id = e[i] = e[i] || 0, e[i]++;
  });
}
function ym() {
  return self.SourceBuffer || self.WebKitSourceBuffer;
}
function Em() {
  if (!Qs())
    return !1;
  const e = ym();
  return !e || e.prototype && typeof e.prototype.appendBuffer == "function" && typeof e.prototype.remove == "function";
}
function Xx() {
  if (!Em())
    return !1;
  const n = Qs();
  return typeof n?.isTypeSupported == "function" && (["avc1.42E01E,mp4a.40.2", "av01.0.01M.08", "vp09.00.50.08"].some((e) => n.isTypeSupported(pa(e, "video"))) || ["mp4a.40.2", "fLaC"].some((e) => n.isTypeSupported(pa(e, "audio"))));
}
function jx() {
  var n;
  const e = ym();
  return typeof (e == null || (n = e.prototype) == null ? void 0 : n.changeType) == "function";
}
const Qx = 100;
class Zx extends Uu {
  constructor(e, t, i) {
    super(e, t, i, "stream-controller", te.MAIN), this.audioCodecSwap = !1, this.level = -1, this._forceStartLoad = !1, this._hasEnoughToStart = !1, this.altAudio = 0, this.audioOnly = !1, this.fragPlaying = null, this.fragLastKbps = 0, this.couldBacktrack = !1, this.backtrackFragment = null, this.audioCodecSwitch = !1, this.videoBuffer = null, this.onMediaPlaying = () => {
      this.tick();
    }, this.onMediaSeeked = () => {
      const s = this.media, r = s ? s.currentTime : null;
      if (r === null || !Z(r) || (this.log(`Media seeked to ${r.toFixed(3)}`), !this.getBufferedFrag(r)))
        return;
      const a = this.getFwdBufferInfoAtPos(s, r, te.MAIN, 0);
      if (a === null || a.len === 0) {
        this.warn(`Main forward buffer length at ${r} on "seeked" event ${a ? a.len : "empty"})`);
        return;
      }
      this.tick();
    }, this.registerListeners();
  }
  registerListeners() {
    super.registerListeners();
    const {
      hls: e
    } = this;
    e.on(x.MANIFEST_PARSED, this.onManifestParsed, this), e.on(x.LEVEL_LOADING, this.onLevelLoading, this), e.on(x.LEVEL_LOADED, this.onLevelLoaded, this), e.on(x.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.on(x.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(x.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(x.BUFFER_CREATED, this.onBufferCreated, this), e.on(x.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(x.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  unregisterListeners() {
    super.unregisterListeners();
    const {
      hls: e
    } = this;
    e.off(x.MANIFEST_PARSED, this.onManifestParsed, this), e.off(x.LEVEL_LOADED, this.onLevelLoaded, this), e.off(x.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.off(x.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(x.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(x.BUFFER_CREATED, this.onBufferCreated, this), e.off(x.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(x.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  onHandlerDestroying() {
    this.onMediaPlaying = this.onMediaSeeked = null, this.unregisterListeners(), super.onHandlerDestroying();
  }
  startLoad(e, t) {
    if (this.levels) {
      const {
        lastCurrentTime: i,
        hls: s
      } = this;
      if (this.stopLoad(), this.setInterval(Qx), this.level = -1, !this.startFragRequested) {
        let r = s.startLevel;
        r === -1 && (s.config.testBandwidth && this.levels.length > 1 ? (r = 0, this.bitrateTest = !0) : r = s.firstAutoLevel), s.nextLoadLevel = r, this.level = s.loadLevel, this._hasEnoughToStart = !!t;
      }
      i > 0 && e === -1 && !t && (this.log(`Override startPosition with lastCurrentTime @${i.toFixed(3)}`), e = i), this.state = q.IDLE, this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset, this.startPosition = t ? -1 : e, this.tick();
    } else
      this._forceStartLoad = !0, this.state = q.STOPPED;
  }
  stopLoad() {
    this._forceStartLoad = !1, super.stopLoad();
  }
  doTick() {
    switch (this.state) {
      case q.WAITING_LEVEL: {
        const {
          levels: e,
          level: t
        } = this, i = e?.[t], s = i?.details;
        if (s && (!s.live || this.levelLastLoaded === i && !this.waitForLive(i))) {
          if (this.waitForCdnTuneIn(s))
            break;
          this.state = q.IDLE;
          break;
        } else if (this.hls.nextLoadLevel !== this.level) {
          this.state = q.IDLE;
          break;
        }
        break;
      }
      case q.FRAG_LOADING_WAITING_RETRY:
        this.checkRetryDate();
        break;
    }
    this.state === q.IDLE && this.doTickIdle(), this.onTickEnd();
  }
  onTickEnd() {
    var e;
    super.onTickEnd(), (e = this.media) != null && e.readyState && this.media.seeking === !1 && (this.lastCurrentTime = this.media.currentTime), this.checkFragmentChanged();
  }
  doTickIdle() {
    const {
      hls: e,
      levelLastLoaded: t,
      levels: i,
      media: s
    } = this;
    if (t === null || !s && !this.primaryPrefetch && (this.startFragRequested || !e.config.startFragPrefetch) || this.altAudio && this.audioOnly)
      return;
    const r = this.buffering ? e.nextLoadLevel : e.loadLevel;
    if (!(i != null && i[r]))
      return;
    const a = i[r], o = this.getMainFwdBufferInfo();
    if (o === null)
      return;
    const l = this.getLevelDetails();
    if (l && this._streamEnded(o, l)) {
      const g = {};
      this.altAudio === 2 && (g.type = "video"), this.hls.trigger(x.BUFFER_EOS, g), this.state = q.ENDED;
      return;
    }
    if (!this.buffering)
      return;
    e.loadLevel !== r && e.manualLevel === -1 && this.log(`Adapting to level ${r} from level ${this.level}`), this.level = e.nextLoadLevel = r;
    const c = a.details;
    if (!c || this.state === q.WAITING_LEVEL || this.waitForLive(a)) {
      this.level = r, this.state = q.WAITING_LEVEL, this.startFragRequested = !1;
      return;
    }
    const u = o.len, d = this.getMaxBufferLength(a.maxBitrate);
    if (u >= d)
      return;
    this.backtrackFragment && this.backtrackFragment.start > o.end && (this.backtrackFragment = null);
    const f = this.backtrackFragment ? this.backtrackFragment.start : o.end;
    let p = this.getNextFragment(f, c);
    if (this.couldBacktrack && !this.fragPrevious && p && ot(p) && this.fragmentTracker.getState(p) !== yt.OK) {
      var h;
      const m = ((h = this.backtrackFragment) != null ? h : p).sn - c.startSN, v = c.fragments[m - 1];
      v && p.cc === v.cc && (p = v, this.fragmentTracker.removeFragment(v));
    } else this.backtrackFragment && o.len && (this.backtrackFragment = null);
    if (p && this.isLoopLoading(p, f)) {
      if (!p.gap) {
        const m = this.audioOnly && !this.altAudio ? Ue.AUDIO : Ue.VIDEO, v = (m === Ue.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
        v && this.afterBufferFlushed(v, m, te.MAIN);
      }
      p = this.getNextFragmentLoopLoading(p, c, o, te.MAIN, d);
    }
    p && (p.initSegment && !p.initSegment.data && !this.bitrateTest && (p = p.initSegment), this.loadFragment(p, a, f));
  }
  loadFragment(e, t, i) {
    const s = this.fragmentTracker.getState(e);
    s === yt.NOT_LOADED || s === yt.PARTIAL ? ot(e) ? this.bitrateTest ? (this.log(`Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`), this._loadBitrateTestFrag(e, t)) : super.loadFragment(e, t, i) : this._loadInitSegment(e, t) : this.clearTrackerIfNeeded(e);
  }
  getBufferedFrag(e) {
    return this.fragmentTracker.getBufferedFrag(e, te.MAIN);
  }
  followingBufferedFrag(e) {
    return e ? this.getBufferedFrag(e.end + 0.5) : null;
  }
  /*
    on immediate level switch :
     - pause playback if playing
     - cancel any pending load request
     - and trigger a buffer flush
  */
  immediateLevelSwitch() {
    this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
  }
  /**
   * try to switch ASAP without breaking video playback:
   * in order to ensure smooth but quick level switching,
   * we need to find the next flushable buffer range
   * we should take into account new segment fetch time
   */
  nextLevelSwitch() {
    const {
      levels: e,
      media: t
    } = this;
    if (t != null && t.readyState) {
      let i;
      const s = this.getAppendedFrag(t.currentTime);
      s && s.start > 1 && this.flushMainBuffer(0, s.start - 1);
      const r = this.getLevelDetails();
      if (r != null && r.live) {
        const o = this.getMainFwdBufferInfo();
        if (!o || o.len < r.targetduration * 2)
          return;
      }
      if (!t.paused && e) {
        const o = this.hls.nextLoadLevel, l = e[o], c = this.fragLastKbps;
        c && this.fragCurrent ? i = this.fragCurrent.duration * l.maxBitrate / (1e3 * c) + 1 : i = 0;
      } else
        i = 0;
      const a = this.getBufferedFrag(t.currentTime + i);
      if (a) {
        const o = this.followingBufferedFrag(a);
        if (o) {
          this.abortCurrentFrag();
          const l = o.maxStartPTS ? o.maxStartPTS : o.start, c = o.duration, u = Math.max(a.end, l + Math.min(Math.max(c - this.config.maxFragLookUpTolerance, c * (this.couldBacktrack ? 0.5 : 0.125)), c * (this.couldBacktrack ? 0.75 : 0.25)));
          this.flushMainBuffer(u, Number.POSITIVE_INFINITY);
        }
      }
    }
  }
  abortCurrentFrag() {
    const e = this.fragCurrent;
    switch (this.fragCurrent = null, this.backtrackFragment = null, e && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.state) {
      case q.KEY_LOADING:
      case q.FRAG_LOADING:
      case q.FRAG_LOADING_WAITING_RETRY:
      case q.PARSING:
      case q.PARSED:
        this.state = q.IDLE;
        break;
    }
    this.nextLoadPosition = this.getLoadPosition();
  }
  flushMainBuffer(e, t) {
    super.flushMainBuffer(e, t, this.altAudio === 2 ? "video" : null);
  }
  onMediaAttached(e, t) {
    super.onMediaAttached(e, t);
    const i = t.media;
    Zt(i, "playing", this.onMediaPlaying), Zt(i, "seeked", this.onMediaSeeked);
  }
  onMediaDetaching(e, t) {
    const {
      media: i
    } = this;
    i && (ti(i, "playing", this.onMediaPlaying), ti(i, "seeked", this.onMediaSeeked)), this.videoBuffer = null, this.fragPlaying = null, super.onMediaDetaching(e, t), !t.transferMedia && (this._hasEnoughToStart = !1);
  }
  onManifestLoading() {
    super.onManifestLoading(), this.log("Trigger BUFFER_RESET"), this.hls.trigger(x.BUFFER_RESET, void 0), this.couldBacktrack = !1, this.fragLastKbps = 0, this.fragPlaying = this.backtrackFragment = null, this.altAudio = 0, this.audioOnly = !1;
  }
  onManifestParsed(e, t) {
    let i = !1, s = !1;
    for (let r = 0; r < t.levels.length; r++) {
      const a = t.levels[r].audioCodec;
      a && (i = i || a.indexOf("mp4a.40.2") !== -1, s = s || a.indexOf("mp4a.40.5") !== -1);
    }
    this.audioCodecSwitch = i && s && !jx(), this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = t.levels, this.startFragRequested = !1;
  }
  onLevelLoading(e, t) {
    const {
      levels: i
    } = this;
    if (!i || this.state !== q.IDLE)
      return;
    const s = t.levelInfo;
    (!s.details || s.details.live && (this.levelLastLoaded !== s || s.details.expired) || this.waitForCdnTuneIn(s.details)) && (this.state = q.WAITING_LEVEL);
  }
  onLevelLoaded(e, t) {
    var i;
    const {
      levels: s,
      startFragRequested: r
    } = this, a = t.level, o = t.details, l = o.totalduration;
    if (!s) {
      this.warn(`Levels were reset while loading level ${a}`);
      return;
    }
    this.log(`Level ${a} loaded [${o.startSN},${o.endSN}]${o.lastPartSn ? `[part-${o.lastPartSn}-${o.lastPartIndex}]` : ""}, cc [${o.startCC}, ${o.endCC}] duration:${l}`);
    const c = t.levelInfo, u = this.fragCurrent;
    u && (this.state === q.FRAG_LOADING || this.state === q.FRAG_LOADING_WAITING_RETRY) && u.level !== t.level && u.loader && this.abortCurrentFrag();
    let d = 0;
    if (o.live || (i = c.details) != null && i.live) {
      var f;
      if (this.checkLiveUpdate(o), o.deltaUpdateFailed)
        return;
      d = this.alignPlaylists(o, c.details, (f = this.levelLastLoaded) == null ? void 0 : f.details);
    }
    if (c.details = o, this.levelLastLoaded = c, r || this.setStartPosition(o, d), this.hls.trigger(x.LEVEL_UPDATED, {
      details: o,
      level: a
    }), this.state === q.WAITING_LEVEL) {
      if (this.waitForCdnTuneIn(o))
        return;
      this.state = q.IDLE;
    }
    r && o.live && this.synchronizeToLiveEdge(o), this.tick();
  }
  synchronizeToLiveEdge(e) {
    const {
      config: t,
      media: i
    } = this;
    if (!i)
      return;
    const s = this.hls.liveSyncPosition, r = this.getLoadPosition(), a = e.fragmentStart, o = e.edge, l = r >= a - t.maxFragLookUpTolerance && r <= o;
    if (s !== null && i.duration > s && (r < s || !l)) {
      const u = t.liveMaxLatencyDuration !== void 0 ? t.liveMaxLatencyDuration : t.liveMaxLatencyDurationCount * e.targetduration;
      if ((!l && i.readyState < 4 || r < o - u) && (this._hasEnoughToStart || (this.nextLoadPosition = s), i.readyState))
        if (this.warn(`Playback: ${r.toFixed(3)} is located too far from the end of live sliding playlist: ${o}, reset currentTime to : ${s.toFixed(3)}`), this.config.liveSyncMode === "buffered") {
          var c;
          const d = de.bufferInfo(i, s, 0);
          if (!((c = d.buffered) != null && c.length)) {
            i.currentTime = s;
            return;
          }
          if (d.start <= r) {
            i.currentTime = s;
            return;
          }
          const {
            nextStart: p
          } = de.bufferedInfo(d.buffered, r, 0);
          p && (i.currentTime = p);
        } else
          i.currentTime = s;
    }
  }
  _handleFragmentLoadProgress(e) {
    var t;
    const i = e.frag, {
      part: s,
      payload: r
    } = e, {
      levels: a
    } = this;
    if (!a) {
      this.warn(`Levels were reset while fragment load was in progress. Fragment ${i.sn} of level ${i.level} will not be buffered`);
      return;
    }
    const o = a[i.level];
    if (!o) {
      this.warn(`Level ${i.level} not found on progress`);
      return;
    }
    const l = o.details;
    if (!l) {
      this.warn(`Dropping fragment ${i.sn} of level ${i.level} after level details were reset`), this.fragmentTracker.removeFragment(i);
      return;
    }
    const c = o.videoCodec, u = l.PTSKnown || !l.live, d = (t = i.initSegment) == null ? void 0 : t.data, f = this._getAudioCodec(o), p = this.transmuxer = this.transmuxer || new Wg(this.hls, te.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)), h = s ? s.index : -1, g = h !== -1, m = new Nu(i.level, i.sn, i.stats.chunkCount, r.byteLength, h, g), v = this.initPTS[i.cc];
    p.push(r, d, f, c, i, s, l.totalduration, u, m, v);
  }
  onAudioTrackSwitching(e, t) {
    const i = this.hls, s = this.altAudio !== 0;
    if (Bo(t.url, i))
      this.altAudio = 1;
    else {
      if (this.mediaBuffer !== this.media) {
        this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
        const a = this.fragCurrent;
        a && (this.log("Switching to main audio track, cancel main fragment load"), a.abortRequests(), this.fragmentTracker.removeFragment(a)), this.resetTransmuxer(), this.resetLoadingState();
      } else this.audioOnly && this.resetTransmuxer();
      if (s) {
        this.altAudio = 0, this.fragmentTracker.removeAllFragments(), i.once(x.BUFFER_FLUSHED, () => {
          this.hls && this.hls.trigger(x.AUDIO_TRACK_SWITCHED, t);
        }), i.trigger(x.BUFFER_FLUSHING, {
          startOffset: 0,
          endOffset: Number.POSITIVE_INFINITY,
          type: null
        });
        return;
      }
      i.trigger(x.AUDIO_TRACK_SWITCHED, t);
    }
  }
  onAudioTrackSwitched(e, t) {
    const i = Bo(t.url, this.hls);
    if (i) {
      const s = this.videoBuffer;
      s && this.mediaBuffer !== s && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = s);
    }
    this.altAudio = i ? 2 : 0, this.tick();
  }
  onBufferCreated(e, t) {
    const i = t.tracks;
    let s, r, a = !1;
    for (const o in i) {
      const l = i[o];
      if (l.id === "main") {
        if (r = o, s = l, o === "video") {
          const c = i[o];
          c && (this.videoBuffer = c.buffer);
        }
      } else
        a = !0;
    }
    a && s ? (this.log(`Alternate track found, use ${r}.buffered to schedule main fragment loading`), this.mediaBuffer = s.buffer) : this.mediaBuffer = this.media;
  }
  onFragBuffered(e, t) {
    const {
      frag: i,
      part: s
    } = t, r = i.type === te.MAIN;
    if (r) {
      if (this.fragContextChanged(i)) {
        this.warn(`Fragment ${i.sn}${s ? " p: " + s.index : ""} of level ${i.level} finished buffering, but was aborted. state: ${this.state}`), this.state === q.PARSED && (this.state = q.IDLE);
        return;
      }
      const o = s ? s.stats : i.stats;
      this.fragLastKbps = Math.round(8 * o.total / (o.buffering.end - o.loading.first)), ot(i) && (this.fragPrevious = i), this.fragBufferedComplete(i, s);
    }
    const a = this.media;
    a && (!this._hasEnoughToStart && de.getBuffered(a).length && (this._hasEnoughToStart = !0, this.seekToStartPos()), r && this.tick());
  }
  get hasEnoughToStart() {
    return this._hasEnoughToStart;
  }
  onError(e, t) {
    var i;
    if (t.fatal) {
      this.state = q.ERROR;
      return;
    }
    switch (t.details) {
      case H.FRAG_GAP:
      case H.FRAG_PARSING_ERROR:
      case H.FRAG_DECRYPT_ERROR:
      case H.FRAG_LOAD_ERROR:
      case H.FRAG_LOAD_TIMEOUT:
      case H.KEY_LOAD_ERROR:
      case H.KEY_LOAD_TIMEOUT:
        this.onFragmentOrKeyLoadError(te.MAIN, t);
        break;
      case H.LEVEL_LOAD_ERROR:
      case H.LEVEL_LOAD_TIMEOUT:
      case H.LEVEL_PARSING_ERROR:
        !t.levelRetry && this.state === q.WAITING_LEVEL && ((i = t.context) == null ? void 0 : i.type) === Ee.LEVEL && (this.state = q.IDLE);
        break;
      case H.BUFFER_ADD_CODEC_ERROR:
      case H.BUFFER_APPEND_ERROR:
        if (t.parent !== "main")
          return;
        this.reduceLengthAndFlushBuffer(t) && this.resetLoadingState();
        break;
      case H.BUFFER_FULL_ERROR:
        if (t.parent !== "main")
          return;
        this.reduceLengthAndFlushBuffer(t) && (!this.config.interstitialsController && this.config.assetPlayerId ? this._hasEnoughToStart = !0 : this.flushMainBuffer(0, Number.POSITIVE_INFINITY));
        break;
      case H.INTERNAL_EXCEPTION:
        this.recoverWorkerError(t);
        break;
    }
  }
  onFragLoadEmergencyAborted() {
    this.state = q.IDLE, this._hasEnoughToStart || (this.startFragRequested = !1, this.nextLoadPosition = this.lastCurrentTime), this.tickImmediate();
  }
  onBufferFlushed(e, {
    type: t
  }) {
    if (t !== Ue.AUDIO || !this.altAudio) {
      const i = (t === Ue.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
      i && (this.afterBufferFlushed(i, t, te.MAIN), this.tick());
    }
  }
  onLevelsUpdated(e, t) {
    this.level > -1 && this.fragCurrent && (this.level = this.fragCurrent.level, this.level === -1 && this.resetWhenMissingContext(this.fragCurrent)), this.levels = t.levels;
  }
  swapAudioCodec() {
    this.audioCodecSwap = !this.audioCodecSwap;
  }
  /**
   * Seeks to the set startPosition if not equal to the mediaElement's current time.
   */
  seekToStartPos() {
    const {
      media: e
    } = this;
    if (!e)
      return;
    const t = e.currentTime;
    let i = this.startPosition;
    if (i >= 0 && t < i) {
      if (e.seeking) {
        this.log(`could not seek to ${i}, already seeking at ${t}`);
        return;
      }
      const s = this.timelineOffset;
      s && i && (i += s);
      const r = this.getLevelDetails(), a = de.getBuffered(e), o = a.length ? a.start(0) : 0, l = o - i, c = Math.max(this.config.maxBufferHole, this.config.maxFragLookUpTolerance);
      (this.config.startOnSegmentBoundary || l > 0 && (l < c || this.loadingParts && l < 2 * (r?.partTarget || 0))) && (this.log(`adjusting start position by ${l} to match buffer start`), i += l, this.startPosition = i), t < i && (this.log(`seek to target start position ${i} from current time ${t} buffer start ${o}`), e.currentTime = i);
    }
  }
  _getAudioCodec(e) {
    let t = this.config.defaultAudioCodec || e.audioCodec;
    return this.audioCodecSwap && t && (this.log("Swapping audio codec"), t.indexOf("mp4a.40.5") !== -1 ? t = "mp4a.40.2" : t = "mp4a.40.5"), t;
  }
  _loadBitrateTestFrag(e, t) {
    e.bitrateTest = !0, this._doFragLoad(e, t).then((i) => {
      const {
        hls: s
      } = this, r = i?.frag;
      if (!r || this.fragContextChanged(r))
        return;
      t.fragmentError = 0, this.state = q.IDLE, this.startFragRequested = !1, this.bitrateTest = !1;
      const a = r.stats;
      a.parsing.start = a.parsing.end = a.buffering.start = a.buffering.end = self.performance.now(), s.trigger(x.FRAG_LOADED, i), r.bitrateTest = !1;
    }).catch((i) => {
      this.state === q.STOPPED || this.state === q.ERROR || (this.warn(i), this.resetFragmentLoading(e));
    });
  }
  _handleTransmuxComplete(e) {
    const t = this.playlistType, {
      hls: i
    } = this, {
      remuxResult: s,
      chunkMeta: r
    } = e, a = this.getCurrentContext(r);
    if (!a) {
      this.resetWhenMissingContext(r);
      return;
    }
    const {
      frag: o,
      part: l,
      level: c
    } = a, {
      video: u,
      text: d,
      id3: f,
      initSegment: p
    } = s, {
      details: h
    } = c, g = this.altAudio ? void 0 : s.audio;
    if (this.fragContextChanged(o)) {
      this.fragmentTracker.removeFragment(o);
      return;
    }
    if (this.state = q.PARSING, p) {
      const m = p.tracks;
      if (m) {
        const T = o.initSegment || o;
        if (this.unhandledEncryptionError(p, o))
          return;
        this._bufferInitSegment(c, m, T, r), i.trigger(x.FRAG_PARSING_INIT_SEGMENT, {
          frag: T,
          id: t,
          tracks: m
        });
      }
      const v = p.initPTS, y = p.timescale, E = this.initPTS[o.cc];
      if (Z(v) && (!E || E.baseTime !== v || E.timescale !== y)) {
        const T = p.trackId;
        this.initPTS[o.cc] = {
          baseTime: v,
          timescale: y,
          trackId: T
        }, i.trigger(x.INIT_PTS_FOUND, {
          frag: o,
          id: t,
          initPTS: v,
          timescale: y,
          trackId: T
        });
      }
    }
    if (u && h) {
      g && u.type === "audiovideo" && this.logMuxedErr(o);
      const m = h.fragments[o.sn - 1 - h.startSN], v = o.sn === h.startSN, y = !m || o.cc > m.cc;
      if (s.independent !== !1) {
        const {
          startPTS: E,
          endPTS: T,
          startDTS: S,
          endDTS: w
        } = u;
        if (l)
          l.elementaryStreams[u.type] = {
            startPTS: E,
            endPTS: T,
            startDTS: S,
            endDTS: w
          };
        else if (u.firstKeyFrame && u.independent && r.id === 1 && !y && (this.couldBacktrack = !0), u.dropped && u.independent) {
          const b = this.getMainFwdBufferInfo(), L = (b ? b.end : this.getLoadPosition()) + this.config.maxBufferHole, A = u.firstKeyFramePTS ? u.firstKeyFramePTS : E;
          if (!v && L < A - this.config.maxBufferHole && !y) {
            this.backtrack(o);
            return;
          } else y && (o.gap = !0);
          o.setElementaryStreamInfo(u.type, o.start, T, o.start, w, !0);
        } else v && E - (h.appliedTimelineOffset || 0) > To && (o.gap = !0);
        o.setElementaryStreamInfo(u.type, E, T, S, w), this.backtrackFragment && (this.backtrackFragment = o), this.bufferFragmentData(u, o, l, r, v || y);
      } else if (v || y)
        o.gap = !0;
      else {
        this.backtrack(o);
        return;
      }
    }
    if (g) {
      const {
        startPTS: m,
        endPTS: v,
        startDTS: y,
        endDTS: E
      } = g;
      l && (l.elementaryStreams[Ue.AUDIO] = {
        startPTS: m,
        endPTS: v,
        startDTS: y,
        endDTS: E
      }), o.setElementaryStreamInfo(Ue.AUDIO, m, v, y, E), this.bufferFragmentData(g, o, l, r);
    }
    if (h && f != null && f.samples.length) {
      const m = {
        id: t,
        frag: o,
        details: h,
        samples: f.samples
      };
      i.trigger(x.FRAG_PARSING_METADATA, m);
    }
    if (h && d) {
      const m = {
        id: t,
        frag: o,
        details: h,
        samples: d.samples
      };
      i.trigger(x.FRAG_PARSING_USERDATA, m);
    }
  }
  logMuxedErr(e) {
    this.warn(`${ot(e) ? "Media" : "Init"} segment with muxed audiovideo where only video expected: ${e.url}`);
  }
  _bufferInitSegment(e, t, i, s) {
    if (this.state !== q.PARSING)
      return;
    this.audioOnly = !!t.audio && !t.video, this.altAudio && !this.audioOnly && (delete t.audio, t.audiovideo && this.logMuxedErr(i));
    const {
      audio: r,
      video: a,
      audiovideo: o
    } = t;
    if (r) {
      const c = e.audioCodec;
      let u = ho(r.codec, c);
      u === "mp4a" && (u = "mp4a.40.5");
      const d = navigator.userAgent.toLowerCase();
      if (this.audioCodecSwitch) {
        u && (u.indexOf("mp4a.40.5") !== -1 ? u = "mp4a.40.2" : u = "mp4a.40.5");
        const f = r.metadata;
        f && "channelCount" in f && (f.channelCount || 1) !== 1 && d.indexOf("firefox") === -1 && (u = "mp4a.40.5");
      }
      u && u.indexOf("mp4a.40.5") !== -1 && d.indexOf("android") !== -1 && r.container !== "audio/mpeg" && (u = "mp4a.40.2", this.log(`Android: force audio codec to ${u}`)), c && c !== u && this.log(`Swapping manifest audio codec "${c}" for "${u}"`), r.levelCodec = u, r.id = te.MAIN, this.log(`Init audio buffer, container:${r.container}, codecs[selected/level/parsed]=[${u || ""}/${c || ""}/${r.codec}]`), delete t.audiovideo;
    }
    if (a) {
      a.levelCodec = e.videoCodec, a.id = te.MAIN;
      const c = a.codec;
      if (c?.length === 4)
        switch (c) {
          case "hvc1":
          case "hev1":
            a.codec = "hvc1.1.6.L120.90";
            break;
          case "av01":
            a.codec = "av01.0.04M.08";
            break;
          case "avc1":
            a.codec = "avc1.42e01e";
            break;
        }
      this.log(`Init video buffer, container:${a.container}, codecs[level/parsed]=[${e.videoCodec || ""}/${c}]${a.codec !== c ? " parsed-corrected=" + a.codec : ""}${a.supplemental ? " supplemental=" + a.supplemental : ""}`), delete t.audiovideo;
    }
    o && (this.log(`Init audiovideo buffer, container:${o.container}, codecs[level/parsed]=[${e.codecs}/${o.codec}]`), delete t.video, delete t.audio);
    const l = Object.keys(t);
    if (l.length) {
      if (this.hls.trigger(x.BUFFER_CODECS, t), !this.hls)
        return;
      l.forEach((c) => {
        const d = t[c].initSegment;
        d != null && d.byteLength && this.hls.trigger(x.BUFFER_APPENDING, {
          type: c,
          data: d,
          frag: i,
          part: null,
          chunkMeta: s,
          parent: i.type
        });
      });
    }
    this.tickImmediate();
  }
  getMainFwdBufferInfo() {
    const e = this.mediaBuffer && this.altAudio === 2 ? this.mediaBuffer : this.media;
    return this.getFwdBufferInfo(e, te.MAIN);
  }
  get maxBufferLength() {
    const {
      levels: e,
      level: t
    } = this, i = e?.[t];
    return i ? this.getMaxBufferLength(i.maxBitrate) : this.config.maxBufferLength;
  }
  backtrack(e) {
    this.couldBacktrack = !0, this.backtrackFragment = e, this.resetTransmuxer(), this.flushBufferGap(e), this.fragmentTracker.removeFragment(e), this.fragPrevious = null, this.nextLoadPosition = e.start, this.state = q.IDLE;
  }
  checkFragmentChanged() {
    const e = this.media;
    let t = null;
    if (e && e.readyState > 1 && e.seeking === !1) {
      const i = e.currentTime;
      if (de.isBuffered(e, i) ? t = this.getAppendedFrag(i) : de.isBuffered(e, i + 0.1) && (t = this.getAppendedFrag(i + 0.1)), t) {
        this.backtrackFragment = null;
        const s = this.fragPlaying, r = t.level;
        (!s || t.sn !== s.sn || s.level !== r) && (this.fragPlaying = t, this.hls.trigger(x.FRAG_CHANGED, {
          frag: t
        }), (!s || s.level !== r) && this.hls.trigger(x.LEVEL_SWITCHED, {
          level: r
        }));
      }
    }
  }
  get nextLevel() {
    const e = this.nextBufferedFrag;
    return e ? e.level : -1;
  }
  get currentFrag() {
    var e;
    if (this.fragPlaying)
      return this.fragPlaying;
    const t = ((e = this.media) == null ? void 0 : e.currentTime) || this.lastCurrentTime;
    return Z(t) ? this.getAppendedFrag(t) : null;
  }
  get currentProgramDateTime() {
    var e;
    const t = ((e = this.media) == null ? void 0 : e.currentTime) || this.lastCurrentTime;
    if (Z(t)) {
      const i = this.getLevelDetails(), s = this.currentFrag || (i ? Rr(null, i.fragments, t) : null);
      if (s) {
        const r = s.programDateTime;
        if (r !== null) {
          const a = r + (t - s.start) * 1e3;
          return new Date(a);
        }
      }
    }
    return null;
  }
  get currentLevel() {
    const e = this.currentFrag;
    return e ? e.level : -1;
  }
  get nextBufferedFrag() {
    const e = this.currentFrag;
    return e ? this.followingBufferedFrag(e) : null;
  }
  get forceStartLoad() {
    return this._forceStartLoad;
  }
}
class Jx extends Fi {
  constructor(e, t) {
    super("key-loader", t), this.config = void 0, this.keyIdToKeyInfo = {}, this.emeController = null, this.config = e;
  }
  abort(e) {
    for (const i in this.keyIdToKeyInfo) {
      const s = this.keyIdToKeyInfo[i].loader;
      if (s) {
        var t;
        if (e && e !== ((t = s.context) == null ? void 0 : t.frag.type))
          return;
        s.abort();
      }
    }
  }
  detach() {
    for (const e in this.keyIdToKeyInfo) {
      const t = this.keyIdToKeyInfo[e];
      (t.mediaKeySessionContext || t.decryptdata.isCommonEncryption) && delete this.keyIdToKeyInfo[e];
    }
  }
  destroy() {
    this.detach();
    for (const e in this.keyIdToKeyInfo) {
      const t = this.keyIdToKeyInfo[e].loader;
      t && t.destroy();
    }
    this.keyIdToKeyInfo = {};
  }
  createKeyLoadError(e, t = H.KEY_LOAD_ERROR, i, s, r) {
    return new ms({
      type: se.NETWORK_ERROR,
      details: t,
      fatal: !1,
      frag: e,
      response: r,
      error: i,
      networkDetails: s
    });
  }
  loadClear(e, t, i) {
    if (this.emeController && this.config.emeEnabled && !this.emeController.getSelectedKeySystemFormats().length) {
      if (t.length)
        for (let s = 0, r = t.length; s < r; s++) {
          const a = t[s];
          if (e.cc <= a.cc && (!ot(e) || !ot(a) || e.sn < a.sn) || !i && s == r - 1)
            return this.emeController.selectKeySystemFormat(a).then((o) => {
              if (!this.emeController)
                return;
              a.setKeyFormat(o);
              const l = go(o);
              if (l)
                return this.emeController.getKeySystemAccess([l]);
            });
        }
      if (this.config.requireKeySystemAccessOnStart) {
        const s = Nn(this.config);
        if (s.length)
          return this.emeController.getKeySystemAccess(s);
      }
    }
    return null;
  }
  load(e) {
    return !e.decryptdata && e.encrypted && this.emeController && this.config.emeEnabled ? this.emeController.selectKeySystemFormat(e).then((t) => this.loadInternal(e, t)) : this.loadInternal(e);
  }
  loadInternal(e, t) {
    var i, s;
    t && e.setKeyFormat(t);
    const r = e.decryptdata;
    if (!r) {
      const c = new Error(t ? `Expected frag.decryptdata to be defined after setting format ${t}` : `Missing decryption data on fragment in onKeyLoading (emeEnabled with controller: ${this.emeController && this.config.emeEnabled})`);
      return Promise.reject(this.createKeyLoadError(e, H.KEY_LOAD_ERROR, c));
    }
    const a = r.uri;
    if (!a)
      return Promise.reject(this.createKeyLoadError(e, H.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${a}"`)));
    const o = Yl(r);
    let l = this.keyIdToKeyInfo[o];
    if ((i = l) != null && i.decryptdata.key)
      return r.key = l.decryptdata.key, Promise.resolve({
        frag: e,
        keyInfo: l
      });
    if (this.emeController && (s = l) != null && s.keyLoadPromise)
      switch (this.emeController.getKeyStatus(l.decryptdata)) {
        case "usable":
        case "usable-in-future":
          return l.keyLoadPromise.then((u) => {
            const {
              keyInfo: d
            } = u;
            return r.key = d.decryptdata.key, {
              frag: e,
              keyInfo: d
            };
          });
      }
    switch (this.log(`${this.keyIdToKeyInfo[o] ? "Rel" : "L"}oading${r.keyId ? " keyId: " + Rt(r.keyId) : ""} URI: ${r.uri} from ${e.type} ${e.level}`), l = this.keyIdToKeyInfo[o] = {
      decryptdata: r,
      keyLoadPromise: null,
      loader: null,
      mediaKeySessionContext: null
    }, r.method) {
      case "SAMPLE-AES":
      case "SAMPLE-AES-CENC":
      case "SAMPLE-AES-CTR":
        return r.keyFormat === "identity" ? this.loadKeyHTTP(l, e) : this.loadKeyEME(l, e);
      case "AES-128":
      case "AES-256":
      case "AES-256-CTR":
        return this.loadKeyHTTP(l, e);
      default:
        return Promise.reject(this.createKeyLoadError(e, H.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${r.method}"`)));
    }
  }
  loadKeyEME(e, t) {
    const i = {
      frag: t,
      keyInfo: e
    };
    if (this.emeController && this.config.emeEnabled) {
      var s;
      if (!e.decryptdata.keyId && (s = t.initSegment) != null && s.data) {
        const a = yy(t.initSegment.data);
        if (a.length) {
          let o = a[0];
          o.some((l) => l !== 0) ? (this.log(`Using keyId found in init segment ${Rt(o)}`), Ys.setKeyIdForUri(e.decryptdata.uri, o)) : (o = Ys.addKeyIdForUri(e.decryptdata.uri), this.log(`Generating keyId to patch media ${Rt(o)}`)), e.decryptdata.keyId = o;
        }
      }
      if (!e.decryptdata.keyId && !ot(t))
        return Promise.resolve(i);
      const r = this.emeController.loadKey(i);
      return (e.keyLoadPromise = r.then((a) => (e.mediaKeySessionContext = a, i))).catch((a) => {
        throw e.keyLoadPromise = null, "data" in a && (a.data.frag = t), a;
      });
    }
    return Promise.resolve(i);
  }
  loadKeyHTTP(e, t) {
    const i = this.config, s = i.loader, r = new s(i);
    return t.keyLoader = e.loader = r, e.keyLoadPromise = new Promise((a, o) => {
      const l = {
        keyInfo: e,
        frag: t,
        responseType: "arraybuffer",
        url: e.decryptdata.uri
      }, c = i.keyLoadPolicy.default, u = {
        loadPolicy: c,
        timeout: c.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0
      }, d = {
        onSuccess: (f, p, h, g) => {
          const {
            frag: m,
            keyInfo: v
          } = h, y = Yl(v.decryptdata);
          if (!m.decryptdata || v !== this.keyIdToKeyInfo[y])
            return o(this.createKeyLoadError(m, H.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), g));
          v.decryptdata.key = m.decryptdata.key = new Uint8Array(f.data), m.keyLoader = null, v.loader = null, a({
            frag: m,
            keyInfo: v
          });
        },
        onError: (f, p, h, g) => {
          this.resetLoader(p), o(this.createKeyLoadError(t, H.KEY_LOAD_ERROR, new Error(`HTTP Error ${f.code} loading key ${f.text}`), h, Me({
            url: l.url,
            data: void 0
          }, f)));
        },
        onTimeout: (f, p, h) => {
          this.resetLoader(p), o(this.createKeyLoadError(t, H.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), h));
        },
        onAbort: (f, p, h) => {
          this.resetLoader(p), o(this.createKeyLoadError(t, H.INTERNAL_ABORTED, new Error("key loading aborted"), h));
        }
      };
      r.load(l, u, d);
    });
  }
  resetLoader(e) {
    const {
      frag: t,
      keyInfo: i,
      url: s
    } = e, r = i.loader;
    t.keyLoader === r && (t.keyLoader = null, i.loader = null);
    const a = Yl(i.decryptdata) || s;
    delete this.keyIdToKeyInfo[a], r && r.destroy();
  }
}
function Yl(n) {
  if (n.keyFormat !== Ct.FAIRPLAY) {
    const e = n.keyId;
    if (e)
      return Rt(e);
  }
  return n.uri;
}
function ah(n) {
  const {
    type: e
  } = n;
  switch (e) {
    case Ee.AUDIO_TRACK:
      return te.AUDIO;
    case Ee.SUBTITLE_TRACK:
      return te.SUBTITLE;
    default:
      return te.MAIN;
  }
}
function ql(n, e) {
  let t = n.url;
  return (t === void 0 || t.indexOf("data:") === 0) && (t = e.url), t;
}
class eb {
  constructor(e) {
    this.hls = void 0, this.loaders = /* @__PURE__ */ Object.create(null), this.variableList = null, this.onManifestLoaded = this.checkAutostartLoad, this.hls = e, this.registerListeners();
  }
  startLoad(e) {
  }
  stopLoad() {
    this.destroyInternalLoaders();
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.LEVEL_LOADING, this.onLevelLoading, this), e.on(x.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.on(x.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this), e.on(x.LEVELS_UPDATED, this.onLevelsUpdated, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.LEVEL_LOADING, this.onLevelLoading, this), e.off(x.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.off(x.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this), e.off(x.LEVELS_UPDATED, this.onLevelsUpdated, this);
  }
  /**
   * Returns defaults or configured loader-type overloads (pLoader and loader config params)
   */
  createInternalLoader(e) {
    const t = this.hls.config, i = t.pLoader, s = t.loader, r = i || s, a = new r(t);
    return this.loaders[e.type] = a, a;
  }
  getInternalLoader(e) {
    return this.loaders[e.type];
  }
  resetInternalLoader(e) {
    this.loaders[e] && delete this.loaders[e];
  }
  /**
   * Call `destroy` on all internal loader instances mapped (one per context type)
   */
  destroyInternalLoaders() {
    for (const e in this.loaders) {
      const t = this.loaders[e];
      t && t.destroy(), this.resetInternalLoader(e);
    }
  }
  destroy() {
    this.variableList = null, this.unregisterListeners(), this.destroyInternalLoaders();
  }
  onManifestLoading(e, t) {
    const {
      url: i
    } = t;
    this.variableList = null, this.load({
      id: null,
      level: 0,
      responseType: "text",
      type: Ee.MANIFEST,
      url: i,
      deliveryDirectives: null,
      levelOrTrack: null
    });
  }
  onLevelLoading(e, t) {
    const {
      id: i,
      level: s,
      pathwayId: r,
      url: a,
      deliveryDirectives: o,
      levelInfo: l
    } = t;
    this.load({
      id: i,
      level: s,
      pathwayId: r,
      responseType: "text",
      type: Ee.LEVEL,
      url: a,
      deliveryDirectives: o,
      levelOrTrack: l
    });
  }
  onAudioTrackLoading(e, t) {
    const {
      id: i,
      groupId: s,
      url: r,
      deliveryDirectives: a,
      track: o
    } = t;
    this.load({
      id: i,
      groupId: s,
      level: null,
      responseType: "text",
      type: Ee.AUDIO_TRACK,
      url: r,
      deliveryDirectives: a,
      levelOrTrack: o
    });
  }
  onSubtitleTrackLoading(e, t) {
    const {
      id: i,
      groupId: s,
      url: r,
      deliveryDirectives: a,
      track: o
    } = t;
    this.load({
      id: i,
      groupId: s,
      level: null,
      responseType: "text",
      type: Ee.SUBTITLE_TRACK,
      url: r,
      deliveryDirectives: a,
      levelOrTrack: o
    });
  }
  onLevelsUpdated(e, t) {
    const i = this.loaders[Ee.LEVEL];
    if (i) {
      const s = i.context;
      s && !t.levels.some((r) => r === s.levelOrTrack) && (i.abort(), delete this.loaders[Ee.LEVEL]);
    }
  }
  load(e) {
    var t;
    const i = this.hls.config;
    let s = this.getInternalLoader(e);
    if (s) {
      const c = this.hls.logger, u = s.context;
      if (u && u.levelOrTrack === e.levelOrTrack && (u.url === e.url || u.deliveryDirectives && !e.deliveryDirectives)) {
        u.url === e.url ? c.log(`[playlist-loader]: ignore ${e.url} ongoing request`) : c.log(`[playlist-loader]: ignore ${e.url} in favor of ${u.url}`);
        return;
      }
      c.log(`[playlist-loader]: aborting previous loader for type: ${e.type}`), s.abort();
    }
    let r;
    if (e.type === Ee.MANIFEST ? r = i.manifestLoadPolicy.default : r = Fe({}, i.playlistLoadPolicy.default, {
      timeoutRetry: null,
      errorRetry: null
    }), s = this.createInternalLoader(e), Z((t = e.deliveryDirectives) == null ? void 0 : t.part)) {
      let c;
      if (e.type === Ee.LEVEL && e.level !== null ? c = this.hls.levels[e.level].details : e.type === Ee.AUDIO_TRACK && e.id !== null ? c = this.hls.audioTracks[e.id].details : e.type === Ee.SUBTITLE_TRACK && e.id !== null && (c = this.hls.subtitleTracks[e.id].details), c) {
        const u = c.partTarget, d = c.targetduration;
        if (u && d) {
          const f = Math.max(u * 3, d * 0.8) * 1e3;
          r = Fe({}, r, {
            maxTimeToFirstByteMs: Math.min(f, r.maxTimeToFirstByteMs),
            maxLoadTimeMs: Math.min(f, r.maxTimeToFirstByteMs)
          });
        }
      }
    }
    const a = r.errorRetry || r.timeoutRetry || {}, o = {
      loadPolicy: r,
      timeout: r.maxLoadTimeMs,
      maxRetry: a.maxNumRetry || 0,
      retryDelay: a.retryDelayMs || 0,
      maxRetryDelay: a.maxRetryDelayMs || 0
    }, l = {
      onSuccess: (c, u, d, f) => {
        const p = this.getInternalLoader(d);
        this.resetInternalLoader(d.type);
        const h = c.data;
        u.parsing.start = performance.now(), ns.isMediaPlaylist(h) || d.type !== Ee.MANIFEST ? this.handleTrackOrLevelPlaylist(c, u, d, f || null, p) : this.handleMasterPlaylist(c, u, d, f);
      },
      onError: (c, u, d, f) => {
        this.handleNetworkError(u, d, !1, c, f);
      },
      onTimeout: (c, u, d) => {
        this.handleNetworkError(u, d, !0, void 0, c);
      }
    };
    s.load(e, o, l);
  }
  checkAutostartLoad() {
    if (!this.hls)
      return;
    const {
      config: {
        autoStartLoad: e,
        startPosition: t
      },
      forceStartLoad: i
    } = this.hls;
    (e || i) && (this.hls.logger.log(`${e ? "auto" : "force"} startLoad with configured startPosition ${t}`), this.hls.startLoad(t));
  }
  handleMasterPlaylist(e, t, i, s) {
    const r = this.hls, a = e.data, o = ql(e, i), l = ns.parseMasterPlaylist(a, o);
    if (l.playlistParsingError) {
      t.parsing.end = performance.now(), this.handleManifestParsingError(e, i, l.playlistParsingError, s, t);
      return;
    }
    const {
      contentSteering: c,
      levels: u,
      sessionData: d,
      sessionKeys: f,
      startTimeOffset: p,
      variableList: h
    } = l;
    this.variableList = h, u.forEach((y) => {
      const {
        unknownCodecs: E
      } = y;
      if (E) {
        const {
          preferManagedMediaSource: T
        } = this.hls.config;
        let {
          audioCodec: S,
          videoCodec: w
        } = y;
        for (let b = E.length; b--; ) {
          const L = E[b];
          ha(L, "audio", T) ? (y.audioCodec = S = S ? `${S},${L}` : L, mn.audio[S.substring(0, 4)] = 2, E.splice(b, 1)) : ha(L, "video", T) && (y.videoCodec = w = w ? `${w},${L}` : L, mn.video[w.substring(0, 4)] = 2, E.splice(b, 1));
        }
      }
    });
    const {
      AUDIO: g = [],
      SUBTITLES: m,
      "CLOSED-CAPTIONS": v
    } = ns.parseMasterPlaylistMedia(a, o, l);
    g.length && !g.some((E) => !E.url) && u[0].audioCodec && !u[0].attrs.AUDIO && (this.hls.logger.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), g.unshift({
      type: "main",
      name: "main",
      groupId: "main",
      default: !1,
      autoselect: !1,
      forced: !1,
      id: -1,
      attrs: new je({}),
      bitrate: 0,
      url: ""
    })), r.trigger(x.MANIFEST_LOADED, {
      levels: u,
      audioTracks: g,
      subtitles: m,
      captions: v,
      contentSteering: c,
      url: o,
      stats: t,
      networkDetails: s,
      sessionData: d,
      sessionKeys: f,
      startTimeOffset: p,
      variableList: h
    });
  }
  handleTrackOrLevelPlaylist(e, t, i, s, r) {
    const a = this.hls, {
      id: o,
      level: l,
      type: c
    } = i, u = ql(e, i), d = Z(l) ? l : Z(o) ? o : 0, f = ah(i), p = ns.parseLevelPlaylist(e.data, u, d, f, 0, this.variableList);
    if (c === Ee.MANIFEST) {
      const h = {
        attrs: new je({}),
        bitrate: 0,
        details: p,
        name: "",
        url: u
      };
      p.requestScheduled = t.loading.start + Tg(p, 0), a.trigger(x.MANIFEST_LOADED, {
        levels: [h],
        audioTracks: [],
        url: u,
        stats: t,
        networkDetails: s,
        sessionData: null,
        sessionKeys: null,
        contentSteering: null,
        startTimeOffset: null,
        variableList: null
      });
    }
    t.parsing.end = performance.now(), i.levelDetails = p, this.handlePlaylistLoaded(p, e, t, i, s, r);
  }
  handleManifestParsingError(e, t, i, s, r) {
    this.hls.trigger(x.ERROR, {
      type: se.NETWORK_ERROR,
      details: H.MANIFEST_PARSING_ERROR,
      fatal: t.type === Ee.MANIFEST,
      url: e.url,
      err: i,
      error: i,
      reason: i.message,
      response: e,
      context: t,
      networkDetails: s,
      stats: r
    });
  }
  handleNetworkError(e, t, i = !1, s, r) {
    let a = `A network ${i ? "timeout" : "error" + (s ? " (status " + s.code + ")" : "")} occurred while loading ${e.type}`;
    e.type === Ee.LEVEL ? a += `: ${e.level} id: ${e.id}` : (e.type === Ee.AUDIO_TRACK || e.type === Ee.SUBTITLE_TRACK) && (a += ` id: ${e.id} group-id: "${e.groupId}"`);
    const o = new Error(a);
    this.hls.logger.warn(`[playlist-loader]: ${a}`);
    let l = H.UNKNOWN, c = !1;
    const u = this.getInternalLoader(e);
    switch (e.type) {
      case Ee.MANIFEST:
        l = i ? H.MANIFEST_LOAD_TIMEOUT : H.MANIFEST_LOAD_ERROR, c = !0;
        break;
      case Ee.LEVEL:
        l = i ? H.LEVEL_LOAD_TIMEOUT : H.LEVEL_LOAD_ERROR, c = !1;
        break;
      case Ee.AUDIO_TRACK:
        l = i ? H.AUDIO_TRACK_LOAD_TIMEOUT : H.AUDIO_TRACK_LOAD_ERROR, c = !1;
        break;
      case Ee.SUBTITLE_TRACK:
        l = i ? H.SUBTITLE_TRACK_LOAD_TIMEOUT : H.SUBTITLE_LOAD_ERROR, c = !1;
        break;
    }
    u && this.resetInternalLoader(e.type);
    const d = {
      type: se.NETWORK_ERROR,
      details: l,
      fatal: c,
      url: e.url,
      loader: u,
      context: e,
      error: o,
      networkDetails: t,
      stats: r
    };
    if (s) {
      const f = t?.url || e.url;
      d.response = Me({
        url: f,
        data: void 0
      }, s);
    }
    this.hls.trigger(x.ERROR, d);
  }
  handlePlaylistLoaded(e, t, i, s, r, a) {
    const o = this.hls, {
      type: l,
      level: c,
      levelOrTrack: u,
      id: d,
      groupId: f,
      deliveryDirectives: p
    } = s, h = ql(t, s), g = ah(s);
    let m = typeof s.level == "number" && g === te.MAIN ? c : void 0;
    const v = e.playlistParsingError;
    if (v) {
      if (this.hls.logger.warn(`${v} ${e.url}`), !o.config.ignorePlaylistParsingErrors) {
        o.trigger(x.ERROR, {
          type: se.NETWORK_ERROR,
          details: H.LEVEL_PARSING_ERROR,
          fatal: !1,
          url: h,
          error: v,
          reason: v.message,
          response: t,
          context: s,
          level: m,
          parent: g,
          networkDetails: r,
          stats: i
        });
        return;
      }
      e.playlistParsingError = null;
    }
    if (!e.fragments.length) {
      const y = e.playlistParsingError = new Error("No Segments found in Playlist");
      o.trigger(x.ERROR, {
        type: se.NETWORK_ERROR,
        details: H.LEVEL_EMPTY_ERROR,
        fatal: !1,
        url: h,
        error: y,
        reason: y.message,
        response: t,
        context: s,
        level: m,
        parent: g,
        networkDetails: r,
        stats: i
      });
      return;
    }
    switch (e.live && a && (a.getCacheAge && (e.ageHeader = a.getCacheAge() || 0), (!a.getCacheAge || isNaN(e.ageHeader)) && (e.ageHeader = 0)), l) {
      case Ee.MANIFEST:
      case Ee.LEVEL:
        if (m) {
          if (!u)
            m = 0;
          else if (u !== o.levels[m]) {
            const y = o.levels.indexOf(u);
            y > -1 && (m = y);
          }
        }
        o.trigger(x.LEVEL_LOADED, {
          details: e,
          levelInfo: u || o.levels[0],
          level: m || 0,
          id: d || 0,
          stats: i,
          networkDetails: r,
          deliveryDirectives: p,
          withoutMultiVariant: l === Ee.MANIFEST
        });
        break;
      case Ee.AUDIO_TRACK:
        o.trigger(x.AUDIO_TRACK_LOADED, {
          details: e,
          track: u,
          id: d || 0,
          groupId: f || "",
          stats: i,
          networkDetails: r,
          deliveryDirectives: p
        });
        break;
      case Ee.SUBTITLE_TRACK:
        o.trigger(x.SUBTITLE_TRACK_LOADED, {
          details: e,
          track: u,
          id: d || 0,
          groupId: f || "",
          stats: i,
          networkDetails: r,
          deliveryDirectives: p
        });
        break;
    }
  }
}
class mt {
  /**
   * Get the video-dev/hls.js package version.
   */
  static get version() {
    return ma;
  }
  /**
   * Check if the required MediaSource Extensions are available.
   */
  static isMSESupported() {
    return Em();
  }
  /**
   * Check if MediaSource Extensions are available and isTypeSupported checks pass for any baseline codecs.
   */
  static isSupported() {
    return Xx();
  }
  /**
   * Get the MediaSource global used for MSE playback (ManagedMediaSource, MediaSource, or WebKitMediaSource).
   */
  static getMediaSource() {
    return Qs();
  }
  static get Events() {
    return x;
  }
  static get MetadataSchema() {
    return vi;
  }
  static get ErrorTypes() {
    return se;
  }
  static get ErrorDetails() {
    return H;
  }
  /**
   * Get the default configuration applied to new instances.
   */
  static get DefaultConfig() {
    return mt.defaultConfig ? mt.defaultConfig : Nx;
  }
  /**
   * Replace the default configuration applied to new instances.
   */
  static set DefaultConfig(e) {
    mt.defaultConfig = e;
  }
  /**
   * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.
   * @param userConfig - Configuration options applied over `Hls.DefaultConfig`
   */
  constructor(e = {}) {
    this.config = void 0, this.userConfig = void 0, this.logger = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this._emitter = new Gu(), this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioStreamController = void 0, this.subtititleStreamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.interstitialsController = void 0, this.gapController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this._url = null, this._sessionId = void 0, this.triggeringException = void 0, this.started = !1;
    const t = this.logger = ay(e.debug || !1, "Hls instance", e.assetPlayerId), i = this.config = Bx(mt.DefaultConfig, e, t);
    this.userConfig = e, i.progressive && Ux(i, t);
    const {
      abrController: s,
      bufferController: r,
      capLevelController: a,
      errorController: o,
      fpsController: l
    } = i, c = new o(this), u = this.abrController = new s(this), d = new tE(this), f = i.interstitialsController, p = f ? this.interstitialsController = new f(this, mt) : null, h = this.bufferController = new r(this, d), g = this.capLevelController = new a(this), m = new l(this), v = new eb(this), y = i.contentSteeringController, E = y ? new y(this) : null, T = this.levelController = new qx(this, E), S = new Kx(this), w = new Jx(this.config, this.logger), b = this.streamController = new Zx(this, d, w), L = this.gapController = new zx(this, d);
    g.setStreamController(b), m.setStreamController(b);
    const A = [v, T, b];
    p && A.splice(1, 0, p), E && A.splice(1, 0, E), this.networkControllers = A;
    const _ = [u, h, L, g, m, S, d];
    this.audioTrackController = this.createController(i.audioTrackController, A);
    const R = i.audioStreamController;
    R && A.push(this.audioStreamController = new R(this, d, w)), this.subtitleTrackController = this.createController(i.subtitleTrackController, A);
    const I = i.subtitleStreamController;
    I && A.push(this.subtititleStreamController = new I(this, d, w)), this.createController(i.timelineController, _), w.emeController = this.emeController = this.createController(i.emeController, _), this.cmcdController = this.createController(i.cmcdController, _), this.latencyController = this.createController(Yx, _), this.coreComponents = _, A.push(c);
    const k = c.onErrorOut;
    typeof k == "function" && this.on(x.ERROR, k, c), this.on(x.MANIFEST_LOADED, v.onManifestLoaded, v);
  }
  createController(e, t) {
    if (e) {
      const i = new e(this);
      return t && t.push(i), i;
    }
    return null;
  }
  // Delegate the EventEmitter through the public API of Hls.js
  on(e, t, i = this) {
    this._emitter.on(e, t, i);
  }
  once(e, t, i = this) {
    this._emitter.once(e, t, i);
  }
  removeAllListeners(e) {
    this._emitter.removeAllListeners(e);
  }
  off(e, t, i = this, s) {
    this._emitter.off(e, t, i, s);
  }
  listeners(e) {
    return this._emitter.listeners(e);
  }
  emit(e, t, i) {
    return this._emitter.emit(e, t, i);
  }
  trigger(e, t) {
    if (this.config.debug)
      return this.emit(e, e, t);
    try {
      return this.emit(e, e, t);
    } catch (i) {
      if (this.logger.error("An internal error happened while handling event " + e + '. Error message: "' + i.message + '". Here is a stacktrace:', i), !this.triggeringException) {
        this.triggeringException = !0;
        const s = e === x.ERROR;
        this.trigger(x.ERROR, {
          type: se.OTHER_ERROR,
          details: H.INTERNAL_EXCEPTION,
          fatal: s,
          event: e,
          error: i
        }), this.triggeringException = !1;
      }
    }
    return !1;
  }
  listenerCount(e) {
    return this._emitter.listenerCount(e);
  }
  /**
   * Dispose of the instance
   */
  destroy() {
    this.logger.log("destroy"), this.trigger(x.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this._url = null, this.networkControllers.forEach((t) => t.destroy()), this.networkControllers.length = 0, this.coreComponents.forEach((t) => t.destroy()), this.coreComponents.length = 0;
    const e = this.config;
    e.xhrSetup = e.fetchSetup = void 0, this.userConfig = null;
  }
  /**
   * Attaches Hls.js to a media element
   */
  attachMedia(e) {
    if (!e || "media" in e && !e.media) {
      const r = new Error(`attachMedia failed: invalid argument (${e})`);
      this.trigger(x.ERROR, {
        type: se.OTHER_ERROR,
        details: H.ATTACH_MEDIA_ERROR,
        fatal: !0,
        error: r
      });
      return;
    }
    this.logger.log("attachMedia"), this._media && (this.logger.warn("media must be detached before attaching"), this.detachMedia());
    const t = "media" in e, i = t ? e.media : e, s = t ? e : {
      media: i
    };
    this._media = i, this.trigger(x.MEDIA_ATTACHING, s);
  }
  /**
   * Detach Hls.js from the media
   */
  detachMedia() {
    this.logger.log("detachMedia"), this.trigger(x.MEDIA_DETACHING, {}), this._media = null;
  }
  /**
   * Detach HTMLMediaElement, MediaSource, and SourceBuffers without reset, for attaching to another instance
   */
  transferMedia() {
    this._media = null;
    const e = this.bufferController.transferMedia();
    return this.trigger(x.MEDIA_DETACHING, {
      transferMedia: e
    }), e;
  }
  /**
   * Set the source URL. Can be relative or absolute.
   */
  loadSource(e) {
    this.stopLoad();
    const t = this.media, i = this._url, s = this._url = Cu.buildAbsoluteURL(self.location.href, e, {
      alwaysNormalize: !0
    });
    this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.logger.log(`loadSource:${s}`), t && i && (i !== s || this.bufferController.hasSourceTypes()) && (this.detachMedia(), this.attachMedia(t)), this.trigger(x.MANIFEST_LOADING, {
      url: e
    });
  }
  /**
   * Gets the currently loaded URL
   */
  get url() {
    return this._url;
  }
  /**
   * Whether or not enough has been buffered to seek to start position or use `media.currentTime` to determine next load position
   */
  get hasEnoughToStart() {
    return this.streamController.hasEnoughToStart;
  }
  /**
   * Get the startPosition set on startLoad(position) or on autostart with config.startPosition
   */
  get startPosition() {
    return this.streamController.startPositionValue;
  }
  /**
   * Start loading data from the stream source.
   * Depending on default config, client starts loading automatically when a source is set.
   *
   * @param startPosition - Set the start position to stream from.
   * Defaults to -1 (None: starts from earliest point)
   */
  startLoad(e = -1, t) {
    this.logger.log(`startLoad(${e + (t ? ", <skip seek to start>" : "")})`), this.started = !0, this.resumeBuffering();
    for (let i = 0; i < this.networkControllers.length && (this.networkControllers[i].startLoad(e, t), !(!this.started || !this.networkControllers)); i++)
      ;
  }
  /**
   * Stop loading of any stream data.
   */
  stopLoad() {
    this.logger.log("stopLoad"), this.started = !1;
    for (let e = 0; e < this.networkControllers.length && (this.networkControllers[e].stopLoad(), !(this.started || !this.networkControllers)); e++)
      ;
  }
  /**
   * Returns whether loading, toggled with `startLoad()` and `stopLoad()`, is active or not`.
   */
  get loadingEnabled() {
    return this.started;
  }
  /**
   * Returns state of fragment loading toggled by calling `pauseBuffering()` and `resumeBuffering()`.
   */
  get bufferingEnabled() {
    return this.streamController.bufferingEnabled;
  }
  /**
   * Resumes stream controller segment loading after `pauseBuffering` has been called.
   */
  resumeBuffering() {
    this.bufferingEnabled || (this.logger.log("resume buffering"), this.networkControllers.forEach((e) => {
      e.resumeBuffering && e.resumeBuffering();
    }));
  }
  /**
   * Prevents stream controller from loading new segments until `resumeBuffering` is called.
   * This allows for media buffering to be paused without interupting playlist loading.
   */
  pauseBuffering() {
    this.bufferingEnabled && (this.logger.log("pause buffering"), this.networkControllers.forEach((e) => {
      e.pauseBuffering && e.pauseBuffering();
    }));
  }
  get inFlightFragments() {
    const e = {
      [te.MAIN]: this.streamController.inFlightFrag
    };
    return this.audioStreamController && (e[te.AUDIO] = this.audioStreamController.inFlightFrag), this.subtititleStreamController && (e[te.SUBTITLE] = this.subtititleStreamController.inFlightFrag), e;
  }
  /**
   * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)
   */
  swapAudioCodec() {
    this.logger.log("swapAudioCodec"), this.streamController.swapAudioCodec();
  }
  /**
   * When the media-element fails, this allows to detach and then re-attach it
   * as one call (convenience method).
   *
   * Automatic recovery of media-errors by this process is configurable.
   */
  recoverMediaError() {
    this.logger.log("recoverMediaError");
    const e = this._media, t = e?.currentTime;
    this.detachMedia(), e && (this.attachMedia(e), t && this.startLoad(t));
  }
  removeLevel(e) {
    this.levelController.removeLevel(e);
  }
  /**
   * @returns a UUID for this player instance
   */
  get sessionId() {
    let e = this._sessionId;
    return e || (e = this._sessionId = zS()), e;
  }
  /**
   * @returns an array of levels (variants) sorted by HDCP-LEVEL, RESOLUTION (height), FRAME-RATE, CODECS, VIDEO-RANGE, and BANDWIDTH
   */
  get levels() {
    const e = this.levelController.levels;
    return e || [];
  }
  /**
   * @returns LevelDetails of last loaded level (variant) or `null` prior to loading a media playlist.
   */
  get latestLevelDetails() {
    return this.streamController.getLevelDetails() || null;
  }
  /**
   * @returns Level object of selected level (variant) or `null` prior to selecting a level or once the level is removed.
   */
  get loadLevelObj() {
    return this.levelController.loadLevelObj;
  }
  /**
   * Index of quality level (variant) currently played
   */
  get currentLevel() {
    return this.streamController.currentLevel;
  }
  /**
   * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.
   */
  set currentLevel(e) {
    this.logger.log(`set currentLevel:${e}`), this.levelController.manualLevel = e, this.streamController.immediateLevelSwitch();
  }
  /**
   * Index of next quality level loaded as scheduled by stream controller.
   */
  get nextLevel() {
    return this.streamController.nextLevel;
  }
  /**
   * Set quality level index for next loaded data.
   * This will switch the video quality asap, without interrupting playback.
   * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).
   * @param newLevel - Pass -1 for automatic level selection
   */
  set nextLevel(e) {
    this.logger.log(`set nextLevel:${e}`), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch();
  }
  /**
   * Return the quality level of the currently or last (of none is loaded currently) segment
   */
  get loadLevel() {
    return this.levelController.level;
  }
  /**
   * Set quality level index for next loaded data in a conservative way.
   * This will switch the quality without flushing, but interrupt current loading.
   * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.
   * @param newLevel - Pass -1 for automatic level selection
   */
  set loadLevel(e) {
    this.logger.log(`set loadLevel:${e}`), this.levelController.manualLevel = e;
  }
  /**
   * get next quality level loaded
   */
  get nextLoadLevel() {
    return this.levelController.nextLoadLevel;
  }
  /**
   * Set quality level of next loaded segment in a fully "non-destructive" way.
   * Same as `loadLevel` but will wait for next switch (until current loading is done).
   */
  set nextLoadLevel(e) {
    this.levelController.nextLoadLevel = e;
  }
  /**
   * Return "first level": like a default level, if not set,
   * falls back to index of first level referenced in manifest
   */
  get firstLevel() {
    return Math.max(this.levelController.firstLevel, this.minAutoLevel);
  }
  /**
   * Sets "first-level", see getter.
   */
  set firstLevel(e) {
    this.logger.log(`set firstLevel:${e}`), this.levelController.firstLevel = e;
  }
  /**
   * Return the desired start level for the first fragment that will be loaded.
   * The default value of -1 indicates automatic start level selection.
   * Setting hls.nextAutoLevel without setting a startLevel will result in
   * the nextAutoLevel value being used for one fragment load.
   */
  get startLevel() {
    const e = this.levelController.startLevel;
    return e === -1 && this.abrController.forcedAutoLevel > -1 ? this.abrController.forcedAutoLevel : e;
  }
  /**
   * set  start level (level of first fragment that will be played back)
   * if not overrided by user, first level appearing in manifest will be used as start level
   * if -1 : automatic start level selection, playback will start from level matching download bandwidth
   * (determined from download of first segment)
   */
  set startLevel(e) {
    this.logger.log(`set startLevel:${e}`), e !== -1 && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e;
  }
  /**
   * Whether level capping is enabled.
   * Default value is set via `config.capLevelToPlayerSize`.
   */
  get capLevelToPlayerSize() {
    return this.config.capLevelToPlayerSize;
  }
  /**
   * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.
   */
  set capLevelToPlayerSize(e) {
    const t = !!e;
    t !== this.config.capLevelToPlayerSize && (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = t);
  }
  /**
   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
   */
  get autoLevelCapping() {
    return this._autoLevelCapping;
  }
  /**
   * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.
   */
  get bandwidthEstimate() {
    const {
      bwEstimator: e
    } = this.abrController;
    return e ? e.getEstimate() : NaN;
  }
  set bandwidthEstimate(e) {
    this.abrController.resetEstimator(e);
  }
  get abrEwmaDefaultEstimate() {
    const {
      bwEstimator: e
    } = this.abrController;
    return e ? e.defaultEstimate : NaN;
  }
  /**
   * get time to first byte estimate
   * @type {number}
   */
  get ttfbEstimate() {
    const {
      bwEstimator: e
    } = this.abrController;
    return e ? e.getEstimateTTFB() : NaN;
  }
  /**
   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
   */
  set autoLevelCapping(e) {
    this._autoLevelCapping !== e && (this.logger.log(`set autoLevelCapping:${e}`), this._autoLevelCapping = e, this.levelController.checkMaxAutoUpdated());
  }
  get maxHdcpLevel() {
    return this._maxHdcpLevel;
  }
  set maxHdcpLevel(e) {
    By(e) && this._maxHdcpLevel !== e && (this._maxHdcpLevel = e, this.levelController.checkMaxAutoUpdated());
  }
  /**
   * True when automatic level selection enabled
   */
  get autoLevelEnabled() {
    return this.levelController.manualLevel === -1;
  }
  /**
   * Level set manually (if any)
   */
  get manualLevel() {
    return this.levelController.manualLevel;
  }
  /**
   * min level selectable in auto mode according to config.minAutoBitrate
   */
  get minAutoLevel() {
    const {
      levels: e,
      config: {
        minAutoBitrate: t
      }
    } = this;
    if (!e) return 0;
    const i = e.length;
    for (let s = 0; s < i; s++)
      if (e[s].maxBitrate >= t)
        return s;
    return 0;
  }
  /**
   * max level selectable in auto mode according to autoLevelCapping
   */
  get maxAutoLevel() {
    const {
      levels: e,
      autoLevelCapping: t,
      maxHdcpLevel: i
    } = this;
    let s;
    if (t === -1 && e != null && e.length ? s = e.length - 1 : s = t, i)
      for (let r = s; r--; ) {
        const a = e[r].attrs["HDCP-LEVEL"];
        if (a && a <= i)
          return r;
      }
    return s;
  }
  get firstAutoLevel() {
    return this.abrController.firstAutoLevel;
  }
  /**
   * next automatically selected quality level
   */
  get nextAutoLevel() {
    return this.abrController.nextAutoLevel;
  }
  /**
   * this setter is used to force next auto level.
   * this is useful to force a switch down in auto mode:
   * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
   * forced value is valid for one fragment. upon successful frag loading at forced level,
   * this value will be resetted to -1 by ABR controller.
   */
  set nextAutoLevel(e) {
    this.abrController.nextAutoLevel = e;
  }
  /**
   * get the datetime value relative to media.currentTime for the active level Program Date Time if present
   */
  get playingDate() {
    return this.streamController.currentProgramDateTime;
  }
  get mainForwardBufferInfo() {
    return this.streamController.getMainFwdBufferInfo();
  }
  get maxBufferLength() {
    return this.streamController.maxBufferLength;
  }
  /**
   * Find and select the best matching audio track, making a level switch when a Group change is necessary.
   * Updates `hls.config.audioPreference`. Returns the selected track, or null when no matching track is found.
   */
  setAudioOption(e) {
    var t;
    return ((t = this.audioTrackController) == null ? void 0 : t.setAudioOption(e)) || null;
  }
  /**
   * Find and select the best matching subtitle track, making a level switch when a Group change is necessary.
   * Updates `hls.config.subtitlePreference`. Returns the selected track, or null when no matching track is found.
   */
  setSubtitleOption(e) {
    var t;
    return ((t = this.subtitleTrackController) == null ? void 0 : t.setSubtitleOption(e)) || null;
  }
  /**
   * Get the complete list of audio tracks across all media groups
   */
  get allAudioTracks() {
    const e = this.audioTrackController;
    return e ? e.allAudioTracks : [];
  }
  /**
   * Get the list of selectable audio tracks
   */
  get audioTracks() {
    const e = this.audioTrackController;
    return e ? e.audioTracks : [];
  }
  /**
   * index of the selected audio track (index in audio track lists)
   */
  get audioTrack() {
    const e = this.audioTrackController;
    return e ? e.audioTrack : -1;
  }
  /**
   * selects an audio track, based on its index in audio track lists
   */
  set audioTrack(e) {
    const t = this.audioTrackController;
    t && (t.audioTrack = e);
  }
  /**
   * get the complete list of subtitle tracks across all media groups
   */
  get allSubtitleTracks() {
    const e = this.subtitleTrackController;
    return e ? e.allSubtitleTracks : [];
  }
  /**
   * get alternate subtitle tracks list from playlist
   */
  get subtitleTracks() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleTracks : [];
  }
  /**
   * index of the selected subtitle track (index in subtitle track lists)
   */
  get subtitleTrack() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleTrack : -1;
  }
  get media() {
    return this._media;
  }
  /**
   * select an subtitle track, based on its index in subtitle track lists
   */
  set subtitleTrack(e) {
    const t = this.subtitleTrackController;
    t && (t.subtitleTrack = e);
  }
  /**
   * Whether subtitle display is enabled or not
   */
  get subtitleDisplay() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleDisplay : !1;
  }
  /**
   * Enable/disable subtitle display rendering
   */
  set subtitleDisplay(e) {
    const t = this.subtitleTrackController;
    t && (t.subtitleDisplay = e);
  }
  /**
   * get mode for Low-Latency HLS loading
   */
  get lowLatencyMode() {
    return this.config.lowLatencyMode;
  }
  /**
   * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.
   */
  set lowLatencyMode(e) {
    this.config.lowLatencyMode = e;
  }
  /**
   * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)
   * @returns null prior to loading live Playlist
   */
  get liveSyncPosition() {
    return this.latencyController.liveSyncPosition;
  }
  /**
   * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)
   * @returns 0 before first playlist is loaded
   */
  get latency() {
    return this.latencyController.latency;
  }
  /**
   * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```
   * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```
   * @returns 0 before first playlist is loaded
   */
  get maxLatency() {
    return this.latencyController.maxLatency;
  }
  /**
   * target distance from the edge as calculated by the latency controller
   */
  get targetLatency() {
    return this.latencyController.targetLatency;
  }
  set targetLatency(e) {
    this.latencyController.targetLatency = e;
  }
  /**
   * the rate at which the edge of the current live playlist is advancing or 1 if there is none
   */
  get drift() {
    return this.latencyController.drift;
  }
  /**
   * set to true when startLoad is called before MANIFEST_PARSED event
   */
  get forceStartLoad() {
    return this.streamController.forceStartLoad;
  }
  /**
   * ContentSteering pathways getter
   */
  get pathways() {
    return this.levelController.pathways;
  }
  /**
   * ContentSteering pathwayPriority getter/setter
   */
  get pathwayPriority() {
    return this.levelController.pathwayPriority;
  }
  set pathwayPriority(e) {
    this.levelController.pathwayPriority = e;
  }
  /**
   * returns true when all SourceBuffers are buffered to the end
   */
  get bufferedToEnd() {
    var e;
    return !!((e = this.bufferController) != null && e.bufferedToEnd);
  }
  /**
   * returns Interstitials Program Manager
   */
  get interstitialsManager() {
    var e;
    return ((e = this.interstitialsController) == null ? void 0 : e.interstitialsManager) || null;
  }
  /**
   * returns mediaCapabilities.decodingInfo for a variant/rendition
   */
  getMediaDecodingInfo(e, t = this.allAudioTracks) {
    const i = ng(t);
    return sg(e, i, navigator.mediaCapabilities);
  }
}
mt.defaultConfig = void 0;
function Tm() {
  document.querySelectorAll("[data-bunny-player-init]").forEach(function(a) {
    var o = a.getAttribute("data-player-src");
    if (!o) return;
    var l = a.querySelector("video");
    if (!l) return;
    try {
      l.pause();
    } catch {
    }
    try {
      l.removeAttribute("src"), l.load();
    } catch {
    }
    function c(O) {
      a.getAttribute("data-player-status") !== O && a.setAttribute("data-player-status", O);
    }
    function u(O) {
      a.setAttribute("data-player-activated", O ? "true" : "false");
    }
    a.hasAttribute("data-player-activated") || u(!1);
    var d = a.getAttribute("data-player-update-size"), f = a.getAttribute("data-player-lazy"), p = f === "true", h = f === "meta", g = a.getAttribute("data-player-autoplay") === "true", m = !1;
    l.muted = !!g, g && (l.loop = !0), l.setAttribute("muted", ""), l.setAttribute("playsinline", ""), l.setAttribute("webkit-playsinline", ""), l.playsInline = !0, typeof l.disableRemotePlayback < "u" && (l.disableRemotePlayback = !0), g && (l.autoplay = !1);
    var v = !!l.canPlayType("application/vnd.apple.mpegurl"), y = !!(mt && mt.isSupported()) && !v;
    if (d === "true" && !h && !p) {
      var E = l.preload;
      l.preload = "metadata";
      var T = function() {
        e(a, d, l.videoWidth, l.videoHeight), l.removeEventListener("loadedmetadata", T), l.preload = E || "";
      };
      l.addEventListener("loadedmetadata", T, { once: !0 }), l.src = o;
    }
    function S() {
      r(o, y).then(function(O) {
        O.width && O.height && e(a, d, O.width, O.height), n(a, m);
      });
    }
    var w = !1, b = "";
    function L() {
      if (!w) {
        if (w = !0, a._hls) {
          try {
            a._hls.destroy();
          } catch {
          }
          a._hls = null;
        }
        if (v)
          l.preload = p || h ? "auto" : l.preload, l.src = o, l.addEventListener("loadedmetadata", function() {
            n(a, m), d === "true" && e(a, d, l.videoWidth, l.videoHeight);
          }, { once: !0 });
        else if (y) {
          var O = new mt({ maxBufferLength: 10 });
          O.attachMedia(l), O.on(mt.Events.MEDIA_ATTACHED, function() {
            O.loadSource(o);
          }), O.on(mt.Events.MANIFEST_PARSED, function() {
            if (n(a, m), d === "true") {
              var F = O.levels || [], C = t(F);
              C && C.width && C.height && e(a, d, C.width, C.height);
            }
          }), a._hls = O;
        } else
          l.src = o;
      }
    }
    h ? (d === "true" && S(), l.preload = "none") : p ? l.preload = "none" : L();
    function A() {
      l.paused || l.ended ? ((p || h) && !w && L(), m = !0, b = "", c("loading"), i(l)) : (b = "manual", l.pause());
    }
    function _() {
      l.muted = !l.muted, a.setAttribute("data-player-muted", l.muted ? "true" : "false");
    }
    a.addEventListener("click", function(O) {
      var F = O.target.closest("[data-player-control]");
      if (!(!F || !a.contains(F))) {
        var C = F.getAttribute("data-player-control");
        C === "play" || C === "pause" || C === "playpause" ? A() : C === "mute" && _();
      }
    }), l.addEventListener("play", function() {
      u(!0), c("playing");
    }), l.addEventListener("playing", function() {
      m = !1, c("playing");
    }), l.addEventListener("pause", function() {
      m = !1, c("paused");
    }), l.addEventListener("waiting", function() {
      c("loading");
    }), l.addEventListener("canplay", function() {
      n(a, m);
    }), l.addEventListener("ended", function() {
      m = !1, c("paused"), u(!1);
    });
    var R = !1;
    function I() {
      if (!(R || d !== "true")) {
        var O = a.querySelector("[data-player-before]");
        O && l.videoWidth && l.videoHeight && (O.style.paddingTop = l.videoHeight / l.videoWidth * 100 + "%", R = !0);
      }
    }
    l.addEventListener("loadedmetadata", function() {
      I();
    }), l.addEventListener("loadeddata", function() {
      I();
    }), l.addEventListener("playing", function() {
      I();
    });
    function k(O) {
      a.getAttribute("data-player-hover") !== O && a.setAttribute("data-player-hover", O);
    }
    if (a.addEventListener("pointerenter", function() {
      k("active");
    }), a.addEventListener("pointerleave", function() {
      k("idle");
    }), g) {
      var M = new IntersectionObserver(function(O) {
        O.forEach(function(F) {
          var C = F.isIntersecting && F.intersectionRatio > 0;
          C ? ((p || h) && !w && L(), (b === "io" || l.paused && b !== "manual") && (c("loading"), l.paused && A(), b = "")) : !l.paused && !l.ended && (b = "io", l.pause());
        });
      }, { threshold: 0.1 });
      M.observe(a);
    }
  });
  function n(a, o) {
    !o && a.getAttribute("data-player-activated") !== "true" && a.getAttribute("data-player-status") === "idle" && a.setAttribute("data-player-status", "ready");
  }
  function e(a, o, l, c) {
    if (!(o !== "true" || !l || !c)) {
      var u = a.querySelector("[data-player-before]");
      u && (u.style.paddingTop = c / l * 100 + "%");
    }
  }
  function t(a) {
    return !a || !a.length ? null : a.reduce(function(o, l) {
      return (l.width || 0) > (o.width || 0) ? l : o;
    }, a[0]);
  }
  function i(a) {
    var o = a.play();
    o && typeof o.then == "function" && o.catch(function() {
    });
  }
  function s(a, o) {
    try {
      return new URL(o, a).toString();
    } catch {
      return o;
    }
  }
  function r(a, o) {
    return new Promise(function(l) {
      if (o && mt && mt.isSupported())
        try {
          var c = new mt(), u = { width: 0, height: 0, duration: NaN };
          c.on(mt.Events.MANIFEST_PARSED, function(p, h) {
            var g = h && h.levels || c.levels || [], m = t(g);
            m && m.width && m.height && (u.width = m.width, u.height = m.height);
          }), c.on(mt.Events.LEVEL_LOADED, function(p, h) {
            h && h.details && isFinite(h.details.totalduration) && (u.duration = h.details.totalduration);
          }), c.on(mt.Events.ERROR, function() {
            try {
              c.destroy();
            } catch {
            }
            l(u);
          }), c.on(mt.Events.LEVEL_LOADED, function() {
            try {
              c.destroy();
            } catch {
            }
            l(u);
          }), c.loadSource(a);
          return;
        } catch {
          l({ width: 0, height: 0, duration: NaN });
          return;
        }
      function d(p) {
        for (var h = p.split(/\r?\n/), g = 0, m = 0, v = null, y = null, E = 0; E < h.length; E++) {
          var T = h[E];
          if (T.indexOf("#EXT-X-STREAM-INF:") === 0)
            y = T;
          else if (y && T && T[0] !== "#") {
            v || (v = T.trim());
            var S = /RESOLUTION=(\d+)x(\d+)/.exec(y);
            if (S) {
              var w = parseInt(S[1], 10), b = parseInt(S[2], 10);
              w > g && (g = w, m = b);
            }
            y = null;
          }
        }
        return { bestW: g, bestH: m, media: v };
      }
      function f(p) {
        for (var h = 0, g = /#EXTINF:([\d.]+)/g, m; m = g.exec(p); ) h += parseFloat(m[1]);
        return h;
      }
      fetch(a, { credentials: "omit", cache: "no-store" }).then(function(p) {
        if (!p.ok) throw new Error("master");
        return p.text();
      }).then(function(p) {
        var h = d(p);
        if (!h.media) {
          l({ width: h.bestW || 0, height: h.bestH || 0, duration: NaN });
          return;
        }
        var g = s(a, h.media);
        return fetch(g, { credentials: "omit", cache: "no-store" }).then(function(m) {
          if (!m.ok) throw new Error("media");
          return m.text();
        }).then(function(m) {
          l({ width: h.bestW || 0, height: h.bestH || 0, duration: f(m) });
        });
      }).catch(function() {
        l({ width: 0, height: 0, duration: NaN });
      });
    });
  }
}
document.addEventListener("DOMContentLoaded", function() {
  Tm();
});
function tb() {
  Iu(), Tm(), Ru(), el(), xa(), window.viewportManager && window.viewportManager.enable();
}
function ib() {
  document.querySelectorAll("[data-clipboard]").forEach((t) => {
    t.removeEventListener("click", e), t.addEventListener("click", e);
  });
  function e(t) {
    const i = t.currentTarget.getAttribute("data-clipboard");
    navigator.clipboard.writeText(i).catch((s) => {
      const r = document.createElement("textarea");
      r.value = i, r.style.position = "fixed", document.body.appendChild(r), r.select();
      try {
        document.execCommand("copy");
      } catch (a) {
        console.error("Fallback copy failed:", a);
      }
      document.body.removeChild(r);
    });
  }
}
function sb() {
  Q.buttonAnimations.initialize(), ib(), xa(), Ru(), window.viewportManager && window.viewportManager.enable();
}
function rb() {
  window.lenis && lenis.destroy(), window.innerWidth >= 768 && Fn({
    smooth: !0,
    lerp: 0.1,
    multiplier: 0.7,
    infinite: !0
  }), Q.buttonAnimations.initialize(), xa(), Ru(), el(), window.viewportManager && window.viewportManager.enable();
}
function oh(n) {
  return n !== null && typeof n == "object" && "constructor" in n && n.constructor === Object;
}
function ed(n, e) {
  n === void 0 && (n = {}), e === void 0 && (e = {});
  const t = ["__proto__", "constructor", "prototype"];
  Object.keys(e).filter((i) => t.indexOf(i) < 0).forEach((i) => {
    typeof n[i] > "u" ? n[i] = e[i] : oh(e[i]) && oh(n[i]) && Object.keys(e[i]).length > 0 && ed(n[i], e[i]);
  });
}
const Sm = {
  body: {},
  addEventListener() {
  },
  removeEventListener() {
  },
  activeElement: {
    blur() {
    },
    nodeName: ""
  },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return {
      initEvent() {
      }
    };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {
      },
      getElementsByTagName() {
        return [];
      }
    };
  },
  createElementNS() {
    return {};
  },
  importNode() {
    return null;
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  }
};
function _t() {
  const n = typeof document < "u" ? document : {};
  return ed(n, Sm), n;
}
const nb = {
  document: Sm,
  navigator: {
    userAgent: ""
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  },
  history: {
    replaceState() {
    },
    pushState() {
    },
    go() {
    },
    back() {
    }
  },
  CustomEvent: function() {
    return this;
  },
  addEventListener() {
  },
  removeEventListener() {
  },
  getComputedStyle() {
    return {
      getPropertyValue() {
        return "";
      }
    };
  },
  Image() {
  },
  Date() {
  },
  screen: {},
  setTimeout() {
  },
  clearTimeout() {
  },
  matchMedia() {
    return {};
  },
  requestAnimationFrame(n) {
    return typeof setTimeout > "u" ? (n(), null) : setTimeout(n, 0);
  },
  cancelAnimationFrame(n) {
    typeof setTimeout > "u" || clearTimeout(n);
  }
};
function qe() {
  const n = typeof window < "u" ? window : {};
  return ed(n, nb), n;
}
function Ds(n) {
  return n === void 0 && (n = ""), n.trim().split(" ").filter((e) => !!e.trim());
}
function ab(n) {
  const e = n;
  Object.keys(e).forEach((t) => {
    try {
      e[t] = null;
    } catch {
    }
    try {
      delete e[t];
    } catch {
    }
  });
}
function yn(n, e) {
  return e === void 0 && (e = 0), setTimeout(n, e);
}
function Ci() {
  return Date.now();
}
function ob(n) {
  const e = qe();
  let t;
  return e.getComputedStyle && (t = e.getComputedStyle(n, null)), !t && n.currentStyle && (t = n.currentStyle), t || (t = n.style), t;
}
function jc(n, e) {
  e === void 0 && (e = "x");
  const t = qe();
  let i, s, r;
  const a = ob(n);
  return t.WebKitCSSMatrix ? (s = a.transform || a.webkitTransform, s.split(",").length > 6 && (s = s.split(", ").map((o) => o.replace(",", ".")).join(", ")), r = new t.WebKitCSSMatrix(s === "none" ? "" : s)) : (r = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), i = r.toString().split(",")), e === "x" && (t.WebKitCSSMatrix ? s = r.m41 : i.length === 16 ? s = parseFloat(i[12]) : s = parseFloat(i[4])), e === "y" && (t.WebKitCSSMatrix ? s = r.m42 : i.length === 16 ? s = parseFloat(i[13]) : s = parseFloat(i[5])), s || 0;
}
function $n(n) {
  return typeof n == "object" && n !== null && n.constructor && Object.prototype.toString.call(n).slice(8, -1) === "Object";
}
function lb(n) {
  return typeof window < "u" && typeof window.HTMLElement < "u" ? n instanceof HTMLElement : n && (n.nodeType === 1 || n.nodeType === 11);
}
function gi() {
  const n = Object(arguments.length <= 0 ? void 0 : arguments[0]), e = ["__proto__", "constructor", "prototype"];
  for (let t = 1; t < arguments.length; t += 1) {
    const i = t < 0 || arguments.length <= t ? void 0 : arguments[t];
    if (i != null && !lb(i)) {
      const s = Object.keys(Object(i)).filter((r) => e.indexOf(r) < 0);
      for (let r = 0, a = s.length; r < a; r += 1) {
        const o = s[r], l = Object.getOwnPropertyDescriptor(i, o);
        l !== void 0 && l.enumerable && ($n(n[o]) && $n(i[o]) ? i[o].__swiper__ ? n[o] = i[o] : gi(n[o], i[o]) : !$n(n[o]) && $n(i[o]) ? (n[o] = {}, i[o].__swiper__ ? n[o] = i[o] : gi(n[o], i[o])) : n[o] = i[o]);
      }
    }
  }
  return n;
}
function Bn(n, e, t) {
  n.style.setProperty(e, t);
}
function xm(n) {
  let {
    swiper: e,
    targetPosition: t,
    side: i
  } = n;
  const s = qe(), r = -e.translate;
  let a = null, o;
  const l = e.params.speed;
  e.wrapperEl.style.scrollSnapType = "none", s.cancelAnimationFrame(e.cssModeFrameID);
  const c = t > r ? "next" : "prev", u = (f, p) => c === "next" && f >= p || c === "prev" && f <= p, d = () => {
    o = (/* @__PURE__ */ new Date()).getTime(), a === null && (a = o);
    const f = Math.max(Math.min((o - a) / l, 1), 0), p = 0.5 - Math.cos(f * Math.PI) / 2;
    let h = r + p * (t - r);
    if (u(h, t) && (h = t), e.wrapperEl.scrollTo({
      [i]: h
    }), u(h, t)) {
      e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.scrollSnapType = "", setTimeout(() => {
        e.wrapperEl.style.overflow = "", e.wrapperEl.scrollTo({
          [i]: h
        });
      }), s.cancelAnimationFrame(e.cssModeFrameID);
      return;
    }
    e.cssModeFrameID = s.requestAnimationFrame(d);
  };
  d();
}
function Pr(n) {
  return n.querySelector(".swiper-slide-transform") || n.shadowRoot && n.shadowRoot.querySelector(".swiper-slide-transform") || n;
}
function Dt(n, e) {
  e === void 0 && (e = "");
  const t = qe(), i = [...n.children];
  return t.HTMLSlotElement && n instanceof HTMLSlotElement && i.push(...n.assignedElements()), e ? i.filter((s) => s.matches(e)) : i;
}
function cb(n, e) {
  const t = [e];
  for (; t.length > 0; ) {
    const i = t.shift();
    if (n === i)
      return !0;
    t.push(...i.children, ...i.shadowRoot ? i.shadowRoot.children : [], ...i.assignedElements ? i.assignedElements() : []);
  }
}
function ub(n, e) {
  const t = qe();
  let i = e.contains(n);
  return !i && t.HTMLSlotElement && e instanceof HTMLSlotElement && (i = [...e.assignedElements()].includes(n), i || (i = cb(n, e))), i;
}
function Yo(n) {
  try {
    console.warn(n);
    return;
  } catch {
  }
}
function Si(n, e) {
  e === void 0 && (e = []);
  const t = document.createElement(n);
  return t.classList.add(...Array.isArray(e) ? e : Ds(e)), t;
}
function qo(n) {
  const e = qe(), t = _t(), i = n.getBoundingClientRect(), s = t.body, r = n.clientTop || s.clientTop || 0, a = n.clientLeft || s.clientLeft || 0, o = n === e ? e.scrollY : n.scrollTop, l = n === e ? e.scrollX : n.scrollLeft;
  return {
    top: i.top + o - r,
    left: i.left + l - a
  };
}
function db(n, e) {
  const t = [];
  for (; n.previousElementSibling; ) {
    const i = n.previousElementSibling;
    e ? i.matches(e) && t.push(i) : t.push(i), n = i;
  }
  return t;
}
function fb(n, e) {
  const t = [];
  for (; n.nextElementSibling; ) {
    const i = n.nextElementSibling;
    e ? i.matches(e) && t.push(i) : t.push(i), n = i;
  }
  return t;
}
function Vs(n, e) {
  return qe().getComputedStyle(n, null).getPropertyValue(e);
}
function Ta(n) {
  let e = n, t;
  if (e) {
    for (t = 0; (e = e.previousSibling) !== null; )
      e.nodeType === 1 && (t += 1);
    return t;
  }
}
function _r(n, e) {
  const t = [];
  let i = n.parentElement;
  for (; i; )
    e ? i.matches(e) && t.push(i) : t.push(i), i = i.parentElement;
  return t;
}
function ta(n, e) {
  function t(i) {
    i.target === n && (e.call(n, i), n.removeEventListener("transitionend", t));
  }
  e && n.addEventListener("transitionend", t);
}
function Qc(n, e, t) {
  const i = qe();
  return n[e === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(i.getComputedStyle(n, null).getPropertyValue(e === "width" ? "margin-right" : "margin-top")) + parseFloat(i.getComputedStyle(n, null).getPropertyValue(e === "width" ? "margin-left" : "margin-bottom"));
}
function be(n) {
  return (Array.isArray(n) ? n : [n]).filter((e) => !!e);
}
function nl(n) {
  return (e) => Math.abs(e) > 0 && n.browser && n.browser.need3dFix && Math.abs(e) % 90 === 0 ? e + 1e-3 : e;
}
function As(n, e) {
  e === void 0 && (e = ""), typeof trustedTypes < "u" ? n.innerHTML = trustedTypes.createPolicy("html", {
    createHTML: (t) => t
  }).createHTML(e) : n.innerHTML = e;
}
let Xl;
function hb() {
  const n = qe(), e = _t();
  return {
    smoothScroll: e.documentElement && e.documentElement.style && "scrollBehavior" in e.documentElement.style,
    touch: !!("ontouchstart" in n || n.DocumentTouch && e instanceof n.DocumentTouch)
  };
}
function bm() {
  return Xl || (Xl = hb()), Xl;
}
let jl;
function pb(n) {
  let {
    userAgent: e
  } = n === void 0 ? {} : n;
  const t = bm(), i = qe(), s = i.navigator.platform, r = e || i.navigator.userAgent, a = {
    ios: !1,
    android: !1
  }, o = i.screen.width, l = i.screen.height, c = r.match(/(Android);?[\s\/]+([\d.]+)?/);
  let u = r.match(/(iPad).*OS\s([\d_]+)/);
  const d = r.match(/(iPod)(.*OS\s([\d_]+))?/), f = !u && r.match(/(iPhone\sOS|iOS)\s([\d_]+)/), p = s === "Win32";
  let h = s === "MacIntel";
  const g = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
  return !u && h && t.touch && g.indexOf(`${o}x${l}`) >= 0 && (u = r.match(/(Version)\/([\d.]+)/), u || (u = [0, 1, "13_0_0"]), h = !1), c && !p && (a.os = "android", a.android = !0), (u || f || d) && (a.os = "ios", a.ios = !0), a;
}
function _m(n) {
  return n === void 0 && (n = {}), jl || (jl = pb(n)), jl;
}
let Ql;
function gb() {
  const n = qe(), e = _m();
  let t = !1;
  function i() {
    const o = n.navigator.userAgent.toLowerCase();
    return o.indexOf("safari") >= 0 && o.indexOf("chrome") < 0 && o.indexOf("android") < 0;
  }
  if (i()) {
    const o = String(n.navigator.userAgent);
    if (o.includes("Version/")) {
      const [l, c] = o.split("Version/")[1].split(" ")[0].split(".").map((u) => Number(u));
      t = l < 16 || l === 16 && c < 2;
    }
  }
  const s = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(n.navigator.userAgent), r = i(), a = r || s && e.ios;
  return {
    isSafari: t || r,
    needPerspectiveFix: t,
    need3dFix: a,
    isWebView: s
  };
}
function Am() {
  return Ql || (Ql = gb()), Ql;
}
function mb(n) {
  let {
    swiper: e,
    on: t,
    emit: i
  } = n;
  const s = qe();
  let r = null, a = null;
  const o = () => {
    !e || e.destroyed || !e.initialized || (i("beforeResize"), i("resize"));
  }, l = () => {
    !e || e.destroyed || !e.initialized || (r = new ResizeObserver((d) => {
      a = s.requestAnimationFrame(() => {
        const {
          width: f,
          height: p
        } = e;
        let h = f, g = p;
        d.forEach((m) => {
          let {
            contentBoxSize: v,
            contentRect: y,
            target: E
          } = m;
          E && E !== e.el || (h = y ? y.width : (v[0] || v).inlineSize, g = y ? y.height : (v[0] || v).blockSize);
        }), (h !== f || g !== p) && o();
      });
    }), r.observe(e.el));
  }, c = () => {
    a && s.cancelAnimationFrame(a), r && r.unobserve && e.el && (r.unobserve(e.el), r = null);
  }, u = () => {
    !e || e.destroyed || !e.initialized || i("orientationchange");
  };
  t("init", () => {
    if (e.params.resizeObserver && typeof s.ResizeObserver < "u") {
      l();
      return;
    }
    s.addEventListener("resize", o), s.addEventListener("orientationchange", u);
  }), t("destroy", () => {
    c(), s.removeEventListener("resize", o), s.removeEventListener("orientationchange", u);
  });
}
function vb(n) {
  let {
    swiper: e,
    extendParams: t,
    on: i,
    emit: s
  } = n;
  const r = [], a = qe(), o = function(u, d) {
    d === void 0 && (d = {});
    const f = a.MutationObserver || a.WebkitMutationObserver, p = new f((h) => {
      if (e.__preventObserver__) return;
      if (h.length === 1) {
        s("observerUpdate", h[0]);
        return;
      }
      const g = function() {
        s("observerUpdate", h[0]);
      };
      a.requestAnimationFrame ? a.requestAnimationFrame(g) : a.setTimeout(g, 0);
    });
    p.observe(u, {
      attributes: typeof d.attributes > "u" ? !0 : d.attributes,
      childList: e.isElement || (typeof d.childList > "u" ? !0 : d).childList,
      characterData: typeof d.characterData > "u" ? !0 : d.characterData
    }), r.push(p);
  }, l = () => {
    if (e.params.observer) {
      if (e.params.observeParents) {
        const u = _r(e.hostEl);
        for (let d = 0; d < u.length; d += 1)
          o(u[d]);
      }
      o(e.hostEl, {
        childList: e.params.observeSlideChildren
      }), o(e.wrapperEl, {
        attributes: !1
      });
    }
  }, c = () => {
    r.forEach((u) => {
      u.disconnect();
    }), r.splice(0, r.length);
  };
  t({
    observer: !1,
    observeParents: !1,
    observeSlideChildren: !1
  }), i("init", l), i("destroy", c);
}
var yb = {
  on(n, e, t) {
    const i = this;
    if (!i.eventsListeners || i.destroyed || typeof e != "function") return i;
    const s = t ? "unshift" : "push";
    return n.split(" ").forEach((r) => {
      i.eventsListeners[r] || (i.eventsListeners[r] = []), i.eventsListeners[r][s](e);
    }), i;
  },
  once(n, e, t) {
    const i = this;
    if (!i.eventsListeners || i.destroyed || typeof e != "function") return i;
    function s() {
      i.off(n, s), s.__emitterProxy && delete s.__emitterProxy;
      for (var r = arguments.length, a = new Array(r), o = 0; o < r; o++)
        a[o] = arguments[o];
      e.apply(i, a);
    }
    return s.__emitterProxy = e, i.on(n, s, t);
  },
  onAny(n, e) {
    const t = this;
    if (!t.eventsListeners || t.destroyed || typeof n != "function") return t;
    const i = e ? "unshift" : "push";
    return t.eventsAnyListeners.indexOf(n) < 0 && t.eventsAnyListeners[i](n), t;
  },
  offAny(n) {
    const e = this;
    if (!e.eventsListeners || e.destroyed || !e.eventsAnyListeners) return e;
    const t = e.eventsAnyListeners.indexOf(n);
    return t >= 0 && e.eventsAnyListeners.splice(t, 1), e;
  },
  off(n, e) {
    const t = this;
    return !t.eventsListeners || t.destroyed || !t.eventsListeners || n.split(" ").forEach((i) => {
      typeof e > "u" ? t.eventsListeners[i] = [] : t.eventsListeners[i] && t.eventsListeners[i].forEach((s, r) => {
        (s === e || s.__emitterProxy && s.__emitterProxy === e) && t.eventsListeners[i].splice(r, 1);
      });
    }), t;
  },
  emit() {
    const n = this;
    if (!n.eventsListeners || n.destroyed || !n.eventsListeners) return n;
    let e, t, i;
    for (var s = arguments.length, r = new Array(s), a = 0; a < s; a++)
      r[a] = arguments[a];
    return typeof r[0] == "string" || Array.isArray(r[0]) ? (e = r[0], t = r.slice(1, r.length), i = n) : (e = r[0].events, t = r[0].data, i = r[0].context || n), t.unshift(i), (Array.isArray(e) ? e : e.split(" ")).forEach((l) => {
      n.eventsAnyListeners && n.eventsAnyListeners.length && n.eventsAnyListeners.forEach((c) => {
        c.apply(i, [l, ...t]);
      }), n.eventsListeners && n.eventsListeners[l] && n.eventsListeners[l].forEach((c) => {
        c.apply(i, t);
      });
    }), n;
  }
};
function Eb() {
  const n = this;
  let e, t;
  const i = n.el;
  typeof n.params.width < "u" && n.params.width !== null ? e = n.params.width : e = i.clientWidth, typeof n.params.height < "u" && n.params.height !== null ? t = n.params.height : t = i.clientHeight, !(e === 0 && n.isHorizontal() || t === 0 && n.isVertical()) && (e = e - parseInt(Vs(i, "padding-left") || 0, 10) - parseInt(Vs(i, "padding-right") || 0, 10), t = t - parseInt(Vs(i, "padding-top") || 0, 10) - parseInt(Vs(i, "padding-bottom") || 0, 10), Number.isNaN(e) && (e = 0), Number.isNaN(t) && (t = 0), Object.assign(n, {
    width: e,
    height: t,
    size: n.isHorizontal() ? e : t
  }));
}
function Tb() {
  const n = this;
  function e(_, R) {
    return parseFloat(_.getPropertyValue(n.getDirectionLabel(R)) || 0);
  }
  const t = n.params, {
    wrapperEl: i,
    slidesEl: s,
    size: r,
    rtlTranslate: a,
    wrongRTL: o
  } = n, l = n.virtual && t.virtual.enabled, c = l ? n.virtual.slides.length : n.slides.length, u = Dt(s, `.${n.params.slideClass}, swiper-slide`), d = l ? n.virtual.slides.length : u.length;
  let f = [];
  const p = [], h = [];
  let g = t.slidesOffsetBefore;
  typeof g == "function" && (g = t.slidesOffsetBefore.call(n));
  let m = t.slidesOffsetAfter;
  typeof m == "function" && (m = t.slidesOffsetAfter.call(n));
  const v = n.snapGrid.length, y = n.slidesGrid.length;
  let E = t.spaceBetween, T = -g, S = 0, w = 0;
  if (typeof r > "u")
    return;
  typeof E == "string" && E.indexOf("%") >= 0 ? E = parseFloat(E.replace("%", "")) / 100 * r : typeof E == "string" && (E = parseFloat(E)), n.virtualSize = -E, u.forEach((_) => {
    a ? _.style.marginLeft = "" : _.style.marginRight = "", _.style.marginBottom = "", _.style.marginTop = "";
  }), t.centeredSlides && t.cssMode && (Bn(i, "--swiper-centered-offset-before", ""), Bn(i, "--swiper-centered-offset-after", ""));
  const b = t.grid && t.grid.rows > 1 && n.grid;
  b ? n.grid.initSlides(u) : n.grid && n.grid.unsetSlides();
  let L;
  const A = t.slidesPerView === "auto" && t.breakpoints && Object.keys(t.breakpoints).filter((_) => typeof t.breakpoints[_].slidesPerView < "u").length > 0;
  for (let _ = 0; _ < d; _ += 1) {
    L = 0;
    let R;
    if (u[_] && (R = u[_]), b && n.grid.updateSlide(_, R, u), !(u[_] && Vs(R, "display") === "none")) {
      if (t.slidesPerView === "auto") {
        A && (u[_].style[n.getDirectionLabel("width")] = "");
        const I = getComputedStyle(R), k = R.style.transform, M = R.style.webkitTransform;
        if (k && (R.style.transform = "none"), M && (R.style.webkitTransform = "none"), t.roundLengths)
          L = n.isHorizontal() ? Qc(R, "width") : Qc(R, "height");
        else {
          const O = e(I, "width"), F = e(I, "padding-left"), C = e(I, "padding-right"), D = e(I, "margin-left"), B = e(I, "margin-right"), P = I.getPropertyValue("box-sizing");
          if (P && P === "border-box")
            L = O + D + B;
          else {
            const {
              clientWidth: K,
              offsetWidth: X
            } = R;
            L = O + F + C + D + B + (X - K);
          }
        }
        k && (R.style.transform = k), M && (R.style.webkitTransform = M), t.roundLengths && (L = Math.floor(L));
      } else
        L = (r - (t.slidesPerView - 1) * E) / t.slidesPerView, t.roundLengths && (L = Math.floor(L)), u[_] && (u[_].style[n.getDirectionLabel("width")] = `${L}px`);
      u[_] && (u[_].swiperSlideSize = L), h.push(L), t.centeredSlides ? (T = T + L / 2 + S / 2 + E, S === 0 && _ !== 0 && (T = T - r / 2 - E), _ === 0 && (T = T - r / 2 - E), Math.abs(T) < 1 / 1e3 && (T = 0), t.roundLengths && (T = Math.floor(T)), w % t.slidesPerGroup === 0 && f.push(T), p.push(T)) : (t.roundLengths && (T = Math.floor(T)), (w - Math.min(n.params.slidesPerGroupSkip, w)) % n.params.slidesPerGroup === 0 && f.push(T), p.push(T), T = T + L + E), n.virtualSize += L + E, S = L, w += 1;
    }
  }
  if (n.virtualSize = Math.max(n.virtualSize, r) + m, a && o && (t.effect === "slide" || t.effect === "coverflow") && (i.style.width = `${n.virtualSize + E}px`), t.setWrapperSize && (i.style[n.getDirectionLabel("width")] = `${n.virtualSize + E}px`), b && n.grid.updateWrapperSize(L, f), !t.centeredSlides) {
    const _ = [];
    for (let R = 0; R < f.length; R += 1) {
      let I = f[R];
      t.roundLengths && (I = Math.floor(I)), f[R] <= n.virtualSize - r && _.push(I);
    }
    f = _, Math.floor(n.virtualSize - r) - Math.floor(f[f.length - 1]) > 1 && f.push(n.virtualSize - r);
  }
  if (l && t.loop) {
    const _ = h[0] + E;
    if (t.slidesPerGroup > 1) {
      const R = Math.ceil((n.virtual.slidesBefore + n.virtual.slidesAfter) / t.slidesPerGroup), I = _ * t.slidesPerGroup;
      for (let k = 0; k < R; k += 1)
        f.push(f[f.length - 1] + I);
    }
    for (let R = 0; R < n.virtual.slidesBefore + n.virtual.slidesAfter; R += 1)
      t.slidesPerGroup === 1 && f.push(f[f.length - 1] + _), p.push(p[p.length - 1] + _), n.virtualSize += _;
  }
  if (f.length === 0 && (f = [0]), E !== 0) {
    const _ = n.isHorizontal() && a ? "marginLeft" : n.getDirectionLabel("marginRight");
    u.filter((R, I) => !t.cssMode || t.loop ? !0 : I !== u.length - 1).forEach((R) => {
      R.style[_] = `${E}px`;
    });
  }
  if (t.centeredSlides && t.centeredSlidesBounds) {
    let _ = 0;
    h.forEach((I) => {
      _ += I + (E || 0);
    }), _ -= E;
    const R = _ > r ? _ - r : 0;
    f = f.map((I) => I <= 0 ? -g : I > R ? R + m : I);
  }
  if (t.centerInsufficientSlides) {
    let _ = 0;
    h.forEach((I) => {
      _ += I + (E || 0);
    }), _ -= E;
    const R = (t.slidesOffsetBefore || 0) + (t.slidesOffsetAfter || 0);
    if (_ + R < r) {
      const I = (r - _ - R) / 2;
      f.forEach((k, M) => {
        f[M] = k - I;
      }), p.forEach((k, M) => {
        p[M] = k + I;
      });
    }
  }
  if (Object.assign(n, {
    slides: u,
    snapGrid: f,
    slidesGrid: p,
    slidesSizesGrid: h
  }), t.centeredSlides && t.cssMode && !t.centeredSlidesBounds) {
    Bn(i, "--swiper-centered-offset-before", `${-f[0]}px`), Bn(i, "--swiper-centered-offset-after", `${n.size / 2 - h[h.length - 1] / 2}px`);
    const _ = -n.snapGrid[0], R = -n.slidesGrid[0];
    n.snapGrid = n.snapGrid.map((I) => I + _), n.slidesGrid = n.slidesGrid.map((I) => I + R);
  }
  if (d !== c && n.emit("slidesLengthChange"), f.length !== v && (n.params.watchOverflow && n.checkOverflow(), n.emit("snapGridLengthChange")), p.length !== y && n.emit("slidesGridLengthChange"), t.watchSlidesProgress && n.updateSlidesOffset(), n.emit("slidesUpdated"), !l && !t.cssMode && (t.effect === "slide" || t.effect === "fade")) {
    const _ = `${t.containerModifierClass}backface-hidden`, R = n.el.classList.contains(_);
    d <= t.maxBackfaceHiddenSlides ? R || n.el.classList.add(_) : R && n.el.classList.remove(_);
  }
}
function Sb(n) {
  const e = this, t = [], i = e.virtual && e.params.virtual.enabled;
  let s = 0, r;
  typeof n == "number" ? e.setTransition(n) : n === !0 && e.setTransition(e.params.speed);
  const a = (o) => i ? e.slides[e.getSlideIndexByData(o)] : e.slides[o];
  if (e.params.slidesPerView !== "auto" && e.params.slidesPerView > 1)
    if (e.params.centeredSlides)
      (e.visibleSlides || []).forEach((o) => {
        t.push(o);
      });
    else
      for (r = 0; r < Math.ceil(e.params.slidesPerView); r += 1) {
        const o = e.activeIndex + r;
        if (o > e.slides.length && !i) break;
        t.push(a(o));
      }
  else
    t.push(a(e.activeIndex));
  for (r = 0; r < t.length; r += 1)
    if (typeof t[r] < "u") {
      const o = t[r].offsetHeight;
      s = o > s ? o : s;
    }
  (s || s === 0) && (e.wrapperEl.style.height = `${s}px`);
}
function xb() {
  const n = this, e = n.slides, t = n.isElement ? n.isHorizontal() ? n.wrapperEl.offsetLeft : n.wrapperEl.offsetTop : 0;
  for (let i = 0; i < e.length; i += 1)
    e[i].swiperSlideOffset = (n.isHorizontal() ? e[i].offsetLeft : e[i].offsetTop) - t - n.cssOverflowAdjustment();
}
const lh = (n, e, t) => {
  e && !n.classList.contains(t) ? n.classList.add(t) : !e && n.classList.contains(t) && n.classList.remove(t);
};
function bb(n) {
  n === void 0 && (n = this && this.translate || 0);
  const e = this, t = e.params, {
    slides: i,
    rtlTranslate: s,
    snapGrid: r
  } = e;
  if (i.length === 0) return;
  typeof i[0].swiperSlideOffset > "u" && e.updateSlidesOffset();
  let a = -n;
  s && (a = n), e.visibleSlidesIndexes = [], e.visibleSlides = [];
  let o = t.spaceBetween;
  typeof o == "string" && o.indexOf("%") >= 0 ? o = parseFloat(o.replace("%", "")) / 100 * e.size : typeof o == "string" && (o = parseFloat(o));
  for (let l = 0; l < i.length; l += 1) {
    const c = i[l];
    let u = c.swiperSlideOffset;
    t.cssMode && t.centeredSlides && (u -= i[0].swiperSlideOffset);
    const d = (a + (t.centeredSlides ? e.minTranslate() : 0) - u) / (c.swiperSlideSize + o), f = (a - r[0] + (t.centeredSlides ? e.minTranslate() : 0) - u) / (c.swiperSlideSize + o), p = -(a - u), h = p + e.slidesSizesGrid[l], g = p >= 0 && p <= e.size - e.slidesSizesGrid[l], m = p >= 0 && p < e.size - 1 || h > 1 && h <= e.size || p <= 0 && h >= e.size;
    m && (e.visibleSlides.push(c), e.visibleSlidesIndexes.push(l)), lh(c, m, t.slideVisibleClass), lh(c, g, t.slideFullyVisibleClass), c.progress = s ? -d : d, c.originalProgress = s ? -f : f;
  }
}
function _b(n) {
  const e = this;
  if (typeof n > "u") {
    const u = e.rtlTranslate ? -1 : 1;
    n = e && e.translate && e.translate * u || 0;
  }
  const t = e.params, i = e.maxTranslate() - e.minTranslate();
  let {
    progress: s,
    isBeginning: r,
    isEnd: a,
    progressLoop: o
  } = e;
  const l = r, c = a;
  if (i === 0)
    s = 0, r = !0, a = !0;
  else {
    s = (n - e.minTranslate()) / i;
    const u = Math.abs(n - e.minTranslate()) < 1, d = Math.abs(n - e.maxTranslate()) < 1;
    r = u || s <= 0, a = d || s >= 1, u && (s = 0), d && (s = 1);
  }
  if (t.loop) {
    const u = e.getSlideIndexByData(0), d = e.getSlideIndexByData(e.slides.length - 1), f = e.slidesGrid[u], p = e.slidesGrid[d], h = e.slidesGrid[e.slidesGrid.length - 1], g = Math.abs(n);
    g >= f ? o = (g - f) / h : o = (g + h - p) / h, o > 1 && (o -= 1);
  }
  Object.assign(e, {
    progress: s,
    progressLoop: o,
    isBeginning: r,
    isEnd: a
  }), (t.watchSlidesProgress || t.centeredSlides && t.autoHeight) && e.updateSlidesProgress(n), r && !l && e.emit("reachBeginning toEdge"), a && !c && e.emit("reachEnd toEdge"), (l && !r || c && !a) && e.emit("fromEdge"), e.emit("progress", s);
}
const Zl = (n, e, t) => {
  e && !n.classList.contains(t) ? n.classList.add(t) : !e && n.classList.contains(t) && n.classList.remove(t);
};
function Ab() {
  const n = this, {
    slides: e,
    params: t,
    slidesEl: i,
    activeIndex: s
  } = n, r = n.virtual && t.virtual.enabled, a = n.grid && t.grid && t.grid.rows > 1, o = (d) => Dt(i, `.${t.slideClass}${d}, swiper-slide${d}`)[0];
  let l, c, u;
  if (r)
    if (t.loop) {
      let d = s - n.virtual.slidesBefore;
      d < 0 && (d = n.virtual.slides.length + d), d >= n.virtual.slides.length && (d -= n.virtual.slides.length), l = o(`[data-swiper-slide-index="${d}"]`);
    } else
      l = o(`[data-swiper-slide-index="${s}"]`);
  else
    a ? (l = e.find((d) => d.column === s), u = e.find((d) => d.column === s + 1), c = e.find((d) => d.column === s - 1)) : l = e[s];
  l && (a || (u = fb(l, `.${t.slideClass}, swiper-slide`)[0], t.loop && !u && (u = e[0]), c = db(l, `.${t.slideClass}, swiper-slide`)[0], t.loop && !c === 0 && (c = e[e.length - 1]))), e.forEach((d) => {
    Zl(d, d === l, t.slideActiveClass), Zl(d, d === u, t.slideNextClass), Zl(d, d === c, t.slidePrevClass);
  }), n.emitSlidesClasses();
}
const So = (n, e) => {
  if (!n || n.destroyed || !n.params) return;
  const t = () => n.isElement ? "swiper-slide" : `.${n.params.slideClass}`, i = e.closest(t());
  if (i) {
    let s = i.querySelector(`.${n.params.lazyPreloaderClass}`);
    !s && n.isElement && (i.shadowRoot ? s = i.shadowRoot.querySelector(`.${n.params.lazyPreloaderClass}`) : requestAnimationFrame(() => {
      i.shadowRoot && (s = i.shadowRoot.querySelector(`.${n.params.lazyPreloaderClass}`), s && s.remove());
    })), s && s.remove();
  }
}, Jl = (n, e) => {
  if (!n.slides[e]) return;
  const t = n.slides[e].querySelector('[loading="lazy"]');
  t && t.removeAttribute("loading");
}, Zc = (n) => {
  if (!n || n.destroyed || !n.params) return;
  let e = n.params.lazyPreloadPrevNext;
  const t = n.slides.length;
  if (!t || !e || e < 0) return;
  e = Math.min(e, t);
  const i = n.params.slidesPerView === "auto" ? n.slidesPerViewDynamic() : Math.ceil(n.params.slidesPerView), s = n.activeIndex;
  if (n.params.grid && n.params.grid.rows > 1) {
    const a = s, o = [a - e];
    o.push(...Array.from({
      length: e
    }).map((l, c) => a + i + c)), n.slides.forEach((l, c) => {
      o.includes(l.column) && Jl(n, c);
    });
    return;
  }
  const r = s + i - 1;
  if (n.params.rewind || n.params.loop)
    for (let a = s - e; a <= r + e; a += 1) {
      const o = (a % t + t) % t;
      (o < s || o > r) && Jl(n, o);
    }
  else
    for (let a = Math.max(s - e, 0); a <= Math.min(r + e, t - 1); a += 1)
      a !== s && (a > r || a < s) && Jl(n, a);
};
function wb(n) {
  const {
    slidesGrid: e,
    params: t
  } = n, i = n.rtlTranslate ? n.translate : -n.translate;
  let s;
  for (let r = 0; r < e.length; r += 1)
    typeof e[r + 1] < "u" ? i >= e[r] && i < e[r + 1] - (e[r + 1] - e[r]) / 2 ? s = r : i >= e[r] && i < e[r + 1] && (s = r + 1) : i >= e[r] && (s = r);
  return t.normalizeSlideIndex && (s < 0 || typeof s > "u") && (s = 0), s;
}
function Lb(n) {
  const e = this, t = e.rtlTranslate ? e.translate : -e.translate, {
    snapGrid: i,
    params: s,
    activeIndex: r,
    realIndex: a,
    snapIndex: o
  } = e;
  let l = n, c;
  const u = (p) => {
    let h = p - e.virtual.slidesBefore;
    return h < 0 && (h = e.virtual.slides.length + h), h >= e.virtual.slides.length && (h -= e.virtual.slides.length), h;
  };
  if (typeof l > "u" && (l = wb(e)), i.indexOf(t) >= 0)
    c = i.indexOf(t);
  else {
    const p = Math.min(s.slidesPerGroupSkip, l);
    c = p + Math.floor((l - p) / s.slidesPerGroup);
  }
  if (c >= i.length && (c = i.length - 1), l === r && !e.params.loop) {
    c !== o && (e.snapIndex = c, e.emit("snapIndexChange"));
    return;
  }
  if (l === r && e.params.loop && e.virtual && e.params.virtual.enabled) {
    e.realIndex = u(l);
    return;
  }
  const d = e.grid && s.grid && s.grid.rows > 1;
  let f;
  if (e.virtual && s.virtual.enabled && s.loop)
    f = u(l);
  else if (d) {
    const p = e.slides.find((g) => g.column === l);
    let h = parseInt(p.getAttribute("data-swiper-slide-index"), 10);
    Number.isNaN(h) && (h = Math.max(e.slides.indexOf(p), 0)), f = Math.floor(h / s.grid.rows);
  } else if (e.slides[l]) {
    const p = e.slides[l].getAttribute("data-swiper-slide-index");
    p ? f = parseInt(p, 10) : f = l;
  } else
    f = l;
  Object.assign(e, {
    previousSnapIndex: o,
    snapIndex: c,
    previousRealIndex: a,
    realIndex: f,
    previousIndex: r,
    activeIndex: l
  }), e.initialized && Zc(e), e.emit("activeIndexChange"), e.emit("snapIndexChange"), (e.initialized || e.params.runCallbacksOnInit) && (a !== f && e.emit("realIndexChange"), e.emit("slideChange"));
}
function Ib(n, e) {
  const t = this, i = t.params;
  let s = n.closest(`.${i.slideClass}, swiper-slide`);
  !s && t.isElement && e && e.length > 1 && e.includes(n) && [...e.slice(e.indexOf(n) + 1, e.length)].forEach((o) => {
    !s && o.matches && o.matches(`.${i.slideClass}, swiper-slide`) && (s = o);
  });
  let r = !1, a;
  if (s) {
    for (let o = 0; o < t.slides.length; o += 1)
      if (t.slides[o] === s) {
        r = !0, a = o;
        break;
      }
  }
  if (s && r)
    t.clickedSlide = s, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(s.getAttribute("data-swiper-slide-index"), 10) : t.clickedIndex = a;
  else {
    t.clickedSlide = void 0, t.clickedIndex = void 0;
    return;
  }
  i.slideToClickedSlide && t.clickedIndex !== void 0 && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide();
}
var Rb = {
  updateSize: Eb,
  updateSlides: Tb,
  updateAutoHeight: Sb,
  updateSlidesOffset: xb,
  updateSlidesProgress: bb,
  updateProgress: _b,
  updateSlidesClasses: Ab,
  updateActiveIndex: Lb,
  updateClickedSlide: Ib
};
function Cb(n) {
  n === void 0 && (n = this.isHorizontal() ? "x" : "y");
  const e = this, {
    params: t,
    rtlTranslate: i,
    translate: s,
    wrapperEl: r
  } = e;
  if (t.virtualTranslate)
    return i ? -s : s;
  if (t.cssMode)
    return s;
  let a = jc(r, n);
  return a += e.cssOverflowAdjustment(), i && (a = -a), a || 0;
}
function Pb(n, e) {
  const t = this, {
    rtlTranslate: i,
    params: s,
    wrapperEl: r,
    progress: a
  } = t;
  let o = 0, l = 0;
  const c = 0;
  t.isHorizontal() ? o = i ? -n : n : l = n, s.roundLengths && (o = Math.floor(o), l = Math.floor(l)), t.previousTranslate = t.translate, t.translate = t.isHorizontal() ? o : l, s.cssMode ? r[t.isHorizontal() ? "scrollLeft" : "scrollTop"] = t.isHorizontal() ? -o : -l : s.virtualTranslate || (t.isHorizontal() ? o -= t.cssOverflowAdjustment() : l -= t.cssOverflowAdjustment(), r.style.transform = `translate3d(${o}px, ${l}px, ${c}px)`);
  let u;
  const d = t.maxTranslate() - t.minTranslate();
  d === 0 ? u = 0 : u = (n - t.minTranslate()) / d, u !== a && t.updateProgress(n), t.emit("setTranslate", t.translate, e);
}
function Db() {
  return -this.snapGrid[0];
}
function kb() {
  return -this.snapGrid[this.snapGrid.length - 1];
}
function Mb(n, e, t, i, s) {
  n === void 0 && (n = 0), e === void 0 && (e = this.params.speed), t === void 0 && (t = !0), i === void 0 && (i = !0);
  const r = this, {
    params: a,
    wrapperEl: o
  } = r;
  if (r.animating && a.preventInteractionOnTransition)
    return !1;
  const l = r.minTranslate(), c = r.maxTranslate();
  let u;
  if (i && n > l ? u = l : i && n < c ? u = c : u = n, r.updateProgress(u), a.cssMode) {
    const d = r.isHorizontal();
    if (e === 0)
      o[d ? "scrollLeft" : "scrollTop"] = -u;
    else {
      if (!r.support.smoothScroll)
        return xm({
          swiper: r,
          targetPosition: -u,
          side: d ? "left" : "top"
        }), !0;
      o.scrollTo({
        [d ? "left" : "top"]: -u,
        behavior: "smooth"
      });
    }
    return !0;
  }
  return e === 0 ? (r.setTransition(0), r.setTranslate(u), t && (r.emit("beforeTransitionStart", e, s), r.emit("transitionEnd"))) : (r.setTransition(e), r.setTranslate(u), t && (r.emit("beforeTransitionStart", e, s), r.emit("transitionStart")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function(f) {
    !r || r.destroyed || f.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, r.animating = !1, t && r.emit("transitionEnd"));
  }), r.wrapperEl.addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd))), !0;
}
var Ob = {
  getTranslate: Cb,
  setTranslate: Pb,
  minTranslate: Db,
  maxTranslate: kb,
  translateTo: Mb
};
function Fb(n, e) {
  const t = this;
  t.params.cssMode || (t.wrapperEl.style.transitionDuration = `${n}ms`, t.wrapperEl.style.transitionDelay = n === 0 ? "0ms" : ""), t.emit("setTransition", n, e);
}
function wm(n) {
  let {
    swiper: e,
    runCallbacks: t,
    direction: i,
    step: s
  } = n;
  const {
    activeIndex: r,
    previousIndex: a
  } = e;
  let o = i;
  o || (r > a ? o = "next" : r < a ? o = "prev" : o = "reset"), e.emit(`transition${s}`), t && o === "reset" ? e.emit(`slideResetTransition${s}`) : t && r !== a && (e.emit(`slideChangeTransition${s}`), o === "next" ? e.emit(`slideNextTransition${s}`) : e.emit(`slidePrevTransition${s}`));
}
function Nb(n, e) {
  n === void 0 && (n = !0);
  const t = this, {
    params: i
  } = t;
  i.cssMode || (i.autoHeight && t.updateAutoHeight(), wm({
    swiper: t,
    runCallbacks: n,
    direction: e,
    step: "Start"
  }));
}
function $b(n, e) {
  n === void 0 && (n = !0);
  const t = this, {
    params: i
  } = t;
  t.animating = !1, !i.cssMode && (t.setTransition(0), wm({
    swiper: t,
    runCallbacks: n,
    direction: e,
    step: "End"
  }));
}
var Bb = {
  setTransition: Fb,
  transitionStart: Nb,
  transitionEnd: $b
};
function Ub(n, e, t, i, s) {
  n === void 0 && (n = 0), t === void 0 && (t = !0), typeof n == "string" && (n = parseInt(n, 10));
  const r = this;
  let a = n;
  a < 0 && (a = 0);
  const {
    params: o,
    snapGrid: l,
    slidesGrid: c,
    previousIndex: u,
    activeIndex: d,
    rtlTranslate: f,
    wrapperEl: p,
    enabled: h
  } = r;
  if (!h && !i && !s || r.destroyed || r.animating && o.preventInteractionOnTransition)
    return !1;
  typeof e > "u" && (e = r.params.speed);
  const g = Math.min(r.params.slidesPerGroupSkip, a);
  let m = g + Math.floor((a - g) / r.params.slidesPerGroup);
  m >= l.length && (m = l.length - 1);
  const v = -l[m];
  if (o.normalizeSlideIndex)
    for (let b = 0; b < c.length; b += 1) {
      const L = -Math.floor(v * 100), A = Math.floor(c[b] * 100), _ = Math.floor(c[b + 1] * 100);
      typeof c[b + 1] < "u" ? L >= A && L < _ - (_ - A) / 2 ? a = b : L >= A && L < _ && (a = b + 1) : L >= A && (a = b);
    }
  if (r.initialized && a !== d && (!r.allowSlideNext && (f ? v > r.translate && v > r.minTranslate() : v < r.translate && v < r.minTranslate()) || !r.allowSlidePrev && v > r.translate && v > r.maxTranslate() && (d || 0) !== a))
    return !1;
  a !== (u || 0) && t && r.emit("beforeSlideChangeStart"), r.updateProgress(v);
  let y;
  a > d ? y = "next" : a < d ? y = "prev" : y = "reset";
  const E = r.virtual && r.params.virtual.enabled;
  if (!(E && s) && (f && -v === r.translate || !f && v === r.translate))
    return r.updateActiveIndex(a), o.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), o.effect !== "slide" && r.setTranslate(v), y !== "reset" && (r.transitionStart(t, y), r.transitionEnd(t, y)), !1;
  if (o.cssMode) {
    const b = r.isHorizontal(), L = f ? v : -v;
    if (e === 0)
      E && (r.wrapperEl.style.scrollSnapType = "none", r._immediateVirtual = !0), E && !r._cssModeVirtualInitialSet && r.params.initialSlide > 0 ? (r._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => {
        p[b ? "scrollLeft" : "scrollTop"] = L;
      })) : p[b ? "scrollLeft" : "scrollTop"] = L, E && requestAnimationFrame(() => {
        r.wrapperEl.style.scrollSnapType = "", r._immediateVirtual = !1;
      });
    else {
      if (!r.support.smoothScroll)
        return xm({
          swiper: r,
          targetPosition: L,
          side: b ? "left" : "top"
        }), !0;
      p.scrollTo({
        [b ? "left" : "top"]: L,
        behavior: "smooth"
      });
    }
    return !0;
  }
  const w = Am().isSafari;
  return E && !s && w && r.isElement && r.virtual.update(!1, !1, a), r.setTransition(e), r.setTranslate(v), r.updateActiveIndex(a), r.updateSlidesClasses(), r.emit("beforeTransitionStart", e, i), r.transitionStart(t, y), e === 0 ? r.transitionEnd(t, y) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function(L) {
    !r || r.destroyed || L.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(t, y));
  }), r.wrapperEl.addEventListener("transitionend", r.onSlideToWrapperTransitionEnd)), !0;
}
function Gb(n, e, t, i) {
  n === void 0 && (n = 0), t === void 0 && (t = !0), typeof n == "string" && (n = parseInt(n, 10));
  const s = this;
  if (s.destroyed) return;
  typeof e > "u" && (e = s.params.speed);
  const r = s.grid && s.params.grid && s.params.grid.rows > 1;
  let a = n;
  if (s.params.loop)
    if (s.virtual && s.params.virtual.enabled)
      a = a + s.virtual.slidesBefore;
    else {
      let o;
      if (r) {
        const f = a * s.params.grid.rows;
        o = s.slides.find((p) => p.getAttribute("data-swiper-slide-index") * 1 === f).column;
      } else
        o = s.getSlideIndexByData(a);
      const l = r ? Math.ceil(s.slides.length / s.params.grid.rows) : s.slides.length, {
        centeredSlides: c
      } = s.params;
      let u = s.params.slidesPerView;
      u === "auto" ? u = s.slidesPerViewDynamic() : (u = Math.ceil(parseFloat(s.params.slidesPerView, 10)), c && u % 2 === 0 && (u = u + 1));
      let d = l - o < u;
      if (c && (d = d || o < Math.ceil(u / 2)), i && c && s.params.slidesPerView !== "auto" && !r && (d = !1), d) {
        const f = c ? o < s.activeIndex ? "prev" : "next" : o - s.activeIndex - 1 < s.params.slidesPerView ? "next" : "prev";
        s.loopFix({
          direction: f,
          slideTo: !0,
          activeSlideIndex: f === "next" ? o + 1 : o - l + 1,
          slideRealIndex: f === "next" ? s.realIndex : void 0
        });
      }
      if (r) {
        const f = a * s.params.grid.rows;
        a = s.slides.find((p) => p.getAttribute("data-swiper-slide-index") * 1 === f).column;
      } else
        a = s.getSlideIndexByData(a);
    }
  return requestAnimationFrame(() => {
    s.slideTo(a, e, t, i);
  }), s;
}
function Hb(n, e, t) {
  e === void 0 && (e = !0);
  const i = this, {
    enabled: s,
    params: r,
    animating: a
  } = i;
  if (!s || i.destroyed) return i;
  typeof n > "u" && (n = i.params.speed);
  let o = r.slidesPerGroup;
  r.slidesPerView === "auto" && r.slidesPerGroup === 1 && r.slidesPerGroupAuto && (o = Math.max(i.slidesPerViewDynamic("current", !0), 1));
  const l = i.activeIndex < r.slidesPerGroupSkip ? 1 : o, c = i.virtual && r.virtual.enabled;
  if (r.loop) {
    if (a && !c && r.loopPreventsSliding) return !1;
    if (i.loopFix({
      direction: "next"
    }), i._clientLeft = i.wrapperEl.clientLeft, i.activeIndex === i.slides.length - 1 && r.cssMode)
      return requestAnimationFrame(() => {
        i.slideTo(i.activeIndex + l, n, e, t);
      }), !0;
  }
  return r.rewind && i.isEnd ? i.slideTo(0, n, e, t) : i.slideTo(i.activeIndex + l, n, e, t);
}
function Vb(n, e, t) {
  e === void 0 && (e = !0);
  const i = this, {
    params: s,
    snapGrid: r,
    slidesGrid: a,
    rtlTranslate: o,
    enabled: l,
    animating: c
  } = i;
  if (!l || i.destroyed) return i;
  typeof n > "u" && (n = i.params.speed);
  const u = i.virtual && s.virtual.enabled;
  if (s.loop) {
    if (c && !u && s.loopPreventsSliding) return !1;
    i.loopFix({
      direction: "prev"
    }), i._clientLeft = i.wrapperEl.clientLeft;
  }
  const d = o ? i.translate : -i.translate;
  function f(y) {
    return y < 0 ? -Math.floor(Math.abs(y)) : Math.floor(y);
  }
  const p = f(d), h = r.map((y) => f(y)), g = s.freeMode && s.freeMode.enabled;
  let m = r[h.indexOf(p) - 1];
  if (typeof m > "u" && (s.cssMode || g)) {
    let y;
    r.forEach((E, T) => {
      p >= E && (y = T);
    }), typeof y < "u" && (m = g ? r[y] : r[y > 0 ? y - 1 : y]);
  }
  let v = 0;
  if (typeof m < "u" && (v = a.indexOf(m), v < 0 && (v = i.activeIndex - 1), s.slidesPerView === "auto" && s.slidesPerGroup === 1 && s.slidesPerGroupAuto && (v = v - i.slidesPerViewDynamic("previous", !0) + 1, v = Math.max(v, 0))), s.rewind && i.isBeginning) {
    const y = i.params.virtual && i.params.virtual.enabled && i.virtual ? i.virtual.slides.length - 1 : i.slides.length - 1;
    return i.slideTo(y, n, e, t);
  } else if (s.loop && i.activeIndex === 0 && s.cssMode)
    return requestAnimationFrame(() => {
      i.slideTo(v, n, e, t);
    }), !0;
  return i.slideTo(v, n, e, t);
}
function zb(n, e, t) {
  e === void 0 && (e = !0);
  const i = this;
  if (!i.destroyed)
    return typeof n > "u" && (n = i.params.speed), i.slideTo(i.activeIndex, n, e, t);
}
function Wb(n, e, t, i) {
  e === void 0 && (e = !0), i === void 0 && (i = 0.5);
  const s = this;
  if (s.destroyed) return;
  typeof n > "u" && (n = s.params.speed);
  let r = s.activeIndex;
  const a = Math.min(s.params.slidesPerGroupSkip, r), o = a + Math.floor((r - a) / s.params.slidesPerGroup), l = s.rtlTranslate ? s.translate : -s.translate;
  if (l >= s.snapGrid[o]) {
    const c = s.snapGrid[o], u = s.snapGrid[o + 1];
    l - c > (u - c) * i && (r += s.params.slidesPerGroup);
  } else {
    const c = s.snapGrid[o - 1], u = s.snapGrid[o];
    l - c <= (u - c) * i && (r -= s.params.slidesPerGroup);
  }
  return r = Math.max(r, 0), r = Math.min(r, s.slidesGrid.length - 1), s.slideTo(r, n, e, t);
}
function Kb() {
  const n = this;
  if (n.destroyed) return;
  const {
    params: e,
    slidesEl: t
  } = n, i = e.slidesPerView === "auto" ? n.slidesPerViewDynamic() : e.slidesPerView;
  let s = n.getSlideIndexWhenGrid(n.clickedIndex), r;
  const a = n.isElement ? "swiper-slide" : `.${e.slideClass}`, o = n.grid && n.params.grid && n.params.grid.rows > 1;
  if (e.loop) {
    if (n.animating) return;
    r = parseInt(n.clickedSlide.getAttribute("data-swiper-slide-index"), 10), e.centeredSlides ? n.slideToLoop(r) : s > (o ? (n.slides.length - i) / 2 - (n.params.grid.rows - 1) : n.slides.length - i) ? (n.loopFix(), s = n.getSlideIndex(Dt(t, `${a}[data-swiper-slide-index="${r}"]`)[0]), yn(() => {
      n.slideTo(s);
    })) : n.slideTo(s);
  } else
    n.slideTo(s);
}
var Yb = {
  slideTo: Ub,
  slideToLoop: Gb,
  slideNext: Hb,
  slidePrev: Vb,
  slideReset: zb,
  slideToClosest: Wb,
  slideToClickedSlide: Kb
};
function qb(n, e) {
  const t = this, {
    params: i,
    slidesEl: s
  } = t;
  if (!i.loop || t.virtual && t.params.virtual.enabled) return;
  const r = () => {
    Dt(s, `.${i.slideClass}, swiper-slide`).forEach((p, h) => {
      p.setAttribute("data-swiper-slide-index", h);
    });
  }, a = () => {
    const f = Dt(s, `.${i.slideBlankClass}`);
    f.forEach((p) => {
      p.remove();
    }), f.length > 0 && (t.recalcSlides(), t.updateSlides());
  }, o = t.grid && i.grid && i.grid.rows > 1;
  i.loopAddBlankSlides && (i.slidesPerGroup > 1 || o) && a();
  const l = i.slidesPerGroup * (o ? i.grid.rows : 1), c = t.slides.length % l !== 0, u = o && t.slides.length % i.grid.rows !== 0, d = (f) => {
    for (let p = 0; p < f; p += 1) {
      const h = t.isElement ? Si("swiper-slide", [i.slideBlankClass]) : Si("div", [i.slideClass, i.slideBlankClass]);
      t.slidesEl.append(h);
    }
  };
  if (c) {
    if (i.loopAddBlankSlides) {
      const f = l - t.slides.length % l;
      d(f), t.recalcSlides(), t.updateSlides();
    } else
      Yo("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
    r();
  } else if (u) {
    if (i.loopAddBlankSlides) {
      const f = i.grid.rows - t.slides.length % i.grid.rows;
      d(f), t.recalcSlides(), t.updateSlides();
    } else
      Yo("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
    r();
  } else
    r();
  t.loopFix({
    slideRealIndex: n,
    direction: i.centeredSlides ? void 0 : "next",
    initial: e
  });
}
function Xb(n) {
  let {
    slideRealIndex: e,
    slideTo: t = !0,
    direction: i,
    setTranslate: s,
    activeSlideIndex: r,
    initial: a,
    byController: o,
    byMousewheel: l
  } = n === void 0 ? {} : n;
  const c = this;
  if (!c.params.loop) return;
  c.emit("beforeLoopFix");
  const {
    slides: u,
    allowSlidePrev: d,
    allowSlideNext: f,
    slidesEl: p,
    params: h
  } = c, {
    centeredSlides: g,
    initialSlide: m
  } = h;
  if (c.allowSlidePrev = !0, c.allowSlideNext = !0, c.virtual && h.virtual.enabled) {
    t && (!h.centeredSlides && c.snapIndex === 0 ? c.slideTo(c.virtual.slides.length, 0, !1, !0) : h.centeredSlides && c.snapIndex < h.slidesPerView ? c.slideTo(c.virtual.slides.length + c.snapIndex, 0, !1, !0) : c.snapIndex === c.snapGrid.length - 1 && c.slideTo(c.virtual.slidesBefore, 0, !1, !0)), c.allowSlidePrev = d, c.allowSlideNext = f, c.emit("loopFix");
    return;
  }
  let v = h.slidesPerView;
  v === "auto" ? v = c.slidesPerViewDynamic() : (v = Math.ceil(parseFloat(h.slidesPerView, 10)), g && v % 2 === 0 && (v = v + 1));
  const y = h.slidesPerGroupAuto ? v : h.slidesPerGroup;
  let E = g ? Math.max(y, Math.ceil(v / 2)) : y;
  E % y !== 0 && (E += y - E % y), E += h.loopAdditionalSlides, c.loopedSlides = E;
  const T = c.grid && h.grid && h.grid.rows > 1;
  u.length < v + E || c.params.effect === "cards" && u.length < v + E * 2 ? Yo("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled or not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : T && h.grid.fill === "row" && Yo("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
  const S = [], w = [], b = T ? Math.ceil(u.length / h.grid.rows) : u.length, L = a && b - m < v && !g;
  let A = L ? m : c.activeIndex;
  typeof r > "u" ? r = c.getSlideIndex(u.find((F) => F.classList.contains(h.slideActiveClass))) : A = r;
  const _ = i === "next" || !i, R = i === "prev" || !i;
  let I = 0, k = 0;
  const O = (T ? u[r].column : r) + (g && typeof s > "u" ? -v / 2 + 0.5 : 0);
  if (O < E) {
    I = Math.max(E - O, y);
    for (let F = 0; F < E - O; F += 1) {
      const C = F - Math.floor(F / b) * b;
      if (T) {
        const D = b - C - 1;
        for (let B = u.length - 1; B >= 0; B -= 1)
          u[B].column === D && S.push(B);
      } else
        S.push(b - C - 1);
    }
  } else if (O + v > b - E) {
    k = Math.max(O - (b - E * 2), y), L && (k = Math.max(k, v - b + m + 1));
    for (let F = 0; F < k; F += 1) {
      const C = F - Math.floor(F / b) * b;
      T ? u.forEach((D, B) => {
        D.column === C && w.push(B);
      }) : w.push(C);
    }
  }
  if (c.__preventObserver__ = !0, requestAnimationFrame(() => {
    c.__preventObserver__ = !1;
  }), c.params.effect === "cards" && u.length < v + E * 2 && (w.includes(r) && w.splice(w.indexOf(r), 1), S.includes(r) && S.splice(S.indexOf(r), 1)), R && S.forEach((F) => {
    u[F].swiperLoopMoveDOM = !0, p.prepend(u[F]), u[F].swiperLoopMoveDOM = !1;
  }), _ && w.forEach((F) => {
    u[F].swiperLoopMoveDOM = !0, p.append(u[F]), u[F].swiperLoopMoveDOM = !1;
  }), c.recalcSlides(), h.slidesPerView === "auto" ? c.updateSlides() : T && (S.length > 0 && R || w.length > 0 && _) && c.slides.forEach((F, C) => {
    c.grid.updateSlide(C, F, c.slides);
  }), h.watchSlidesProgress && c.updateSlidesOffset(), t) {
    if (S.length > 0 && R) {
      if (typeof e > "u") {
        const F = c.slidesGrid[A], D = c.slidesGrid[A + I] - F;
        l ? c.setTranslate(c.translate - D) : (c.slideTo(A + Math.ceil(I), 0, !1, !0), s && (c.touchEventsData.startTranslate = c.touchEventsData.startTranslate - D, c.touchEventsData.currentTranslate = c.touchEventsData.currentTranslate - D));
      } else if (s) {
        const F = T ? S.length / h.grid.rows : S.length;
        c.slideTo(c.activeIndex + F, 0, !1, !0), c.touchEventsData.currentTranslate = c.translate;
      }
    } else if (w.length > 0 && _)
      if (typeof e > "u") {
        const F = c.slidesGrid[A], D = c.slidesGrid[A - k] - F;
        l ? c.setTranslate(c.translate - D) : (c.slideTo(A - k, 0, !1, !0), s && (c.touchEventsData.startTranslate = c.touchEventsData.startTranslate - D, c.touchEventsData.currentTranslate = c.touchEventsData.currentTranslate - D));
      } else {
        const F = T ? w.length / h.grid.rows : w.length;
        c.slideTo(c.activeIndex - F, 0, !1, !0);
      }
  }
  if (c.allowSlidePrev = d, c.allowSlideNext = f, c.controller && c.controller.control && !o) {
    const F = {
      slideRealIndex: e,
      direction: i,
      setTranslate: s,
      activeSlideIndex: r,
      byController: !0
    };
    Array.isArray(c.controller.control) ? c.controller.control.forEach((C) => {
      !C.destroyed && C.params.loop && C.loopFix({
        ...F,
        slideTo: C.params.slidesPerView === h.slidesPerView ? t : !1
      });
    }) : c.controller.control instanceof c.constructor && c.controller.control.params.loop && c.controller.control.loopFix({
      ...F,
      slideTo: c.controller.control.params.slidesPerView === h.slidesPerView ? t : !1
    });
  }
  c.emit("loopFix");
}
function jb() {
  const n = this, {
    params: e,
    slidesEl: t
  } = n;
  if (!e.loop || !t || n.virtual && n.params.virtual.enabled) return;
  n.recalcSlides();
  const i = [];
  n.slides.forEach((s) => {
    const r = typeof s.swiperSlideIndex > "u" ? s.getAttribute("data-swiper-slide-index") * 1 : s.swiperSlideIndex;
    i[r] = s;
  }), n.slides.forEach((s) => {
    s.removeAttribute("data-swiper-slide-index");
  }), i.forEach((s) => {
    t.append(s);
  }), n.recalcSlides(), n.slideTo(n.realIndex, 0);
}
var Qb = {
  loopCreate: qb,
  loopFix: Xb,
  loopDestroy: jb
};
function Zb(n) {
  const e = this;
  if (!e.params.simulateTouch || e.params.watchOverflow && e.isLocked || e.params.cssMode) return;
  const t = e.params.touchEventsTarget === "container" ? e.el : e.wrapperEl;
  e.isElement && (e.__preventObserver__ = !0), t.style.cursor = "move", t.style.cursor = n ? "grabbing" : "grab", e.isElement && requestAnimationFrame(() => {
    e.__preventObserver__ = !1;
  });
}
function Jb() {
  const n = this;
  n.params.watchOverflow && n.isLocked || n.params.cssMode || (n.isElement && (n.__preventObserver__ = !0), n[n.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "", n.isElement && requestAnimationFrame(() => {
    n.__preventObserver__ = !1;
  }));
}
var e_ = {
  setGrabCursor: Zb,
  unsetGrabCursor: Jb
};
function t_(n, e) {
  e === void 0 && (e = this);
  function t(i) {
    if (!i || i === _t() || i === qe()) return null;
    i.assignedSlot && (i = i.assignedSlot);
    const s = i.closest(n);
    return !s && !i.getRootNode ? null : s || t(i.getRootNode().host);
  }
  return t(e);
}
function ch(n, e, t) {
  const i = qe(), {
    params: s
  } = n, r = s.edgeSwipeDetection, a = s.edgeSwipeThreshold;
  return r && (t <= a || t >= i.innerWidth - a) ? r === "prevent" ? (e.preventDefault(), !0) : !1 : !0;
}
function i_(n) {
  const e = this, t = _t();
  let i = n;
  i.originalEvent && (i = i.originalEvent);
  const s = e.touchEventsData;
  if (i.type === "pointerdown") {
    if (s.pointerId !== null && s.pointerId !== i.pointerId)
      return;
    s.pointerId = i.pointerId;
  } else i.type === "touchstart" && i.targetTouches.length === 1 && (s.touchId = i.targetTouches[0].identifier);
  if (i.type === "touchstart") {
    ch(e, i, i.targetTouches[0].pageX);
    return;
  }
  const {
    params: r,
    touches: a,
    enabled: o
  } = e;
  if (!o || !r.simulateTouch && i.pointerType === "mouse" || e.animating && r.preventInteractionOnTransition)
    return;
  !e.animating && r.cssMode && r.loop && e.loopFix();
  let l = i.target;
  if (r.touchEventsTarget === "wrapper" && !ub(l, e.wrapperEl) || "which" in i && i.which === 3 || "button" in i && i.button > 0 || s.isTouched && s.isMoved) return;
  const c = !!r.noSwipingClass && r.noSwipingClass !== "", u = i.composedPath ? i.composedPath() : i.path;
  c && i.target && i.target.shadowRoot && u && (l = u[0]);
  const d = r.noSwipingSelector ? r.noSwipingSelector : `.${r.noSwipingClass}`, f = !!(i.target && i.target.shadowRoot);
  if (r.noSwiping && (f ? t_(d, l) : l.closest(d))) {
    e.allowClick = !0;
    return;
  }
  if (r.swipeHandler && !l.closest(r.swipeHandler))
    return;
  a.currentX = i.pageX, a.currentY = i.pageY;
  const p = a.currentX, h = a.currentY;
  if (!ch(e, i, p))
    return;
  Object.assign(s, {
    isTouched: !0,
    isMoved: !1,
    allowTouchCallbacks: !0,
    isScrolling: void 0,
    startMoving: void 0
  }), a.startX = p, a.startY = h, s.touchStartTime = Ci(), e.allowClick = !0, e.updateSize(), e.swipeDirection = void 0, r.threshold > 0 && (s.allowThresholdMove = !1);
  let g = !0;
  l.matches(s.focusableElements) && (g = !1, l.nodeName === "SELECT" && (s.isTouched = !1)), t.activeElement && t.activeElement.matches(s.focusableElements) && t.activeElement !== l && (i.pointerType === "mouse" || i.pointerType !== "mouse" && !l.matches(s.focusableElements)) && t.activeElement.blur();
  const m = g && e.allowTouchMove && r.touchStartPreventDefault;
  (r.touchStartForcePreventDefault || m) && !l.isContentEditable && i.preventDefault(), r.freeMode && r.freeMode.enabled && e.freeMode && e.animating && !r.cssMode && e.freeMode.onTouchStart(), e.emit("touchStart", i);
}
function s_(n) {
  const e = _t(), t = this, i = t.touchEventsData, {
    params: s,
    touches: r,
    rtlTranslate: a,
    enabled: o
  } = t;
  if (!o || !s.simulateTouch && n.pointerType === "mouse") return;
  let l = n;
  if (l.originalEvent && (l = l.originalEvent), l.type === "pointermove" && (i.touchId !== null || l.pointerId !== i.pointerId))
    return;
  let c;
  if (l.type === "touchmove") {
    if (c = [...l.changedTouches].find((S) => S.identifier === i.touchId), !c || c.identifier !== i.touchId) return;
  } else
    c = l;
  if (!i.isTouched) {
    i.startMoving && i.isScrolling && t.emit("touchMoveOpposite", l);
    return;
  }
  const u = c.pageX, d = c.pageY;
  if (l.preventedByNestedSwiper) {
    r.startX = u, r.startY = d;
    return;
  }
  if (!t.allowTouchMove) {
    l.target.matches(i.focusableElements) || (t.allowClick = !1), i.isTouched && (Object.assign(r, {
      startX: u,
      startY: d,
      currentX: u,
      currentY: d
    }), i.touchStartTime = Ci());
    return;
  }
  if (s.touchReleaseOnEdges && !s.loop)
    if (t.isVertical()) {
      if (d < r.startY && t.translate <= t.maxTranslate() || d > r.startY && t.translate >= t.minTranslate()) {
        i.isTouched = !1, i.isMoved = !1;
        return;
      }
    } else {
      if (a && (u > r.startX && -t.translate <= t.maxTranslate() || u < r.startX && -t.translate >= t.minTranslate()))
        return;
      if (!a && (u < r.startX && t.translate <= t.maxTranslate() || u > r.startX && t.translate >= t.minTranslate()))
        return;
    }
  if (e.activeElement && e.activeElement.matches(i.focusableElements) && e.activeElement !== l.target && l.pointerType !== "mouse" && e.activeElement.blur(), e.activeElement && l.target === e.activeElement && l.target.matches(i.focusableElements)) {
    i.isMoved = !0, t.allowClick = !1;
    return;
  }
  i.allowTouchCallbacks && t.emit("touchMove", l), r.previousX = r.currentX, r.previousY = r.currentY, r.currentX = u, r.currentY = d;
  const f = r.currentX - r.startX, p = r.currentY - r.startY;
  if (t.params.threshold && Math.sqrt(f ** 2 + p ** 2) < t.params.threshold) return;
  if (typeof i.isScrolling > "u") {
    let S;
    t.isHorizontal() && r.currentY === r.startY || t.isVertical() && r.currentX === r.startX ? i.isScrolling = !1 : f * f + p * p >= 25 && (S = Math.atan2(Math.abs(p), Math.abs(f)) * 180 / Math.PI, i.isScrolling = t.isHorizontal() ? S > s.touchAngle : 90 - S > s.touchAngle);
  }
  if (i.isScrolling && t.emit("touchMoveOpposite", l), typeof i.startMoving > "u" && (r.currentX !== r.startX || r.currentY !== r.startY) && (i.startMoving = !0), i.isScrolling || l.type === "touchmove" && i.preventTouchMoveFromPointerMove) {
    i.isTouched = !1;
    return;
  }
  if (!i.startMoving)
    return;
  t.allowClick = !1, !s.cssMode && l.cancelable && l.preventDefault(), s.touchMoveStopPropagation && !s.nested && l.stopPropagation();
  let h = t.isHorizontal() ? f : p, g = t.isHorizontal() ? r.currentX - r.previousX : r.currentY - r.previousY;
  s.oneWayMovement && (h = Math.abs(h) * (a ? 1 : -1), g = Math.abs(g) * (a ? 1 : -1)), r.diff = h, h *= s.touchRatio, a && (h = -h, g = -g);
  const m = t.touchesDirection;
  t.swipeDirection = h > 0 ? "prev" : "next", t.touchesDirection = g > 0 ? "prev" : "next";
  const v = t.params.loop && !s.cssMode, y = t.touchesDirection === "next" && t.allowSlideNext || t.touchesDirection === "prev" && t.allowSlidePrev;
  if (!i.isMoved) {
    if (v && y && t.loopFix({
      direction: t.swipeDirection
    }), i.startTranslate = t.getTranslate(), t.setTransition(0), t.animating) {
      const S = new window.CustomEvent("transitionend", {
        bubbles: !0,
        cancelable: !0,
        detail: {
          bySwiperTouchMove: !0
        }
      });
      t.wrapperEl.dispatchEvent(S);
    }
    i.allowMomentumBounce = !1, s.grabCursor && (t.allowSlideNext === !0 || t.allowSlidePrev === !0) && t.setGrabCursor(!0), t.emit("sliderFirstMove", l);
  }
  if ((/* @__PURE__ */ new Date()).getTime(), s._loopSwapReset !== !1 && i.isMoved && i.allowThresholdMove && m !== t.touchesDirection && v && y && Math.abs(h) >= 1) {
    Object.assign(r, {
      startX: u,
      startY: d,
      currentX: u,
      currentY: d,
      startTranslate: i.currentTranslate
    }), i.loopSwapReset = !0, i.startTranslate = i.currentTranslate;
    return;
  }
  t.emit("sliderMove", l), i.isMoved = !0, i.currentTranslate = h + i.startTranslate;
  let E = !0, T = s.resistanceRatio;
  if (s.touchReleaseOnEdges && (T = 0), h > 0 ? (v && y && i.allowThresholdMove && i.currentTranslate > (s.centeredSlides ? t.minTranslate() - t.slidesSizesGrid[t.activeIndex + 1] - (s.slidesPerView !== "auto" && t.slides.length - s.slidesPerView >= 2 ? t.slidesSizesGrid[t.activeIndex + 1] + t.params.spaceBetween : 0) - t.params.spaceBetween : t.minTranslate()) && t.loopFix({
    direction: "prev",
    setTranslate: !0,
    activeSlideIndex: 0
  }), i.currentTranslate > t.minTranslate() && (E = !1, s.resistance && (i.currentTranslate = t.minTranslate() - 1 + (-t.minTranslate() + i.startTranslate + h) ** T))) : h < 0 && (v && y && i.allowThresholdMove && i.currentTranslate < (s.centeredSlides ? t.maxTranslate() + t.slidesSizesGrid[t.slidesSizesGrid.length - 1] + t.params.spaceBetween + (s.slidesPerView !== "auto" && t.slides.length - s.slidesPerView >= 2 ? t.slidesSizesGrid[t.slidesSizesGrid.length - 1] + t.params.spaceBetween : 0) : t.maxTranslate()) && t.loopFix({
    direction: "next",
    setTranslate: !0,
    activeSlideIndex: t.slides.length - (s.slidesPerView === "auto" ? t.slidesPerViewDynamic() : Math.ceil(parseFloat(s.slidesPerView, 10)))
  }), i.currentTranslate < t.maxTranslate() && (E = !1, s.resistance && (i.currentTranslate = t.maxTranslate() + 1 - (t.maxTranslate() - i.startTranslate - h) ** T))), E && (l.preventedByNestedSwiper = !0), !t.allowSlideNext && t.swipeDirection === "next" && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !t.allowSlidePrev && t.swipeDirection === "prev" && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), !t.allowSlidePrev && !t.allowSlideNext && (i.currentTranslate = i.startTranslate), s.threshold > 0)
    if (Math.abs(h) > s.threshold || i.allowThresholdMove) {
      if (!i.allowThresholdMove) {
        i.allowThresholdMove = !0, r.startX = r.currentX, r.startY = r.currentY, i.currentTranslate = i.startTranslate, r.diff = t.isHorizontal() ? r.currentX - r.startX : r.currentY - r.startY;
        return;
      }
    } else {
      i.currentTranslate = i.startTranslate;
      return;
    }
  !s.followFinger || s.cssMode || ((s.freeMode && s.freeMode.enabled && t.freeMode || s.watchSlidesProgress) && (t.updateActiveIndex(), t.updateSlidesClasses()), s.freeMode && s.freeMode.enabled && t.freeMode && t.freeMode.onTouchMove(), t.updateProgress(i.currentTranslate), t.setTranslate(i.currentTranslate));
}
function r_(n) {
  const e = this, t = e.touchEventsData;
  let i = n;
  i.originalEvent && (i = i.originalEvent);
  let s;
  if (i.type === "touchend" || i.type === "touchcancel") {
    if (s = [...i.changedTouches].find((S) => S.identifier === t.touchId), !s || s.identifier !== t.touchId) return;
  } else {
    if (t.touchId !== null || i.pointerId !== t.pointerId) return;
    s = i;
  }
  if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(i.type) && !(["pointercancel", "contextmenu"].includes(i.type) && (e.browser.isSafari || e.browser.isWebView)))
    return;
  t.pointerId = null, t.touchId = null;
  const {
    params: a,
    touches: o,
    rtlTranslate: l,
    slidesGrid: c,
    enabled: u
  } = e;
  if (!u || !a.simulateTouch && i.pointerType === "mouse") return;
  if (t.allowTouchCallbacks && e.emit("touchEnd", i), t.allowTouchCallbacks = !1, !t.isTouched) {
    t.isMoved && a.grabCursor && e.setGrabCursor(!1), t.isMoved = !1, t.startMoving = !1;
    return;
  }
  a.grabCursor && t.isMoved && t.isTouched && (e.allowSlideNext === !0 || e.allowSlidePrev === !0) && e.setGrabCursor(!1);
  const d = Ci(), f = d - t.touchStartTime;
  if (e.allowClick) {
    const S = i.path || i.composedPath && i.composedPath();
    e.updateClickedSlide(S && S[0] || i.target, S), e.emit("tap click", i), f < 300 && d - t.lastClickTime < 300 && e.emit("doubleTap doubleClick", i);
  }
  if (t.lastClickTime = Ci(), yn(() => {
    e.destroyed || (e.allowClick = !0);
  }), !t.isTouched || !t.isMoved || !e.swipeDirection || o.diff === 0 && !t.loopSwapReset || t.currentTranslate === t.startTranslate && !t.loopSwapReset) {
    t.isTouched = !1, t.isMoved = !1, t.startMoving = !1;
    return;
  }
  t.isTouched = !1, t.isMoved = !1, t.startMoving = !1;
  let p;
  if (a.followFinger ? p = l ? e.translate : -e.translate : p = -t.currentTranslate, a.cssMode)
    return;
  if (a.freeMode && a.freeMode.enabled) {
    e.freeMode.onTouchEnd({
      currentPos: p
    });
    return;
  }
  const h = p >= -e.maxTranslate() && !e.params.loop;
  let g = 0, m = e.slidesSizesGrid[0];
  for (let S = 0; S < c.length; S += S < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup) {
    const w = S < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
    typeof c[S + w] < "u" ? (h || p >= c[S] && p < c[S + w]) && (g = S, m = c[S + w] - c[S]) : (h || p >= c[S]) && (g = S, m = c[c.length - 1] - c[c.length - 2]);
  }
  let v = null, y = null;
  a.rewind && (e.isBeginning ? y = a.virtual && a.virtual.enabled && e.virtual ? e.virtual.slides.length - 1 : e.slides.length - 1 : e.isEnd && (v = 0));
  const E = (p - c[g]) / m, T = g < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
  if (f > a.longSwipesMs) {
    if (!a.longSwipes) {
      e.slideTo(e.activeIndex);
      return;
    }
    e.swipeDirection === "next" && (E >= a.longSwipesRatio ? e.slideTo(a.rewind && e.isEnd ? v : g + T) : e.slideTo(g)), e.swipeDirection === "prev" && (E > 1 - a.longSwipesRatio ? e.slideTo(g + T) : y !== null && E < 0 && Math.abs(E) > a.longSwipesRatio ? e.slideTo(y) : e.slideTo(g));
  } else {
    if (!a.shortSwipes) {
      e.slideTo(e.activeIndex);
      return;
    }
    e.navigation && (i.target === e.navigation.nextEl || i.target === e.navigation.prevEl) ? i.target === e.navigation.nextEl ? e.slideTo(g + T) : e.slideTo(g) : (e.swipeDirection === "next" && e.slideTo(v !== null ? v : g + T), e.swipeDirection === "prev" && e.slideTo(y !== null ? y : g));
  }
}
function uh() {
  const n = this, {
    params: e,
    el: t
  } = n;
  if (t && t.offsetWidth === 0) return;
  e.breakpoints && n.setBreakpoint();
  const {
    allowSlideNext: i,
    allowSlidePrev: s,
    snapGrid: r
  } = n, a = n.virtual && n.params.virtual.enabled;
  n.allowSlideNext = !0, n.allowSlidePrev = !0, n.updateSize(), n.updateSlides(), n.updateSlidesClasses();
  const o = a && e.loop;
  (e.slidesPerView === "auto" || e.slidesPerView > 1) && n.isEnd && !n.isBeginning && !n.params.centeredSlides && !o ? n.slideTo(n.slides.length - 1, 0, !1, !0) : n.params.loop && !a ? n.slideToLoop(n.realIndex, 0, !1, !0) : n.slideTo(n.activeIndex, 0, !1, !0), n.autoplay && n.autoplay.running && n.autoplay.paused && (clearTimeout(n.autoplay.resizeTimeout), n.autoplay.resizeTimeout = setTimeout(() => {
    n.autoplay && n.autoplay.running && n.autoplay.paused && n.autoplay.resume();
  }, 500)), n.allowSlidePrev = s, n.allowSlideNext = i, n.params.watchOverflow && r !== n.snapGrid && n.checkOverflow();
}
function n_(n) {
  const e = this;
  e.enabled && (e.allowClick || (e.params.preventClicks && n.preventDefault(), e.params.preventClicksPropagation && e.animating && (n.stopPropagation(), n.stopImmediatePropagation())));
}
function a_() {
  const n = this, {
    wrapperEl: e,
    rtlTranslate: t,
    enabled: i
  } = n;
  if (!i) return;
  n.previousTranslate = n.translate, n.isHorizontal() ? n.translate = -e.scrollLeft : n.translate = -e.scrollTop, n.translate === 0 && (n.translate = 0), n.updateActiveIndex(), n.updateSlidesClasses();
  let s;
  const r = n.maxTranslate() - n.minTranslate();
  r === 0 ? s = 0 : s = (n.translate - n.minTranslate()) / r, s !== n.progress && n.updateProgress(t ? -n.translate : n.translate), n.emit("setTranslate", n.translate, !1);
}
function o_(n) {
  const e = this;
  So(e, n.target), !(e.params.cssMode || e.params.slidesPerView !== "auto" && !e.params.autoHeight) && e.update();
}
function l_() {
  const n = this;
  n.documentTouchHandlerProceeded || (n.documentTouchHandlerProceeded = !0, n.params.touchReleaseOnEdges && (n.el.style.touchAction = "auto"));
}
const Lm = (n, e) => {
  const t = _t(), {
    params: i,
    el: s,
    wrapperEl: r,
    device: a
  } = n, o = !!i.nested, l = e === "on" ? "addEventListener" : "removeEventListener", c = e;
  !s || typeof s == "string" || (t[l]("touchstart", n.onDocumentTouchStart, {
    passive: !1,
    capture: o
  }), s[l]("touchstart", n.onTouchStart, {
    passive: !1
  }), s[l]("pointerdown", n.onTouchStart, {
    passive: !1
  }), t[l]("touchmove", n.onTouchMove, {
    passive: !1,
    capture: o
  }), t[l]("pointermove", n.onTouchMove, {
    passive: !1,
    capture: o
  }), t[l]("touchend", n.onTouchEnd, {
    passive: !0
  }), t[l]("pointerup", n.onTouchEnd, {
    passive: !0
  }), t[l]("pointercancel", n.onTouchEnd, {
    passive: !0
  }), t[l]("touchcancel", n.onTouchEnd, {
    passive: !0
  }), t[l]("pointerout", n.onTouchEnd, {
    passive: !0
  }), t[l]("pointerleave", n.onTouchEnd, {
    passive: !0
  }), t[l]("contextmenu", n.onTouchEnd, {
    passive: !0
  }), (i.preventClicks || i.preventClicksPropagation) && s[l]("click", n.onClick, !0), i.cssMode && r[l]("scroll", n.onScroll), i.updateOnWindowResize ? n[c](a.ios || a.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", uh, !0) : n[c]("observerUpdate", uh, !0), s[l]("load", n.onLoad, {
    capture: !0
  }));
};
function c_() {
  const n = this, {
    params: e
  } = n;
  n.onTouchStart = i_.bind(n), n.onTouchMove = s_.bind(n), n.onTouchEnd = r_.bind(n), n.onDocumentTouchStart = l_.bind(n), e.cssMode && (n.onScroll = a_.bind(n)), n.onClick = n_.bind(n), n.onLoad = o_.bind(n), Lm(n, "on");
}
function u_() {
  Lm(this, "off");
}
var d_ = {
  attachEvents: c_,
  detachEvents: u_
};
const dh = (n, e) => n.grid && e.grid && e.grid.rows > 1;
function f_() {
  const n = this, {
    realIndex: e,
    initialized: t,
    params: i,
    el: s
  } = n, r = i.breakpoints;
  if (!r || r && Object.keys(r).length === 0) return;
  const a = _t(), o = i.breakpointsBase === "window" || !i.breakpointsBase ? i.breakpointsBase : "container", l = ["window", "container"].includes(i.breakpointsBase) || !i.breakpointsBase ? n.el : a.querySelector(i.breakpointsBase), c = n.getBreakpoint(r, o, l);
  if (!c || n.currentBreakpoint === c) return;
  const d = (c in r ? r[c] : void 0) || n.originalParams, f = dh(n, i), p = dh(n, d), h = n.params.grabCursor, g = d.grabCursor, m = i.enabled;
  f && !p ? (s.classList.remove(`${i.containerModifierClass}grid`, `${i.containerModifierClass}grid-column`), n.emitContainerClasses()) : !f && p && (s.classList.add(`${i.containerModifierClass}grid`), (d.grid.fill && d.grid.fill === "column" || !d.grid.fill && i.grid.fill === "column") && s.classList.add(`${i.containerModifierClass}grid-column`), n.emitContainerClasses()), h && !g ? n.unsetGrabCursor() : !h && g && n.setGrabCursor(), ["navigation", "pagination", "scrollbar"].forEach((w) => {
    if (typeof d[w] > "u") return;
    const b = i[w] && i[w].enabled, L = d[w] && d[w].enabled;
    b && !L && n[w].disable(), !b && L && n[w].enable();
  });
  const v = d.direction && d.direction !== i.direction, y = i.loop && (d.slidesPerView !== i.slidesPerView || v), E = i.loop;
  v && t && n.changeDirection(), gi(n.params, d);
  const T = n.params.enabled, S = n.params.loop;
  Object.assign(n, {
    allowTouchMove: n.params.allowTouchMove,
    allowSlideNext: n.params.allowSlideNext,
    allowSlidePrev: n.params.allowSlidePrev
  }), m && !T ? n.disable() : !m && T && n.enable(), n.currentBreakpoint = c, n.emit("_beforeBreakpoint", d), t && (y ? (n.loopDestroy(), n.loopCreate(e), n.updateSlides()) : !E && S ? (n.loopCreate(e), n.updateSlides()) : E && !S && n.loopDestroy()), n.emit("breakpoint", d);
}
function h_(n, e, t) {
  if (e === void 0 && (e = "window"), !n || e === "container" && !t) return;
  let i = !1;
  const s = qe(), r = e === "window" ? s.innerHeight : t.clientHeight, a = Object.keys(n).map((o) => {
    if (typeof o == "string" && o.indexOf("@") === 0) {
      const l = parseFloat(o.substr(1));
      return {
        value: r * l,
        point: o
      };
    }
    return {
      value: o,
      point: o
    };
  });
  a.sort((o, l) => parseInt(o.value, 10) - parseInt(l.value, 10));
  for (let o = 0; o < a.length; o += 1) {
    const {
      point: l,
      value: c
    } = a[o];
    e === "window" ? s.matchMedia(`(min-width: ${c}px)`).matches && (i = l) : c <= t.clientWidth && (i = l);
  }
  return i || "max";
}
var p_ = {
  setBreakpoint: f_,
  getBreakpoint: h_
};
function g_(n, e) {
  const t = [];
  return n.forEach((i) => {
    typeof i == "object" ? Object.keys(i).forEach((s) => {
      i[s] && t.push(e + s);
    }) : typeof i == "string" && t.push(e + i);
  }), t;
}
function m_() {
  const n = this, {
    classNames: e,
    params: t,
    rtl: i,
    el: s,
    device: r
  } = n, a = g_(["initialized", t.direction, {
    "free-mode": n.params.freeMode && t.freeMode.enabled
  }, {
    autoheight: t.autoHeight
  }, {
    rtl: i
  }, {
    grid: t.grid && t.grid.rows > 1
  }, {
    "grid-column": t.grid && t.grid.rows > 1 && t.grid.fill === "column"
  }, {
    android: r.android
  }, {
    ios: r.ios
  }, {
    "css-mode": t.cssMode
  }, {
    centered: t.cssMode && t.centeredSlides
  }, {
    "watch-progress": t.watchSlidesProgress
  }], t.containerModifierClass);
  e.push(...a), s.classList.add(...e), n.emitContainerClasses();
}
function v_() {
  const n = this, {
    el: e,
    classNames: t
  } = n;
  !e || typeof e == "string" || (e.classList.remove(...t), n.emitContainerClasses());
}
var y_ = {
  addClasses: m_,
  removeClasses: v_
};
function E_() {
  const n = this, {
    isLocked: e,
    params: t
  } = n, {
    slidesOffsetBefore: i
  } = t;
  if (i) {
    const s = n.slides.length - 1, r = n.slidesGrid[s] + n.slidesSizesGrid[s] + i * 2;
    n.isLocked = n.size > r;
  } else
    n.isLocked = n.snapGrid.length === 1;
  t.allowSlideNext === !0 && (n.allowSlideNext = !n.isLocked), t.allowSlidePrev === !0 && (n.allowSlidePrev = !n.isLocked), e && e !== n.isLocked && (n.isEnd = !1), e !== n.isLocked && n.emit(n.isLocked ? "lock" : "unlock");
}
var T_ = {
  checkOverflow: E_
}, fh = {
  init: !0,
  direction: "horizontal",
  oneWayMovement: !1,
  swiperElementNodeName: "SWIPER-CONTAINER",
  touchEventsTarget: "wrapper",
  initialSlide: 0,
  speed: 300,
  cssMode: !1,
  updateOnWindowResize: !0,
  resizeObserver: !0,
  nested: !1,
  createElements: !1,
  eventsPrefix: "swiper",
  enabled: !0,
  focusableElements: "input, select, option, textarea, button, video, label",
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: !1,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: !1,
  edgeSwipeThreshold: 20,
  // Autoheight
  autoHeight: !1,
  // Set wrapper width
  setWrapperSize: !1,
  // Virtual Translate
  virtualTranslate: !1,
  // Effects
  effect: "slide",
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
  // Breakpoints
  breakpoints: void 0,
  breakpointsBase: "window",
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: !1,
  centeredSlides: !1,
  centeredSlidesBounds: !1,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: !0,
  centerInsufficientSlides: !1,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: !0,
  // Round length
  roundLengths: !1,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: !0,
  shortSwipes: !0,
  longSwipes: !0,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: !0,
  allowTouchMove: !0,
  threshold: 5,
  touchMoveStopPropagation: !1,
  touchStartPreventDefault: !0,
  touchStartForcePreventDefault: !1,
  touchReleaseOnEdges: !1,
  // Unique Navigation Elements
  uniqueNavElements: !0,
  // Resistance
  resistance: !0,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: !1,
  // Cursor
  grabCursor: !1,
  // Clicks
  preventClicks: !0,
  preventClicksPropagation: !0,
  slideToClickedSlide: !1,
  // loop
  loop: !1,
  loopAddBlankSlides: !0,
  loopAdditionalSlides: 0,
  loopPreventsSliding: !0,
  // rewind
  rewind: !1,
  // Swiping/no swiping
  allowSlidePrev: !0,
  allowSlideNext: !0,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: !0,
  noSwipingClass: "swiper-no-swiping",
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: !0,
  maxBackfaceHiddenSlides: 10,
  // NS
  containerModifierClass: "swiper-",
  // NEW
  slideClass: "swiper-slide",
  slideBlankClass: "swiper-slide-blank",
  slideActiveClass: "swiper-slide-active",
  slideVisibleClass: "swiper-slide-visible",
  slideFullyVisibleClass: "swiper-slide-fully-visible",
  slideNextClass: "swiper-slide-next",
  slidePrevClass: "swiper-slide-prev",
  wrapperClass: "swiper-wrapper",
  lazyPreloaderClass: "swiper-lazy-preloader",
  lazyPreloadPrevNext: 0,
  // Callbacks
  runCallbacksOnInit: !0,
  // Internals
  _emitClasses: !1
};
function S_(n, e) {
  return function(i) {
    i === void 0 && (i = {});
    const s = Object.keys(i)[0], r = i[s];
    if (typeof r != "object" || r === null) {
      gi(e, i);
      return;
    }
    if (n[s] === !0 && (n[s] = {
      enabled: !0
    }), s === "navigation" && n[s] && n[s].enabled && !n[s].prevEl && !n[s].nextEl && (n[s].auto = !0), ["pagination", "scrollbar"].indexOf(s) >= 0 && n[s] && n[s].enabled && !n[s].el && (n[s].auto = !0), !(s in n && "enabled" in r)) {
      gi(e, i);
      return;
    }
    typeof n[s] == "object" && !("enabled" in n[s]) && (n[s].enabled = !0), n[s] || (n[s] = {
      enabled: !1
    }), gi(e, i);
  };
}
const ec = {
  eventsEmitter: yb,
  update: Rb,
  translate: Ob,
  transition: Bb,
  slide: Yb,
  loop: Qb,
  grabCursor: e_,
  events: d_,
  breakpoints: p_,
  checkOverflow: T_,
  classes: y_
}, tc = {};
class hi {
  constructor() {
    let e, t;
    for (var i = arguments.length, s = new Array(i), r = 0; r < i; r++)
      s[r] = arguments[r];
    s.length === 1 && s[0].constructor && Object.prototype.toString.call(s[0]).slice(8, -1) === "Object" ? t = s[0] : [e, t] = s, t || (t = {}), t = gi({}, t), e && !t.el && (t.el = e);
    const a = _t();
    if (t.el && typeof t.el == "string" && a.querySelectorAll(t.el).length > 1) {
      const u = [];
      return a.querySelectorAll(t.el).forEach((d) => {
        const f = gi({}, t, {
          el: d
        });
        u.push(new hi(f));
      }), u;
    }
    const o = this;
    o.__swiper__ = !0, o.support = bm(), o.device = _m({
      userAgent: t.userAgent
    }), o.browser = Am(), o.eventsListeners = {}, o.eventsAnyListeners = [], o.modules = [...o.__modules__], t.modules && Array.isArray(t.modules) && o.modules.push(...t.modules);
    const l = {};
    o.modules.forEach((u) => {
      u({
        params: t,
        swiper: o,
        extendParams: S_(t, l),
        on: o.on.bind(o),
        once: o.once.bind(o),
        off: o.off.bind(o),
        emit: o.emit.bind(o)
      });
    });
    const c = gi({}, fh, l);
    return o.params = gi({}, c, tc, t), o.originalParams = gi({}, o.params), o.passedParams = gi({}, t), o.params && o.params.on && Object.keys(o.params.on).forEach((u) => {
      o.on(u, o.params.on[u]);
    }), o.params && o.params.onAny && o.onAny(o.params.onAny), Object.assign(o, {
      enabled: o.params.enabled,
      el: e,
      // Classes
      classNames: [],
      // Slides
      slides: [],
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      // isDirection
      isHorizontal() {
        return o.params.direction === "horizontal";
      },
      isVertical() {
        return o.params.direction === "vertical";
      },
      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: !0,
      isEnd: !1,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: !1,
      cssOverflowAdjustment() {
        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
      },
      // Locks
      allowSlideNext: o.params.allowSlideNext,
      allowSlidePrev: o.params.allowSlidePrev,
      // Touch Events
      touchEventsData: {
        isTouched: void 0,
        isMoved: void 0,
        allowTouchCallbacks: void 0,
        touchStartTime: void 0,
        isScrolling: void 0,
        currentTranslate: void 0,
        startTranslate: void 0,
        allowThresholdMove: void 0,
        // Form elements to match
        focusableElements: o.params.focusableElements,
        // Last click time
        lastClickTime: 0,
        clickTimeout: void 0,
        // Velocities
        velocities: [],
        allowMomentumBounce: void 0,
        startMoving: void 0,
        pointerId: null,
        touchId: null
      },
      // Clicks
      allowClick: !0,
      // Touches
      allowTouchMove: o.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0
    }), o.emit("_swiper"), o.params.init && o.init(), o;
  }
  getDirectionLabel(e) {
    return this.isHorizontal() ? e : {
      width: "height",
      "margin-top": "margin-left",
      "margin-bottom ": "margin-right",
      "margin-left": "margin-top",
      "margin-right": "margin-bottom",
      "padding-left": "padding-top",
      "padding-right": "padding-bottom",
      marginRight: "marginBottom"
    }[e];
  }
  getSlideIndex(e) {
    const {
      slidesEl: t,
      params: i
    } = this, s = Dt(t, `.${i.slideClass}, swiper-slide`), r = Ta(s[0]);
    return Ta(e) - r;
  }
  getSlideIndexByData(e) {
    return this.getSlideIndex(this.slides.find((t) => t.getAttribute("data-swiper-slide-index") * 1 === e));
  }
  getSlideIndexWhenGrid(e) {
    return this.grid && this.params.grid && this.params.grid.rows > 1 && (this.params.grid.fill === "column" ? e = Math.floor(e / this.params.grid.rows) : this.params.grid.fill === "row" && (e = e % Math.ceil(this.slides.length / this.params.grid.rows))), e;
  }
  recalcSlides() {
    const e = this, {
      slidesEl: t,
      params: i
    } = e;
    e.slides = Dt(t, `.${i.slideClass}, swiper-slide`);
  }
  enable() {
    const e = this;
    e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable"));
  }
  disable() {
    const e = this;
    e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable"));
  }
  setProgress(e, t) {
    const i = this;
    e = Math.min(Math.max(e, 0), 1);
    const s = i.minTranslate(), a = (i.maxTranslate() - s) * e + s;
    i.translateTo(a, typeof t > "u" ? 0 : t), i.updateActiveIndex(), i.updateSlidesClasses();
  }
  emitContainerClasses() {
    const e = this;
    if (!e.params._emitClasses || !e.el) return;
    const t = e.el.className.split(" ").filter((i) => i.indexOf("swiper") === 0 || i.indexOf(e.params.containerModifierClass) === 0);
    e.emit("_containerClasses", t.join(" "));
  }
  getSlideClasses(e) {
    const t = this;
    return t.destroyed ? "" : e.className.split(" ").filter((i) => i.indexOf("swiper-slide") === 0 || i.indexOf(t.params.slideClass) === 0).join(" ");
  }
  emitSlidesClasses() {
    const e = this;
    if (!e.params._emitClasses || !e.el) return;
    const t = [];
    e.slides.forEach((i) => {
      const s = e.getSlideClasses(i);
      t.push({
        slideEl: i,
        classNames: s
      }), e.emit("_slideClass", i, s);
    }), e.emit("_slideClasses", t);
  }
  slidesPerViewDynamic(e, t) {
    e === void 0 && (e = "current"), t === void 0 && (t = !1);
    const i = this, {
      params: s,
      slides: r,
      slidesGrid: a,
      slidesSizesGrid: o,
      size: l,
      activeIndex: c
    } = i;
    let u = 1;
    if (typeof s.slidesPerView == "number") return s.slidesPerView;
    if (s.centeredSlides) {
      let d = r[c] ? Math.ceil(r[c].swiperSlideSize) : 0, f;
      for (let p = c + 1; p < r.length; p += 1)
        r[p] && !f && (d += Math.ceil(r[p].swiperSlideSize), u += 1, d > l && (f = !0));
      for (let p = c - 1; p >= 0; p -= 1)
        r[p] && !f && (d += r[p].swiperSlideSize, u += 1, d > l && (f = !0));
    } else if (e === "current")
      for (let d = c + 1; d < r.length; d += 1)
        (t ? a[d] + o[d] - a[c] < l : a[d] - a[c] < l) && (u += 1);
    else
      for (let d = c - 1; d >= 0; d -= 1)
        a[c] - a[d] < l && (u += 1);
    return u;
  }
  update() {
    const e = this;
    if (!e || e.destroyed) return;
    const {
      snapGrid: t,
      params: i
    } = e;
    i.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach((a) => {
      a.complete && So(e, a);
    }), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses();
    function s() {
      const a = e.rtlTranslate ? e.translate * -1 : e.translate, o = Math.min(Math.max(a, e.maxTranslate()), e.minTranslate());
      e.setTranslate(o), e.updateActiveIndex(), e.updateSlidesClasses();
    }
    let r;
    if (i.freeMode && i.freeMode.enabled && !i.cssMode)
      s(), i.autoHeight && e.updateAutoHeight();
    else {
      if ((i.slidesPerView === "auto" || i.slidesPerView > 1) && e.isEnd && !i.centeredSlides) {
        const a = e.virtual && i.virtual.enabled ? e.virtual.slides : e.slides;
        r = e.slideTo(a.length - 1, 0, !1, !0);
      } else
        r = e.slideTo(e.activeIndex, 0, !1, !0);
      r || s();
    }
    i.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update");
  }
  changeDirection(e, t) {
    t === void 0 && (t = !0);
    const i = this, s = i.params.direction;
    return e || (e = s === "horizontal" ? "vertical" : "horizontal"), e === s || e !== "horizontal" && e !== "vertical" || (i.el.classList.remove(`${i.params.containerModifierClass}${s}`), i.el.classList.add(`${i.params.containerModifierClass}${e}`), i.emitContainerClasses(), i.params.direction = e, i.slides.forEach((r) => {
      e === "vertical" ? r.style.width = "" : r.style.height = "";
    }), i.emit("changeDirection"), t && i.update()), i;
  }
  changeLanguageDirection(e) {
    const t = this;
    t.rtl && e === "rtl" || !t.rtl && e === "ltr" || (t.rtl = e === "rtl", t.rtlTranslate = t.params.direction === "horizontal" && t.rtl, t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update());
  }
  mount(e) {
    const t = this;
    if (t.mounted) return !0;
    let i = e || t.params.el;
    if (typeof i == "string" && (i = document.querySelector(i)), !i)
      return !1;
    i.swiper = t, i.parentNode && i.parentNode.host && i.parentNode.host.nodeName === t.params.swiperElementNodeName.toUpperCase() && (t.isElement = !0);
    const s = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`;
    let a = i && i.shadowRoot && i.shadowRoot.querySelector ? i.shadowRoot.querySelector(s()) : Dt(i, s())[0];
    return !a && t.params.createElements && (a = Si("div", t.params.wrapperClass), i.append(a), Dt(i, `.${t.params.slideClass}`).forEach((o) => {
      a.append(o);
    })), Object.assign(t, {
      el: i,
      wrapperEl: a,
      slidesEl: t.isElement && !i.parentNode.host.slideSlots ? i.parentNode.host : a,
      hostEl: t.isElement ? i.parentNode.host : i,
      mounted: !0,
      // RTL
      rtl: i.dir.toLowerCase() === "rtl" || Vs(i, "direction") === "rtl",
      rtlTranslate: t.params.direction === "horizontal" && (i.dir.toLowerCase() === "rtl" || Vs(i, "direction") === "rtl"),
      wrongRTL: Vs(a, "display") === "-webkit-box"
    }), !0;
  }
  init(e) {
    const t = this;
    if (t.initialized || t.mount(e) === !1) return t;
    t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(void 0, !0), t.attachEvents();
    const s = [...t.el.querySelectorAll('[loading="lazy"]')];
    return t.isElement && s.push(...t.hostEl.querySelectorAll('[loading="lazy"]')), s.forEach((r) => {
      r.complete ? So(t, r) : r.addEventListener("load", (a) => {
        So(t, a.target);
      });
    }), Zc(t), t.initialized = !0, Zc(t), t.emit("init"), t.emit("afterInit"), t;
  }
  destroy(e, t) {
    e === void 0 && (e = !0), t === void 0 && (t = !0);
    const i = this, {
      params: s,
      el: r,
      wrapperEl: a,
      slides: o
    } = i;
    return typeof i.params > "u" || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), s.loop && i.loopDestroy(), t && (i.removeClasses(), r && typeof r != "string" && r.removeAttribute("style"), a && a.removeAttribute("style"), o && o.length && o.forEach((l) => {
      l.classList.remove(s.slideVisibleClass, s.slideFullyVisibleClass, s.slideActiveClass, s.slideNextClass, s.slidePrevClass), l.removeAttribute("style"), l.removeAttribute("data-swiper-slide-index");
    })), i.emit("destroy"), Object.keys(i.eventsListeners).forEach((l) => {
      i.off(l);
    }), e !== !1 && (i.el && typeof i.el != "string" && (i.el.swiper = null), ab(i)), i.destroyed = !0), null;
  }
  static extendDefaults(e) {
    gi(tc, e);
  }
  static get extendedDefaults() {
    return tc;
  }
  static get defaults() {
    return fh;
  }
  static installModule(e) {
    hi.prototype.__modules__ || (hi.prototype.__modules__ = []);
    const t = hi.prototype.__modules__;
    typeof e == "function" && t.indexOf(e) < 0 && t.push(e);
  }
  static use(e) {
    return Array.isArray(e) ? (e.forEach((t) => hi.installModule(t)), hi) : (hi.installModule(e), hi);
  }
}
Object.keys(ec).forEach((n) => {
  Object.keys(ec[n]).forEach((e) => {
    hi.prototype[e] = ec[n][e];
  });
});
hi.use([mb, vb]);
function x_(n) {
  let {
    swiper: e,
    extendParams: t,
    on: i,
    emit: s
  } = n;
  t({
    virtual: {
      enabled: !1,
      slides: [],
      cache: !0,
      renderSlide: null,
      renderExternal: null,
      renderExternalUpdate: !0,
      addSlidesBefore: 0,
      addSlidesAfter: 0
    }
  });
  let r;
  const a = _t();
  e.virtual = {
    cache: {},
    from: void 0,
    to: void 0,
    slides: [],
    offset: 0,
    slidesGrid: []
  };
  const o = a.createElement("div");
  function l(h, g) {
    const m = e.params.virtual;
    if (m.cache && e.virtual.cache[g])
      return e.virtual.cache[g];
    let v;
    return m.renderSlide ? (v = m.renderSlide.call(e, h, g), typeof v == "string" && (As(o, v), v = o.children[0])) : e.isElement ? v = Si("swiper-slide") : v = Si("div", e.params.slideClass), v.setAttribute("data-swiper-slide-index", g), m.renderSlide || As(v, h), m.cache && (e.virtual.cache[g] = v), v;
  }
  function c(h, g, m) {
    const {
      slidesPerView: v,
      slidesPerGroup: y,
      centeredSlides: E,
      loop: T,
      initialSlide: S
    } = e.params;
    if (g && !T && S > 0)
      return;
    const {
      addSlidesBefore: w,
      addSlidesAfter: b
    } = e.params.virtual, {
      from: L,
      to: A,
      slides: _,
      slidesGrid: R,
      offset: I
    } = e.virtual;
    e.params.cssMode || e.updateActiveIndex();
    const k = typeof m > "u" ? e.activeIndex || 0 : m;
    let M;
    e.rtlTranslate ? M = "right" : M = e.isHorizontal() ? "left" : "top";
    let O, F;
    E ? (O = Math.floor(v / 2) + y + b, F = Math.floor(v / 2) + y + w) : (O = v + (y - 1) + b, F = (T ? v : y) + w);
    let C = k - F, D = k + O;
    T || (C = Math.max(C, 0), D = Math.min(D, _.length - 1));
    let B = (e.slidesGrid[C] || 0) - (e.slidesGrid[0] || 0);
    T && k >= F ? (C -= F, E || (B += e.slidesGrid[0])) : T && k < F && (C = -F, E && (B += e.slidesGrid[0])), Object.assign(e.virtual, {
      from: C,
      to: D,
      offset: B,
      slidesGrid: e.slidesGrid,
      slidesBefore: F,
      slidesAfter: O
    });
    function P() {
      e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), s("virtualUpdate");
    }
    if (L === C && A === D && !h) {
      e.slidesGrid !== R && B !== I && e.slides.forEach((U) => {
        U.style[M] = `${B - Math.abs(e.cssOverflowAdjustment())}px`;
      }), e.updateProgress(), s("virtualUpdate");
      return;
    }
    if (e.params.virtual.renderExternal) {
      e.params.virtual.renderExternal.call(e, {
        offset: B,
        from: C,
        to: D,
        slides: (function() {
          const V = [];
          for (let j = C; j <= D; j += 1)
            V.push(_[j]);
          return V;
        })()
      }), e.params.virtual.renderExternalUpdate ? P() : s("virtualUpdate");
      return;
    }
    const K = [], X = [], W = (U) => {
      let V = U;
      return U < 0 ? V = _.length + U : V >= _.length && (V = V - _.length), V;
    };
    if (h)
      e.slides.filter((U) => U.matches(`.${e.params.slideClass}, swiper-slide`)).forEach((U) => {
        U.remove();
      });
    else
      for (let U = L; U <= A; U += 1)
        if (U < C || U > D) {
          const V = W(U);
          e.slides.filter((j) => j.matches(`.${e.params.slideClass}[data-swiper-slide-index="${V}"], swiper-slide[data-swiper-slide-index="${V}"]`)).forEach((j) => {
            j.remove();
          });
        }
    const Y = T ? -_.length : 0, N = T ? _.length * 2 : _.length;
    for (let U = Y; U < N; U += 1)
      if (U >= C && U <= D) {
        const V = W(U);
        typeof A > "u" || h ? X.push(V) : (U > A && X.push(V), U < L && K.push(V));
      }
    if (X.forEach((U) => {
      e.slidesEl.append(l(_[U], U));
    }), T)
      for (let U = K.length - 1; U >= 0; U -= 1) {
        const V = K[U];
        e.slidesEl.prepend(l(_[V], V));
      }
    else
      K.sort((U, V) => V - U), K.forEach((U) => {
        e.slidesEl.prepend(l(_[U], U));
      });
    Dt(e.slidesEl, ".swiper-slide, swiper-slide").forEach((U) => {
      U.style[M] = `${B - Math.abs(e.cssOverflowAdjustment())}px`;
    }), P();
  }
  function u(h) {
    if (typeof h == "object" && "length" in h)
      for (let g = 0; g < h.length; g += 1)
        h[g] && e.virtual.slides.push(h[g]);
    else
      e.virtual.slides.push(h);
    c(!0);
  }
  function d(h) {
    const g = e.activeIndex;
    let m = g + 1, v = 1;
    if (Array.isArray(h)) {
      for (let y = 0; y < h.length; y += 1)
        h[y] && e.virtual.slides.unshift(h[y]);
      m = g + h.length, v = h.length;
    } else
      e.virtual.slides.unshift(h);
    if (e.params.virtual.cache) {
      const y = e.virtual.cache, E = {};
      Object.keys(y).forEach((T) => {
        const S = y[T], w = S.getAttribute("data-swiper-slide-index");
        w && S.setAttribute("data-swiper-slide-index", parseInt(w, 10) + v), E[parseInt(T, 10) + v] = S;
      }), e.virtual.cache = E;
    }
    c(!0), e.slideTo(m, 0);
  }
  function f(h) {
    if (typeof h > "u" || h === null) return;
    let g = e.activeIndex;
    if (Array.isArray(h))
      for (let m = h.length - 1; m >= 0; m -= 1)
        e.params.virtual.cache && (delete e.virtual.cache[h[m]], Object.keys(e.virtual.cache).forEach((v) => {
          v > h && (e.virtual.cache[v - 1] = e.virtual.cache[v], e.virtual.cache[v - 1].setAttribute("data-swiper-slide-index", v - 1), delete e.virtual.cache[v]);
        })), e.virtual.slides.splice(h[m], 1), h[m] < g && (g -= 1), g = Math.max(g, 0);
    else
      e.params.virtual.cache && (delete e.virtual.cache[h], Object.keys(e.virtual.cache).forEach((m) => {
        m > h && (e.virtual.cache[m - 1] = e.virtual.cache[m], e.virtual.cache[m - 1].setAttribute("data-swiper-slide-index", m - 1), delete e.virtual.cache[m]);
      })), e.virtual.slides.splice(h, 1), h < g && (g -= 1), g = Math.max(g, 0);
    c(!0), e.slideTo(g, 0);
  }
  function p() {
    e.virtual.slides = [], e.params.virtual.cache && (e.virtual.cache = {}), c(!0), e.slideTo(0, 0);
  }
  i("beforeInit", () => {
    if (!e.params.virtual.enabled) return;
    let h;
    if (typeof e.passedParams.virtual.slides > "u") {
      const g = [...e.slidesEl.children].filter((m) => m.matches(`.${e.params.slideClass}, swiper-slide`));
      g && g.length && (e.virtual.slides = [...g], h = !0, g.forEach((m, v) => {
        m.setAttribute("data-swiper-slide-index", v), e.virtual.cache[v] = m, m.remove();
      }));
    }
    h || (e.virtual.slides = e.params.virtual.slides), e.classNames.push(`${e.params.containerModifierClass}virtual`), e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0, c(!1, !0);
  }), i("setTranslate", () => {
    e.params.virtual.enabled && (e.params.cssMode && !e._immediateVirtual ? (clearTimeout(r), r = setTimeout(() => {
      c();
    }, 100)) : c());
  }), i("init update resize", () => {
    e.params.virtual.enabled && e.params.cssMode && Bn(e.wrapperEl, "--swiper-virtual-size", `${e.virtualSize}px`);
  }), Object.assign(e.virtual, {
    appendSlide: u,
    prependSlide: d,
    removeSlide: f,
    removeAllSlides: p,
    update: c
  });
}
function b_(n) {
  let {
    swiper: e,
    extendParams: t,
    on: i,
    emit: s
  } = n;
  const r = _t(), a = qe();
  e.keyboard = {
    enabled: !1
  }, t({
    keyboard: {
      enabled: !1,
      onlyInViewport: !0,
      pageUpDown: !0
    }
  });
  function o(u) {
    if (!e.enabled) return;
    const {
      rtlTranslate: d
    } = e;
    let f = u;
    f.originalEvent && (f = f.originalEvent);
    const p = f.keyCode || f.charCode, h = e.params.keyboard.pageUpDown, g = h && p === 33, m = h && p === 34, v = p === 37, y = p === 39, E = p === 38, T = p === 40;
    if (!e.allowSlideNext && (e.isHorizontal() && y || e.isVertical() && T || m) || !e.allowSlidePrev && (e.isHorizontal() && v || e.isVertical() && E || g))
      return !1;
    if (!(f.shiftKey || f.altKey || f.ctrlKey || f.metaKey) && !(r.activeElement && (r.activeElement.isContentEditable || r.activeElement.nodeName && (r.activeElement.nodeName.toLowerCase() === "input" || r.activeElement.nodeName.toLowerCase() === "textarea")))) {
      if (e.params.keyboard.onlyInViewport && (g || m || v || y || E || T)) {
        let S = !1;
        if (_r(e.el, `.${e.params.slideClass}, swiper-slide`).length > 0 && _r(e.el, `.${e.params.slideActiveClass}`).length === 0)
          return;
        const w = e.el, b = w.clientWidth, L = w.clientHeight, A = a.innerWidth, _ = a.innerHeight, R = qo(w);
        d && (R.left -= w.scrollLeft);
        const I = [[R.left, R.top], [R.left + b, R.top], [R.left, R.top + L], [R.left + b, R.top + L]];
        for (let k = 0; k < I.length; k += 1) {
          const M = I[k];
          if (M[0] >= 0 && M[0] <= A && M[1] >= 0 && M[1] <= _) {
            if (M[0] === 0 && M[1] === 0) continue;
            S = !0;
          }
        }
        if (!S) return;
      }
      e.isHorizontal() ? ((g || m || v || y) && (f.preventDefault ? f.preventDefault() : f.returnValue = !1), ((m || y) && !d || (g || v) && d) && e.slideNext(), ((g || v) && !d || (m || y) && d) && e.slidePrev()) : ((g || m || E || T) && (f.preventDefault ? f.preventDefault() : f.returnValue = !1), (m || T) && e.slideNext(), (g || E) && e.slidePrev()), s("keyPress", p);
    }
  }
  function l() {
    e.keyboard.enabled || (r.addEventListener("keydown", o), e.keyboard.enabled = !0);
  }
  function c() {
    e.keyboard.enabled && (r.removeEventListener("keydown", o), e.keyboard.enabled = !1);
  }
  i("init", () => {
    e.params.keyboard.enabled && l();
  }), i("destroy", () => {
    e.keyboard.enabled && c();
  }), Object.assign(e.keyboard, {
    enable: l,
    disable: c
  });
}
function __(n) {
  let {
    swiper: e,
    extendParams: t,
    on: i,
    emit: s
  } = n;
  const r = qe();
  t({
    mousewheel: {
      enabled: !1,
      releaseOnEdges: !1,
      invert: !1,
      forceToAxis: !1,
      sensitivity: 1,
      eventsTarget: "container",
      thresholdDelta: null,
      thresholdTime: null,
      noMousewheelClass: "swiper-no-mousewheel"
    }
  }), e.mousewheel = {
    enabled: !1
  };
  let a, o = Ci(), l;
  const c = [];
  function u(E) {
    let b = 0, L = 0, A = 0, _ = 0;
    return "detail" in E && (L = E.detail), "wheelDelta" in E && (L = -E.wheelDelta / 120), "wheelDeltaY" in E && (L = -E.wheelDeltaY / 120), "wheelDeltaX" in E && (b = -E.wheelDeltaX / 120), "axis" in E && E.axis === E.HORIZONTAL_AXIS && (b = L, L = 0), A = b * 10, _ = L * 10, "deltaY" in E && (_ = E.deltaY), "deltaX" in E && (A = E.deltaX), E.shiftKey && !A && (A = _, _ = 0), (A || _) && E.deltaMode && (E.deltaMode === 1 ? (A *= 40, _ *= 40) : (A *= 800, _ *= 800)), A && !b && (b = A < 1 ? -1 : 1), _ && !L && (L = _ < 1 ? -1 : 1), {
      spinX: b,
      spinY: L,
      pixelX: A,
      pixelY: _
    };
  }
  function d() {
    e.enabled && (e.mouseEntered = !0);
  }
  function f() {
    e.enabled && (e.mouseEntered = !1);
  }
  function p(E) {
    return e.params.mousewheel.thresholdDelta && E.delta < e.params.mousewheel.thresholdDelta || e.params.mousewheel.thresholdTime && Ci() - o < e.params.mousewheel.thresholdTime ? !1 : E.delta >= 6 && Ci() - o < 60 ? !0 : (E.direction < 0 ? (!e.isEnd || e.params.loop) && !e.animating && (e.slideNext(), s("scroll", E.raw)) : (!e.isBeginning || e.params.loop) && !e.animating && (e.slidePrev(), s("scroll", E.raw)), o = new r.Date().getTime(), !1);
  }
  function h(E) {
    const T = e.params.mousewheel;
    if (E.direction < 0) {
      if (e.isEnd && !e.params.loop && T.releaseOnEdges)
        return !0;
    } else if (e.isBeginning && !e.params.loop && T.releaseOnEdges)
      return !0;
    return !1;
  }
  function g(E) {
    let T = E, S = !0;
    if (!e.enabled || E.target.closest(`.${e.params.mousewheel.noMousewheelClass}`)) return;
    const w = e.params.mousewheel;
    e.params.cssMode && T.preventDefault();
    let b = e.el;
    e.params.mousewheel.eventsTarget !== "container" && (b = document.querySelector(e.params.mousewheel.eventsTarget));
    const L = b && b.contains(T.target);
    if (!e.mouseEntered && !L && !w.releaseOnEdges) return !0;
    T.originalEvent && (T = T.originalEvent);
    let A = 0;
    const _ = e.rtlTranslate ? -1 : 1, R = u(T);
    if (w.forceToAxis)
      if (e.isHorizontal())
        if (Math.abs(R.pixelX) > Math.abs(R.pixelY)) A = -R.pixelX * _;
        else return !0;
      else if (Math.abs(R.pixelY) > Math.abs(R.pixelX)) A = -R.pixelY;
      else return !0;
    else
      A = Math.abs(R.pixelX) > Math.abs(R.pixelY) ? -R.pixelX * _ : -R.pixelY;
    if (A === 0) return !0;
    w.invert && (A = -A);
    let I = e.getTranslate() + A * w.sensitivity;
    if (I >= e.minTranslate() && (I = e.minTranslate()), I <= e.maxTranslate() && (I = e.maxTranslate()), S = e.params.loop ? !0 : !(I === e.minTranslate() || I === e.maxTranslate()), S && e.params.nested && T.stopPropagation(), !e.params.freeMode || !e.params.freeMode.enabled) {
      const k = {
        time: Ci(),
        delta: Math.abs(A),
        direction: Math.sign(A),
        raw: E
      };
      c.length >= 2 && c.shift();
      const M = c.length ? c[c.length - 1] : void 0;
      if (c.push(k), M ? (k.direction !== M.direction || k.delta > M.delta || k.time > M.time + 150) && p(k) : p(k), h(k))
        return !0;
    } else {
      const k = {
        time: Ci(),
        delta: Math.abs(A),
        direction: Math.sign(A)
      }, M = l && k.time < l.time + 500 && k.delta <= l.delta && k.direction === l.direction;
      if (!M) {
        l = void 0;
        let O = e.getTranslate() + A * w.sensitivity;
        const F = e.isBeginning, C = e.isEnd;
        if (O >= e.minTranslate() && (O = e.minTranslate()), O <= e.maxTranslate() && (O = e.maxTranslate()), e.setTransition(0), e.setTranslate(O), e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses(), (!F && e.isBeginning || !C && e.isEnd) && e.updateSlidesClasses(), e.params.loop && e.loopFix({
          direction: k.direction < 0 ? "next" : "prev",
          byMousewheel: !0
        }), e.params.freeMode.sticky) {
          clearTimeout(a), a = void 0, c.length >= 15 && c.shift();
          const D = c.length ? c[c.length - 1] : void 0, B = c[0];
          if (c.push(k), D && (k.delta > D.delta || k.direction !== D.direction))
            c.splice(0);
          else if (c.length >= 15 && k.time - B.time < 500 && B.delta - k.delta >= 1 && k.delta <= 6) {
            const P = A > 0 ? 0.8 : 0.2;
            l = k, c.splice(0), a = yn(() => {
              e.destroyed || !e.params || e.slideToClosest(e.params.speed, !0, void 0, P);
            }, 0);
          }
          a || (a = yn(() => {
            if (e.destroyed || !e.params) return;
            const P = 0.5;
            l = k, c.splice(0), e.slideToClosest(e.params.speed, !0, void 0, P);
          }, 500));
        }
        if (M || s("scroll", T), e.params.autoplay && e.params.autoplay.disableOnInteraction && e.autoplay.stop(), w.releaseOnEdges && (O === e.minTranslate() || O === e.maxTranslate()))
          return !0;
      }
    }
    return T.preventDefault ? T.preventDefault() : T.returnValue = !1, !1;
  }
  function m(E) {
    let T = e.el;
    e.params.mousewheel.eventsTarget !== "container" && (T = document.querySelector(e.params.mousewheel.eventsTarget)), T[E]("mouseenter", d), T[E]("mouseleave", f), T[E]("wheel", g);
  }
  function v() {
    return e.params.cssMode ? (e.wrapperEl.removeEventListener("wheel", g), !0) : e.mousewheel.enabled ? !1 : (m("addEventListener"), e.mousewheel.enabled = !0, !0);
  }
  function y() {
    return e.params.cssMode ? (e.wrapperEl.addEventListener(event, g), !0) : e.mousewheel.enabled ? (m("removeEventListener"), e.mousewheel.enabled = !1, !0) : !1;
  }
  i("init", () => {
    !e.params.mousewheel.enabled && e.params.cssMode && y(), e.params.mousewheel.enabled && v();
  }), i("destroy", () => {
    e.params.cssMode && v(), e.mousewheel.enabled && y();
  }), Object.assign(e.mousewheel, {
    enable: v,
    disable: y
  });
}
function td(n, e, t, i) {
  return n.params.createElements && Object.keys(i).forEach((s) => {
    if (!t[s] && t.auto === !0) {
      let r = Dt(n.el, `.${i[s]}`)[0];
      r || (r = Si("div", i[s]), r.className = i[s], n.el.append(r)), t[s] = r, e[s] = r;
    }
  }), t;
}
function A_(n) {
  let {
    swiper: e,
    extendParams: t,
    on: i,
    emit: s
  } = n;
  t({
    navigation: {
      nextEl: null,
      prevEl: null,
      hideOnClick: !1,
      disabledClass: "swiper-button-disabled",
      hiddenClass: "swiper-button-hidden",
      lockClass: "swiper-button-lock",
      navigationDisabledClass: "swiper-navigation-disabled"
    }
  }), e.navigation = {
    nextEl: null,
    prevEl: null
  };
  function r(h) {
    let g;
    return h && typeof h == "string" && e.isElement && (g = e.el.querySelector(h) || e.hostEl.querySelector(h), g) ? g : (h && (typeof h == "string" && (g = [...document.querySelectorAll(h)]), e.params.uniqueNavElements && typeof h == "string" && g && g.length > 1 && e.el.querySelectorAll(h).length === 1 ? g = e.el.querySelector(h) : g && g.length === 1 && (g = g[0])), h && !g ? h : g);
  }
  function a(h, g) {
    const m = e.params.navigation;
    h = be(h), h.forEach((v) => {
      v && (v.classList[g ? "add" : "remove"](...m.disabledClass.split(" ")), v.tagName === "BUTTON" && (v.disabled = g), e.params.watchOverflow && e.enabled && v.classList[e.isLocked ? "add" : "remove"](m.lockClass));
    });
  }
  function o() {
    const {
      nextEl: h,
      prevEl: g
    } = e.navigation;
    if (e.params.loop) {
      a(g, !1), a(h, !1);
      return;
    }
    a(g, e.isBeginning && !e.params.rewind), a(h, e.isEnd && !e.params.rewind);
  }
  function l(h) {
    h.preventDefault(), !(e.isBeginning && !e.params.loop && !e.params.rewind) && (e.slidePrev(), s("navigationPrev"));
  }
  function c(h) {
    h.preventDefault(), !(e.isEnd && !e.params.loop && !e.params.rewind) && (e.slideNext(), s("navigationNext"));
  }
  function u() {
    const h = e.params.navigation;
    if (e.params.navigation = td(e, e.originalParams.navigation, e.params.navigation, {
      nextEl: "swiper-button-next",
      prevEl: "swiper-button-prev"
    }), !(h.nextEl || h.prevEl)) return;
    let g = r(h.nextEl), m = r(h.prevEl);
    Object.assign(e.navigation, {
      nextEl: g,
      prevEl: m
    }), g = be(g), m = be(m);
    const v = (y, E) => {
      y && y.addEventListener("click", E === "next" ? c : l), !e.enabled && y && y.classList.add(...h.lockClass.split(" "));
    };
    g.forEach((y) => v(y, "next")), m.forEach((y) => v(y, "prev"));
  }
  function d() {
    let {
      nextEl: h,
      prevEl: g
    } = e.navigation;
    h = be(h), g = be(g);
    const m = (v, y) => {
      v.removeEventListener("click", y === "next" ? c : l), v.classList.remove(...e.params.navigation.disabledClass.split(" "));
    };
    h.forEach((v) => m(v, "next")), g.forEach((v) => m(v, "prev"));
  }
  i("init", () => {
    e.params.navigation.enabled === !1 ? p() : (u(), o());
  }), i("toEdge fromEdge lock unlock", () => {
    o();
  }), i("destroy", () => {
    d();
  }), i("enable disable", () => {
    let {
      nextEl: h,
      prevEl: g
    } = e.navigation;
    if (h = be(h), g = be(g), e.enabled) {
      o();
      return;
    }
    [...h, ...g].filter((m) => !!m).forEach((m) => m.classList.add(e.params.navigation.lockClass));
  }), i("click", (h, g) => {
    let {
      nextEl: m,
      prevEl: v
    } = e.navigation;
    m = be(m), v = be(v);
    const y = g.target;
    let E = v.includes(y) || m.includes(y);
    if (e.isElement && !E) {
      const T = g.path || g.composedPath && g.composedPath();
      T && (E = T.find((S) => m.includes(S) || v.includes(S)));
    }
    if (e.params.navigation.hideOnClick && !E) {
      if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === y || e.pagination.el.contains(y))) return;
      let T;
      m.length ? T = m[0].classList.contains(e.params.navigation.hiddenClass) : v.length && (T = v[0].classList.contains(e.params.navigation.hiddenClass)), s(T === !0 ? "navigationShow" : "navigationHide"), [...m, ...v].filter((S) => !!S).forEach((S) => S.classList.toggle(e.params.navigation.hiddenClass));
    }
  });
  const f = () => {
    e.el.classList.remove(...e.params.navigation.navigationDisabledClass.split(" ")), u(), o();
  }, p = () => {
    e.el.classList.add(...e.params.navigation.navigationDisabledClass.split(" ")), d();
  };
  Object.assign(e.navigation, {
    enable: f,
    disable: p,
    update: o,
    init: u,
    destroy: d
  });
}
function Ts(n) {
  return n === void 0 && (n = ""), `.${n.trim().replace(/([\.:!+\/()[\]])/g, "\\$1").replace(/ /g, ".")}`;
}
function w_(n) {
  let {
    swiper: e,
    extendParams: t,
    on: i,
    emit: s
  } = n;
  const r = "swiper-pagination";
  t({
    pagination: {
      el: null,
      bulletElement: "span",
      clickable: !1,
      hideOnClick: !1,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: !1,
      type: "bullets",
      // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: !1,
      dynamicMainBullets: 1,
      formatFractionCurrent: (y) => y,
      formatFractionTotal: (y) => y,
      bulletClass: `${r}-bullet`,
      bulletActiveClass: `${r}-bullet-active`,
      modifierClass: `${r}-`,
      currentClass: `${r}-current`,
      totalClass: `${r}-total`,
      hiddenClass: `${r}-hidden`,
      progressbarFillClass: `${r}-progressbar-fill`,
      progressbarOppositeClass: `${r}-progressbar-opposite`,
      clickableClass: `${r}-clickable`,
      lockClass: `${r}-lock`,
      horizontalClass: `${r}-horizontal`,
      verticalClass: `${r}-vertical`,
      paginationDisabledClass: `${r}-disabled`
    }
  }), e.pagination = {
    el: null,
    bullets: []
  };
  let a, o = 0;
  function l() {
    return !e.params.pagination.el || !e.pagination.el || Array.isArray(e.pagination.el) && e.pagination.el.length === 0;
  }
  function c(y, E) {
    const {
      bulletActiveClass: T
    } = e.params.pagination;
    y && (y = y[`${E === "prev" ? "previous" : "next"}ElementSibling`], y && (y.classList.add(`${T}-${E}`), y = y[`${E === "prev" ? "previous" : "next"}ElementSibling`], y && y.classList.add(`${T}-${E}-${E}`)));
  }
  function u(y, E, T) {
    if (y = y % T, E = E % T, E === y + 1)
      return "next";
    if (E === y - 1)
      return "previous";
  }
  function d(y) {
    const E = y.target.closest(Ts(e.params.pagination.bulletClass));
    if (!E)
      return;
    y.preventDefault();
    const T = Ta(E) * e.params.slidesPerGroup;
    if (e.params.loop) {
      if (e.realIndex === T) return;
      const S = u(e.realIndex, T, e.slides.length);
      S === "next" ? e.slideNext() : S === "previous" ? e.slidePrev() : e.slideToLoop(T);
    } else
      e.slideTo(T);
  }
  function f() {
    const y = e.rtl, E = e.params.pagination;
    if (l()) return;
    let T = e.pagination.el;
    T = be(T);
    let S, w;
    const b = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, L = e.params.loop ? Math.ceil(b / e.params.slidesPerGroup) : e.snapGrid.length;
    if (e.params.loop ? (w = e.previousRealIndex || 0, S = e.params.slidesPerGroup > 1 ? Math.floor(e.realIndex / e.params.slidesPerGroup) : e.realIndex) : typeof e.snapIndex < "u" ? (S = e.snapIndex, w = e.previousSnapIndex) : (w = e.previousIndex || 0, S = e.activeIndex || 0), E.type === "bullets" && e.pagination.bullets && e.pagination.bullets.length > 0) {
      const A = e.pagination.bullets;
      let _, R, I;
      if (E.dynamicBullets && (a = Qc(A[0], e.isHorizontal() ? "width" : "height"), T.forEach((k) => {
        k.style[e.isHorizontal() ? "width" : "height"] = `${a * (E.dynamicMainBullets + 4)}px`;
      }), E.dynamicMainBullets > 1 && w !== void 0 && (o += S - (w || 0), o > E.dynamicMainBullets - 1 ? o = E.dynamicMainBullets - 1 : o < 0 && (o = 0)), _ = Math.max(S - o, 0), R = _ + (Math.min(A.length, E.dynamicMainBullets) - 1), I = (R + _) / 2), A.forEach((k) => {
        const M = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((O) => `${E.bulletActiveClass}${O}`)].map((O) => typeof O == "string" && O.includes(" ") ? O.split(" ") : O).flat();
        k.classList.remove(...M);
      }), T.length > 1)
        A.forEach((k) => {
          const M = Ta(k);
          M === S ? k.classList.add(...E.bulletActiveClass.split(" ")) : e.isElement && k.setAttribute("part", "bullet"), E.dynamicBullets && (M >= _ && M <= R && k.classList.add(...`${E.bulletActiveClass}-main`.split(" ")), M === _ && c(k, "prev"), M === R && c(k, "next"));
        });
      else {
        const k = A[S];
        if (k && k.classList.add(...E.bulletActiveClass.split(" ")), e.isElement && A.forEach((M, O) => {
          M.setAttribute("part", O === S ? "bullet-active" : "bullet");
        }), E.dynamicBullets) {
          const M = A[_], O = A[R];
          for (let F = _; F <= R; F += 1)
            A[F] && A[F].classList.add(...`${E.bulletActiveClass}-main`.split(" "));
          c(M, "prev"), c(O, "next");
        }
      }
      if (E.dynamicBullets) {
        const k = Math.min(A.length, E.dynamicMainBullets + 4), M = (a * k - a) / 2 - I * a, O = y ? "right" : "left";
        A.forEach((F) => {
          F.style[e.isHorizontal() ? O : "top"] = `${M}px`;
        });
      }
    }
    T.forEach((A, _) => {
      if (E.type === "fraction" && (A.querySelectorAll(Ts(E.currentClass)).forEach((R) => {
        R.textContent = E.formatFractionCurrent(S + 1);
      }), A.querySelectorAll(Ts(E.totalClass)).forEach((R) => {
        R.textContent = E.formatFractionTotal(L);
      })), E.type === "progressbar") {
        let R;
        E.progressbarOpposite ? R = e.isHorizontal() ? "vertical" : "horizontal" : R = e.isHorizontal() ? "horizontal" : "vertical";
        const I = (S + 1) / L;
        let k = 1, M = 1;
        R === "horizontal" ? k = I : M = I, A.querySelectorAll(Ts(E.progressbarFillClass)).forEach((O) => {
          O.style.transform = `translate3d(0,0,0) scaleX(${k}) scaleY(${M})`, O.style.transitionDuration = `${e.params.speed}ms`;
        });
      }
      E.type === "custom" && E.renderCustom ? (As(A, E.renderCustom(e, S + 1, L)), _ === 0 && s("paginationRender", A)) : (_ === 0 && s("paginationRender", A), s("paginationUpdate", A)), e.params.watchOverflow && e.enabled && A.classList[e.isLocked ? "add" : "remove"](E.lockClass);
    });
  }
  function p() {
    const y = e.params.pagination;
    if (l()) return;
    const E = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.grid && e.params.grid.rows > 1 ? e.slides.length / Math.ceil(e.params.grid.rows) : e.slides.length;
    let T = e.pagination.el;
    T = be(T);
    let S = "";
    if (y.type === "bullets") {
      let w = e.params.loop ? Math.ceil(E / e.params.slidesPerGroup) : e.snapGrid.length;
      e.params.freeMode && e.params.freeMode.enabled && w > E && (w = E);
      for (let b = 0; b < w; b += 1)
        y.renderBullet ? S += y.renderBullet.call(e, b, y.bulletClass) : S += `<${y.bulletElement} ${e.isElement ? 'part="bullet"' : ""} class="${y.bulletClass}"></${y.bulletElement}>`;
    }
    y.type === "fraction" && (y.renderFraction ? S = y.renderFraction.call(e, y.currentClass, y.totalClass) : S = `<span class="${y.currentClass}"></span> / <span class="${y.totalClass}"></span>`), y.type === "progressbar" && (y.renderProgressbar ? S = y.renderProgressbar.call(e, y.progressbarFillClass) : S = `<span class="${y.progressbarFillClass}"></span>`), e.pagination.bullets = [], T.forEach((w) => {
      y.type !== "custom" && As(w, S || ""), y.type === "bullets" && e.pagination.bullets.push(...w.querySelectorAll(Ts(y.bulletClass)));
    }), y.type !== "custom" && s("paginationRender", T[0]);
  }
  function h() {
    e.params.pagination = td(e, e.originalParams.pagination, e.params.pagination, {
      el: "swiper-pagination"
    });
    const y = e.params.pagination;
    if (!y.el) return;
    let E;
    typeof y.el == "string" && e.isElement && (E = e.el.querySelector(y.el)), !E && typeof y.el == "string" && (E = [...document.querySelectorAll(y.el)]), E || (E = y.el), !(!E || E.length === 0) && (e.params.uniqueNavElements && typeof y.el == "string" && Array.isArray(E) && E.length > 1 && (E = [...e.el.querySelectorAll(y.el)], E.length > 1 && (E = E.find((T) => _r(T, ".swiper")[0] === e.el))), Array.isArray(E) && E.length === 1 && (E = E[0]), Object.assign(e.pagination, {
      el: E
    }), E = be(E), E.forEach((T) => {
      y.type === "bullets" && y.clickable && T.classList.add(...(y.clickableClass || "").split(" ")), T.classList.add(y.modifierClass + y.type), T.classList.add(e.isHorizontal() ? y.horizontalClass : y.verticalClass), y.type === "bullets" && y.dynamicBullets && (T.classList.add(`${y.modifierClass}${y.type}-dynamic`), o = 0, y.dynamicMainBullets < 1 && (y.dynamicMainBullets = 1)), y.type === "progressbar" && y.progressbarOpposite && T.classList.add(y.progressbarOppositeClass), y.clickable && T.addEventListener("click", d), e.enabled || T.classList.add(y.lockClass);
    }));
  }
  function g() {
    const y = e.params.pagination;
    if (l()) return;
    let E = e.pagination.el;
    E && (E = be(E), E.forEach((T) => {
      T.classList.remove(y.hiddenClass), T.classList.remove(y.modifierClass + y.type), T.classList.remove(e.isHorizontal() ? y.horizontalClass : y.verticalClass), y.clickable && (T.classList.remove(...(y.clickableClass || "").split(" ")), T.removeEventListener("click", d));
    })), e.pagination.bullets && e.pagination.bullets.forEach((T) => T.classList.remove(...y.bulletActiveClass.split(" ")));
  }
  i("changeDirection", () => {
    if (!e.pagination || !e.pagination.el) return;
    const y = e.params.pagination;
    let {
      el: E
    } = e.pagination;
    E = be(E), E.forEach((T) => {
      T.classList.remove(y.horizontalClass, y.verticalClass), T.classList.add(e.isHorizontal() ? y.horizontalClass : y.verticalClass);
    });
  }), i("init", () => {
    e.params.pagination.enabled === !1 ? v() : (h(), p(), f());
  }), i("activeIndexChange", () => {
    typeof e.snapIndex > "u" && f();
  }), i("snapIndexChange", () => {
    f();
  }), i("snapGridLengthChange", () => {
    p(), f();
  }), i("destroy", () => {
    g();
  }), i("enable disable", () => {
    let {
      el: y
    } = e.pagination;
    y && (y = be(y), y.forEach((E) => E.classList[e.enabled ? "remove" : "add"](e.params.pagination.lockClass)));
  }), i("lock unlock", () => {
    f();
  }), i("click", (y, E) => {
    const T = E.target, S = be(e.pagination.el);
    if (e.params.pagination.el && e.params.pagination.hideOnClick && S && S.length > 0 && !T.classList.contains(e.params.pagination.bulletClass)) {
      if (e.navigation && (e.navigation.nextEl && T === e.navigation.nextEl || e.navigation.prevEl && T === e.navigation.prevEl)) return;
      const w = S[0].classList.contains(e.params.pagination.hiddenClass);
      s(w === !0 ? "paginationShow" : "paginationHide"), S.forEach((b) => b.classList.toggle(e.params.pagination.hiddenClass));
    }
  });
  const m = () => {
    e.el.classList.remove(e.params.pagination.paginationDisabledClass);
    let {
      el: y
    } = e.pagination;
    y && (y = be(y), y.forEach((E) => E.classList.remove(e.params.pagination.paginationDisabledClass))), h(), p(), f();
  }, v = () => {
    e.el.classList.add(e.params.pagination.paginationDisabledClass);
    let {
      el: y
    } = e.pagination;
    y && (y = be(y), y.forEach((E) => E.classList.add(e.params.pagination.paginationDisabledClass))), g();
  };
  Object.assign(e.pagination, {
    enable: m,
    disable: v,
    render: p,
    update: f,
    init: h,
    destroy: g
  });
}
function L_(n) {
  let {
    swiper: e,
    extendParams: t,
    on: i,
    emit: s
  } = n;
  const r = _t();
  let a = !1, o = null, l = null, c, u, d, f;
  t({
    scrollbar: {
      el: null,
      dragSize: "auto",
      hide: !1,
      draggable: !1,
      snapOnRelease: !0,
      lockClass: "swiper-scrollbar-lock",
      dragClass: "swiper-scrollbar-drag",
      scrollbarDisabledClass: "swiper-scrollbar-disabled",
      horizontalClass: "swiper-scrollbar-horizontal",
      verticalClass: "swiper-scrollbar-vertical"
    }
  }), e.scrollbar = {
    el: null,
    dragEl: null
  };
  function p() {
    if (!e.params.scrollbar.el || !e.scrollbar.el) return;
    const {
      scrollbar: I,
      rtlTranslate: k
    } = e, {
      dragEl: M,
      el: O
    } = I, F = e.params.scrollbar, C = e.params.loop ? e.progressLoop : e.progress;
    let D = u, B = (d - u) * C;
    k ? (B = -B, B > 0 ? (D = u - B, B = 0) : -B + u > d && (D = d + B)) : B < 0 ? (D = u + B, B = 0) : B + u > d && (D = d - B), e.isHorizontal() ? (M.style.transform = `translate3d(${B}px, 0, 0)`, M.style.width = `${D}px`) : (M.style.transform = `translate3d(0px, ${B}px, 0)`, M.style.height = `${D}px`), F.hide && (clearTimeout(o), O.style.opacity = 1, o = setTimeout(() => {
      O.style.opacity = 0, O.style.transitionDuration = "400ms";
    }, 1e3));
  }
  function h(I) {
    !e.params.scrollbar.el || !e.scrollbar.el || (e.scrollbar.dragEl.style.transitionDuration = `${I}ms`);
  }
  function g() {
    if (!e.params.scrollbar.el || !e.scrollbar.el) return;
    const {
      scrollbar: I
    } = e, {
      dragEl: k,
      el: M
    } = I;
    k.style.width = "", k.style.height = "", d = e.isHorizontal() ? M.offsetWidth : M.offsetHeight, f = e.size / (e.virtualSize + e.params.slidesOffsetBefore - (e.params.centeredSlides ? e.snapGrid[0] : 0)), e.params.scrollbar.dragSize === "auto" ? u = d * f : u = parseInt(e.params.scrollbar.dragSize, 10), e.isHorizontal() ? k.style.width = `${u}px` : k.style.height = `${u}px`, f >= 1 ? M.style.display = "none" : M.style.display = "", e.params.scrollbar.hide && (M.style.opacity = 0), e.params.watchOverflow && e.enabled && I.el.classList[e.isLocked ? "add" : "remove"](e.params.scrollbar.lockClass);
  }
  function m(I) {
    return e.isHorizontal() ? I.clientX : I.clientY;
  }
  function v(I) {
    const {
      scrollbar: k,
      rtlTranslate: M
    } = e, {
      el: O
    } = k;
    let F;
    F = (m(I) - qo(O)[e.isHorizontal() ? "left" : "top"] - (c !== null ? c : u / 2)) / (d - u), F = Math.max(Math.min(F, 1), 0), M && (F = 1 - F);
    const C = e.minTranslate() + (e.maxTranslate() - e.minTranslate()) * F;
    e.updateProgress(C), e.setTranslate(C), e.updateActiveIndex(), e.updateSlidesClasses();
  }
  function y(I) {
    const k = e.params.scrollbar, {
      scrollbar: M,
      wrapperEl: O
    } = e, {
      el: F,
      dragEl: C
    } = M;
    a = !0, c = I.target === C ? m(I) - I.target.getBoundingClientRect()[e.isHorizontal() ? "left" : "top"] : null, I.preventDefault(), I.stopPropagation(), O.style.transitionDuration = "100ms", C.style.transitionDuration = "100ms", v(I), clearTimeout(l), F.style.transitionDuration = "0ms", k.hide && (F.style.opacity = 1), e.params.cssMode && (e.wrapperEl.style["scroll-snap-type"] = "none"), s("scrollbarDragStart", I);
  }
  function E(I) {
    const {
      scrollbar: k,
      wrapperEl: M
    } = e, {
      el: O,
      dragEl: F
    } = k;
    a && (I.preventDefault && I.cancelable ? I.preventDefault() : I.returnValue = !1, v(I), M.style.transitionDuration = "0ms", O.style.transitionDuration = "0ms", F.style.transitionDuration = "0ms", s("scrollbarDragMove", I));
  }
  function T(I) {
    const k = e.params.scrollbar, {
      scrollbar: M,
      wrapperEl: O
    } = e, {
      el: F
    } = M;
    a && (a = !1, e.params.cssMode && (e.wrapperEl.style["scroll-snap-type"] = "", O.style.transitionDuration = ""), k.hide && (clearTimeout(l), l = yn(() => {
      F.style.opacity = 0, F.style.transitionDuration = "400ms";
    }, 1e3)), s("scrollbarDragEnd", I), k.snapOnRelease && e.slideToClosest());
  }
  function S(I) {
    const {
      scrollbar: k,
      params: M
    } = e, O = k.el;
    if (!O) return;
    const F = O, C = M.passiveListeners ? {
      passive: !1,
      capture: !1
    } : !1, D = M.passiveListeners ? {
      passive: !0,
      capture: !1
    } : !1;
    if (!F) return;
    const B = I === "on" ? "addEventListener" : "removeEventListener";
    F[B]("pointerdown", y, C), r[B]("pointermove", E, C), r[B]("pointerup", T, D);
  }
  function w() {
    !e.params.scrollbar.el || !e.scrollbar.el || S("on");
  }
  function b() {
    !e.params.scrollbar.el || !e.scrollbar.el || S("off");
  }
  function L() {
    const {
      scrollbar: I,
      el: k
    } = e;
    e.params.scrollbar = td(e, e.originalParams.scrollbar, e.params.scrollbar, {
      el: "swiper-scrollbar"
    });
    const M = e.params.scrollbar;
    if (!M.el) return;
    let O;
    if (typeof M.el == "string" && e.isElement && (O = e.el.querySelector(M.el)), !O && typeof M.el == "string") {
      if (O = r.querySelectorAll(M.el), !O.length) return;
    } else O || (O = M.el);
    e.params.uniqueNavElements && typeof M.el == "string" && O.length > 1 && k.querySelectorAll(M.el).length === 1 && (O = k.querySelector(M.el)), O.length > 0 && (O = O[0]), O.classList.add(e.isHorizontal() ? M.horizontalClass : M.verticalClass);
    let F;
    O && (F = O.querySelector(Ts(e.params.scrollbar.dragClass)), F || (F = Si("div", e.params.scrollbar.dragClass), O.append(F))), Object.assign(I, {
      el: O,
      dragEl: F
    }), M.draggable && w(), O && O.classList[e.enabled ? "remove" : "add"](...Ds(e.params.scrollbar.lockClass));
  }
  function A() {
    const I = e.params.scrollbar, k = e.scrollbar.el;
    k && k.classList.remove(...Ds(e.isHorizontal() ? I.horizontalClass : I.verticalClass)), b();
  }
  i("changeDirection", () => {
    if (!e.scrollbar || !e.scrollbar.el) return;
    const I = e.params.scrollbar;
    let {
      el: k
    } = e.scrollbar;
    k = be(k), k.forEach((M) => {
      M.classList.remove(I.horizontalClass, I.verticalClass), M.classList.add(e.isHorizontal() ? I.horizontalClass : I.verticalClass);
    });
  }), i("init", () => {
    e.params.scrollbar.enabled === !1 ? R() : (L(), g(), p());
  }), i("update resize observerUpdate lock unlock changeDirection", () => {
    g();
  }), i("setTranslate", () => {
    p();
  }), i("setTransition", (I, k) => {
    h(k);
  }), i("enable disable", () => {
    const {
      el: I
    } = e.scrollbar;
    I && I.classList[e.enabled ? "remove" : "add"](...Ds(e.params.scrollbar.lockClass));
  }), i("destroy", () => {
    A();
  });
  const _ = () => {
    e.el.classList.remove(...Ds(e.params.scrollbar.scrollbarDisabledClass)), e.scrollbar.el && e.scrollbar.el.classList.remove(...Ds(e.params.scrollbar.scrollbarDisabledClass)), L(), g(), p();
  }, R = () => {
    e.el.classList.add(...Ds(e.params.scrollbar.scrollbarDisabledClass)), e.scrollbar.el && e.scrollbar.el.classList.add(...Ds(e.params.scrollbar.scrollbarDisabledClass)), A();
  };
  Object.assign(e.scrollbar, {
    enable: _,
    disable: R,
    updateSize: g,
    setTranslate: p,
    init: L,
    destroy: A
  });
}
function I_(n) {
  let {
    swiper: e,
    extendParams: t,
    on: i
  } = n;
  t({
    parallax: {
      enabled: !1
    }
  });
  const s = "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]", r = (l, c) => {
    const {
      rtl: u
    } = e, d = u ? -1 : 1, f = l.getAttribute("data-swiper-parallax") || "0";
    let p = l.getAttribute("data-swiper-parallax-x"), h = l.getAttribute("data-swiper-parallax-y");
    const g = l.getAttribute("data-swiper-parallax-scale"), m = l.getAttribute("data-swiper-parallax-opacity"), v = l.getAttribute("data-swiper-parallax-rotate");
    if (p || h ? (p = p || "0", h = h || "0") : e.isHorizontal() ? (p = f, h = "0") : (h = f, p = "0"), p.indexOf("%") >= 0 ? p = `${parseInt(p, 10) * c * d}%` : p = `${p * c * d}px`, h.indexOf("%") >= 0 ? h = `${parseInt(h, 10) * c}%` : h = `${h * c}px`, typeof m < "u" && m !== null) {
      const E = m - (m - 1) * (1 - Math.abs(c));
      l.style.opacity = E;
    }
    let y = `translate3d(${p}, ${h}, 0px)`;
    if (typeof g < "u" && g !== null) {
      const E = g - (g - 1) * (1 - Math.abs(c));
      y += ` scale(${E})`;
    }
    if (v && typeof v < "u" && v !== null) {
      const E = v * c * -1;
      y += ` rotate(${E}deg)`;
    }
    l.style.transform = y;
  }, a = () => {
    const {
      el: l,
      slides: c,
      progress: u,
      snapGrid: d,
      isElement: f
    } = e, p = Dt(l, s);
    e.isElement && p.push(...Dt(e.hostEl, s)), p.forEach((h) => {
      r(h, u);
    }), c.forEach((h, g) => {
      let m = h.progress;
      e.params.slidesPerGroup > 1 && e.params.slidesPerView !== "auto" && (m += Math.ceil(g / 2) - u * (d.length - 1)), m = Math.min(Math.max(m, -1), 1), h.querySelectorAll(`${s}, [data-swiper-parallax-rotate]`).forEach((v) => {
        r(v, m);
      });
    });
  }, o = function(l) {
    l === void 0 && (l = e.params.speed);
    const {
      el: c,
      hostEl: u
    } = e, d = [...c.querySelectorAll(s)];
    e.isElement && d.push(...u.querySelectorAll(s)), d.forEach((f) => {
      let p = parseInt(f.getAttribute("data-swiper-parallax-duration"), 10) || l;
      l === 0 && (p = 0), f.style.transitionDuration = `${p}ms`;
    });
  };
  i("beforeInit", () => {
    e.params.parallax.enabled && (e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0);
  }), i("init", () => {
    e.params.parallax.enabled && a();
  }), i("setTranslate", () => {
    e.params.parallax.enabled && a();
  }), i("setTransition", (l, c) => {
    e.params.parallax.enabled && o(c);
  });
}
function R_(n) {
  let {
    swiper: e,
    extendParams: t,
    on: i,
    emit: s
  } = n;
  const r = qe();
  t({
    zoom: {
      enabled: !1,
      limitToOriginalSize: !1,
      maxRatio: 3,
      minRatio: 1,
      panOnMouseMove: !1,
      toggle: !0,
      containerClass: "swiper-zoom-container",
      zoomedSlideClass: "swiper-slide-zoomed"
    }
  }), e.zoom = {
    enabled: !1
  };
  let a = 1, o = !1, l = !1, c = {
    x: 0,
    y: 0
  };
  const u = -3;
  let d, f;
  const p = [], h = {
    originX: 0,
    originY: 0,
    slideEl: void 0,
    slideWidth: void 0,
    slideHeight: void 0,
    imageEl: void 0,
    imageWrapEl: void 0,
    maxRatio: 3
  }, g = {
    isTouched: void 0,
    isMoved: void 0,
    currentX: void 0,
    currentY: void 0,
    minX: void 0,
    minY: void 0,
    maxX: void 0,
    maxY: void 0,
    width: void 0,
    height: void 0,
    startX: void 0,
    startY: void 0,
    touchesStart: {},
    touchesCurrent: {}
  }, m = {
    x: void 0,
    y: void 0,
    prevPositionX: void 0,
    prevPositionY: void 0,
    prevTime: void 0
  };
  let v = 1;
  Object.defineProperty(e.zoom, "scale", {
    get() {
      return v;
    },
    set(N) {
      if (v !== N) {
        const U = h.imageEl, V = h.slideEl;
        s("zoomChange", N, U, V);
      }
      v = N;
    }
  });
  function y() {
    if (p.length < 2) return 1;
    const N = p[0].pageX, U = p[0].pageY, V = p[1].pageX, j = p[1].pageY;
    return Math.sqrt((V - N) ** 2 + (j - U) ** 2);
  }
  function E() {
    const N = e.params.zoom, U = h.imageWrapEl.getAttribute("data-swiper-zoom") || N.maxRatio;
    if (N.limitToOriginalSize && h.imageEl && h.imageEl.naturalWidth) {
      const V = h.imageEl.naturalWidth / h.imageEl.offsetWidth;
      return Math.min(V, U);
    }
    return U;
  }
  function T() {
    if (p.length < 2) return {
      x: null,
      y: null
    };
    const N = h.imageEl.getBoundingClientRect();
    return [(p[0].pageX + (p[1].pageX - p[0].pageX) / 2 - N.x - r.scrollX) / a, (p[0].pageY + (p[1].pageY - p[0].pageY) / 2 - N.y - r.scrollY) / a];
  }
  function S() {
    return e.isElement ? "swiper-slide" : `.${e.params.slideClass}`;
  }
  function w(N) {
    const U = S();
    return !!(N.target.matches(U) || e.slides.filter((V) => V.contains(N.target)).length > 0);
  }
  function b(N) {
    const U = `.${e.params.zoom.containerClass}`;
    return !!(N.target.matches(U) || [...e.hostEl.querySelectorAll(U)].filter((V) => V.contains(N.target)).length > 0);
  }
  function L(N) {
    if (N.pointerType === "mouse" && p.splice(0, p.length), !w(N)) return;
    const U = e.params.zoom;
    if (d = !1, f = !1, p.push(N), !(p.length < 2)) {
      if (d = !0, h.scaleStart = y(), !h.slideEl) {
        h.slideEl = N.target.closest(`.${e.params.slideClass}, swiper-slide`), h.slideEl || (h.slideEl = e.slides[e.activeIndex]);
        let V = h.slideEl.querySelector(`.${U.containerClass}`);
        if (V && (V = V.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), h.imageEl = V, V ? h.imageWrapEl = _r(h.imageEl, `.${U.containerClass}`)[0] : h.imageWrapEl = void 0, !h.imageWrapEl) {
          h.imageEl = void 0;
          return;
        }
        h.maxRatio = E();
      }
      if (h.imageEl) {
        const [V, j] = T();
        h.originX = V, h.originY = j, h.imageEl.style.transitionDuration = "0ms";
      }
      o = !0;
    }
  }
  function A(N) {
    if (!w(N)) return;
    const U = e.params.zoom, V = e.zoom, j = p.findIndex((ee) => ee.pointerId === N.pointerId);
    j >= 0 && (p[j] = N), !(p.length < 2) && (f = !0, h.scaleMove = y(), h.imageEl && (V.scale = h.scaleMove / h.scaleStart * a, V.scale > h.maxRatio && (V.scale = h.maxRatio - 1 + (V.scale - h.maxRatio + 1) ** 0.5), V.scale < U.minRatio && (V.scale = U.minRatio + 1 - (U.minRatio - V.scale + 1) ** 0.5), h.imageEl.style.transform = `translate3d(0,0,0) scale(${V.scale})`));
  }
  function _(N) {
    if (!w(N) || N.pointerType === "mouse" && N.type === "pointerout") return;
    const U = e.params.zoom, V = e.zoom, j = p.findIndex((ee) => ee.pointerId === N.pointerId);
    j >= 0 && p.splice(j, 1), !(!d || !f) && (d = !1, f = !1, h.imageEl && (V.scale = Math.max(Math.min(V.scale, h.maxRatio), U.minRatio), h.imageEl.style.transitionDuration = `${e.params.speed}ms`, h.imageEl.style.transform = `translate3d(0,0,0) scale(${V.scale})`, a = V.scale, o = !1, V.scale > 1 && h.slideEl ? h.slideEl.classList.add(`${U.zoomedSlideClass}`) : V.scale <= 1 && h.slideEl && h.slideEl.classList.remove(`${U.zoomedSlideClass}`), V.scale === 1 && (h.originX = 0, h.originY = 0, h.slideEl = void 0)));
  }
  let R;
  function I() {
    e.touchEventsData.preventTouchMoveFromPointerMove = !1;
  }
  function k() {
    clearTimeout(R), e.touchEventsData.preventTouchMoveFromPointerMove = !0, R = setTimeout(() => {
      e.destroyed || I();
    });
  }
  function M(N) {
    const U = e.device;
    if (!h.imageEl || g.isTouched) return;
    U.android && N.cancelable && N.preventDefault(), g.isTouched = !0;
    const V = p.length > 0 ? p[0] : N;
    g.touchesStart.x = V.pageX, g.touchesStart.y = V.pageY;
  }
  function O(N) {
    const V = N.pointerType === "mouse" && e.params.zoom.panOnMouseMove;
    if (!w(N) || !b(N))
      return;
    const j = e.zoom;
    if (!h.imageEl)
      return;
    if (!g.isTouched || !h.slideEl) {
      V && D(N);
      return;
    }
    if (V) {
      D(N);
      return;
    }
    g.isMoved || (g.width = h.imageEl.offsetWidth || h.imageEl.clientWidth, g.height = h.imageEl.offsetHeight || h.imageEl.clientHeight, g.startX = jc(h.imageWrapEl, "x") || 0, g.startY = jc(h.imageWrapEl, "y") || 0, h.slideWidth = h.slideEl.offsetWidth, h.slideHeight = h.slideEl.offsetHeight, h.imageWrapEl.style.transitionDuration = "0ms");
    const ee = g.width * j.scale, ce = g.height * j.scale;
    if (g.minX = Math.min(h.slideWidth / 2 - ee / 2, 0), g.maxX = -g.minX, g.minY = Math.min(h.slideHeight / 2 - ce / 2, 0), g.maxY = -g.minY, g.touchesCurrent.x = p.length > 0 ? p[0].pageX : N.pageX, g.touchesCurrent.y = p.length > 0 ? p[0].pageY : N.pageY, Math.max(Math.abs(g.touchesCurrent.x - g.touchesStart.x), Math.abs(g.touchesCurrent.y - g.touchesStart.y)) > 5 && (e.allowClick = !1), !g.isMoved && !o) {
      if (e.isHorizontal() && (Math.floor(g.minX) === Math.floor(g.startX) && g.touchesCurrent.x < g.touchesStart.x || Math.floor(g.maxX) === Math.floor(g.startX) && g.touchesCurrent.x > g.touchesStart.x)) {
        g.isTouched = !1, I();
        return;
      }
      if (!e.isHorizontal() && (Math.floor(g.minY) === Math.floor(g.startY) && g.touchesCurrent.y < g.touchesStart.y || Math.floor(g.maxY) === Math.floor(g.startY) && g.touchesCurrent.y > g.touchesStart.y)) {
        g.isTouched = !1, I();
        return;
      }
    }
    N.cancelable && N.preventDefault(), N.stopPropagation(), k(), g.isMoved = !0;
    const Le = (j.scale - a) / (h.maxRatio - e.params.zoom.minRatio), {
      originX: ne,
      originY: fe
    } = h;
    g.currentX = g.touchesCurrent.x - g.touchesStart.x + g.startX + Le * (g.width - ne * 2), g.currentY = g.touchesCurrent.y - g.touchesStart.y + g.startY + Le * (g.height - fe * 2), g.currentX < g.minX && (g.currentX = g.minX + 1 - (g.minX - g.currentX + 1) ** 0.8), g.currentX > g.maxX && (g.currentX = g.maxX - 1 + (g.currentX - g.maxX + 1) ** 0.8), g.currentY < g.minY && (g.currentY = g.minY + 1 - (g.minY - g.currentY + 1) ** 0.8), g.currentY > g.maxY && (g.currentY = g.maxY - 1 + (g.currentY - g.maxY + 1) ** 0.8), m.prevPositionX || (m.prevPositionX = g.touchesCurrent.x), m.prevPositionY || (m.prevPositionY = g.touchesCurrent.y), m.prevTime || (m.prevTime = Date.now()), m.x = (g.touchesCurrent.x - m.prevPositionX) / (Date.now() - m.prevTime) / 2, m.y = (g.touchesCurrent.y - m.prevPositionY) / (Date.now() - m.prevTime) / 2, Math.abs(g.touchesCurrent.x - m.prevPositionX) < 2 && (m.x = 0), Math.abs(g.touchesCurrent.y - m.prevPositionY) < 2 && (m.y = 0), m.prevPositionX = g.touchesCurrent.x, m.prevPositionY = g.touchesCurrent.y, m.prevTime = Date.now(), h.imageWrapEl.style.transform = `translate3d(${g.currentX}px, ${g.currentY}px,0)`;
  }
  function F() {
    const N = e.zoom;
    if (p.length = 0, !h.imageEl) return;
    if (!g.isTouched || !g.isMoved) {
      g.isTouched = !1, g.isMoved = !1;
      return;
    }
    g.isTouched = !1, g.isMoved = !1;
    let U = 300, V = 300;
    const j = m.x * U, ee = g.currentX + j, ce = m.y * V, oe = g.currentY + ce;
    m.x !== 0 && (U = Math.abs((ee - g.currentX) / m.x)), m.y !== 0 && (V = Math.abs((oe - g.currentY) / m.y));
    const Le = Math.max(U, V);
    g.currentX = ee, g.currentY = oe;
    const ne = g.width * N.scale, fe = g.height * N.scale;
    g.minX = Math.min(h.slideWidth / 2 - ne / 2, 0), g.maxX = -g.minX, g.minY = Math.min(h.slideHeight / 2 - fe / 2, 0), g.maxY = -g.minY, g.currentX = Math.max(Math.min(g.currentX, g.maxX), g.minX), g.currentY = Math.max(Math.min(g.currentY, g.maxY), g.minY), h.imageWrapEl.style.transitionDuration = `${Le}ms`, h.imageWrapEl.style.transform = `translate3d(${g.currentX}px, ${g.currentY}px,0)`;
  }
  function C() {
    const N = e.zoom;
    h.slideEl && e.activeIndex !== e.slides.indexOf(h.slideEl) && (h.imageEl && (h.imageEl.style.transform = "translate3d(0,0,0) scale(1)"), h.imageWrapEl && (h.imageWrapEl.style.transform = "translate3d(0,0,0)"), h.slideEl.classList.remove(`${e.params.zoom.zoomedSlideClass}`), N.scale = 1, a = 1, h.slideEl = void 0, h.imageEl = void 0, h.imageWrapEl = void 0, h.originX = 0, h.originY = 0);
  }
  function D(N) {
    if (a <= 1 || !h.imageWrapEl || !w(N) || !b(N)) return;
    const U = r.getComputedStyle(h.imageWrapEl).transform, V = new r.DOMMatrix(U);
    if (!l) {
      l = !0, c.x = N.clientX, c.y = N.clientY, g.startX = V.e, g.startY = V.f, g.width = h.imageEl.offsetWidth || h.imageEl.clientWidth, g.height = h.imageEl.offsetHeight || h.imageEl.clientHeight, h.slideWidth = h.slideEl.offsetWidth, h.slideHeight = h.slideEl.offsetHeight;
      return;
    }
    const j = (N.clientX - c.x) * u, ee = (N.clientY - c.y) * u, ce = g.width * a, oe = g.height * a, Le = h.slideWidth, ne = h.slideHeight, fe = Math.min(Le / 2 - ce / 2, 0), Ce = -fe, re = Math.min(ne / 2 - oe / 2, 0), z = -re, Re = Math.max(Math.min(g.startX + j, Ce), fe), We = Math.max(Math.min(g.startY + ee, z), re);
    h.imageWrapEl.style.transitionDuration = "0ms", h.imageWrapEl.style.transform = `translate3d(${Re}px, ${We}px, 0)`, c.x = N.clientX, c.y = N.clientY, g.startX = Re, g.startY = We, g.currentX = Re, g.currentY = We;
  }
  function B(N) {
    const U = e.zoom, V = e.params.zoom;
    if (!h.slideEl) {
      N && N.target && (h.slideEl = N.target.closest(`.${e.params.slideClass}, swiper-slide`)), h.slideEl || (e.params.virtual && e.params.virtual.enabled && e.virtual ? h.slideEl = Dt(e.slidesEl, `.${e.params.slideActiveClass}`)[0] : h.slideEl = e.slides[e.activeIndex]);
      let rt = h.slideEl.querySelector(`.${V.containerClass}`);
      rt && (rt = rt.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), h.imageEl = rt, rt ? h.imageWrapEl = _r(h.imageEl, `.${V.containerClass}`)[0] : h.imageWrapEl = void 0;
    }
    if (!h.imageEl || !h.imageWrapEl) return;
    e.params.cssMode && (e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.touchAction = "none"), h.slideEl.classList.add(`${V.zoomedSlideClass}`);
    let j, ee, ce, oe, Le, ne, fe, Ce, re, z, Re, We, Ve, Ie, st, zt, Mt, ze;
    typeof g.touchesStart.x > "u" && N ? (j = N.pageX, ee = N.pageY) : (j = g.touchesStart.x, ee = g.touchesStart.y);
    const Et = a, Pe = typeof N == "number" ? N : null;
    a === 1 && Pe && (j = void 0, ee = void 0, g.touchesStart.x = void 0, g.touchesStart.y = void 0);
    const Ot = E();
    U.scale = Pe || Ot, a = Pe || Ot, N && !(a === 1 && Pe) ? (Mt = h.slideEl.offsetWidth, ze = h.slideEl.offsetHeight, ce = qo(h.slideEl).left + r.scrollX, oe = qo(h.slideEl).top + r.scrollY, Le = ce + Mt / 2 - j, ne = oe + ze / 2 - ee, re = h.imageEl.offsetWidth || h.imageEl.clientWidth, z = h.imageEl.offsetHeight || h.imageEl.clientHeight, Re = re * U.scale, We = z * U.scale, Ve = Math.min(Mt / 2 - Re / 2, 0), Ie = Math.min(ze / 2 - We / 2, 0), st = -Ve, zt = -Ie, Et > 0 && Pe && typeof g.currentX == "number" && typeof g.currentY == "number" ? (fe = g.currentX * U.scale / Et, Ce = g.currentY * U.scale / Et) : (fe = Le * U.scale, Ce = ne * U.scale), fe < Ve && (fe = Ve), fe > st && (fe = st), Ce < Ie && (Ce = Ie), Ce > zt && (Ce = zt)) : (fe = 0, Ce = 0), Pe && U.scale === 1 && (h.originX = 0, h.originY = 0), g.currentX = fe, g.currentY = Ce, h.imageWrapEl.style.transitionDuration = "300ms", h.imageWrapEl.style.transform = `translate3d(${fe}px, ${Ce}px,0)`, h.imageEl.style.transitionDuration = "300ms", h.imageEl.style.transform = `translate3d(0,0,0) scale(${U.scale})`;
  }
  function P() {
    const N = e.zoom, U = e.params.zoom;
    if (!h.slideEl) {
      e.params.virtual && e.params.virtual.enabled && e.virtual ? h.slideEl = Dt(e.slidesEl, `.${e.params.slideActiveClass}`)[0] : h.slideEl = e.slides[e.activeIndex];
      let V = h.slideEl.querySelector(`.${U.containerClass}`);
      V && (V = V.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), h.imageEl = V, V ? h.imageWrapEl = _r(h.imageEl, `.${U.containerClass}`)[0] : h.imageWrapEl = void 0;
    }
    !h.imageEl || !h.imageWrapEl || (e.params.cssMode && (e.wrapperEl.style.overflow = "", e.wrapperEl.style.touchAction = ""), N.scale = 1, a = 1, g.currentX = void 0, g.currentY = void 0, g.touchesStart.x = void 0, g.touchesStart.y = void 0, h.imageWrapEl.style.transitionDuration = "300ms", h.imageWrapEl.style.transform = "translate3d(0,0,0)", h.imageEl.style.transitionDuration = "300ms", h.imageEl.style.transform = "translate3d(0,0,0) scale(1)", h.slideEl.classList.remove(`${U.zoomedSlideClass}`), h.slideEl = void 0, h.originX = 0, h.originY = 0, e.params.zoom.panOnMouseMove && (c = {
      x: 0,
      y: 0
    }, l && (l = !1, g.startX = 0, g.startY = 0)));
  }
  function K(N) {
    const U = e.zoom;
    U.scale && U.scale !== 1 ? P() : B(N);
  }
  function X() {
    const N = e.params.passiveListeners ? {
      passive: !0,
      capture: !1
    } : !1, U = e.params.passiveListeners ? {
      passive: !1,
      capture: !0
    } : !0;
    return {
      passiveListener: N,
      activeListenerWithCapture: U
    };
  }
  function W() {
    const N = e.zoom;
    if (N.enabled) return;
    N.enabled = !0;
    const {
      passiveListener: U,
      activeListenerWithCapture: V
    } = X();
    e.wrapperEl.addEventListener("pointerdown", L, U), e.wrapperEl.addEventListener("pointermove", A, V), ["pointerup", "pointercancel", "pointerout"].forEach((j) => {
      e.wrapperEl.addEventListener(j, _, U);
    }), e.wrapperEl.addEventListener("pointermove", O, V);
  }
  function Y() {
    const N = e.zoom;
    if (!N.enabled) return;
    N.enabled = !1;
    const {
      passiveListener: U,
      activeListenerWithCapture: V
    } = X();
    e.wrapperEl.removeEventListener("pointerdown", L, U), e.wrapperEl.removeEventListener("pointermove", A, V), ["pointerup", "pointercancel", "pointerout"].forEach((j) => {
      e.wrapperEl.removeEventListener(j, _, U);
    }), e.wrapperEl.removeEventListener("pointermove", O, V);
  }
  i("init", () => {
    e.params.zoom.enabled && W();
  }), i("destroy", () => {
    Y();
  }), i("touchStart", (N, U) => {
    e.zoom.enabled && M(U);
  }), i("touchEnd", (N, U) => {
    e.zoom.enabled && F();
  }), i("doubleTap", (N, U) => {
    !e.animating && e.params.zoom.enabled && e.zoom.enabled && e.params.zoom.toggle && K(U);
  }), i("transitionEnd", () => {
    e.zoom.enabled && e.params.zoom.enabled && C();
  }), i("slideChange", () => {
    e.zoom.enabled && e.params.zoom.enabled && e.params.cssMode && C();
  }), Object.assign(e.zoom, {
    enable: W,
    disable: Y,
    in: B,
    out: P,
    toggle: K
  });
}
function C_(n) {
  let {
    swiper: e,
    extendParams: t,
    on: i
  } = n;
  t({
    controller: {
      control: void 0,
      inverse: !1,
      by: "slide"
      // or 'container'
    }
  }), e.controller = {
    control: void 0
  };
  function s(c, u) {
    const d = /* @__PURE__ */ (function() {
      let g, m, v;
      return (y, E) => {
        for (m = -1, g = y.length; g - m > 1; )
          v = g + m >> 1, y[v] <= E ? m = v : g = v;
        return g;
      };
    })();
    this.x = c, this.y = u, this.lastIndex = c.length - 1;
    let f, p;
    return this.interpolate = function(g) {
      return g ? (p = d(this.x, g), f = p - 1, (g - this.x[f]) * (this.y[p] - this.y[f]) / (this.x[p] - this.x[f]) + this.y[f]) : 0;
    }, this;
  }
  function r(c) {
    e.controller.spline = e.params.loop ? new s(e.slidesGrid, c.slidesGrid) : new s(e.snapGrid, c.snapGrid);
  }
  function a(c, u) {
    const d = e.controller.control;
    let f, p;
    const h = e.constructor;
    function g(m) {
      if (m.destroyed) return;
      const v = e.rtlTranslate ? -e.translate : e.translate;
      e.params.controller.by === "slide" && (r(m), p = -e.controller.spline.interpolate(-v)), (!p || e.params.controller.by === "container") && (f = (m.maxTranslate() - m.minTranslate()) / (e.maxTranslate() - e.minTranslate()), (Number.isNaN(f) || !Number.isFinite(f)) && (f = 1), p = (v - e.minTranslate()) * f + m.minTranslate()), e.params.controller.inverse && (p = m.maxTranslate() - p), m.updateProgress(p), m.setTranslate(p, e), m.updateActiveIndex(), m.updateSlidesClasses();
    }
    if (Array.isArray(d))
      for (let m = 0; m < d.length; m += 1)
        d[m] !== u && d[m] instanceof h && g(d[m]);
    else d instanceof h && u !== d && g(d);
  }
  function o(c, u) {
    const d = e.constructor, f = e.controller.control;
    let p;
    function h(g) {
      g.destroyed || (g.setTransition(c, e), c !== 0 && (g.transitionStart(), g.params.autoHeight && yn(() => {
        g.updateAutoHeight();
      }), ta(g.wrapperEl, () => {
        f && g.transitionEnd();
      })));
    }
    if (Array.isArray(f))
      for (p = 0; p < f.length; p += 1)
        f[p] !== u && f[p] instanceof d && h(f[p]);
    else f instanceof d && u !== f && h(f);
  }
  function l() {
    e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline);
  }
  i("beforeInit", () => {
    if (typeof window < "u" && // eslint-disable-line
    (typeof e.params.controller.control == "string" || e.params.controller.control instanceof HTMLElement)) {
      (typeof e.params.controller.control == "string" ? [...document.querySelectorAll(e.params.controller.control)] : [e.params.controller.control]).forEach((u) => {
        if (e.controller.control || (e.controller.control = []), u && u.swiper)
          e.controller.control.push(u.swiper);
        else if (u) {
          const d = `${e.params.eventsPrefix}init`, f = (p) => {
            e.controller.control.push(p.detail[0]), e.update(), u.removeEventListener(d, f);
          };
          u.addEventListener(d, f);
        }
      });
      return;
    }
    e.controller.control = e.params.controller.control;
  }), i("update", () => {
    l();
  }), i("resize", () => {
    l();
  }), i("observerUpdate", () => {
    l();
  }), i("setTranslate", (c, u, d) => {
    !e.controller.control || e.controller.control.destroyed || e.controller.setTranslate(u, d);
  }), i("setTransition", (c, u, d) => {
    !e.controller.control || e.controller.control.destroyed || e.controller.setTransition(u, d);
  }), Object.assign(e.controller, {
    setTranslate: a,
    setTransition: o
  });
}
function P_(n) {
  let {
    swiper: e,
    extendParams: t,
    on: i
  } = n;
  t({
    a11y: {
      enabled: !0,
      notificationClass: "swiper-notification",
      prevSlideMessage: "Previous slide",
      nextSlideMessage: "Next slide",
      firstSlideMessage: "This is the first slide",
      lastSlideMessage: "This is the last slide",
      paginationBulletMessage: "Go to slide {{index}}",
      slideLabelMessage: "{{index}} / {{slidesLength}}",
      containerMessage: null,
      containerRoleDescriptionMessage: null,
      containerRole: null,
      itemRoleDescriptionMessage: null,
      slideRole: "group",
      id: null,
      scrollOnFocus: !0
    }
  }), e.a11y = {
    clicked: !1
  };
  let s = null, r, a, o = (/* @__PURE__ */ new Date()).getTime();
  function l(C) {
    const D = s;
    D.length !== 0 && As(D, C);
  }
  function c(C) {
    const D = () => Math.round(16 * Math.random()).toString(16);
    return "x".repeat(C).replace(/x/g, D);
  }
  function u(C) {
    C = be(C), C.forEach((D) => {
      D.setAttribute("tabIndex", "0");
    });
  }
  function d(C) {
    C = be(C), C.forEach((D) => {
      D.setAttribute("tabIndex", "-1");
    });
  }
  function f(C, D) {
    C = be(C), C.forEach((B) => {
      B.setAttribute("role", D);
    });
  }
  function p(C, D) {
    C = be(C), C.forEach((B) => {
      B.setAttribute("aria-roledescription", D);
    });
  }
  function h(C, D) {
    C = be(C), C.forEach((B) => {
      B.setAttribute("aria-controls", D);
    });
  }
  function g(C, D) {
    C = be(C), C.forEach((B) => {
      B.setAttribute("aria-label", D);
    });
  }
  function m(C, D) {
    C = be(C), C.forEach((B) => {
      B.setAttribute("id", D);
    });
  }
  function v(C, D) {
    C = be(C), C.forEach((B) => {
      B.setAttribute("aria-live", D);
    });
  }
  function y(C) {
    C = be(C), C.forEach((D) => {
      D.setAttribute("aria-disabled", !0);
    });
  }
  function E(C) {
    C = be(C), C.forEach((D) => {
      D.setAttribute("aria-disabled", !1);
    });
  }
  function T(C) {
    if (C.keyCode !== 13 && C.keyCode !== 32) return;
    const D = e.params.a11y, B = C.target;
    if (!(e.pagination && e.pagination.el && (B === e.pagination.el || e.pagination.el.contains(C.target)) && !C.target.matches(Ts(e.params.pagination.bulletClass)))) {
      if (e.navigation && e.navigation.prevEl && e.navigation.nextEl) {
        const P = be(e.navigation.prevEl);
        be(e.navigation.nextEl).includes(B) && (e.isEnd && !e.params.loop || e.slideNext(), e.isEnd ? l(D.lastSlideMessage) : l(D.nextSlideMessage)), P.includes(B) && (e.isBeginning && !e.params.loop || e.slidePrev(), e.isBeginning ? l(D.firstSlideMessage) : l(D.prevSlideMessage));
      }
      e.pagination && B.matches(Ts(e.params.pagination.bulletClass)) && B.click();
    }
  }
  function S() {
    if (e.params.loop || e.params.rewind || !e.navigation) return;
    const {
      nextEl: C,
      prevEl: D
    } = e.navigation;
    D && (e.isBeginning ? (y(D), d(D)) : (E(D), u(D))), C && (e.isEnd ? (y(C), d(C)) : (E(C), u(C)));
  }
  function w() {
    return e.pagination && e.pagination.bullets && e.pagination.bullets.length;
  }
  function b() {
    return w() && e.params.pagination.clickable;
  }
  function L() {
    const C = e.params.a11y;
    w() && e.pagination.bullets.forEach((D) => {
      e.params.pagination.clickable && (u(D), e.params.pagination.renderBullet || (f(D, "button"), g(D, C.paginationBulletMessage.replace(/\{\{index\}\}/, Ta(D) + 1)))), D.matches(Ts(e.params.pagination.bulletActiveClass)) ? D.setAttribute("aria-current", "true") : D.removeAttribute("aria-current");
    });
  }
  const A = (C, D, B) => {
    u(C), C.tagName !== "BUTTON" && (f(C, "button"), C.addEventListener("keydown", T)), g(C, B), h(C, D);
  }, _ = (C) => {
    a && a !== C.target && !a.contains(C.target) && (r = !0), e.a11y.clicked = !0;
  }, R = () => {
    r = !1, requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        e.destroyed || (e.a11y.clicked = !1);
      });
    });
  }, I = (C) => {
    o = (/* @__PURE__ */ new Date()).getTime();
  }, k = (C) => {
    if (e.a11y.clicked || !e.params.a11y.scrollOnFocus || (/* @__PURE__ */ new Date()).getTime() - o < 100) return;
    const D = C.target.closest(`.${e.params.slideClass}, swiper-slide`);
    if (!D || !e.slides.includes(D)) return;
    a = D;
    const B = e.slides.indexOf(D) === e.activeIndex, P = e.params.watchSlidesProgress && e.visibleSlides && e.visibleSlides.includes(D);
    B || P || C.sourceCapabilities && C.sourceCapabilities.firesTouchEvents || (e.isHorizontal() ? e.el.scrollLeft = 0 : e.el.scrollTop = 0, requestAnimationFrame(() => {
      r || (e.params.loop ? e.slideToLoop(e.getSlideIndexWhenGrid(parseInt(D.getAttribute("data-swiper-slide-index"))), 0) : e.slideTo(e.getSlideIndexWhenGrid(e.slides.indexOf(D)), 0), r = !1);
    }));
  }, M = () => {
    const C = e.params.a11y;
    C.itemRoleDescriptionMessage && p(e.slides, C.itemRoleDescriptionMessage), C.slideRole && f(e.slides, C.slideRole);
    const D = e.slides.length;
    C.slideLabelMessage && e.slides.forEach((B, P) => {
      const K = e.params.loop ? parseInt(B.getAttribute("data-swiper-slide-index"), 10) : P, X = C.slideLabelMessage.replace(/\{\{index\}\}/, K + 1).replace(/\{\{slidesLength\}\}/, D);
      g(B, X);
    });
  }, O = () => {
    const C = e.params.a11y;
    e.el.append(s);
    const D = e.el;
    C.containerRoleDescriptionMessage && p(D, C.containerRoleDescriptionMessage), C.containerMessage && g(D, C.containerMessage), C.containerRole && f(D, C.containerRole);
    const B = e.wrapperEl, P = C.id || B.getAttribute("id") || `swiper-wrapper-${c(16)}`, K = e.params.autoplay && e.params.autoplay.enabled ? "off" : "polite";
    m(B, P), v(B, K), M();
    let {
      nextEl: X,
      prevEl: W
    } = e.navigation ? e.navigation : {};
    X = be(X), W = be(W), X && X.forEach((N) => A(N, P, C.nextSlideMessage)), W && W.forEach((N) => A(N, P, C.prevSlideMessage)), b() && be(e.pagination.el).forEach((U) => {
      U.addEventListener("keydown", T);
    }), _t().addEventListener("visibilitychange", I), e.el.addEventListener("focus", k, !0), e.el.addEventListener("focus", k, !0), e.el.addEventListener("pointerdown", _, !0), e.el.addEventListener("pointerup", R, !0);
  };
  function F() {
    s && s.remove();
    let {
      nextEl: C,
      prevEl: D
    } = e.navigation ? e.navigation : {};
    C = be(C), D = be(D), C && C.forEach((P) => P.removeEventListener("keydown", T)), D && D.forEach((P) => P.removeEventListener("keydown", T)), b() && be(e.pagination.el).forEach((K) => {
      K.removeEventListener("keydown", T);
    }), _t().removeEventListener("visibilitychange", I), e.el && typeof e.el != "string" && (e.el.removeEventListener("focus", k, !0), e.el.removeEventListener("pointerdown", _, !0), e.el.removeEventListener("pointerup", R, !0));
  }
  i("beforeInit", () => {
    s = Si("span", e.params.a11y.notificationClass), s.setAttribute("aria-live", "assertive"), s.setAttribute("aria-atomic", "true");
  }), i("afterInit", () => {
    e.params.a11y.enabled && O();
  }), i("slidesLengthChange snapGridLengthChange slidesGridLengthChange", () => {
    e.params.a11y.enabled && M();
  }), i("fromEdge toEdge afterInit lock unlock", () => {
    e.params.a11y.enabled && S();
  }), i("paginationUpdate", () => {
    e.params.a11y.enabled && L();
  }), i("destroy", () => {
    e.params.a11y.enabled && F();
  });
}
function D_(n) {
  let {
    swiper: e,
    extendParams: t,
    on: i
  } = n;
  t({
    history: {
      enabled: !1,
      root: "",
      replaceState: !1,
      key: "slides",
      keepQuery: !1
    }
  });
  let s = !1, r = {};
  const a = (p) => p.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), o = (p) => {
    const h = qe();
    let g;
    p ? g = new URL(p) : g = h.location;
    const m = g.pathname.slice(1).split("/").filter((T) => T !== ""), v = m.length, y = m[v - 2], E = m[v - 1];
    return {
      key: y,
      value: E
    };
  }, l = (p, h) => {
    const g = qe();
    if (!s || !e.params.history.enabled) return;
    let m;
    e.params.url ? m = new URL(e.params.url) : m = g.location;
    const v = e.virtual && e.params.virtual.enabled ? e.slidesEl.querySelector(`[data-swiper-slide-index="${h}"]`) : e.slides[h];
    let y = a(v.getAttribute("data-history"));
    if (e.params.history.root.length > 0) {
      let T = e.params.history.root;
      T[T.length - 1] === "/" && (T = T.slice(0, T.length - 1)), y = `${T}/${p ? `${p}/` : ""}${y}`;
    } else m.pathname.includes(p) || (y = `${p ? `${p}/` : ""}${y}`);
    e.params.history.keepQuery && (y += m.search);
    const E = g.history.state;
    E && E.value === y || (e.params.history.replaceState ? g.history.replaceState({
      value: y
    }, null, y) : g.history.pushState({
      value: y
    }, null, y));
  }, c = (p, h, g) => {
    if (h)
      for (let m = 0, v = e.slides.length; m < v; m += 1) {
        const y = e.slides[m];
        if (a(y.getAttribute("data-history")) === h) {
          const T = e.getSlideIndex(y);
          e.slideTo(T, p, g);
        }
      }
    else
      e.slideTo(0, p, g);
  }, u = () => {
    r = o(e.params.url), c(e.params.speed, r.value, !1);
  }, d = () => {
    const p = qe();
    if (e.params.history) {
      if (!p.history || !p.history.pushState) {
        e.params.history.enabled = !1, e.params.hashNavigation.enabled = !0;
        return;
      }
      if (s = !0, r = o(e.params.url), !r.key && !r.value) {
        e.params.history.replaceState || p.addEventListener("popstate", u);
        return;
      }
      c(0, r.value, e.params.runCallbacksOnInit), e.params.history.replaceState || p.addEventListener("popstate", u);
    }
  }, f = () => {
    const p = qe();
    e.params.history.replaceState || p.removeEventListener("popstate", u);
  };
  i("init", () => {
    e.params.history.enabled && d();
  }), i("destroy", () => {
    e.params.history.enabled && f();
  }), i("transitionEnd _freeModeNoMomentumRelease", () => {
    s && l(e.params.history.key, e.activeIndex);
  }), i("slideChange", () => {
    s && e.params.cssMode && l(e.params.history.key, e.activeIndex);
  });
}
function k_(n) {
  let {
    swiper: e,
    extendParams: t,
    emit: i,
    on: s
  } = n, r = !1;
  const a = _t(), o = qe();
  t({
    hashNavigation: {
      enabled: !1,
      replaceState: !1,
      watchState: !1,
      getSlideIndex(f, p) {
        if (e.virtual && e.params.virtual.enabled) {
          const h = e.slides.find((m) => m.getAttribute("data-hash") === p);
          return h ? parseInt(h.getAttribute("data-swiper-slide-index"), 10) : 0;
        }
        return e.getSlideIndex(Dt(e.slidesEl, `.${e.params.slideClass}[data-hash="${p}"], swiper-slide[data-hash="${p}"]`)[0]);
      }
    }
  });
  const l = () => {
    i("hashChange");
    const f = a.location.hash.replace("#", ""), p = e.virtual && e.params.virtual.enabled ? e.slidesEl.querySelector(`[data-swiper-slide-index="${e.activeIndex}"]`) : e.slides[e.activeIndex], h = p ? p.getAttribute("data-hash") : "";
    if (f !== h) {
      const g = e.params.hashNavigation.getSlideIndex(e, f);
      if (typeof g > "u" || Number.isNaN(g)) return;
      e.slideTo(g);
    }
  }, c = () => {
    if (!r || !e.params.hashNavigation.enabled) return;
    const f = e.virtual && e.params.virtual.enabled ? e.slidesEl.querySelector(`[data-swiper-slide-index="${e.activeIndex}"]`) : e.slides[e.activeIndex], p = f ? f.getAttribute("data-hash") || f.getAttribute("data-history") : "";
    e.params.hashNavigation.replaceState && o.history && o.history.replaceState ? (o.history.replaceState(null, null, `#${p}` || ""), i("hashSet")) : (a.location.hash = p || "", i("hashSet"));
  }, u = () => {
    if (!e.params.hashNavigation.enabled || e.params.history && e.params.history.enabled) return;
    r = !0;
    const f = a.location.hash.replace("#", "");
    if (f) {
      const h = e.params.hashNavigation.getSlideIndex(e, f);
      e.slideTo(h || 0, 0, e.params.runCallbacksOnInit, !0);
    }
    e.params.hashNavigation.watchState && o.addEventListener("hashchange", l);
  }, d = () => {
    e.params.hashNavigation.watchState && o.removeEventListener("hashchange", l);
  };
  s("init", () => {
    e.params.hashNavigation.enabled && u();
  }), s("destroy", () => {
    e.params.hashNavigation.enabled && d();
  }), s("transitionEnd _freeModeNoMomentumRelease", () => {
    r && c();
  }), s("slideChange", () => {
    r && e.params.cssMode && c();
  });
}
function M_(n) {
  let {
    swiper: e,
    extendParams: t,
    on: i,
    emit: s,
    params: r
  } = n;
  e.autoplay = {
    running: !1,
    paused: !1,
    timeLeft: 0
  }, t({
    autoplay: {
      enabled: !1,
      delay: 3e3,
      waitForTransition: !0,
      disableOnInteraction: !1,
      stopOnLastSlide: !1,
      reverseDirection: !1,
      pauseOnMouseEnter: !1
    }
  });
  let a, o, l = r && r.autoplay ? r.autoplay.delay : 3e3, c = r && r.autoplay ? r.autoplay.delay : 3e3, u, d = (/* @__PURE__ */ new Date()).getTime(), f, p, h, g, m, v, y;
  function E(D) {
    !e || e.destroyed || !e.wrapperEl || D.target === e.wrapperEl && (e.wrapperEl.removeEventListener("transitionend", E), !(y || D.detail && D.detail.bySwiperTouchMove) && _());
  }
  const T = () => {
    if (e.destroyed || !e.autoplay.running) return;
    e.autoplay.paused ? f = !0 : f && (c = u, f = !1);
    const D = e.autoplay.paused ? u : d + c - (/* @__PURE__ */ new Date()).getTime();
    e.autoplay.timeLeft = D, s("autoplayTimeLeft", D, D / l), o = requestAnimationFrame(() => {
      T();
    });
  }, S = () => {
    let D;
    return e.virtual && e.params.virtual.enabled ? D = e.slides.find((P) => P.classList.contains("swiper-slide-active")) : D = e.slides[e.activeIndex], D ? parseInt(D.getAttribute("data-swiper-autoplay"), 10) : void 0;
  }, w = (D) => {
    if (e.destroyed || !e.autoplay.running) return;
    cancelAnimationFrame(o), T();
    let B = typeof D > "u" ? e.params.autoplay.delay : D;
    l = e.params.autoplay.delay, c = e.params.autoplay.delay;
    const P = S();
    !Number.isNaN(P) && P > 0 && typeof D > "u" && (B = P, l = P, c = P), u = B;
    const K = e.params.speed, X = () => {
      !e || e.destroyed || (e.params.autoplay.reverseDirection ? !e.isBeginning || e.params.loop || e.params.rewind ? (e.slidePrev(K, !0, !0), s("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(e.slides.length - 1, K, !0, !0), s("autoplay")) : !e.isEnd || e.params.loop || e.params.rewind ? (e.slideNext(K, !0, !0), s("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(0, K, !0, !0), s("autoplay")), e.params.cssMode && (d = (/* @__PURE__ */ new Date()).getTime(), requestAnimationFrame(() => {
        w();
      })));
    };
    return B > 0 ? (clearTimeout(a), a = setTimeout(() => {
      X();
    }, B)) : requestAnimationFrame(() => {
      X();
    }), B;
  }, b = () => {
    d = (/* @__PURE__ */ new Date()).getTime(), e.autoplay.running = !0, w(), s("autoplayStart");
  }, L = () => {
    e.autoplay.running = !1, clearTimeout(a), cancelAnimationFrame(o), s("autoplayStop");
  }, A = (D, B) => {
    if (e.destroyed || !e.autoplay.running) return;
    clearTimeout(a), D || (v = !0);
    const P = () => {
      s("autoplayPause"), e.params.autoplay.waitForTransition ? e.wrapperEl.addEventListener("transitionend", E) : _();
    };
    if (e.autoplay.paused = !0, B) {
      m && (u = e.params.autoplay.delay), m = !1, P();
      return;
    }
    u = (u || e.params.autoplay.delay) - ((/* @__PURE__ */ new Date()).getTime() - d), !(e.isEnd && u < 0 && !e.params.loop) && (u < 0 && (u = 0), P());
  }, _ = () => {
    e.isEnd && u < 0 && !e.params.loop || e.destroyed || !e.autoplay.running || (d = (/* @__PURE__ */ new Date()).getTime(), v ? (v = !1, w(u)) : w(), e.autoplay.paused = !1, s("autoplayResume"));
  }, R = () => {
    if (e.destroyed || !e.autoplay.running) return;
    const D = _t();
    D.visibilityState === "hidden" && (v = !0, A(!0)), D.visibilityState === "visible" && _();
  }, I = (D) => {
    D.pointerType === "mouse" && (v = !0, y = !0, !(e.animating || e.autoplay.paused) && A(!0));
  }, k = (D) => {
    D.pointerType === "mouse" && (y = !1, e.autoplay.paused && _());
  }, M = () => {
    e.params.autoplay.pauseOnMouseEnter && (e.el.addEventListener("pointerenter", I), e.el.addEventListener("pointerleave", k));
  }, O = () => {
    e.el && typeof e.el != "string" && (e.el.removeEventListener("pointerenter", I), e.el.removeEventListener("pointerleave", k));
  }, F = () => {
    _t().addEventListener("visibilitychange", R);
  }, C = () => {
    _t().removeEventListener("visibilitychange", R);
  };
  i("init", () => {
    e.params.autoplay.enabled && (M(), F(), b());
  }), i("destroy", () => {
    O(), C(), e.autoplay.running && L();
  }), i("_freeModeStaticRelease", () => {
    (h || v) && _();
  }), i("_freeModeNoMomentumRelease", () => {
    e.params.autoplay.disableOnInteraction ? L() : A(!0, !0);
  }), i("beforeTransitionStart", (D, B, P) => {
    e.destroyed || !e.autoplay.running || (P || !e.params.autoplay.disableOnInteraction ? A(!0, !0) : L());
  }), i("sliderFirstMove", () => {
    if (!(e.destroyed || !e.autoplay.running)) {
      if (e.params.autoplay.disableOnInteraction) {
        L();
        return;
      }
      p = !0, h = !1, v = !1, g = setTimeout(() => {
        v = !0, h = !0, A(!0);
      }, 200);
    }
  }), i("touchEnd", () => {
    if (!(e.destroyed || !e.autoplay.running || !p)) {
      if (clearTimeout(g), clearTimeout(a), e.params.autoplay.disableOnInteraction) {
        h = !1, p = !1;
        return;
      }
      h && e.params.cssMode && _(), h = !1, p = !1;
    }
  }), i("slideChange", () => {
    e.destroyed || !e.autoplay.running || (m = !0);
  }), Object.assign(e.autoplay, {
    start: b,
    stop: L,
    pause: A,
    resume: _
  });
}
function O_(n) {
  let {
    swiper: e,
    extendParams: t,
    on: i
  } = n;
  t({
    thumbs: {
      swiper: null,
      multipleActiveThumbs: !0,
      autoScrollOffset: 0,
      slideThumbActiveClass: "swiper-slide-thumb-active",
      thumbsContainerClass: "swiper-thumbs"
    }
  });
  let s = !1, r = !1;
  e.thumbs = {
    swiper: null
  };
  function a() {
    const c = e.thumbs.swiper;
    if (!c || c.destroyed) return;
    const u = c.clickedIndex, d = c.clickedSlide;
    if (d && d.classList.contains(e.params.thumbs.slideThumbActiveClass) || typeof u > "u" || u === null) return;
    let f;
    c.params.loop ? f = parseInt(c.clickedSlide.getAttribute("data-swiper-slide-index"), 10) : f = u, e.params.loop ? e.slideToLoop(f) : e.slideTo(f);
  }
  function o() {
    const {
      thumbs: c
    } = e.params;
    if (s) return !1;
    s = !0;
    const u = e.constructor;
    if (c.swiper instanceof u) {
      if (c.swiper.destroyed)
        return s = !1, !1;
      e.thumbs.swiper = c.swiper, Object.assign(e.thumbs.swiper.originalParams, {
        watchSlidesProgress: !0,
        slideToClickedSlide: !1
      }), Object.assign(e.thumbs.swiper.params, {
        watchSlidesProgress: !0,
        slideToClickedSlide: !1
      }), e.thumbs.swiper.update();
    } else if ($n(c.swiper)) {
      const d = Object.assign({}, c.swiper);
      Object.assign(d, {
        watchSlidesProgress: !0,
        slideToClickedSlide: !1
      }), e.thumbs.swiper = new u(d), r = !0;
    }
    return e.thumbs.swiper.el.classList.add(e.params.thumbs.thumbsContainerClass), e.thumbs.swiper.on("tap", a), !0;
  }
  function l(c) {
    const u = e.thumbs.swiper;
    if (!u || u.destroyed) return;
    const d = u.params.slidesPerView === "auto" ? u.slidesPerViewDynamic() : u.params.slidesPerView;
    let f = 1;
    const p = e.params.thumbs.slideThumbActiveClass;
    if (e.params.slidesPerView > 1 && !e.params.centeredSlides && (f = e.params.slidesPerView), e.params.thumbs.multipleActiveThumbs || (f = 1), f = Math.floor(f), u.slides.forEach((m) => m.classList.remove(p)), u.params.loop || u.params.virtual && u.params.virtual.enabled)
      for (let m = 0; m < f; m += 1)
        Dt(u.slidesEl, `[data-swiper-slide-index="${e.realIndex + m}"]`).forEach((v) => {
          v.classList.add(p);
        });
    else
      for (let m = 0; m < f; m += 1)
        u.slides[e.realIndex + m] && u.slides[e.realIndex + m].classList.add(p);
    const h = e.params.thumbs.autoScrollOffset, g = h && !u.params.loop;
    if (e.realIndex !== u.realIndex || g) {
      const m = u.activeIndex;
      let v, y;
      if (u.params.loop) {
        const E = u.slides.find((T) => T.getAttribute("data-swiper-slide-index") === `${e.realIndex}`);
        v = u.slides.indexOf(E), y = e.activeIndex > e.previousIndex ? "next" : "prev";
      } else
        v = e.realIndex, y = v > e.previousIndex ? "next" : "prev";
      g && (v += y === "next" ? h : -1 * h), u.visibleSlidesIndexes && u.visibleSlidesIndexes.indexOf(v) < 0 && (u.params.centeredSlides ? v > m ? v = v - Math.floor(d / 2) + 1 : v = v + Math.floor(d / 2) - 1 : v > m && u.params.slidesPerGroup, u.slideTo(v, c ? 0 : void 0));
    }
  }
  i("beforeInit", () => {
    const {
      thumbs: c
    } = e.params;
    if (!(!c || !c.swiper))
      if (typeof c.swiper == "string" || c.swiper instanceof HTMLElement) {
        const u = _t(), d = () => {
          const p = typeof c.swiper == "string" ? u.querySelector(c.swiper) : c.swiper;
          if (p && p.swiper)
            c.swiper = p.swiper, o(), l(!0);
          else if (p) {
            const h = `${e.params.eventsPrefix}init`, g = (m) => {
              c.swiper = m.detail[0], p.removeEventListener(h, g), o(), l(!0), c.swiper.update(), e.update();
            };
            p.addEventListener(h, g);
          }
          return p;
        }, f = () => {
          if (e.destroyed) return;
          d() || requestAnimationFrame(f);
        };
        requestAnimationFrame(f);
      } else
        o(), l(!0);
  }), i("slideChange update resize observerUpdate", () => {
    l();
  }), i("setTransition", (c, u) => {
    const d = e.thumbs.swiper;
    !d || d.destroyed || d.setTransition(u);
  }), i("beforeDestroy", () => {
    const c = e.thumbs.swiper;
    !c || c.destroyed || r && c.destroy();
  }), Object.assign(e.thumbs, {
    init: o,
    update: l
  });
}
function F_(n) {
  let {
    swiper: e,
    extendParams: t,
    emit: i,
    once: s
  } = n;
  t({
    freeMode: {
      enabled: !1,
      momentum: !0,
      momentumRatio: 1,
      momentumBounce: !0,
      momentumBounceRatio: 1,
      momentumVelocityRatio: 1,
      sticky: !1,
      minimumVelocity: 0.02
    }
  });
  function r() {
    if (e.params.cssMode) return;
    const l = e.getTranslate();
    e.setTranslate(l), e.setTransition(0), e.touchEventsData.velocities.length = 0, e.freeMode.onTouchEnd({
      currentPos: e.rtl ? e.translate : -e.translate
    });
  }
  function a() {
    if (e.params.cssMode) return;
    const {
      touchEventsData: l,
      touches: c
    } = e;
    l.velocities.length === 0 && l.velocities.push({
      position: c[e.isHorizontal() ? "startX" : "startY"],
      time: l.touchStartTime
    }), l.velocities.push({
      position: c[e.isHorizontal() ? "currentX" : "currentY"],
      time: Ci()
    });
  }
  function o(l) {
    let {
      currentPos: c
    } = l;
    if (e.params.cssMode) return;
    const {
      params: u,
      wrapperEl: d,
      rtlTranslate: f,
      snapGrid: p,
      touchEventsData: h
    } = e, m = Ci() - h.touchStartTime;
    if (c < -e.minTranslate()) {
      e.slideTo(e.activeIndex);
      return;
    }
    if (c > -e.maxTranslate()) {
      e.slides.length < p.length ? e.slideTo(p.length - 1) : e.slideTo(e.slides.length - 1);
      return;
    }
    if (u.freeMode.momentum) {
      if (h.velocities.length > 1) {
        const L = h.velocities.pop(), A = h.velocities.pop(), _ = L.position - A.position, R = L.time - A.time;
        e.velocity = _ / R, e.velocity /= 2, Math.abs(e.velocity) < u.freeMode.minimumVelocity && (e.velocity = 0), (R > 150 || Ci() - L.time > 300) && (e.velocity = 0);
      } else
        e.velocity = 0;
      e.velocity *= u.freeMode.momentumVelocityRatio, h.velocities.length = 0;
      let v = 1e3 * u.freeMode.momentumRatio;
      const y = e.velocity * v;
      let E = e.translate + y;
      f && (E = -E);
      let T = !1, S;
      const w = Math.abs(e.velocity) * 20 * u.freeMode.momentumBounceRatio;
      let b;
      if (E < e.maxTranslate())
        u.freeMode.momentumBounce ? (E + e.maxTranslate() < -w && (E = e.maxTranslate() - w), S = e.maxTranslate(), T = !0, h.allowMomentumBounce = !0) : E = e.maxTranslate(), u.loop && u.centeredSlides && (b = !0);
      else if (E > e.minTranslate())
        u.freeMode.momentumBounce ? (E - e.minTranslate() > w && (E = e.minTranslate() + w), S = e.minTranslate(), T = !0, h.allowMomentumBounce = !0) : E = e.minTranslate(), u.loop && u.centeredSlides && (b = !0);
      else if (u.freeMode.sticky) {
        let L;
        for (let A = 0; A < p.length; A += 1)
          if (p[A] > -E) {
            L = A;
            break;
          }
        Math.abs(p[L] - E) < Math.abs(p[L - 1] - E) || e.swipeDirection === "next" ? E = p[L] : E = p[L - 1], E = -E;
      }
      if (b && s("transitionEnd", () => {
        e.loopFix();
      }), e.velocity !== 0) {
        if (f ? v = Math.abs((-E - e.translate) / e.velocity) : v = Math.abs((E - e.translate) / e.velocity), u.freeMode.sticky) {
          const L = Math.abs((f ? -E : E) - e.translate), A = e.slidesSizesGrid[e.activeIndex];
          L < A ? v = u.speed : L < 2 * A ? v = u.speed * 1.5 : v = u.speed * 2.5;
        }
      } else if (u.freeMode.sticky) {
        e.slideToClosest();
        return;
      }
      u.freeMode.momentumBounce && T ? (e.updateProgress(S), e.setTransition(v), e.setTranslate(E), e.transitionStart(!0, e.swipeDirection), e.animating = !0, ta(d, () => {
        !e || e.destroyed || !h.allowMomentumBounce || (i("momentumBounce"), e.setTransition(u.speed), setTimeout(() => {
          e.setTranslate(S), ta(d, () => {
            !e || e.destroyed || e.transitionEnd();
          });
        }, 0));
      })) : e.velocity ? (i("_freeModeNoMomentumRelease"), e.updateProgress(E), e.setTransition(v), e.setTranslate(E), e.transitionStart(!0, e.swipeDirection), e.animating || (e.animating = !0, ta(d, () => {
        !e || e.destroyed || e.transitionEnd();
      }))) : e.updateProgress(E), e.updateActiveIndex(), e.updateSlidesClasses();
    } else if (u.freeMode.sticky) {
      e.slideToClosest();
      return;
    } else u.freeMode && i("_freeModeNoMomentumRelease");
    (!u.freeMode.momentum || m >= u.longSwipesMs) && (i("_freeModeStaticRelease"), e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses());
  }
  Object.assign(e, {
    freeMode: {
      onTouchStart: r,
      onTouchMove: a,
      onTouchEnd: o
    }
  });
}
function N_(n) {
  let {
    swiper: e,
    extendParams: t,
    on: i
  } = n;
  t({
    grid: {
      rows: 1,
      fill: "column"
    }
  });
  let s, r, a, o;
  const l = () => {
    let g = e.params.spaceBetween;
    return typeof g == "string" && g.indexOf("%") >= 0 ? g = parseFloat(g.replace("%", "")) / 100 * e.size : typeof g == "string" && (g = parseFloat(g)), g;
  }, c = (g) => {
    const {
      slidesPerView: m
    } = e.params, {
      rows: v,
      fill: y
    } = e.params.grid, E = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : g.length;
    a = Math.floor(E / v), Math.floor(E / v) === E / v ? s = E : s = Math.ceil(E / v) * v, m !== "auto" && y === "row" && (s = Math.max(s, m * v)), r = s / v;
  }, u = () => {
    e.slides && e.slides.forEach((g) => {
      g.swiperSlideGridSet && (g.style.height = "", g.style[e.getDirectionLabel("margin-top")] = "");
    });
  }, d = (g, m, v) => {
    const {
      slidesPerGroup: y
    } = e.params, E = l(), {
      rows: T,
      fill: S
    } = e.params.grid, w = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : v.length;
    let b, L, A;
    if (S === "row" && y > 1) {
      const _ = Math.floor(g / (y * T)), R = g - T * y * _, I = _ === 0 ? y : Math.min(Math.ceil((w - _ * T * y) / T), y);
      A = Math.floor(R / I), L = R - A * I + _ * y, b = L + A * s / T, m.style.order = b;
    } else S === "column" ? (L = Math.floor(g / T), A = g - L * T, (L > a || L === a && A === T - 1) && (A += 1, A >= T && (A = 0, L += 1))) : (A = Math.floor(g / r), L = g - A * r);
    m.row = A, m.column = L, m.style.height = `calc((100% - ${(T - 1) * E}px) / ${T})`, m.style[e.getDirectionLabel("margin-top")] = A !== 0 ? E && `${E}px` : "", m.swiperSlideGridSet = !0;
  }, f = (g, m) => {
    const {
      centeredSlides: v,
      roundLengths: y
    } = e.params, E = l(), {
      rows: T
    } = e.params.grid;
    if (e.virtualSize = (g + E) * s, e.virtualSize = Math.ceil(e.virtualSize / T) - E, e.params.cssMode || (e.wrapperEl.style[e.getDirectionLabel("width")] = `${e.virtualSize + E}px`), v) {
      const S = [];
      for (let w = 0; w < m.length; w += 1) {
        let b = m[w];
        y && (b = Math.floor(b)), m[w] < e.virtualSize + m[0] && S.push(b);
      }
      m.splice(0, m.length), m.push(...S);
    }
  }, p = () => {
    o = e.params.grid && e.params.grid.rows > 1;
  }, h = () => {
    const {
      params: g,
      el: m
    } = e, v = g.grid && g.grid.rows > 1;
    o && !v ? (m.classList.remove(`${g.containerModifierClass}grid`, `${g.containerModifierClass}grid-column`), a = 1, e.emitContainerClasses()) : !o && v && (m.classList.add(`${g.containerModifierClass}grid`), g.grid.fill === "column" && m.classList.add(`${g.containerModifierClass}grid-column`), e.emitContainerClasses()), o = v;
  };
  i("init", p), i("update", h), e.grid = {
    initSlides: c,
    unsetSlides: u,
    updateSlide: d,
    updateWrapperSize: f
  };
}
function $_(n) {
  const e = this, {
    params: t,
    slidesEl: i
  } = e;
  t.loop && e.loopDestroy();
  const s = (r) => {
    if (typeof r == "string") {
      const a = document.createElement("div");
      As(a, r), i.append(a.children[0]), As(a, "");
    } else
      i.append(r);
  };
  if (typeof n == "object" && "length" in n)
    for (let r = 0; r < n.length; r += 1)
      n[r] && s(n[r]);
  else
    s(n);
  e.recalcSlides(), t.loop && e.loopCreate(), (!t.observer || e.isElement) && e.update();
}
function B_(n) {
  const e = this, {
    params: t,
    activeIndex: i,
    slidesEl: s
  } = e;
  t.loop && e.loopDestroy();
  let r = i + 1;
  const a = (o) => {
    if (typeof o == "string") {
      const l = document.createElement("div");
      As(l, o), s.prepend(l.children[0]), As(l, "");
    } else
      s.prepend(o);
  };
  if (typeof n == "object" && "length" in n) {
    for (let o = 0; o < n.length; o += 1)
      n[o] && a(n[o]);
    r = i + n.length;
  } else
    a(n);
  e.recalcSlides(), t.loop && e.loopCreate(), (!t.observer || e.isElement) && e.update(), e.slideTo(r, 0, !1);
}
function U_(n, e) {
  const t = this, {
    params: i,
    activeIndex: s,
    slidesEl: r
  } = t;
  let a = s;
  i.loop && (a -= t.loopedSlides, t.loopDestroy(), t.recalcSlides());
  const o = t.slides.length;
  if (n <= 0) {
    t.prependSlide(e);
    return;
  }
  if (n >= o) {
    t.appendSlide(e);
    return;
  }
  let l = a > n ? a + 1 : a;
  const c = [];
  for (let u = o - 1; u >= n; u -= 1) {
    const d = t.slides[u];
    d.remove(), c.unshift(d);
  }
  if (typeof e == "object" && "length" in e) {
    for (let u = 0; u < e.length; u += 1)
      e[u] && r.append(e[u]);
    l = a > n ? a + e.length : a;
  } else
    r.append(e);
  for (let u = 0; u < c.length; u += 1)
    r.append(c[u]);
  t.recalcSlides(), i.loop && t.loopCreate(), (!i.observer || t.isElement) && t.update(), i.loop ? t.slideTo(l + t.loopedSlides, 0, !1) : t.slideTo(l, 0, !1);
}
function G_(n) {
  const e = this, {
    params: t,
    activeIndex: i
  } = e;
  let s = i;
  t.loop && (s -= e.loopedSlides, e.loopDestroy());
  let r = s, a;
  if (typeof n == "object" && "length" in n) {
    for (let o = 0; o < n.length; o += 1)
      a = n[o], e.slides[a] && e.slides[a].remove(), a < r && (r -= 1);
    r = Math.max(r, 0);
  } else
    a = n, e.slides[a] && e.slides[a].remove(), a < r && (r -= 1), r = Math.max(r, 0);
  e.recalcSlides(), t.loop && e.loopCreate(), (!t.observer || e.isElement) && e.update(), t.loop ? e.slideTo(r + e.loopedSlides, 0, !1) : e.slideTo(r, 0, !1);
}
function H_() {
  const n = this, e = [];
  for (let t = 0; t < n.slides.length; t += 1)
    e.push(t);
  n.removeSlide(e);
}
function V_(n) {
  let {
    swiper: e
  } = n;
  Object.assign(e, {
    appendSlide: $_.bind(e),
    prependSlide: B_.bind(e),
    addSlide: U_.bind(e),
    removeSlide: G_.bind(e),
    removeAllSlides: H_.bind(e)
  });
}
function Tn(n) {
  const {
    effect: e,
    swiper: t,
    on: i,
    setTranslate: s,
    setTransition: r,
    overwriteParams: a,
    perspective: o,
    recreateShadows: l,
    getEffectParams: c
  } = n;
  i("beforeInit", () => {
    if (t.params.effect !== e) return;
    t.classNames.push(`${t.params.containerModifierClass}${e}`), o && o() && t.classNames.push(`${t.params.containerModifierClass}3d`);
    const d = a ? a() : {};
    Object.assign(t.params, d), Object.assign(t.originalParams, d);
  }), i("setTranslate _virtualUpdated", () => {
    t.params.effect === e && s();
  }), i("setTransition", (d, f) => {
    t.params.effect === e && r(f);
  }), i("transitionEnd", () => {
    if (t.params.effect === e && l) {
      if (!c || !c().slideShadows) return;
      t.slides.forEach((d) => {
        d.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((f) => f.remove());
      }), l();
    }
  });
  let u;
  i("virtualUpdate", () => {
    t.params.effect === e && (t.slides.length || (u = !0), requestAnimationFrame(() => {
      u && t.slides && t.slides.length && (s(), u = !1);
    }));
  });
}
function ba(n, e) {
  const t = Pr(e);
  return t !== e && (t.style.backfaceVisibility = "hidden", t.style["-webkit-backface-visibility"] = "hidden"), t;
}
function al(n) {
  let {
    swiper: e,
    duration: t,
    transformElements: i,
    allSlides: s
  } = n;
  const {
    activeIndex: r
  } = e, a = (o) => o.parentElement ? o.parentElement : e.slides.find((c) => c.shadowRoot && c.shadowRoot === o.parentNode);
  if (e.params.virtualTranslate && t !== 0) {
    let o = !1, l;
    s ? l = i : l = i.filter((c) => {
      const u = c.classList.contains("swiper-slide-transform") ? a(c) : c;
      return e.getSlideIndex(u) === r;
    }), l.forEach((c) => {
      ta(c, () => {
        if (o || !e || e.destroyed) return;
        o = !0, e.animating = !1;
        const u = new window.CustomEvent("transitionend", {
          bubbles: !0,
          cancelable: !0
        });
        e.wrapperEl.dispatchEvent(u);
      });
    });
  }
}
function z_(n) {
  let {
    swiper: e,
    extendParams: t,
    on: i
  } = n;
  t({
    fadeEffect: {
      crossFade: !1
    }
  }), Tn({
    effect: "fade",
    swiper: e,
    on: i,
    setTranslate: () => {
      const {
        slides: a
      } = e, o = e.params.fadeEffect;
      for (let l = 0; l < a.length; l += 1) {
        const c = e.slides[l];
        let d = -c.swiperSlideOffset;
        e.params.virtualTranslate || (d -= e.translate);
        let f = 0;
        e.isHorizontal() || (f = d, d = 0);
        const p = e.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(c.progress), 0) : 1 + Math.min(Math.max(c.progress, -1), 0), h = ba(o, c);
        h.style.opacity = p, h.style.transform = `translate3d(${d}px, ${f}px, 0px)`;
      }
    },
    setTransition: (a) => {
      const o = e.slides.map((l) => Pr(l));
      o.forEach((l) => {
        l.style.transitionDuration = `${a}ms`;
      }), al({
        swiper: e,
        duration: a,
        transformElements: o,
        allSlides: !0
      });
    },
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: !0,
      spaceBetween: 0,
      virtualTranslate: !e.params.cssMode
    })
  });
}
function W_(n) {
  let {
    swiper: e,
    extendParams: t,
    on: i
  } = n;
  t({
    cubeEffect: {
      slideShadows: !0,
      shadow: !0,
      shadowOffset: 20,
      shadowScale: 0.94
    }
  });
  const s = (l, c, u) => {
    let d = u ? l.querySelector(".swiper-slide-shadow-left") : l.querySelector(".swiper-slide-shadow-top"), f = u ? l.querySelector(".swiper-slide-shadow-right") : l.querySelector(".swiper-slide-shadow-bottom");
    d || (d = Si("div", `swiper-slide-shadow-cube swiper-slide-shadow-${u ? "left" : "top"}`.split(" ")), l.append(d)), f || (f = Si("div", `swiper-slide-shadow-cube swiper-slide-shadow-${u ? "right" : "bottom"}`.split(" ")), l.append(f)), d && (d.style.opacity = Math.max(-c, 0)), f && (f.style.opacity = Math.max(c, 0));
  };
  Tn({
    effect: "cube",
    swiper: e,
    on: i,
    setTranslate: () => {
      const {
        el: l,
        wrapperEl: c,
        slides: u,
        width: d,
        height: f,
        rtlTranslate: p,
        size: h,
        browser: g
      } = e, m = nl(e), v = e.params.cubeEffect, y = e.isHorizontal(), E = e.virtual && e.params.virtual.enabled;
      let T = 0, S;
      v.shadow && (y ? (S = e.wrapperEl.querySelector(".swiper-cube-shadow"), S || (S = Si("div", "swiper-cube-shadow"), e.wrapperEl.append(S)), S.style.height = `${d}px`) : (S = l.querySelector(".swiper-cube-shadow"), S || (S = Si("div", "swiper-cube-shadow"), l.append(S))));
      for (let b = 0; b < u.length; b += 1) {
        const L = u[b];
        let A = b;
        E && (A = parseInt(L.getAttribute("data-swiper-slide-index"), 10));
        let _ = A * 90, R = Math.floor(_ / 360);
        p && (_ = -_, R = Math.floor(-_ / 360));
        const I = Math.max(Math.min(L.progress, 1), -1);
        let k = 0, M = 0, O = 0;
        A % 4 === 0 ? (k = -R * 4 * h, O = 0) : (A - 1) % 4 === 0 ? (k = 0, O = -R * 4 * h) : (A - 2) % 4 === 0 ? (k = h + R * 4 * h, O = h) : (A - 3) % 4 === 0 && (k = -h, O = 3 * h + h * 4 * R), p && (k = -k), y || (M = k, k = 0);
        const F = `rotateX(${m(y ? 0 : -_)}deg) rotateY(${m(y ? _ : 0)}deg) translate3d(${k}px, ${M}px, ${O}px)`;
        I <= 1 && I > -1 && (T = A * 90 + I * 90, p && (T = -A * 90 - I * 90)), L.style.transform = F, v.slideShadows && s(L, I, y);
      }
      if (c.style.transformOrigin = `50% 50% -${h / 2}px`, c.style["-webkit-transform-origin"] = `50% 50% -${h / 2}px`, v.shadow)
        if (y)
          S.style.transform = `translate3d(0px, ${d / 2 + v.shadowOffset}px, ${-d / 2}px) rotateX(89.99deg) rotateZ(0deg) scale(${v.shadowScale})`;
        else {
          const b = Math.abs(T) - Math.floor(Math.abs(T) / 90) * 90, L = 1.5 - (Math.sin(b * 2 * Math.PI / 360) / 2 + Math.cos(b * 2 * Math.PI / 360) / 2), A = v.shadowScale, _ = v.shadowScale / L, R = v.shadowOffset;
          S.style.transform = `scale3d(${A}, 1, ${_}) translate3d(0px, ${f / 2 + R}px, ${-f / 2 / _}px) rotateX(-89.99deg)`;
        }
      const w = (g.isSafari || g.isWebView) && g.needPerspectiveFix ? -h / 2 : 0;
      c.style.transform = `translate3d(0px,0,${w}px) rotateX(${m(e.isHorizontal() ? 0 : T)}deg) rotateY(${m(e.isHorizontal() ? -T : 0)}deg)`, c.style.setProperty("--swiper-cube-translate-z", `${w}px`);
    },
    setTransition: (l) => {
      const {
        el: c,
        slides: u
      } = e;
      if (u.forEach((d) => {
        d.style.transitionDuration = `${l}ms`, d.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((f) => {
          f.style.transitionDuration = `${l}ms`;
        });
      }), e.params.cubeEffect.shadow && !e.isHorizontal()) {
        const d = c.querySelector(".swiper-cube-shadow");
        d && (d.style.transitionDuration = `${l}ms`);
      }
    },
    recreateShadows: () => {
      const l = e.isHorizontal();
      e.slides.forEach((c) => {
        const u = Math.max(Math.min(c.progress, 1), -1);
        s(c, u, l);
      });
    },
    getEffectParams: () => e.params.cubeEffect,
    perspective: () => !0,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: !0,
      resistanceRatio: 0,
      spaceBetween: 0,
      centeredSlides: !1,
      virtualTranslate: !0
    })
  });
}
function En(n, e, t) {
  const i = `swiper-slide-shadow${t ? `-${t}` : ""}${n ? ` swiper-slide-shadow-${n}` : ""}`, s = Pr(e);
  let r = s.querySelector(`.${i.split(" ").join(".")}`);
  return r || (r = Si("div", i.split(" ")), s.append(r)), r;
}
function K_(n) {
  let {
    swiper: e,
    extendParams: t,
    on: i
  } = n;
  t({
    flipEffect: {
      slideShadows: !0,
      limitRotation: !0
    }
  });
  const s = (l, c) => {
    let u = e.isHorizontal() ? l.querySelector(".swiper-slide-shadow-left") : l.querySelector(".swiper-slide-shadow-top"), d = e.isHorizontal() ? l.querySelector(".swiper-slide-shadow-right") : l.querySelector(".swiper-slide-shadow-bottom");
    u || (u = En("flip", l, e.isHorizontal() ? "left" : "top")), d || (d = En("flip", l, e.isHorizontal() ? "right" : "bottom")), u && (u.style.opacity = Math.max(-c, 0)), d && (d.style.opacity = Math.max(c, 0));
  };
  Tn({
    effect: "flip",
    swiper: e,
    on: i,
    setTranslate: () => {
      const {
        slides: l,
        rtlTranslate: c
      } = e, u = e.params.flipEffect, d = nl(e);
      for (let f = 0; f < l.length; f += 1) {
        const p = l[f];
        let h = p.progress;
        e.params.flipEffect.limitRotation && (h = Math.max(Math.min(p.progress, 1), -1));
        const g = p.swiperSlideOffset;
        let v = -180 * h, y = 0, E = e.params.cssMode ? -g - e.translate : -g, T = 0;
        e.isHorizontal() ? c && (v = -v) : (T = E, E = 0, y = -v, v = 0), p.style.zIndex = -Math.abs(Math.round(h)) + l.length, u.slideShadows && s(p, h);
        const S = `translate3d(${E}px, ${T}px, 0px) rotateX(${d(y)}deg) rotateY(${d(v)}deg)`, w = ba(u, p);
        w.style.transform = S;
      }
    },
    setTransition: (l) => {
      const c = e.slides.map((u) => Pr(u));
      c.forEach((u) => {
        u.style.transitionDuration = `${l}ms`, u.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((d) => {
          d.style.transitionDuration = `${l}ms`;
        });
      }), al({
        swiper: e,
        duration: l,
        transformElements: c
      });
    },
    recreateShadows: () => {
      e.params.flipEffect, e.slides.forEach((l) => {
        let c = l.progress;
        e.params.flipEffect.limitRotation && (c = Math.max(Math.min(l.progress, 1), -1)), s(l, c);
      });
    },
    getEffectParams: () => e.params.flipEffect,
    perspective: () => !0,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: !0,
      spaceBetween: 0,
      virtualTranslate: !e.params.cssMode
    })
  });
}
function Y_(n) {
  let {
    swiper: e,
    extendParams: t,
    on: i
  } = n;
  t({
    coverflowEffect: {
      rotate: 50,
      stretch: 0,
      depth: 100,
      scale: 1,
      modifier: 1,
      slideShadows: !0
    }
  }), Tn({
    effect: "coverflow",
    swiper: e,
    on: i,
    setTranslate: () => {
      const {
        width: a,
        height: o,
        slides: l,
        slidesSizesGrid: c
      } = e, u = e.params.coverflowEffect, d = e.isHorizontal(), f = e.translate, p = d ? -f + a / 2 : -f + o / 2, h = d ? u.rotate : -u.rotate, g = u.depth, m = nl(e);
      for (let v = 0, y = l.length; v < y; v += 1) {
        const E = l[v], T = c[v], S = E.swiperSlideOffset, w = (p - S - T / 2) / T, b = typeof u.modifier == "function" ? u.modifier(w) : w * u.modifier;
        let L = d ? h * b : 0, A = d ? 0 : h * b, _ = -g * Math.abs(b), R = u.stretch;
        typeof R == "string" && R.indexOf("%") !== -1 && (R = parseFloat(u.stretch) / 100 * T);
        let I = d ? 0 : R * b, k = d ? R * b : 0, M = 1 - (1 - u.scale) * Math.abs(b);
        Math.abs(k) < 1e-3 && (k = 0), Math.abs(I) < 1e-3 && (I = 0), Math.abs(_) < 1e-3 && (_ = 0), Math.abs(L) < 1e-3 && (L = 0), Math.abs(A) < 1e-3 && (A = 0), Math.abs(M) < 1e-3 && (M = 0);
        const O = `translate3d(${k}px,${I}px,${_}px)  rotateX(${m(A)}deg) rotateY(${m(L)}deg) scale(${M})`, F = ba(u, E);
        if (F.style.transform = O, E.style.zIndex = -Math.abs(Math.round(b)) + 1, u.slideShadows) {
          let C = d ? E.querySelector(".swiper-slide-shadow-left") : E.querySelector(".swiper-slide-shadow-top"), D = d ? E.querySelector(".swiper-slide-shadow-right") : E.querySelector(".swiper-slide-shadow-bottom");
          C || (C = En("coverflow", E, d ? "left" : "top")), D || (D = En("coverflow", E, d ? "right" : "bottom")), C && (C.style.opacity = b > 0 ? b : 0), D && (D.style.opacity = -b > 0 ? -b : 0);
        }
      }
    },
    setTransition: (a) => {
      e.slides.map((l) => Pr(l)).forEach((l) => {
        l.style.transitionDuration = `${a}ms`, l.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((c) => {
          c.style.transitionDuration = `${a}ms`;
        });
      });
    },
    perspective: () => !0,
    overwriteParams: () => ({
      watchSlidesProgress: !0
    })
  });
}
function q_(n) {
  let {
    swiper: e,
    extendParams: t,
    on: i
  } = n;
  t({
    creativeEffect: {
      limitProgress: 1,
      shadowPerProgress: !1,
      progressMultiplier: 1,
      perspective: !0,
      prev: {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        opacity: 1,
        scale: 1
      },
      next: {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        opacity: 1,
        scale: 1
      }
    }
  });
  const s = (o) => typeof o == "string" ? o : `${o}px`;
  Tn({
    effect: "creative",
    swiper: e,
    on: i,
    setTranslate: () => {
      const {
        slides: o,
        wrapperEl: l,
        slidesSizesGrid: c
      } = e, u = e.params.creativeEffect, {
        progressMultiplier: d
      } = u, f = e.params.centeredSlides, p = nl(e);
      if (f) {
        const h = c[0] / 2 - e.params.slidesOffsetBefore || 0;
        l.style.transform = `translateX(calc(50% - ${h}px))`;
      }
      for (let h = 0; h < o.length; h += 1) {
        const g = o[h], m = g.progress, v = Math.min(Math.max(g.progress, -u.limitProgress), u.limitProgress);
        let y = v;
        f || (y = Math.min(Math.max(g.originalProgress, -u.limitProgress), u.limitProgress));
        const E = g.swiperSlideOffset, T = [e.params.cssMode ? -E - e.translate : -E, 0, 0], S = [0, 0, 0];
        let w = !1;
        e.isHorizontal() || (T[1] = T[0], T[0] = 0);
        let b = {
          translate: [0, 0, 0],
          rotate: [0, 0, 0],
          scale: 1,
          opacity: 1
        };
        v < 0 ? (b = u.next, w = !0) : v > 0 && (b = u.prev, w = !0), T.forEach((M, O) => {
          T[O] = `calc(${M}px + (${s(b.translate[O])} * ${Math.abs(v * d)}))`;
        }), S.forEach((M, O) => {
          let F = b.rotate[O] * Math.abs(v * d);
          S[O] = F;
        }), g.style.zIndex = -Math.abs(Math.round(m)) + o.length;
        const L = T.join(", "), A = `rotateX(${p(S[0])}deg) rotateY(${p(S[1])}deg) rotateZ(${p(S[2])}deg)`, _ = y < 0 ? `scale(${1 + (1 - b.scale) * y * d})` : `scale(${1 - (1 - b.scale) * y * d})`, R = y < 0 ? 1 + (1 - b.opacity) * y * d : 1 - (1 - b.opacity) * y * d, I = `translate3d(${L}) ${A} ${_}`;
        if (w && b.shadow || !w) {
          let M = g.querySelector(".swiper-slide-shadow");
          if (!M && b.shadow && (M = En("creative", g)), M) {
            const O = u.shadowPerProgress ? v * (1 / u.limitProgress) : v;
            M.style.opacity = Math.min(Math.max(Math.abs(O), 0), 1);
          }
        }
        const k = ba(u, g);
        k.style.transform = I, k.style.opacity = R, b.origin && (k.style.transformOrigin = b.origin);
      }
    },
    setTransition: (o) => {
      const l = e.slides.map((c) => Pr(c));
      l.forEach((c) => {
        c.style.transitionDuration = `${o}ms`, c.querySelectorAll(".swiper-slide-shadow").forEach((u) => {
          u.style.transitionDuration = `${o}ms`;
        });
      }), al({
        swiper: e,
        duration: o,
        transformElements: l,
        allSlides: !0
      });
    },
    perspective: () => e.params.creativeEffect.perspective,
    overwriteParams: () => ({
      watchSlidesProgress: !0,
      virtualTranslate: !e.params.cssMode
    })
  });
}
function X_(n) {
  let {
    swiper: e,
    extendParams: t,
    on: i
  } = n;
  t({
    cardsEffect: {
      slideShadows: !0,
      rotate: !0,
      perSlideRotate: 2,
      perSlideOffset: 8
    }
  }), Tn({
    effect: "cards",
    swiper: e,
    on: i,
    setTranslate: () => {
      const {
        slides: a,
        activeIndex: o,
        rtlTranslate: l
      } = e, c = e.params.cardsEffect, {
        startTranslate: u,
        isTouched: d
      } = e.touchEventsData, f = l ? -e.translate : e.translate;
      for (let p = 0; p < a.length; p += 1) {
        const h = a[p], g = h.progress, m = Math.min(Math.max(g, -4), 4);
        let v = h.swiperSlideOffset;
        e.params.centeredSlides && !e.params.cssMode && (e.wrapperEl.style.transform = `translateX(${e.minTranslate()}px)`), e.params.centeredSlides && e.params.cssMode && (v -= a[0].swiperSlideOffset);
        let y = e.params.cssMode ? -v - e.translate : -v, E = 0;
        const T = -100 * Math.abs(m);
        let S = 1, w = -c.perSlideRotate * m, b = c.perSlideOffset - Math.abs(m) * 0.75;
        const L = e.virtual && e.params.virtual.enabled ? e.virtual.from + p : p, A = (L === o || L === o - 1) && m > 0 && m < 1 && (d || e.params.cssMode) && f < u, _ = (L === o || L === o + 1) && m < 0 && m > -1 && (d || e.params.cssMode) && f > u;
        if (A || _) {
          const M = (1 - Math.abs((Math.abs(m) - 0.5) / 0.5)) ** 0.5;
          w += -28 * m * M, S += -0.5 * M, b += 96 * M, E = `${-25 * M * Math.abs(m)}%`;
        }
        if (m < 0 ? y = `calc(${y}px ${l ? "-" : "+"} (${b * Math.abs(m)}%))` : m > 0 ? y = `calc(${y}px ${l ? "-" : "+"} (-${b * Math.abs(m)}%))` : y = `${y}px`, !e.isHorizontal()) {
          const M = E;
          E = y, y = M;
        }
        const R = m < 0 ? `${1 + (1 - S) * m}` : `${1 - (1 - S) * m}`, I = `
        translate3d(${y}, ${E}, ${T}px)
        rotateZ(${c.rotate ? l ? -w : w : 0}deg)
        scale(${R})
      `;
        if (c.slideShadows) {
          let M = h.querySelector(".swiper-slide-shadow");
          M || (M = En("cards", h)), M && (M.style.opacity = Math.min(Math.max((Math.abs(m) - 0.5) / 0.5, 0), 1));
        }
        h.style.zIndex = -Math.abs(Math.round(g)) + a.length;
        const k = ba(c, h);
        k.style.transform = I;
      }
    },
    setTransition: (a) => {
      const o = e.slides.map((l) => Pr(l));
      o.forEach((l) => {
        l.style.transitionDuration = `${a}ms`, l.querySelectorAll(".swiper-slide-shadow").forEach((c) => {
          c.style.transitionDuration = `${a}ms`;
        });
      }), al({
        swiper: e,
        duration: a,
        transformElements: o
      });
    },
    perspective: () => !0,
    overwriteParams: () => ({
      _loopSwapReset: !1,
      watchSlidesProgress: !0,
      loopAdditionalSlides: e.params.cardsEffect.rotate ? 3 : 2,
      centeredSlides: !0,
      virtualTranslate: !e.params.cssMode
    })
  });
}
const j_ = [x_, b_, __, A_, w_, L_, I_, R_, C_, P_, D_, k_, M_, O_, F_, N_, V_, z_, W_, K_, Y_, q_, X_];
hi.use(j_);
const Jc = {
  swipers: [],
  isInitialized: !1,
  // Check if device is mobile/tablet (not desktop)
  isMobileOrTablet() {
    return window.innerWidth < 480 || "ontouchstart" in window;
  },
  // Cache commonly used elements
  cacheElements() {
    return {
      heroTitleLine1: document.querySelectorAll('.home_title_text[data-line="1"]'),
      heroTitleLine2: document.querySelectorAll('.home_title_text[data-line="2"]'),
      infoLine1: document.querySelectorAll('.home_info_text[data-line="1"]'),
      infoLine2: document.querySelectorAll('.home_info_text[data-line="2"]'),
      infoLine3: document.querySelectorAll('.home_info_text[data-line="3"]'),
      locationElement: document.querySelectorAll('.home_info_text[data-line="location"]'),
      timeElement: document.querySelectorAll('[data-line="time"]'),
      yearElement: document.querySelectorAll('.home_info_text[data-line="year"]')
    };
  },
  // Update content with shuffle effect
  updateContent(n) {
    if (!n || typeof Q > "u") return;
    const e = this.cacheElements(), t = {
      title: n.getAttribute("data-project-title") || "",
      service1: n.getAttribute("data-project-service1") || "",
      service2: n.getAttribute("data-project-service2") || "",
      service3: n.getAttribute("data-project-service3") || "",
      year: n.getAttribute("data-project-year") || ""
    };
    e.locationElement.forEach((a) => a.style.display = "none"), e.timeElement.forEach((a) => a.style.display = "none");
    const i = t.title.split(" "), s = i[0] || "", r = i.slice(1).join(" ") || "";
    setTimeout(() => {
      [
        [e.heroTitleLine1, s],
        [e.heroTitleLine2, r],
        [e.infoLine1, t.service1],
        [e.infoLine2, t.service2],
        [e.infoLine3, t.service3],
        [e.yearElement, t.year]
      ].forEach(([o, l]) => {
        o.forEach((c) => {
          Q.shuffleWords(c.textContent, l, c, 50, !0);
        });
      });
    }, 50), e.timeElement[0] && e.yearElement[0] && Q.hoverAnimations && Q.hoverAnimations.toggleTimeAndYear(
      e.timeElement[0],
      e.yearElement[0],
      !0,
      t.year
    );
  },
  // Initialize single slider
  initializeSlider(n, e) {
    const t = $(n), i = parseInt(t.attr("slider-duration")) || 800, s = t.find(".swiper")[0];
    if (!s) return null;
    const r = new hi(s, {
      speed: i,
      loop: !0,
      loopAdditionalSlides: 1,
      autoHeight: !1,
      centeredSlides: !0,
      followFinger: !0,
      freeMode: !1,
      slideToClickedSlide: !1,
      slidesPerView: 1,
      spaceBetween: "5%",
      rewind: !1,
      mousewheel: {
        forceToAxis: !0
      },
      keyboard: {
        enabled: !0,
        onlyInViewport: !0
      },
      breakpoints: {
        480: { slidesPerView: 1, spaceBetween: "5%" }
      },
      pagination: {
        el: t.find(".swiper_pagination")[0],
        type: "fraction"
      },
      navigation: {
        nextEl: t.find(".swiper-next")[0],
        prevEl: t.find(".swiper-prev")[0],
        disabledClass: "is-disabled"
      },
      scrollbar: {
        el: t.find(".swiper-drag-wrapper")[0],
        draggable: !0,
        dragClass: "swiper-drag",
        snapOnRelease: !0
      },
      slideActiveClass: "is-active",
      slideDuplicateActiveClass: "is-active",
      observer: !0,
      observeParents: !0,
      watchSlidesProgress: !0,
      touchRatio: 1,
      touchAngle: 45,
      grabCursor: !0,
      preventInteractionOnTransition: !0
    });
    return r.on("slideChangeTransitionStart", () => {
      r.slides.forEach((a) => a.classList.remove("is-active")), r.slides[r.activeIndex] && (r.slides[r.activeIndex].classList.add("is-active"), this.updateContent(r.slides[r.activeIndex]));
    }), r.on("transitionEnd", () => {
      r.slides.forEach((a) => a.classList.remove("is-active")), r.slides[r.activeIndex] && r.slides[r.activeIndex].classList.add("is-active");
    }), r.slides.length > 0 && r.slides[r.activeIndex] && this.updateContent(r.slides[r.activeIndex]), r;
  },
  // Initialize all sliders
  initSlider() {
    return this.isMobileOrTablet() ? (this.cleanup(), $(".slider-main_component").each((n, e) => {
      const t = this.initializeSlider(e, n);
      t && this.swipers.push(t);
    }), this.isInitialized = !0, !0) : !1;
  },
  // Cleanup all swipers
  cleanup() {
    this.swipers.forEach((n) => {
      n && n.destroy && n.destroy(!0, !0);
    }), this.swipers = [], this.isInitialized = !1;
  },
  // Handle window resize
  handleResize() {
    !this.isMobileOrTablet() && this.isInitialized ? this.cleanup() : this.isMobileOrTablet() && !this.isInitialized && this.initSlider();
  },
  // Public methods
  reinitialize() {
    return this.cleanup(), this.initSlider();
  },
  destroy() {
    this.cleanup();
  }
};
function Q_() {
  return Jc.initSlider();
}
document.addEventListener("DOMContentLoaded", () => {
  Jc.initSlider();
  let n;
  window.addEventListener("resize", () => {
    clearTimeout(n), n = setTimeout(() => {
      Jc.handleResize();
    }, 250);
  });
});
function Z_() {
  const n = document.querySelectorAll("[data-time]");
  if (!n?.length) return;
  const e = {
    timeZone: "Europe/Vienna",
    hour12: !1,
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit"
  }, t = () => {
    const i = new Intl.DateTimeFormat("en-GB", e).format(/* @__PURE__ */ new Date());
    n.forEach((s) => s.textContent = i);
  };
  t(), setInterval(t, 1e3);
}
const eu = {
  elements: {},
  isInitialized: !1,
  eventListeners: [],
  timeInterval: null,
  // Check if device is desktop
  isDesktop() {
    return window.innerWidth >= 480 && !("ontouchstart" in window);
  },
  cacheElements() {
    return this.elements = {
      projectCards: document.querySelectorAll(".showcase_item"),
      heroTitleLine1: document.querySelector('.home_title_text[data-line="1"]'),
      heroTitleLine2: document.querySelector('.home_title_text[data-line="2"]'),
      infoLine1: document.querySelector('.home_info_text[data-line="1"]'),
      infoLine2: document.querySelector('.home_info_text[data-line="2"]'),
      infoLine3: document.querySelector('.home_info_text[data-line="3"]'),
      locationElement: document.querySelector('.home_info_text[data-line="location"]'),
      timeElement: document.querySelector('[data-line="time"]'),
      yearElement: document.querySelector('.home_info_text[data-line="year"]'),
      showcaseItemInners: document.querySelectorAll(".showcase_item_inner")
    }, this.elements.projectCards.length > 0;
  },
  toggleTimeAndYear(n, e, t, i = "") {
    if (!(!n || !e))
      try {
        t ? (n.style.display = "none", e.style.display = "block", Q.shuffleWords(e.textContent, i, e, 50, !0)) : Q.shuffleWords(e.textContent, n.textContent, e, 50, !0, () => {
          e.style.display = "none", n.style.display = "block";
        });
      } catch (s) {
        console.error("Toggle time/year failed:", s);
      }
  },
  cleanup() {
    this.eventListeners.forEach(({ element: n, event: e, handler: t }) => {
      n?.removeEventListener(e, t);
    }), this.eventListeners = [], this.timeInterval && (clearInterval(this.timeInterval), this.timeInterval = null);
  },
  attachProjectCardEvents() {
    this.elements.projectCards.forEach((n) => {
      const e = () => {
        try {
          const i = {
            title: n.getAttribute("data-project-title") || "",
            service1: n.getAttribute("data-project-service1") || "",
            service2: n.getAttribute("data-project-service2") || "",
            service3: n.getAttribute("data-project-service3") || "",
            year: n.getAttribute("data-project-year") || ""
          }, [s = "", r = ""] = i.title.split(" ");
          this.elements.heroTitleLine1 && Q.shuffleWords(
            this.elements.heroTitleLine1.textContent,
            r ? s : "",
            this.elements.heroTitleLine1,
            50,
            !0
          ), this.elements.heroTitleLine2 && Q.shuffleWords(
            this.elements.heroTitleLine2.textContent,
            r || s,
            this.elements.heroTitleLine2,
            50,
            !0
          ), [this.elements.infoLine1, this.elements.infoLine2, this.elements.infoLine3].forEach((a, o) => {
            if (a) {
              const l = [i.service1 || " ", i.service2, i.service3][o];
              Q.shuffleWords(a.textContent, l || "", a, 50, !0);
            }
          }), this.elements.locationElement && Q.shuffleWords(this.elements.locationElement.textContent, "", this.elements.locationElement, 50, !0), this.toggleTimeAndYear(this.elements.timeElement, this.elements.yearElement, !0, i.year), this.applyHoverEffects(n);
        } catch (i) {
          console.error("Mouseenter handler failed:", i);
        }
      }, t = () => {
        try {
          [
            [this.elements.heroTitleLine1, "Rylan"],
            [this.elements.heroTitleLine2, "Phillips"],
            [this.elements.infoLine1, " "],
            [this.elements.infoLine2, "Designer &"],
            [this.elements.infoLine3, "Developer"],
            [this.elements.locationElement, "Vienna, AT"]
          ].forEach(([s, r]) => {
            s && r !== void 0 && Q.shuffleWords(s.textContent, r, s, 50, !0);
          }), this.toggleTimeAndYear(this.elements.timeElement, this.elements.yearElement, !1), this.removeHoverEffects();
        } catch (i) {
          console.error("Mouseleave handler failed:", i);
        }
      };
      n.addEventListener("mouseenter", e), n.addEventListener("mouseleave", t), this.eventListeners.push(
        { element: n, event: "mouseenter", handler: e },
        { element: n, event: "mouseleave", handler: t }
      );
    });
  },
  applyHoverEffects(n) {
    this.elements.projectCards.forEach((e) => {
      if (e !== n) {
        const t = e.querySelector(".showcase_item_inner");
        t && (t.style.filter = "blur(8px)");
        const i = e.querySelector(".showcase_desc_left");
        i && (i.style.filter = "blur(8px)"), e.classList.add("shrink");
      }
    }), n.classList.add("hovered");
  },
  removeHoverEffects() {
    this.elements.projectCards.forEach((n) => {
      const e = n.querySelector(".showcase_item_inner");
      e && (e.style.filter = "blur(0px)");
      const t = n.querySelector(".showcase_desc_left");
      t && (t.style.filter = "blur(0px)"), n.classList.remove("shrink", "hovered");
    });
  },
  initialize() {
    return window.location.pathname !== "/" || !this.isDesktop() || typeof Q > "u" ? !1 : (this.cleanup(), this.cacheElements() ? (this.attachProjectCardEvents(), this.isInitialized = !0, !0) : (console.warn("No project cards found"), !1));
  },
  reinitialize() {
    return this.isInitialized = !1, this.initialize();
  },
  // Handle window resize
  handleResize() {
    !this.isDesktop() && this.isInitialized ? (this.cleanup(), this.isInitialized = !1) : this.isDesktop() && !this.isInitialized && this.initialize();
  }
};
document.addEventListener("DOMContentLoaded", () => {
  eu.initialize();
  let n;
  window.addEventListener("resize", () => {
    clearTimeout(n), n = setTimeout(() => {
      eu.handleResize();
    }, 250);
  });
});
const J_ = {
  initializeFirstLoad() {
    if (sessionStorage.getItem("hasVisited")) {
      this.initializeReturnVisit();
      return;
    }
    sessionStorage.setItem("hasVisited", "true");
    const n = document.querySelector(".loader_wrap"), e = document.querySelector('[data-load="title2"]'), t = document.querySelector('[data-load="subtitle"]'), i = document.querySelectorAll('[data-image="desktop"]'), s = document.querySelectorAll('[data-image="mobile"]'), r = document.querySelectorAll('[data-image="desktop"], [data-image="mobile"]');
    if (!n || !e || !t) {
      console.warn("Load animation elements not found, falling back to normal initialization"), Q.initializeSingle(), Q.initializeMulti();
      return;
    }
    me.set(r, { opacity: 0, filter: "blur(12px)" }), me.set([e, t], { opacity: 0 });
    const a = document.querySelectorAll("[data-shuffle-load], [data-preloader]");
    me.set(a, { opacity: 0 });
    const o = 1300, c = Math.max(0, o - 100), u = e.textContent, d = t.textContent;
    me.to(e, { opacity: 1, duration: 0.3, ease: "power3.out" }), Q.shuffleIn("Welcome", e, 50, !1), setTimeout(() => {
      me.to(t, { opacity: 1, duration: 0.3, ease: "power3.out" }), Q.shuffleIn(d, t, 50, !1);
    }, 100), setTimeout(() => {
      Q.shuffleWords(e.textContent || u, u, e, 50, !1), setTimeout(() => {
        Q.shuffleWords(t.textContent || d, d, t, 50, !1);
      }, 0);
    }, c), setTimeout(() => {
      const f = me.timeline();
      f.set(n, { display: "none" }), me.set([e, t], { opacity: 0 }), f.set(a, { opacity: 1 }), f.add(() => {
        Q.loadAnimations.initializeSingle(), Q.loadAnimations.initializeMulti();
      }), f.to(i, {
        opacity: 1,
        filter: "blur(0px)",
        duration: 0.4,
        ease: "power3.out",
        stagger: 0.1
      }, 0.2), f.to(s, {
        opacity: 1,
        filter: "blur(0px)",
        duration: 0.4,
        ease: "power3.out",
        stagger: 0.1
      }, 0.2);
    }, o);
  },
  initializeReturnVisit() {
    const n = document.querySelector(".loader_wrap"), e = document.querySelector('[data-load="title"]'), t = document.querySelector('[data-load="title2"]'), i = document.querySelector('[data-load="subtitle"]'), s = document.querySelectorAll('[data-image="desktop"]'), r = document.querySelectorAll('[data-image="mobile"]'), a = document.querySelectorAll('[data-image="icon"]'), o = document.querySelectorAll('[data-image="desktop"], [data-image="mobile"], [data-image="icon"]');
    if (!n || !e || !i) {
      console.warn("Return visit animation elements not found, falling back to normal initialization"), Q.loadAnimations.initializeSingle(), Q.loadAnimations.initializeMulti();
      return;
    }
    me.set(o, { opacity: 0, filter: "blur(12px)" }), me.set([e, t, i], { opacity: 0 });
    const l = document.querySelectorAll("[data-shuffle-load], [data-preloader]");
    me.set(l, { opacity: 0 });
    const c = 800, d = Math.max(0, c - 100), f = i.textContent;
    me.to(e, { opacity: 1, duration: 0.3, ease: "power3.out" }), Q.shuffleIn("Welcome", e, 50, !1), setTimeout(() => {
      t && (me.to(t, { opacity: 1, duration: 0.3, ease: "power3.out" }), Q.shuffleIn("back", t, 50, !1));
    }), setTimeout(() => {
      me.to(i, { opacity: 1, duration: 0.3, ease: "power3.out" }), Q.shuffleIn(f, i, 50, !1);
    }, 100), setTimeout(() => {
      Q.shuffleWords(e.textContent || "Welcome", "Welcome", e, 50, !1), setTimeout(() => {
        t && Q.shuffleWords(t.textContent || "back", "back", t, 50, !1);
      }, 50), setTimeout(() => {
        Q.shuffleWords(i.textContent || f, f, i, 50, !1);
      }, 100);
    }, d), setTimeout(() => {
      const p = me.timeline();
      p.set(n, { display: "none" }), p.set(l, { opacity: 1 }), p.add(() => {
        Q.loadAnimations.initializeSingle(), Q.loadAnimations.initializeMulti();
      }), p.to(s, {
        opacity: 1,
        filter: "blur(0px)",
        duration: 0.4,
        ease: "power3.out",
        stagger: 0.1
      }, 0.2), p.to(r, {
        opacity: 1,
        filter: "blur(0px)",
        duration: 0.4,
        ease: "power3.out",
        stagger: 0.1
      }, 0.2), p.to(a, {
        opacity: 1,
        filter: "blur(0px)",
        duration: 0.4,
        ease: "power3.out",
        stagger: 0.1
      }, 0.2);
    }, c);
  },
  initialize() {
    if (typeof Q > "u") {
      console.error("ShuffleAnimations not loaded");
      return;
    }
    this.initializeFirstLoad();
  }
};
function Im(n) {
  document.querySelectorAll("[data-nav-btn]").forEach((t) => {
    t.classList.remove("nav-active"), t.removeAttribute("aria-current"), t.classList.remove("w--current"), t.querySelectorAll(".link_bracket_text").forEach((i) => {
      i.style.removeProperty("opacity");
    }), t.getAttribute("data-nav-btn") === n && (t.classList.add("nav-active"), t.classList.add("w--current"), t.setAttribute("aria-current", "page"), t.querySelectorAll(".link_bracket_text").forEach((i) => {
      i.style.opacity = "1";
    }));
  });
}
document.addEventListener("DOMContentLoaded", () => {
  const n = document.querySelector(".w--current[data-nav-btn]");
  if (n) {
    const e = n.getAttribute("data-nav-btn");
    Im(e);
  }
});
const eA = () => {
  window.scrollTo(0, 0);
}, tA = (n) => {
  const t = new DOMParser().parseFromString(n.next.html, "text/html"), i = $(t).find("html").attr("data-wf-page");
  if ($("html").attr("data-wf-page", i), window.Webflow)
    try {
      window.Webflow.destroy(), window.Webflow.ready();
      const s = window.Webflow.require("ix2");
      s && typeof s.init == "function" && s.init();
      const r = window.Webflow.require("forms");
      r && typeof r.ready == "function" && r.ready();
    } catch (s) {
      console.warn("Webflow reinit error:", s);
    }
  document.dispatchEvent(new Event("readystatechange"));
}, iA = (n) => {
  Im(n);
}, sA = {
  name: "shuffle-transition",
  leave(n) {
    return new Promise((e) => {
      const t = [], i = [], s = [];
      n.current.container.querySelectorAll('[data-transition="image"]');
      const r = new IntersectionObserver((a, o) => {
        a.forEach((c) => {
          if (c.isIntersecting) {
            const u = c.target;
            u.hasAttribute("data-shuffle-load") && u.getAttribute("data-shuffle-load") === "multi" ? i.push(u) : (!u.children.length || u.dataset.allowShuffle != null) && u.innerText ? (t.push(u), u.setAttribute("data-original-text", u.innerText)) : (u.classList.contains("content") || u.dataset.fadeContent !== void 0) && s.push(u);
          }
        }), o.disconnect();
        const l = me.timeline({ onComplete: e });
        t.forEach((c) => {
          const u = c.getAttribute("data-original-text");
          c.shuffleInterval = setInterval(() => {
            const d = Q.chars.mixed, p = Q.splitIntoWords(u).map(
              (h) => Q.isWhitespace(h) ? h : Q.shuffleWord(h, d)
            );
            c.textContent = p.join("");
          }, 50);
        }), i.forEach((c) => {
          c.querySelectorAll(".line-wrapper").forEach((d) => {
            const f = d.textContent;
            d.shuffleInterval = setInterval(() => {
              const p = Q.chars.mixed, g = Q.splitIntoWords(f).map(
                (m) => Q.isWhitespace(m) ? m : Q.shuffleWord(m, p)
              );
              d.textContent = g.join("");
            }, 50);
          });
        }), s.length > 0 && l.to(s, {
          opacity: 0,
          duration: 0.2,
          ease: "power3.out"
        }, 0.1), l.to(n.current.container, {
          opacity: 0,
          duration: 0.2
        }, 0.1);
      }, { threshold: [0] });
      n.current.container.querySelectorAll("*").forEach((a) => {
        r.observe(a);
      });
    });
  },
  beforeEnter(n) {
    const e = n.next.container;
    me.set(e, { opacity: 0 });
    const t = e.querySelectorAll('[data-shuffle-load="single"]'), i = e.querySelectorAll('[data-shuffle-load="multi"]');
    (t.length > 0 || i.length > 0) && me.set([...t, ...i], { opacity: 0 });
    const s = e.querySelectorAll('[data-image="desktop"], [data-image="mobile"], [data-image="icon"]');
    s.length > 0 && me.set(s, { opacity: 0, filter: "blur(12px)" });
    const r = e.querySelectorAll(".content, [data-fade-content]");
    r.length > 0 && me.set(r, { opacity: 0 }), iA(n.next.namespace);
  },
  enter(n) {
    return new Promise((e) => {
      const t = n.next.container, i = t.querySelectorAll('[data-shuffle-load="single"]'), s = t.querySelectorAll('[data-shuffle-load="multi"]'), r = t.querySelectorAll(".content, [data-fade-content]"), a = t.querySelectorAll('[data-image="desktop"]'), o = t.querySelectorAll('[data-image="mobile"]'), l = t.querySelectorAll('[data-image="icon"]'), c = me.timeline({ onComplete: e });
      c.to(t, { opacity: 1, duration: 0.5, ease: "power2.out" }, 0), s.length > 0 && c.add(() => {
        Q.loadAnimations.initializeMulti(), me.to(s, {
          opacity: 1,
          duration: 0.3,
          ease: "power2.out"
        });
      }, 0.1), i.length > 0 && c.add(() => {
        i.forEach((u) => {
          const d = u.textContent;
          u.textContent = "", Q.shuffleWords("", d, u, 50, !1);
        }), me.to(i, { opacity: 1, duration: 0.2, ease: "power2.out" });
      }, 0.3), r.length > 0 && c.to(r, { opacity: 1, duration: 0.2, ease: "power3.out" }, 0.6), a.length > 0 && c.to(a, {
        opacity: 1,
        filter: "blur(0px)",
        duration: 0.5,
        ease: "power3.out",
        stagger: 0.1
      }, 0.2), o.length > 0 && c.to(o, {
        opacity: 1,
        filter: "blur(0px)",
        duration: 0.5,
        ease: "power3.out",
        stagger: 0.1
      }, 0.2), l.length > 0 && c.to(l, {
        opacity: 1,
        filter: "blur(0px)",
        duration: 0.5,
        ease: "power3.out",
        stagger: 0.1
      }, 0.2);
    });
  }
};
class Rm {
  constructor(e = {}) {
    this.options = {
      debounceDelay: 300,
      minResizeDelta: 50
    }, this.initialViewport = {
      width: window.innerWidth
    }, this.resizeTimeout = null, this.isReloading = !1, this.init();
  }
  init() {
    document.querySelectorAll("[data-shuffle-load]").length !== 0 && (window.addEventListener("resize", this.handleResize.bind(this)), window.barba && (window.barba.hooks.before(() => {
      this.isReloading = !0;
    }), window.barba.hooks.after(() => {
      this.initialViewport = {
        width: window.innerWidth
      }, this.isReloading = !1;
    })));
  }
  handleResize() {
    this.isReloading || (this.resizeTimeout && clearTimeout(this.resizeTimeout), this.resizeTimeout = setTimeout(() => {
      this.checkAndReload();
    }, this.options.debounceDelay));
  }
  checkAndReload() {
    const e = {
      width: window.innerWidth
    }, t = Math.abs(e.width - this.initialViewport.width), i = Math.abs(e.height - this.initialViewport.height);
    (t >= this.options.minResizeDelta || i >= this.options.minResizeDelta) && this.performReload();
  }
  performReload() {
    this.isReloading = !0, window.location.reload();
  }
  // disable reloads
  disable() {
    this.isReloading = !0;
  }
  // enable reloads
  enable() {
    this.isReloading = !1, this.initialViewport = {
      width: window.innerWidth
    };
  }
}
document.addEventListener("DOMContentLoaded", () => {
  window.viewportManager = new Rm({
    debounceDelay: 250,
    minResizeDelta: 75
  });
});
function rA() {
  const n = document.querySelectorAll(".scroll_text");
  window.addEventListener("scroll", () => {
    const e = window.pageYOffset || document.documentElement.scrollTop, t = document.documentElement.scrollHeight - window.innerHeight;
    let i = e / t * 100;
    i = Math.max(0, Math.min(100, i)), n.forEach((s) => {
      s.innerHTML = Math.round(i) + "%";
    });
  });
}
class nA {
  constructor() {
    this.initApp();
  }
  initApp() {
    document.addEventListener("DOMContentLoaded", () => {
      J_.initialize(), window.viewportManager = new Rm({
        debounceDelay: 250,
        minResizeDelta: 75
      });
    }), cl.init({
      transitions: [sA],
      views: this.getViews()
    }), this.setupGlobalHooks();
  }
  getViews() {
    return [
      {
        namespace: "home",
        beforeEnter: () => this.initHomeComponents(),
        afterEnter: () => this.afterHomeEnter()
      },
      {
        namespace: "project",
        beforeEnter: () => this.beforeProjectEnter(),
        afterEnter: () => this.afterProjectEnter(),
        leave: () => initializeInfiniteAnimations.cleanup()
      },
      {
        namespace: "info",
        beforeEnter: () => this.afterInfoEnter()
      },
      {
        namespace: "archive",
        afterEnter: () => this.afterArchiveEnter()
      },
      {
        namespace: "404",
        beforeEnter: () => this.initBase()
      },
      {
        namespace: "imprint",
        beforeEnter: () => this.initBase(),
        afterEnter: () => this.afterBaseEnter()
      }
    ];
  }
  // Component initialization methods
  initHomeComponents() {
    Q_(), Z_(), eu.initialize();
  }
  afterHomeEnter() {
    Fn(), Bv();
  }
  beforeProjectEnter() {
    rA(), Qv(), Q.buttonAnimations.initialize(), ShuffleReveal.bind();
  }
  afterProjectEnter() {
    Fn(), tb();
  }
  afterInfoEnter() {
    sb(), Fn();
  }
  afterArchiveEnter() {
    rb(), el();
  }
  afterBaseEnter() {
    Fn();
  }
  setupGlobalHooks() {
    cl.hooks.enter(eA), cl.hooks.beforeEnter(tA);
  }
}
new nA();
